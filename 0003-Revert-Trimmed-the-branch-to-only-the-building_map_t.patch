From 408d94c855d3f0aaa2640f4cc5f87f1d8b728791 Mon Sep 17 00:00:00 2001
From: "Marco A. Gutierrez" <marco@openrobotics.org>
Date: Thu, 7 Jan 2021 16:53:05 +0800
Subject: [PATCH 3/9] Revert "Trimmed the branch to only the building_map_tools
 sub directory"

This reverts commit 9f41f5e306f838bc8624c964707ae476179448d6.
---
 .github/workflows/build.yaml                  |   76 +
 .github/workflows/style.yaml                  |   22 +
 README.md                                     |   31 +-
 building_map_msgs/CHANGELOG.rst               |   30 +
 building_map_msgs/CMakeLists.txt              |   46 +
 building_map_msgs/QUALITY_DECLARATION.md      |  141 +
 building_map_msgs/README.md                   |    9 +
 building_map_msgs/msg/AffineImage.msg         |    7 +
 building_map_msgs/msg/BuildingMap.msg         |    3 +
 building_map_msgs/msg/Door.msg                |   44 +
 building_map_msgs/msg/Graph.msg               |    4 +
 building_map_msgs/msg/GraphEdge.msg           |    9 +
 building_map_msgs/msg/GraphNode.msg           |    4 +
 building_map_msgs/msg/Level.msg               |    7 +
 building_map_msgs/msg/Lift.msg                |   14 +
 building_map_msgs/msg/Param.msg               |   13 +
 building_map_msgs/msg/Place.msg               |    6 +
 building_map_msgs/package.xml                 |   29 +
 building_map_msgs/srv/GetBuildingMap.srv      |    2 +
 .../CHANGELOG.rst                             |    0
 .../QUALITY_DECLARATION.md                    |    0
 README.md => building_map_tools/README.md     |    0
 .../building_crowdsim}/__init__.py            |    0
 .../building_crowdsim}/_init_argparse.py      |    0
 .../building_crowdsim}/building_crowdsim.py   |    0
 .../building_crowdsim}/building_yaml_parse.py |    0
 .../building_crowdsim}/config/__init__.py     |    0
 .../config/behavior_file.py                   |    0
 .../config/configfile_generator.py            |    0
 .../building_crowdsim}/config/leaf_element.py |    0
 .../building_crowdsim}/config/plugin_file.py  |    0
 .../building_crowdsim}/config/scene_file.py   |    0
 .../building_crowdsim}/config/util.py         |    0
 .../building_crowdsim}/navmesh/__init__.py    |    0
 .../navmesh/build_navmesh.py                  |    0
 .../building_crowdsim}/navmesh/connection.py  |    0
 .../building_crowdsim}/navmesh/edge.py        |    0
 .../building_crowdsim}/navmesh/file_writer.py |    0
 .../building_crowdsim}/navmesh/lane.py        |    0
 .../navmesh/navmesh_generator.py              |    0
 .../navmesh/object_manager.py                 |    0
 .../building_crowdsim}/navmesh/obstacle.py    |    0
 .../building_crowdsim}/navmesh/polygon.py     |    0
 .../navmesh/polygon_factory.py                |    0
 .../building_crowdsim}/navmesh/vector.py      |    0
 .../building_crowdsim}/navmesh/vertex.py      |    0
 .../building_map}/__init__.py                 |    0
 .../building_map}/building.py                 |    0
 .../building_map}/doors/__init__.py           |    0
 .../building_map}/doors/door.py               |    0
 .../doors/double_sliding_door.py              |    0
 .../building_map}/doors/double_swing_door.py  |    0
 .../building_map}/doors/sliding_door.py       |    0
 .../building_map}/doors/swing_door.py         |    0
 .../building_map}/edge.py                     |    0
 .../building_map}/etree_utils.py              |    0
 .../building_map}/fiducial.py                 |    0
 .../building_map}/floor.py                    |    0
 .../building_map}/generator.py                |    0
 .../building_map}/hole.py                     |    0
 .../building_map}/level.py                    |    0
 .../building_map}/lift.py                     |    0
 .../building_map}/model.py                    |    0
 .../building_map}/param_value.py              |    0
 .../building_map}/templates/gz_world.sdf      |    0
 .../building_map}/templates/ign_world.sdf     |    0
 .../building_map}/transform.py                |    0
 .../building_map}/utils.py                    |    0
 .../building_map}/vertex.py                   |    0
 .../building_map}/wall.py                     |    0
 .../building_map_generator}/__init__.py       |    0
 .../building_map_generator}/_init_argparse.py |    0
 .../building_map_generator.py                 |    0
 .../textures/beige.png                        |  Bin
 .../textures/beige_black_marble_tiles.png     |  Bin
 .../textures/beige_tiles.png                  |  Bin
 .../textures/black_concrete.png               |  Bin
 .../textures/black_glitter_marble.png         |  Bin
 .../textures/blue_linoleum.png                |  Bin
 .../textures/blue_linoleum_high_contrast.png  |  Bin
 .../textures/brown_marble.png                 |  Bin
 .../textures/carpark_walkway.png              |  Bin
 .../textures/concrete.png                     |  Bin
 .../textures/concrete2.png                    |  Bin
 .../textures/concrete3.png                    |  Bin
 .../textures/concrete4.png                    |  Bin
 .../textures/default.png                      |  Bin
 .../textures/gray_flooring.png                |  Bin
 .../textures/metal.png                        |  Bin
 .../textures/red_tiles.png                    |  Bin
 .../textures/rubber_pieces.png                |  Bin
 .../building_map_generator}/textures/wall.png |  Bin
 .../textures/white_beige_tiles.png            |  Bin
 .../textures/white_brick.png                  |  Bin
 .../textures/white_marble.png                 |  Bin
 .../__init__.py                               |    0
 .../building_map_model_downloader.py          |    0
 .../building_map_server}/__init__.py          |    0
 .../building_map_server.py                    |    0
 .../test/test_map_client.py                   |    0
 .../model_downloader}/__init__.py             |    0
 .../model_downloader}/model_downloader.py     |    0
 package.xml => building_map_tools/package.xml |    0
 .../pit_crew}/__init__.py                     |    0
 .../pit_crew}/pit_crew.py                     |    0
 .../pit_crew}/usage_examples.py               |    0
 .../resource}/building_map_tools              |    0
 setup.cfg => building_map_tools/setup.cfg     |    0
 setup.py => building_map_tools/setup.py       |    0
 .../test}/building_crowdsim/config_test.yaml  |    0
 .../test_build_configfile.py                  |    0
 .../building_crowdsim/test_build_navmesh.py   |    0
 .../test_build_navmesh_result.nav             |    0
 .../building_gazebo_plugins/CHANGELOG.rst     |   50 +
 .../building_gazebo_plugins/CMakeLists.txt    |  211 ++
 .../QUALITY_DECLARATION.md                    |  183 ++
 .../building_gazebo_plugins/README.md         |    7 +
 .../building_gazebo_plugins/package.xml       |   38 +
 .../src/crowd_simulator.cpp                   |  308 ++
 .../src/crowd_simulator.hpp                   |   85 +
 .../building_gazebo_plugins/src/door.cpp      |  110 +
 .../building_gazebo_plugins/src/lift.cpp      |   95 +
 .../building_gazebo_plugins/src/slotcar.cpp   |  168 ++
 .../src/thumbnail_generator.cpp               |  317 ++
 .../src/toggle_charging.cpp                   |  124 +
 .../src/toggle_floors.cpp                     |  136 +
 .../building_ignition_plugins/CHANGELOG.rst   |   27 +
 .../building_ignition_plugins/CMakeLists.txt  |  218 ++
 .../QUALITY_DECLARATION.md                    |  168 ++
 .../building_ignition_plugins/README.md       |    7 +
 .../building_ignition_plugins/package.xml     |   31 +
 .../src/crowd_simulator.cpp                   |  467 +++
 .../src/crowd_simulator.hpp                   |   90 +
 .../building_ignition_plugins/src/door.cpp    |  158 +
 .../building_ignition_plugins/src/lift.cpp    |  328 +++
 .../building_ignition_plugins/src/slotcar.cpp |  360 +++
 .../toggle_charging/toggle_charging.config    |    3 +
 .../src/toggle_charging/toggle_charging.cpp   |  112 +
 .../src/toggle_charging/toggle_charging.qml   |   77 +
 .../src/toggle_charging/toggle_charging.qrc   |    5 +
 .../building_plugins_common/CHANGELOG.rst     |   35 +
 .../building_plugins_common/CMakeLists.txt    |  166 ++
 .../QUALITY_DECLARATION.md                    |  172 ++
 .../building_plugins_common/README.md         |    7 +
 .../crowd_simulator_common.hpp                |  449 +++
 .../building_sim_common/door_common.hpp       |  265 ++
 .../building_sim_common/lift_common.hpp       |  266 ++
 .../building_sim_common/slotcar_common.hpp    |  433 +++
 .../include/building_sim_common/utils.hpp     |  234 ++
 .../building_plugins_common/package.xml       |   38 +
 .../src/crowd_simulator_common.cpp            |  266 ++
 .../src/door_common.cpp                       |  201 ++
 .../src/lift_common.cpp                       |  350 +++
 .../src/slotcar_common.cpp                    |  801 +++++
 .../building_plugins_common/src/utils.cpp     |  117 +
 test_maps/CHANGELOG.rst                       |   28 +
 test_maps/CMakeLists.txt                      |   57 +
 test_maps/QUALITY_DECLARATION.md              |  133 +
 test_maps/README.md                           |    7 +
 .../door_madness/door_madness.building.yaml   |   49 +
 .../door_madness/door_madness.project.yaml    |    4 +
 test_maps/package.xml                         |   19 +
 traffic_editor/CHANGELOG.rst                  |  370 +++
 traffic_editor/CMakeLists.txt                 |  173 ++
 traffic_editor/LICENSE                        |  201 ++
 traffic_editor/QUALITY_DECLARATION.md         |  158 +
 traffic_editor/README.md                      |  151 +
 traffic_editor/gui/actions/add_edge.cpp       |  125 +
 traffic_editor/gui/actions/add_edge.h         |   50 +
 traffic_editor/gui/actions/add_fiducial.cpp   |   63 +
 traffic_editor/gui/actions/add_fiducial.h     |   43 +
 traffic_editor/gui/actions/add_model.cpp      |   65 +
 traffic_editor/gui/actions/add_model.h        |   44 +
 traffic_editor/gui/actions/add_polygon.cpp    |   54 +
 traffic_editor/gui/actions/add_polygon.h      |   44 +
 traffic_editor/gui/actions/add_property.cpp   |   71 +
 traffic_editor/gui/actions/add_property.h     |   41 +
 traffic_editor/gui/actions/add_vertex.cpp     |   70 +
 traffic_editor/gui/actions/add_vertex.h       |   46 +
 traffic_editor/gui/actions/delete.cpp         |  128 +
 traffic_editor/gui/actions/delete.h           |   31 +
 traffic_editor/gui/actions/move_fiducial.cpp  |   59 +
 traffic_editor/gui/actions/move_fiducial.h    |   47 +
 traffic_editor/gui/actions/move_model.cpp     |   59 +
 traffic_editor/gui/actions/move_model.h       |   47 +
 traffic_editor/gui/actions/move_vertex.cpp    |   69 +
 traffic_editor/gui/actions/move_vertex.h      |   43 +
 .../gui/actions/polygon_add_vertex.cpp        |   46 +
 .../gui/actions/polygon_add_vertex.h          |   43 +
 .../gui/actions/polygon_remove_vertices.cpp   |   40 +
 .../gui/actions/polygon_remove_vertices.h     |   41 +
 traffic_editor/gui/actions/rotate_model.cpp   |   51 +
 traffic_editor/gui/actions/rotate_model.h     |   48 +
 traffic_editor/gui/add_param_dialog.cpp       |   82 +
 traffic_editor/gui/add_param_dialog.h         |   47 +
 traffic_editor/gui/building.cpp               |  687 +++++
 traffic_editor/gui/building_dialog.cpp        |   76 +
 traffic_editor/gui/building_dialog.h          |   44 +
 traffic_editor/gui/building_level.cpp         |  993 +++++++
 traffic_editor/gui/building_level_dialog.cpp  |  251 ++
 traffic_editor/gui/building_level_dialog.h    |   53 +
 traffic_editor/gui/building_level_table.cpp   |  114 +
 traffic_editor/gui/building_level_table.h     |   40 +
 traffic_editor/gui/crowd_sim/agent_group.cpp  |   60 +
 .../gui/crowd_sim/agent_group_table.cpp       |  211 ++
 .../gui/crowd_sim/agent_group_table.h         |   62 +
 .../gui/crowd_sim/agent_profile.cpp           |   57 +
 .../gui/crowd_sim/agent_profile_table.cpp     |  261 ++
 .../gui/crowd_sim/agent_profile_table.h       |   55 +
 traffic_editor/gui/crowd_sim/condition.cpp    |  188 ++
 .../gui/crowd_sim/condition_dialog.cpp        |  339 +++
 .../gui/crowd_sim/condition_dialog.h          |   80 +
 .../gui/crowd_sim/crowd_sim_dialog.cpp        |  113 +
 .../gui/crowd_sim/crowd_sim_dialog.h          |   52 +
 .../gui/crowd_sim/crowd_sim_editor_table.cpp  |  237 ++
 .../gui/crowd_sim/crowd_sim_editor_table.h    |   70 +
 .../gui/crowd_sim/crowd_sim_impl.cpp          |  308 ++
 .../gui/crowd_sim/crowd_sim_table_base.cpp    |   83 +
 .../gui/crowd_sim/crowd_sim_table_base.h      |   55 +
 traffic_editor/gui/crowd_sim/goal_set.cpp     |   67 +
 .../gui/crowd_sim/goal_set_table.cpp          |  138 +
 traffic_editor/gui/crowd_sim/goal_set_table.h |   58 +
 traffic_editor/gui/crowd_sim/model_type.cpp   |   50 +
 .../gui/crowd_sim/model_type_table.cpp        |  136 +
 .../gui/crowd_sim/model_type_table.h          |   56 +
 traffic_editor/gui/crowd_sim/state.cpp        |   50 +
 traffic_editor/gui/crowd_sim/state_table.cpp  |  198 ++
 traffic_editor/gui/crowd_sim/state_table.h    |   59 +
 .../gui/crowd_sim/to_state_dialog.cpp         |   47 +
 .../gui/crowd_sim/to_state_dialog.h           |   39 +
 .../gui/crowd_sim/to_state_table.cpp          |  116 +
 traffic_editor/gui/crowd_sim/to_state_table.h |   63 +
 traffic_editor/gui/crowd_sim/transition.cpp   |   66 +
 .../gui/crowd_sim/transition_table.cpp        |  174 ++
 .../gui/crowd_sim/transition_table.h          |   58 +
 traffic_editor/gui/edge.cpp                   |  198 ++
 traffic_editor/gui/editor.cpp                 | 2591 +++++++++++++++++
 traffic_editor/gui/editor.h                   |  357 +++
 traffic_editor/gui/editor_mode_id.h           |   29 +
 traffic_editor/gui/editor_model.cpp           |   76 +
 traffic_editor/gui/fiducial.cpp               |   92 +
 traffic_editor/gui/layer.cpp                  |   73 +
 traffic_editor/gui/layer_dialog.cpp           |  216 ++
 traffic_editor/gui/layer_dialog.h             |   60 +
 traffic_editor/gui/level.cpp                  |  188 ++
 traffic_editor/gui/lift.cpp                   |  244 ++
 traffic_editor/gui/lift_dialog.cpp            |  592 ++++
 traffic_editor/gui/lift_dialog.h              |   88 +
 traffic_editor/gui/lift_door.cpp              |   48 +
 traffic_editor/gui/lift_table.cpp             |   95 +
 traffic_editor/gui/lift_table.h               |   35 +
 traffic_editor/gui/main.cpp                   |   53 +
 traffic_editor/gui/map_view.cpp               |  106 +
 traffic_editor/gui/map_view.h                 |   45 +
 traffic_editor/gui/model.cpp                  |  227 ++
 traffic_editor/gui/model_dialog.cpp           |  147 +
 traffic_editor/gui/model_dialog.h             |   58 +
 traffic_editor/gui/multi_select_combo_box.cpp |   93 +
 traffic_editor/gui/multi_select_combo_box.h   |   79 +
 traffic_editor/gui/param.cpp                  |  123 +
 traffic_editor/gui/polygon.cpp                |  134 +
 traffic_editor/gui/preferences_dialog.cpp     |  118 +
 traffic_editor/gui/preferences_dialog.h       |   43 +
 traffic_editor/gui/preferences_keys.cpp       |   20 +
 traffic_editor/gui/preferences_keys.h         |   21 +
 traffic_editor/gui/project.cpp                |  746 +++++
 traffic_editor/gui/project.h                  |  152 +
 traffic_editor/gui/project_dialog.cpp         |  110 +
 traffic_editor/gui/project_dialog.h           |   45 +
 traffic_editor/gui/scenario.cpp               |  259 ++
 traffic_editor/gui/scenario.h                 |   90 +
 traffic_editor/gui/scenario_dialog.cpp        |  132 +
 traffic_editor/gui/scenario_dialog.h          |   47 +
 traffic_editor/gui/scenario_level.cpp         |  174 ++
 traffic_editor/gui/scenario_level.h           |   51 +
 traffic_editor/gui/scenario_table.cpp         |   87 +
 traffic_editor/gui/scenario_table.h           |   35 +
 traffic_editor/gui/sim_thread.cpp             |   41 +
 traffic_editor/gui/sim_thread.h               |   34 +
 traffic_editor/gui/table_list.cpp             |   57 +
 traffic_editor/gui/table_list.h               |   35 +
 traffic_editor/gui/traffic_map.cpp            |   77 +
 traffic_editor/gui/traffic_map.h              |   43 +
 traffic_editor/gui/traffic_map_dialog.cpp     |  129 +
 traffic_editor/gui/traffic_map_dialog.h       |   46 +
 traffic_editor/gui/traffic_table.cpp          |  134 +
 traffic_editor/gui/traffic_table.h            |   35 +
 traffic_editor/gui/transform_dialog.ui        |   94 +
 traffic_editor/gui/vertex.cpp                 |  142 +
 traffic_editor/gui/yaml_utils.cpp             |   75 +
 traffic_editor/gui/yaml_utils.h               |   30 +
 .../include/traffic_editor/building.h         |  173 ++
 .../include/traffic_editor/building_level.h   |  128 +
 .../traffic_editor/crowd_sim/agent_group.h    |  111 +
 .../traffic_editor/crowd_sim/agent_profile.h  |   73 +
 .../traffic_editor/crowd_sim/condition.h      |  237 ++
 .../traffic_editor/crowd_sim/crowd_sim_impl.h |  128 +
 .../traffic_editor/crowd_sim/goal_set.h       |   71 +
 .../traffic_editor/crowd_sim/model_type.h     |   83 +
 .../include/traffic_editor/crowd_sim/state.h  |   77 +
 .../traffic_editor/crowd_sim/transition.h     |  101 +
 traffic_editor/include/traffic_editor/edge.h  |   76 +
 .../include/traffic_editor/editor_model.h     |   41 +
 .../include/traffic_editor/fiducial.h         |   51 +
 traffic_editor/include/traffic_editor/layer.h |   49 +
 traffic_editor/include/traffic_editor/level.h |   88 +
 traffic_editor/include/traffic_editor/lift.h  |  103 +
 .../include/traffic_editor/lift_door.h        |   51 +
 traffic_editor/include/traffic_editor/model.h |   71 +
 .../include/traffic_editor/model_state.h      |   33 +
 traffic_editor/include/traffic_editor/param.h |   60 +
 .../include/traffic_editor/polygon.h          |   72 +
 .../traffic_editor/rendering_options.h        |   30 +
 .../include/traffic_editor/vertex.h           |   63 +
 traffic_editor/package.xml                    |   22 +
 traffic_editor/plugins/simulation.h           |   42 +
 traffic_editor/resources/icons/door.svg       |   77 +
 traffic_editor/resources/icons/fiducial.svg   |   93 +
 traffic_editor/resources/icons/floor.svg      |   64 +
 traffic_editor/resources/icons/hole.svg       |   69 +
 .../resources/icons/measurement.svg           |   76 +
 traffic_editor/resources/icons/move.svg       |   92 +
 traffic_editor/resources/icons/roi.svg        |   64 +
 traffic_editor/resources/icons/rotate.svg     |   99 +
 traffic_editor/resources/icons/select.svg     |   64 +
 traffic_editor/resources/icons/vertex.svg     |   64 +
 traffic_editor/resources/icons/wall.svg       |   76 +
 traffic_editor/resources/resource.qrc         |   16 +
 traffic_editor/scripts/generate_model_list.py |   78 +
 traffic_editor/scripts/generate_thumbnails.py |   79 +
 traffic_editor/scripts/merge_model_lists.py   |   64 +
 traffic_editor/scripts/sort_model_list.py     |   43 +
 traffic_editor/test/model_blacklist.yaml      |    2 +
 traffic_editor/test/model_list.yaml           |    5 +
 334 files changed, 29292 insertions(+), 7 deletions(-)
 create mode 100644 .github/workflows/build.yaml
 create mode 100644 .github/workflows/style.yaml
 rewrite README.md (98%)
 create mode 100644 building_map_msgs/CHANGELOG.rst
 create mode 100644 building_map_msgs/CMakeLists.txt
 create mode 100644 building_map_msgs/QUALITY_DECLARATION.md
 create mode 100644 building_map_msgs/README.md
 create mode 100644 building_map_msgs/msg/AffineImage.msg
 create mode 100644 building_map_msgs/msg/BuildingMap.msg
 create mode 100644 building_map_msgs/msg/Door.msg
 create mode 100644 building_map_msgs/msg/Graph.msg
 create mode 100644 building_map_msgs/msg/GraphEdge.msg
 create mode 100644 building_map_msgs/msg/GraphNode.msg
 create mode 100644 building_map_msgs/msg/Level.msg
 create mode 100644 building_map_msgs/msg/Lift.msg
 create mode 100644 building_map_msgs/msg/Param.msg
 create mode 100644 building_map_msgs/msg/Place.msg
 create mode 100644 building_map_msgs/package.xml
 create mode 100644 building_map_msgs/srv/GetBuildingMap.srv
 rename CHANGELOG.rst => building_map_tools/CHANGELOG.rst (100%)
 rename QUALITY_DECLARATION.md => building_map_tools/QUALITY_DECLARATION.md (100%)
 copy README.md => building_map_tools/README.md (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/__init__.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/_init_argparse.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/building_crowdsim.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/building_yaml_parse.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/__init__.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/behavior_file.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/configfile_generator.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/leaf_element.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/plugin_file.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/scene_file.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/config/util.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/__init__.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/build_navmesh.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/connection.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/edge.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/file_writer.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/lane.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/navmesh_generator.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/object_manager.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/obstacle.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/polygon.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/polygon_factory.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/vector.py (100%)
 rename {building_crowdsim => building_map_tools/building_crowdsim}/navmesh/vertex.py (100%)
 rename {building_map => building_map_tools/building_map}/__init__.py (100%)
 rename {building_map => building_map_tools/building_map}/building.py (100%)
 rename {building_map => building_map_tools/building_map}/doors/__init__.py (100%)
 rename {building_map => building_map_tools/building_map}/doors/door.py (100%)
 rename {building_map => building_map_tools/building_map}/doors/double_sliding_door.py (100%)
 rename {building_map => building_map_tools/building_map}/doors/double_swing_door.py (100%)
 rename {building_map => building_map_tools/building_map}/doors/sliding_door.py (100%)
 rename {building_map => building_map_tools/building_map}/doors/swing_door.py (100%)
 rename {building_map => building_map_tools/building_map}/edge.py (100%)
 rename {building_map => building_map_tools/building_map}/etree_utils.py (100%)
 rename {building_map => building_map_tools/building_map}/fiducial.py (100%)
 rename {building_map => building_map_tools/building_map}/floor.py (100%)
 rename {building_map => building_map_tools/building_map}/generator.py (100%)
 rename {building_map => building_map_tools/building_map}/hole.py (100%)
 rename {building_map => building_map_tools/building_map}/level.py (100%)
 rename {building_map => building_map_tools/building_map}/lift.py (100%)
 rename {building_map => building_map_tools/building_map}/model.py (100%)
 rename {building_map => building_map_tools/building_map}/param_value.py (100%)
 rename {building_map => building_map_tools/building_map}/templates/gz_world.sdf (100%)
 rename {building_map => building_map_tools/building_map}/templates/ign_world.sdf (100%)
 rename {building_map => building_map_tools/building_map}/transform.py (100%)
 rename {building_map => building_map_tools/building_map}/utils.py (100%)
 rename {building_map => building_map_tools/building_map}/vertex.py (100%)
 rename {building_map => building_map_tools/building_map}/wall.py (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/__init__.py (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/_init_argparse.py (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/building_map_generator.py (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/beige.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/beige_black_marble_tiles.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/beige_tiles.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/black_concrete.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/black_glitter_marble.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/blue_linoleum.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/blue_linoleum_high_contrast.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/brown_marble.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/carpark_walkway.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/concrete.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/concrete2.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/concrete3.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/concrete4.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/default.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/gray_flooring.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/metal.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/red_tiles.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/rubber_pieces.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/wall.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/white_beige_tiles.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/white_brick.png (100%)
 rename {building_map_generator => building_map_tools/building_map_generator}/textures/white_marble.png (100%)
 rename {building_map_model_downloader => building_map_tools/building_map_model_downloader}/__init__.py (100%)
 rename {building_map_model_downloader => building_map_tools/building_map_model_downloader}/building_map_model_downloader.py (100%)
 rename {building_map_server => building_map_tools/building_map_server}/__init__.py (100%)
 rename {building_map_server => building_map_tools/building_map_server}/building_map_server.py (100%)
 rename {building_map_server => building_map_tools/building_map_server}/test/test_map_client.py (100%)
 rename {model_downloader => building_map_tools/model_downloader}/__init__.py (100%)
 rename {model_downloader => building_map_tools/model_downloader}/model_downloader.py (100%)
 rename package.xml => building_map_tools/package.xml (100%)
 rename {pit_crew => building_map_tools/pit_crew}/__init__.py (100%)
 rename {pit_crew => building_map_tools/pit_crew}/pit_crew.py (100%)
 rename {pit_crew => building_map_tools/pit_crew}/usage_examples.py (100%)
 rename {resource => building_map_tools/resource}/building_map_tools (100%)
 rename setup.cfg => building_map_tools/setup.cfg (100%)
 rename setup.py => building_map_tools/setup.py (100%)
 rename {test => building_map_tools/test}/building_crowdsim/config_test.yaml (100%)
 rename {test => building_map_tools/test}/building_crowdsim/test_build_configfile.py (100%)
 rename {test => building_map_tools/test}/building_crowdsim/test_build_navmesh.py (100%)
 rename {test => building_map_tools/test}/building_crowdsim/test_build_navmesh_result.nav (100%)
 create mode 100644 building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst
 create mode 100644 building_sim_plugins/building_gazebo_plugins/CMakeLists.txt
 create mode 100644 building_sim_plugins/building_gazebo_plugins/QUALITY_DECLARATION.md
 create mode 100644 building_sim_plugins/building_gazebo_plugins/README.md
 create mode 100644 building_sim_plugins/building_gazebo_plugins/package.xml
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/door.cpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/lift.cpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/toggle_charging.cpp
 create mode 100644 building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/CHANGELOG.rst
 create mode 100644 building_sim_plugins/building_ignition_plugins/CMakeLists.txt
 create mode 100644 building_sim_plugins/building_ignition_plugins/QUALITY_DECLARATION.md
 create mode 100644 building_sim_plugins/building_ignition_plugins/README.md
 create mode 100644 building_sim_plugins/building_ignition_plugins/package.xml
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/door.cpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/lift.cpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/slotcar.cpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.config
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.cpp
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qml
 create mode 100644 building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qrc
 create mode 100644 building_sim_plugins/building_plugins_common/CHANGELOG.rst
 create mode 100644 building_sim_plugins/building_plugins_common/CMakeLists.txt
 create mode 100644 building_sim_plugins/building_plugins_common/QUALITY_DECLARATION.md
 create mode 100644 building_sim_plugins/building_plugins_common/README.md
 create mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp
 create mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp
 create mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp
 create mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp
 create mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp
 create mode 100644 building_sim_plugins/building_plugins_common/package.xml
 create mode 100644 building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp
 create mode 100644 building_sim_plugins/building_plugins_common/src/door_common.cpp
 create mode 100644 building_sim_plugins/building_plugins_common/src/lift_common.cpp
 create mode 100644 building_sim_plugins/building_plugins_common/src/slotcar_common.cpp
 create mode 100644 building_sim_plugins/building_plugins_common/src/utils.cpp
 create mode 100644 test_maps/CHANGELOG.rst
 create mode 100644 test_maps/CMakeLists.txt
 create mode 100644 test_maps/QUALITY_DECLARATION.md
 create mode 100644 test_maps/README.md
 create mode 100644 test_maps/maps/door_madness/door_madness.building.yaml
 create mode 100644 test_maps/maps/door_madness/door_madness.project.yaml
 create mode 100644 test_maps/package.xml
 create mode 100644 traffic_editor/CHANGELOG.rst
 create mode 100644 traffic_editor/CMakeLists.txt
 create mode 100644 traffic_editor/LICENSE
 create mode 100644 traffic_editor/QUALITY_DECLARATION.md
 create mode 100644 traffic_editor/README.md
 create mode 100644 traffic_editor/gui/actions/add_edge.cpp
 create mode 100644 traffic_editor/gui/actions/add_edge.h
 create mode 100644 traffic_editor/gui/actions/add_fiducial.cpp
 create mode 100644 traffic_editor/gui/actions/add_fiducial.h
 create mode 100644 traffic_editor/gui/actions/add_model.cpp
 create mode 100644 traffic_editor/gui/actions/add_model.h
 create mode 100644 traffic_editor/gui/actions/add_polygon.cpp
 create mode 100644 traffic_editor/gui/actions/add_polygon.h
 create mode 100644 traffic_editor/gui/actions/add_property.cpp
 create mode 100644 traffic_editor/gui/actions/add_property.h
 create mode 100644 traffic_editor/gui/actions/add_vertex.cpp
 create mode 100644 traffic_editor/gui/actions/add_vertex.h
 create mode 100644 traffic_editor/gui/actions/delete.cpp
 create mode 100644 traffic_editor/gui/actions/delete.h
 create mode 100644 traffic_editor/gui/actions/move_fiducial.cpp
 create mode 100644 traffic_editor/gui/actions/move_fiducial.h
 create mode 100644 traffic_editor/gui/actions/move_model.cpp
 create mode 100644 traffic_editor/gui/actions/move_model.h
 create mode 100644 traffic_editor/gui/actions/move_vertex.cpp
 create mode 100644 traffic_editor/gui/actions/move_vertex.h
 create mode 100644 traffic_editor/gui/actions/polygon_add_vertex.cpp
 create mode 100644 traffic_editor/gui/actions/polygon_add_vertex.h
 create mode 100644 traffic_editor/gui/actions/polygon_remove_vertices.cpp
 create mode 100644 traffic_editor/gui/actions/polygon_remove_vertices.h
 create mode 100644 traffic_editor/gui/actions/rotate_model.cpp
 create mode 100644 traffic_editor/gui/actions/rotate_model.h
 create mode 100644 traffic_editor/gui/add_param_dialog.cpp
 create mode 100644 traffic_editor/gui/add_param_dialog.h
 create mode 100644 traffic_editor/gui/building.cpp
 create mode 100644 traffic_editor/gui/building_dialog.cpp
 create mode 100644 traffic_editor/gui/building_dialog.h
 create mode 100644 traffic_editor/gui/building_level.cpp
 create mode 100644 traffic_editor/gui/building_level_dialog.cpp
 create mode 100644 traffic_editor/gui/building_level_dialog.h
 create mode 100644 traffic_editor/gui/building_level_table.cpp
 create mode 100644 traffic_editor/gui/building_level_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/agent_group.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/agent_group_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/agent_group_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/agent_profile.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/agent_profile_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/agent_profile_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/condition.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/condition_dialog.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/condition_dialog.h
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_dialog.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_dialog.h
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_editor_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_editor_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_impl.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_table_base.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/crowd_sim_table_base.h
 create mode 100644 traffic_editor/gui/crowd_sim/goal_set.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/goal_set_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/goal_set_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/model_type.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/model_type_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/model_type_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/state.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/state_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/state_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/to_state_dialog.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/to_state_dialog.h
 create mode 100644 traffic_editor/gui/crowd_sim/to_state_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/to_state_table.h
 create mode 100644 traffic_editor/gui/crowd_sim/transition.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/transition_table.cpp
 create mode 100644 traffic_editor/gui/crowd_sim/transition_table.h
 create mode 100644 traffic_editor/gui/edge.cpp
 create mode 100644 traffic_editor/gui/editor.cpp
 create mode 100644 traffic_editor/gui/editor.h
 create mode 100644 traffic_editor/gui/editor_mode_id.h
 create mode 100644 traffic_editor/gui/editor_model.cpp
 create mode 100644 traffic_editor/gui/fiducial.cpp
 create mode 100644 traffic_editor/gui/layer.cpp
 create mode 100644 traffic_editor/gui/layer_dialog.cpp
 create mode 100644 traffic_editor/gui/layer_dialog.h
 create mode 100644 traffic_editor/gui/level.cpp
 create mode 100644 traffic_editor/gui/lift.cpp
 create mode 100644 traffic_editor/gui/lift_dialog.cpp
 create mode 100644 traffic_editor/gui/lift_dialog.h
 create mode 100644 traffic_editor/gui/lift_door.cpp
 create mode 100644 traffic_editor/gui/lift_table.cpp
 create mode 100644 traffic_editor/gui/lift_table.h
 create mode 100644 traffic_editor/gui/main.cpp
 create mode 100644 traffic_editor/gui/map_view.cpp
 create mode 100644 traffic_editor/gui/map_view.h
 create mode 100644 traffic_editor/gui/model.cpp
 create mode 100644 traffic_editor/gui/model_dialog.cpp
 create mode 100644 traffic_editor/gui/model_dialog.h
 create mode 100644 traffic_editor/gui/multi_select_combo_box.cpp
 create mode 100644 traffic_editor/gui/multi_select_combo_box.h
 create mode 100644 traffic_editor/gui/param.cpp
 create mode 100644 traffic_editor/gui/polygon.cpp
 create mode 100644 traffic_editor/gui/preferences_dialog.cpp
 create mode 100644 traffic_editor/gui/preferences_dialog.h
 create mode 100644 traffic_editor/gui/preferences_keys.cpp
 create mode 100644 traffic_editor/gui/preferences_keys.h
 create mode 100644 traffic_editor/gui/project.cpp
 create mode 100644 traffic_editor/gui/project.h
 create mode 100644 traffic_editor/gui/project_dialog.cpp
 create mode 100644 traffic_editor/gui/project_dialog.h
 create mode 100644 traffic_editor/gui/scenario.cpp
 create mode 100644 traffic_editor/gui/scenario.h
 create mode 100644 traffic_editor/gui/scenario_dialog.cpp
 create mode 100644 traffic_editor/gui/scenario_dialog.h
 create mode 100644 traffic_editor/gui/scenario_level.cpp
 create mode 100644 traffic_editor/gui/scenario_level.h
 create mode 100644 traffic_editor/gui/scenario_table.cpp
 create mode 100644 traffic_editor/gui/scenario_table.h
 create mode 100644 traffic_editor/gui/sim_thread.cpp
 create mode 100644 traffic_editor/gui/sim_thread.h
 create mode 100644 traffic_editor/gui/table_list.cpp
 create mode 100644 traffic_editor/gui/table_list.h
 create mode 100644 traffic_editor/gui/traffic_map.cpp
 create mode 100644 traffic_editor/gui/traffic_map.h
 create mode 100644 traffic_editor/gui/traffic_map_dialog.cpp
 create mode 100644 traffic_editor/gui/traffic_map_dialog.h
 create mode 100644 traffic_editor/gui/traffic_table.cpp
 create mode 100644 traffic_editor/gui/traffic_table.h
 create mode 100644 traffic_editor/gui/transform_dialog.ui
 create mode 100644 traffic_editor/gui/vertex.cpp
 create mode 100644 traffic_editor/gui/yaml_utils.cpp
 create mode 100644 traffic_editor/gui/yaml_utils.h
 create mode 100644 traffic_editor/include/traffic_editor/building.h
 create mode 100644 traffic_editor/include/traffic_editor/building_level.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/agent_group.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/agent_profile.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/condition.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/crowd_sim_impl.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/goal_set.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/model_type.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/state.h
 create mode 100644 traffic_editor/include/traffic_editor/crowd_sim/transition.h
 create mode 100644 traffic_editor/include/traffic_editor/edge.h
 create mode 100644 traffic_editor/include/traffic_editor/editor_model.h
 create mode 100644 traffic_editor/include/traffic_editor/fiducial.h
 create mode 100644 traffic_editor/include/traffic_editor/layer.h
 create mode 100644 traffic_editor/include/traffic_editor/level.h
 create mode 100644 traffic_editor/include/traffic_editor/lift.h
 create mode 100644 traffic_editor/include/traffic_editor/lift_door.h
 create mode 100644 traffic_editor/include/traffic_editor/model.h
 create mode 100644 traffic_editor/include/traffic_editor/model_state.h
 create mode 100644 traffic_editor/include/traffic_editor/param.h
 create mode 100644 traffic_editor/include/traffic_editor/polygon.h
 create mode 100644 traffic_editor/include/traffic_editor/rendering_options.h
 create mode 100644 traffic_editor/include/traffic_editor/vertex.h
 create mode 100644 traffic_editor/package.xml
 create mode 100644 traffic_editor/plugins/simulation.h
 create mode 100644 traffic_editor/resources/icons/door.svg
 create mode 100644 traffic_editor/resources/icons/fiducial.svg
 create mode 100644 traffic_editor/resources/icons/floor.svg
 create mode 100644 traffic_editor/resources/icons/hole.svg
 create mode 100644 traffic_editor/resources/icons/measurement.svg
 create mode 100644 traffic_editor/resources/icons/move.svg
 create mode 100644 traffic_editor/resources/icons/roi.svg
 create mode 100644 traffic_editor/resources/icons/rotate.svg
 create mode 100644 traffic_editor/resources/icons/select.svg
 create mode 100644 traffic_editor/resources/icons/vertex.svg
 create mode 100644 traffic_editor/resources/icons/wall.svg
 create mode 100644 traffic_editor/resources/resource.qrc
 create mode 100755 traffic_editor/scripts/generate_model_list.py
 create mode 100755 traffic_editor/scripts/generate_thumbnails.py
 create mode 100755 traffic_editor/scripts/merge_model_lists.py
 create mode 100755 traffic_editor/scripts/sort_model_list.py
 create mode 100644 traffic_editor/test/model_blacklist.yaml
 create mode 100644 traffic_editor/test/model_list.yaml

diff --git a/.github/workflows/build.yaml b/.github/workflows/build.yaml
new file mode 100644
index 0000000..7a3b949
--- /dev/null
+++ b/.github/workflows/build.yaml
@@ -0,0 +1,76 @@
+name: build
+on: [push, pull_request]
+jobs:
+  build:
+    runs-on: ubuntu-18.04
+    container:
+      image: docker://ros:eloquent-ros-base-bionic
+    
+    steps:
+    - name: osrf-repo
+      shell: bash
+      run: |
+        sudo apt-get update
+        sudo apt-get install -y wget
+        echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable bionic main" > /etc/apt/sources.list.d/gazebo-stable.list
+        wget https://packages.osrfoundation.org/gazebo.key -O - | apt-key add -
+        sudo apt-get update
+        sudo apt-get install -y libignition-plugin-dev libignition-common3-dev
+
+    - name: ros-workspace
+      run: |
+        mkdir -p ws/src
+
+    - name: checkout
+      uses: actions/checkout@v2
+      with:
+        path: ws/src/traffic_editor
+
+    - name: non-ros-deps
+      run: |
+        sudo apt-get update
+        sudo apt-get install -y git cmake wget libyaml-cpp-dev qt5-default \
+          libopencv-dev libopencv-videoio-dev
+
+    - name: build
+      shell: bash
+      run: |
+        cd ws
+        source /opt/ros/eloquent/setup.bash
+        colcon build --packages-select traffic_editor --cmake-args -DNO_DOWNLOAD_MODELS=True
+
+  build_without_plugin_support:
+    runs-on: ubuntu-18.04
+    container:
+      image: docker://ros:eloquent-ros-base-bionic
+
+    steps:
+    - name: osrf-repo
+      shell: bash
+      run: |
+        sudo apt-get update
+        sudo apt-get install -y wget
+        echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable bionic main" > /etc/apt/sources.list.d/gazebo-stable.list
+        wget https://packages.osrfoundation.org/gazebo.key -O - | apt-key add -
+        sudo apt-get update
+
+    - name: ros-workspace
+      run: |
+        mkdir -p ws/src
+
+    - name: checkout
+      uses: actions/checkout@v2
+      with:
+        path: ws/src/traffic_editor
+
+    - name: non-ros-deps
+      run: |
+        sudo apt-get update
+        sudo apt-get install -y git cmake wget libyaml-cpp-dev qt5-default
+
+    - name: build
+      shell: bash
+      run: |
+        cd ws
+        source /opt/ros/eloquent/setup.bash
+        colcon build --packages-select traffic_editor --cmake-args -DNO_DOWNLOAD_MODELS=True
diff --git a/.github/workflows/style.yaml b/.github/workflows/style.yaml
new file mode 100644
index 0000000..775d68e
--- /dev/null
+++ b/.github/workflows/style.yaml
@@ -0,0 +1,22 @@
+name: style
+on: [push, pull_request]
+jobs:
+  build:
+    runs-on: ubuntu-18.04
+    container:
+      image: docker://ros:eloquent-ros-base-bionic
+    steps:
+    - uses: actions/checkout@v1
+    - name: deps
+      run: |
+        sudo apt-get update
+        sudo apt-get install pycodestyle wget
+    - name: pycodestyle
+      run: |
+        pycodestyle .
+    - name: rmf_uncrustify
+      shell: bash
+      run: |
+        wget https://raw.githubusercontent.com/osrf/rmf_core/master/rmf_utils/test/format/rmf_code_style.cfg
+        source /opt/ros/eloquent/setup.bash
+        ament_uncrustify -c rmf_code_style.cfg .
diff --git a/README.md b/README.md
dissimilarity index 98%
index 11fca62..aff28d9 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,24 @@
-# building\_map\_tools package
-
-This package provides tools for manipulating and format-converting building maps.
-
-## Quality Declaration
-
-This package claims to be in the **Quality Level 4** category. See the [Quality Declaration](QUALITY_DECLARATION.md) for more details.
+![](https://github.com/osrf/traffic_editor/workflows/build/badge.svg)
+![](https://github.com/osrf/traffic_editor/workflows/style/badge.svg)
+
+# traffic\_editor
+
+Welcome!
+
+This repository has the following directories:
+ * `traffic_editor`: GUI for annotating floorplans to create traffic patterns
+ * `building_map_msgs`: messages that can carry these traffic plans
+ * `building_map_tools`: Python-based tools to use and manipulate the map files created by `traffic_editor`, such as:
+   * a ROS 2 node to serve maps using `building_map_msgs`
+   * translators to simulators such as Gazebo
+   * translators to navigation packages such as `rmf_core`
+
+# Installation
+
+This repository is structed as a collection of ROS 2 packages and can be built using `colcon`.
+
+The `building_map_tools` package requires the following Python 3 dependencies to generate worlds:
+
+```
+sudo apt install python3-shapely python3-yaml python3-requests
+```
diff --git a/building_map_msgs/CHANGELOG.rst b/building_map_msgs/CHANGELOG.rst
new file mode 100644
index 0000000..87d0f0e
--- /dev/null
+++ b/building_map_msgs/CHANGELOG.rst
@@ -0,0 +1,30 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package building_map_msgs
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.2.0 (2021-01-06)
+------------------
+* Add first pass of quality declarations for all packages (`#235 <https://github.com/osrf/traffic_editor/issues/235>`_)
+* Contributors: Geoffrey Biggs, Marco A. Gutierrez, Marco A. Gutiérrez
+
+1.0.0 (2020-06-22)
+------------------
+* merging master
+* Merge branch 'master' into ch3/migrate-traffic-editor-thumbnails
+* Merge branch 'master' into ch3/author-namespaced-thumbnails
+* Merge pull request `#131 <https://github.com/osrf/traffic_editor/issues/131>`_ from osrf/bug/building_map_server
+  Fix coordinate frame of lifts and doors in building_map_server
+* Fixed coordinate system for lifts and doors populated in BuildingMap msg
+* Merge pull request `#122 <https://github.com/osrf/traffic_editor/issues/122>`_ from osrf/fix/building_map_server
+  Fix/building map server
+* Merge pull request `#121 <https://github.com/osrf/traffic_editor/issues/121>`_ from osrf/bug/fix_pkg_dependencies
+  adding missing pkg dependencies
+* Lift skeleton
+* Fixed format
+* doors populated in map server
+* adding missing pkg dependencies
+* Merge pull request `#16 <https://github.com/osrf/traffic_editor/issues/16>`_ from osrf/repository_reorganization
+  Repository reorganization
+* add lift cabin reference point
+* grand reorganization as colcon-buildable packages for ros2 integration
+* Contributors: Marco A. Gutierrez, Marco A. Gutiérrez, Morgan Quigley, Yadu, Yadunund, methylDragon
diff --git a/building_map_msgs/CMakeLists.txt b/building_map_msgs/CMakeLists.txt
new file mode 100644
index 0000000..248481a
--- /dev/null
+++ b/building_map_msgs/CMakeLists.txt
@@ -0,0 +1,46 @@
+cmake_minimum_required(VERSION 3.5)
+
+project(building_map_msgs)
+
+# Default to C++14
+if(NOT CMAKE_CXX_STANDARD)
+  set(CMAKE_CXX_STANDARD 14)
+endif()
+if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  # we dont use add_compile_options with pedantic in message packages
+  # because the Python C extensions dont comply with it
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wpedantic")
+endif()
+
+find_package(ament_cmake REQUIRED)
+find_package(builtin_interfaces REQUIRED)
+find_package(geometry_msgs REQUIRED)
+find_package(rosidl_default_generators REQUIRED)
+
+set(msg_files
+  "msg/AffineImage.msg"
+  "msg/BuildingMap.msg"
+  "msg/Door.msg"
+  "msg/Graph.msg"
+  "msg/GraphEdge.msg"
+  "msg/GraphNode.msg"
+  "msg/Level.msg"
+  "msg/Lift.msg"
+  "msg/Param.msg"
+  "msg/Place.msg"
+)
+
+set(srv_files
+  "srv/GetBuildingMap.srv"
+)
+
+rosidl_generate_interfaces(${PROJECT_NAME}
+  ${msg_files}
+  ${srv_files}
+  DEPENDENCIES builtin_interfaces
+  ADD_LINTER_TESTS
+)
+
+ament_export_dependencies(rosidl_default_runtime)
+
+ament_package()
diff --git a/building_map_msgs/QUALITY_DECLARATION.md b/building_map_msgs/QUALITY_DECLARATION.md
new file mode 100644
index 0000000..7216888
--- /dev/null
+++ b/building_map_msgs/QUALITY_DECLARATION.md
@@ -0,0 +1,141 @@
+This document is a declaration of software quality for the `building_map_msgs` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+# `building_map_msgs` Quality Declaration
+
+The package `building_map_msgs` claims to be in the **Quality Level 3** category.
+
+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+## Version Policy [1]
+
+### Version Scheme [1.i]
+
+`building_map_msgs` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).
+
+### Version Stability [1.ii]
+
+`building_map_msgs` is at a stable version, i.e. `>= 1.0.0`.
+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).
+
+### Public API Declaration [1.iii]
+
+All message definition files located the `msg` directory and service definition files located in the `srv` directory are considered part of the public API.
+
+### API Stability Within a Released ROS Distribution [1.iv]/[1.vi]
+
+`building_map_msgs` will not break public API within a released ROS distribution, i.e. no major releases once the ROS distribution is released.
+
+### ABI Stability Within a Released ROS Distribution [1.v]/[1.vi]
+
+`building_map_msgs` does not contain any C or C++ code and therefore will not affect ABI stability.
+
+## Change Control Process [2]
+
+`building_map_msgs` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).
+
+### Change Requests [2.i]
+
+`building_map_msgs` requires that all changes occur through a pull request.
+
+### Contributor Origin [2.ii]
+
+`building_map_msgs` does not require a confirmation of contributor origin.
+
+### Peer Review Policy [2.iii]
+
+All pull requests must have at least 1 peer review.
+
+### Continuous Integration [2.iv]
+
+All pull requests must pass CI on all platforms supported by RMF.
+The CI checks only that the package builds.
+The most recent CI results can be seen on [the workflow page](https://github.com/osrf/traffic_editor/actions).
+
+### Documentation Policy [2.v]
+
+All pull requests must resolve related documentation changes before merging.
+
+## Documentation [3]
+
+### Feature Documentation [3.i]
+
+`building_map_msgs` has basic comments in the message and service definition files, but no list of messages, services, or usage guide is provided.
+New messages and services require their own documentation in order to be added.
+
+### Public API Documentation [3.ii]
+
+`building_map_msgs` has embedded API documentation, but it is not currently hosted.
+
+### License [3.iii]
+
+The license for `building_map_msgs` is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.
+
+There are no source files that are currently copyrighted in this package so files are not checked for abbreviated license statements.
+
+### Copyright Statement [3.iv]
+
+There are no copyrighted source files in this package.
+
+### Quality declaration document [3.v]
+
+This quality declaration is linked in the [README file](README.md).
+
+This quality declaration has not been externally peer-reviewed and is not registered on any Level 3 lists.
+
+## Testing [4]
+
+### Feature Testing [4.i]
+
+`building_map_msgs` is a package providing strictly message and service definitions and therefore does not require associated tests.
+
+### Public API Testing [4.ii]
+
+`building_map_msgs` is a package providing strictly message and service definitions and therefore does not require associated tests.
+
+### Coverage [4.iii]
+
+`building_map_msgs` is a package providing strictly message and service definitions and therefore has no coverage requirements.
+
+### Performance [4.iv]
+
+`building_map_msgs` is a package providing strictly message and service definitions and therefore has no performance requirements.
+
+### Linters and Static Analysis [4.v]
+
+`building_map_msgs` does not use the standard linters and static analysis tools for its generated C++ and Python code to ensure it follows the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).
+
+## Dependencies [5]
+
+### Direct Runtime ROS Dependencies [5.i]
+
+`building_map_msgs` has the following runtime ROS dependencies.
+
+#### builtin\_interfaces
+
+`builtin_interfaces` is at [**Quality Level 3**](https://github.com/ros2/rcl_interfaces/tree/master/builtin_interfaces/QUALITY_DECLARATION.md)
+
+#### rosidl\_default_runtime
+
+`rosidl_default_runtime` is at [**Quality Level 3**](https://github.com/ros2/rosidl_defaults/tree/master/rosidl_default_runtime/QUALITY_DECLARATION.md)
+
+#### geometry_msgs
+
+`geometry_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/geometry_msgs/QUALITY_DECLARATION.md).
+
+### Optional Direct Runtime ROS Dependencies [5.ii]
+
+`building_map_msgs` does not have any optional direct runtime ROS dependencies.
+
+### Direct Runtime non-ROS Dependency [5.iii]
+
+`building_map_msgs` does not have any runtime non-ROS dependencies.
+
+## Platform Support [6]
+
+As a pure message and service definitions package, `building_map_msgs` supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers), but does not currently test each change against all of them.
+
+## Security [7]
+
+### Vulnerability Disclosure Policy [7.i]
+
+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).
diff --git a/building_map_msgs/README.md b/building_map_msgs/README.md
new file mode 100644
index 0000000..d142cd6
--- /dev/null
+++ b/building_map_msgs/README.md
@@ -0,0 +1,9 @@
+# building\_map\_msgs
+
+`building_map_msgs` provides message and service types for communicating about building infrastructure.
+
+For more information about ROS 2 interfaces, see [index.ros2.org](https://index.ros.org/doc/ros2/Concepts/About-ROS-Interfaces/)
+
+## Quality Declaration
+
+This package claims to be in the **Quality Level 3** category. See the [Quality Declaration](QUALITY_DECLARATION.md) for more details.
diff --git a/building_map_msgs/msg/AffineImage.msg b/building_map_msgs/msg/AffineImage.msg
new file mode 100644
index 0000000..f08234b
--- /dev/null
+++ b/building_map_msgs/msg/AffineImage.msg
@@ -0,0 +1,7 @@
+string name
+float32 x_offset
+float32 y_offset
+float32 yaw
+float32 scale
+string encoding
+uint8[] data
diff --git a/building_map_msgs/msg/BuildingMap.msg b/building_map_msgs/msg/BuildingMap.msg
new file mode 100644
index 0000000..734755b
--- /dev/null
+++ b/building_map_msgs/msg/BuildingMap.msg
@@ -0,0 +1,3 @@
+string name
+Level[] levels
+Lift[] lifts
diff --git a/building_map_msgs/msg/Door.msg b/building_map_msgs/msg/Door.msg
new file mode 100644
index 0000000..1b9c001
--- /dev/null
+++ b/building_map_msgs/msg/Door.msg
@@ -0,0 +1,44 @@
+string name
+
+# CONVENTIONS
+# ===========
+# single hinge doors:
+#   * hinge is located at (v1_x, v1_y)
+#   * door extends till (v2_x, v2_y)
+#   * motion_range = door swing range in DEGREES
+#   * there are two possible motions: clockwise and anti-clockwise
+#     selected by the motion_direction parameter, which is +1 or -1
+#
+# double hinge doors:
+#   * hinges are located at both (v1_x, v1_y) and (v2_x, v2_y)
+#   * motion range = door swing ranges in DEGREES (assume symmetric)
+#   * same motion-direction selection as single hinge
+#
+# single sliding doors:
+#   * the door slides from (v2_x, v2_y) towards (v1_x, v1_y)
+#   * range of motion is entire distance from v2->v1. No need to specify.
+#
+# double sliding doors:
+#   * door panels slide from the centerpoint of v1<->v2 towards v1 and v2
+#
+# single/double telescoping doors:
+#   * common in elevators; same parameters as sliding doors; they just
+#     open/close faster and take up less space inside the wall.
+
+float32 v1_x
+float32 v1_y
+
+float32 v2_x
+float32 v2_y
+
+uint8 door_type
+uint8 DOOR_TYPE_UNDEFINED=0
+uint8 DOOR_TYPE_SINGLE_SLIDING=1
+uint8 DOOR_TYPE_DOUBLE_SLIDING=2
+uint8 DOOR_TYPE_SINGLE_TELESCOPE=3
+uint8 DOOR_TYPE_DOUBLE_TELESCOPE=4
+uint8 DOOR_TYPE_SINGLE_SWING=5
+uint8 DOOR_TYPE_DOUBLE_SWING=6
+
+float32 motion_range
+int32 motion_direction
diff --git a/building_map_msgs/msg/Graph.msg b/building_map_msgs/msg/Graph.msg
new file mode 100644
index 0000000..a5b7f99
--- /dev/null
+++ b/building_map_msgs/msg/Graph.msg
@@ -0,0 +1,4 @@
+string name
+GraphNode[] vertices
+GraphEdge[] edges
+Param[] params
diff --git a/building_map_msgs/msg/GraphEdge.msg b/building_map_msgs/msg/GraphEdge.msg
new file mode 100644
index 0000000..7457537
--- /dev/null
+++ b/building_map_msgs/msg/GraphEdge.msg
@@ -0,0 +1,9 @@
+uint32 v1_idx
+uint32 v2_idx
+Param[] params
+
+# when edge_type is UNIDIRECTIONAL, it means v1 -> v2
+# when edge_type is BIDIRECTIONAL, it means v1 <-> v2
+uint8 edge_type
+uint8 EDGE_TYPE_BIDIRECTIONAL=0
+uint8 EDGE_TYPE_UNIDIRECTIONAL=1
diff --git a/building_map_msgs/msg/GraphNode.msg b/building_map_msgs/msg/GraphNode.msg
new file mode 100644
index 0000000..ed498c4
--- /dev/null
+++ b/building_map_msgs/msg/GraphNode.msg
@@ -0,0 +1,4 @@
+float32 x
+float32 y
+string name
+Param[] params
diff --git a/building_map_msgs/msg/Level.msg b/building_map_msgs/msg/Level.msg
new file mode 100644
index 0000000..4ea3d4f
--- /dev/null
+++ b/building_map_msgs/msg/Level.msg
@@ -0,0 +1,7 @@
+string name
+float32 elevation
+AffineImage[] images
+Place[] places
+Door[] doors
+Graph[] nav_graphs
+Graph wall_graph
diff --git a/building_map_msgs/msg/Lift.msg b/building_map_msgs/msg/Lift.msg
new file mode 100644
index 0000000..1167df7
--- /dev/null
+++ b/building_map_msgs/msg/Lift.msg
@@ -0,0 +1,14 @@
+string name
+string[] levels
+Door[] doors
+Graph wall_graph
+
+# (ref_x, ref_y, ref_yaw) is a "reference orientation" of the lift cabin
+# which can be used to align floors.
+float32 ref_x
+float32 ref_y
+float32 ref_yaw
+
+# width and depth of the cabin
+float32 width
+float32 depth
\ No newline at end of file
diff --git a/building_map_msgs/msg/Param.msg b/building_map_msgs/msg/Param.msg
new file mode 100644
index 0000000..a8fd90e
--- /dev/null
+++ b/building_map_msgs/msg/Param.msg
@@ -0,0 +1,13 @@
+string name
+
+uint32 type
+uint32 TYPE_UNDEFINED=0
+uint32 TYPE_STRING=1
+uint32 TYPE_INT=2
+uint32 TYPE_DOUBLE=3
+uint32 TYPE_BOOL=4
+
+int32 value_int
+float32 value_float
+string value_string
+bool value_bool
diff --git a/building_map_msgs/msg/Place.msg b/building_map_msgs/msg/Place.msg
new file mode 100644
index 0000000..d8e93a8
--- /dev/null
+++ b/building_map_msgs/msg/Place.msg
@@ -0,0 +1,6 @@
+string name
+float32 x
+float32 y
+float32 yaw
+float32 position_tolerance
+float32 yaw_tolerance
diff --git a/building_map_msgs/package.xml b/building_map_msgs/package.xml
new file mode 100644
index 0000000..cf0bfca
--- /dev/null
+++ b/building_map_msgs/package.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0"?>
+<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
+<package format="3">
+  <name>building_map_msgs</name>
+  <version>1.2.0</version>
+  <description>Messages used to send building maps</description>
+  <maintainer email="mquigley@openrobotics.org">Morgan Quigley</maintainer>
+  <license>Apache License 2.0</license>
+
+  <buildtool_depend>ament_cmake</buildtool_depend>
+
+  <buildtool_depend>rosidl_default_generators</buildtool_depend>
+
+  <build_depend>builtin_interfaces</build_depend>
+  <build_depend>geometry_msgs</build_depend>
+
+  <exec_depend>builtin_interfaces</exec_depend>
+  <exec_depend>geometry_msgs</exec_depend>
+  <exec_depend>rosidl_default_runtime</exec_depend>
+
+  <test_depend>ament_lint_common</test_depend>
+
+  <member_of_group>rosidl_interface_packages</member_of_group>
+
+  <export>
+    <build_type>ament_cmake</build_type>
+  </export>
+</package>
+
diff --git a/building_map_msgs/srv/GetBuildingMap.srv b/building_map_msgs/srv/GetBuildingMap.srv
new file mode 100644
index 0000000..6d54a61
--- /dev/null
+++ b/building_map_msgs/srv/GetBuildingMap.srv
@@ -0,0 +1,2 @@
+---
+BuildingMap building_map
diff --git a/CHANGELOG.rst b/building_map_tools/CHANGELOG.rst
similarity index 100%
rename from CHANGELOG.rst
rename to building_map_tools/CHANGELOG.rst
diff --git a/QUALITY_DECLARATION.md b/building_map_tools/QUALITY_DECLARATION.md
similarity index 100%
rename from QUALITY_DECLARATION.md
rename to building_map_tools/QUALITY_DECLARATION.md
diff --git a/README.md b/building_map_tools/README.md
similarity index 100%
copy from README.md
copy to building_map_tools/README.md
diff --git a/building_crowdsim/__init__.py b/building_map_tools/building_crowdsim/__init__.py
similarity index 100%
rename from building_crowdsim/__init__.py
rename to building_map_tools/building_crowdsim/__init__.py
diff --git a/building_crowdsim/_init_argparse.py b/building_map_tools/building_crowdsim/_init_argparse.py
similarity index 100%
rename from building_crowdsim/_init_argparse.py
rename to building_map_tools/building_crowdsim/_init_argparse.py
diff --git a/building_crowdsim/building_crowdsim.py b/building_map_tools/building_crowdsim/building_crowdsim.py
similarity index 100%
rename from building_crowdsim/building_crowdsim.py
rename to building_map_tools/building_crowdsim/building_crowdsim.py
diff --git a/building_crowdsim/building_yaml_parse.py b/building_map_tools/building_crowdsim/building_yaml_parse.py
similarity index 100%
rename from building_crowdsim/building_yaml_parse.py
rename to building_map_tools/building_crowdsim/building_yaml_parse.py
diff --git a/building_crowdsim/config/__init__.py b/building_map_tools/building_crowdsim/config/__init__.py
similarity index 100%
rename from building_crowdsim/config/__init__.py
rename to building_map_tools/building_crowdsim/config/__init__.py
diff --git a/building_crowdsim/config/behavior_file.py b/building_map_tools/building_crowdsim/config/behavior_file.py
similarity index 100%
rename from building_crowdsim/config/behavior_file.py
rename to building_map_tools/building_crowdsim/config/behavior_file.py
diff --git a/building_crowdsim/config/configfile_generator.py b/building_map_tools/building_crowdsim/config/configfile_generator.py
similarity index 100%
rename from building_crowdsim/config/configfile_generator.py
rename to building_map_tools/building_crowdsim/config/configfile_generator.py
diff --git a/building_crowdsim/config/leaf_element.py b/building_map_tools/building_crowdsim/config/leaf_element.py
similarity index 100%
rename from building_crowdsim/config/leaf_element.py
rename to building_map_tools/building_crowdsim/config/leaf_element.py
diff --git a/building_crowdsim/config/plugin_file.py b/building_map_tools/building_crowdsim/config/plugin_file.py
similarity index 100%
rename from building_crowdsim/config/plugin_file.py
rename to building_map_tools/building_crowdsim/config/plugin_file.py
diff --git a/building_crowdsim/config/scene_file.py b/building_map_tools/building_crowdsim/config/scene_file.py
similarity index 100%
rename from building_crowdsim/config/scene_file.py
rename to building_map_tools/building_crowdsim/config/scene_file.py
diff --git a/building_crowdsim/config/util.py b/building_map_tools/building_crowdsim/config/util.py
similarity index 100%
rename from building_crowdsim/config/util.py
rename to building_map_tools/building_crowdsim/config/util.py
diff --git a/building_crowdsim/navmesh/__init__.py b/building_map_tools/building_crowdsim/navmesh/__init__.py
similarity index 100%
rename from building_crowdsim/navmesh/__init__.py
rename to building_map_tools/building_crowdsim/navmesh/__init__.py
diff --git a/building_crowdsim/navmesh/build_navmesh.py b/building_map_tools/building_crowdsim/navmesh/build_navmesh.py
similarity index 100%
rename from building_crowdsim/navmesh/build_navmesh.py
rename to building_map_tools/building_crowdsim/navmesh/build_navmesh.py
diff --git a/building_crowdsim/navmesh/connection.py b/building_map_tools/building_crowdsim/navmesh/connection.py
similarity index 100%
rename from building_crowdsim/navmesh/connection.py
rename to building_map_tools/building_crowdsim/navmesh/connection.py
diff --git a/building_crowdsim/navmesh/edge.py b/building_map_tools/building_crowdsim/navmesh/edge.py
similarity index 100%
rename from building_crowdsim/navmesh/edge.py
rename to building_map_tools/building_crowdsim/navmesh/edge.py
diff --git a/building_crowdsim/navmesh/file_writer.py b/building_map_tools/building_crowdsim/navmesh/file_writer.py
similarity index 100%
rename from building_crowdsim/navmesh/file_writer.py
rename to building_map_tools/building_crowdsim/navmesh/file_writer.py
diff --git a/building_crowdsim/navmesh/lane.py b/building_map_tools/building_crowdsim/navmesh/lane.py
similarity index 100%
rename from building_crowdsim/navmesh/lane.py
rename to building_map_tools/building_crowdsim/navmesh/lane.py
diff --git a/building_crowdsim/navmesh/navmesh_generator.py b/building_map_tools/building_crowdsim/navmesh/navmesh_generator.py
similarity index 100%
rename from building_crowdsim/navmesh/navmesh_generator.py
rename to building_map_tools/building_crowdsim/navmesh/navmesh_generator.py
diff --git a/building_crowdsim/navmesh/object_manager.py b/building_map_tools/building_crowdsim/navmesh/object_manager.py
similarity index 100%
rename from building_crowdsim/navmesh/object_manager.py
rename to building_map_tools/building_crowdsim/navmesh/object_manager.py
diff --git a/building_crowdsim/navmesh/obstacle.py b/building_map_tools/building_crowdsim/navmesh/obstacle.py
similarity index 100%
rename from building_crowdsim/navmesh/obstacle.py
rename to building_map_tools/building_crowdsim/navmesh/obstacle.py
diff --git a/building_crowdsim/navmesh/polygon.py b/building_map_tools/building_crowdsim/navmesh/polygon.py
similarity index 100%
rename from building_crowdsim/navmesh/polygon.py
rename to building_map_tools/building_crowdsim/navmesh/polygon.py
diff --git a/building_crowdsim/navmesh/polygon_factory.py b/building_map_tools/building_crowdsim/navmesh/polygon_factory.py
similarity index 100%
rename from building_crowdsim/navmesh/polygon_factory.py
rename to building_map_tools/building_crowdsim/navmesh/polygon_factory.py
diff --git a/building_crowdsim/navmesh/vector.py b/building_map_tools/building_crowdsim/navmesh/vector.py
similarity index 100%
rename from building_crowdsim/navmesh/vector.py
rename to building_map_tools/building_crowdsim/navmesh/vector.py
diff --git a/building_crowdsim/navmesh/vertex.py b/building_map_tools/building_crowdsim/navmesh/vertex.py
similarity index 100%
rename from building_crowdsim/navmesh/vertex.py
rename to building_map_tools/building_crowdsim/navmesh/vertex.py
diff --git a/building_map/__init__.py b/building_map_tools/building_map/__init__.py
similarity index 100%
rename from building_map/__init__.py
rename to building_map_tools/building_map/__init__.py
diff --git a/building_map/building.py b/building_map_tools/building_map/building.py
similarity index 100%
rename from building_map/building.py
rename to building_map_tools/building_map/building.py
diff --git a/building_map/doors/__init__.py b/building_map_tools/building_map/doors/__init__.py
similarity index 100%
rename from building_map/doors/__init__.py
rename to building_map_tools/building_map/doors/__init__.py
diff --git a/building_map/doors/door.py b/building_map_tools/building_map/doors/door.py
similarity index 100%
rename from building_map/doors/door.py
rename to building_map_tools/building_map/doors/door.py
diff --git a/building_map/doors/double_sliding_door.py b/building_map_tools/building_map/doors/double_sliding_door.py
similarity index 100%
rename from building_map/doors/double_sliding_door.py
rename to building_map_tools/building_map/doors/double_sliding_door.py
diff --git a/building_map/doors/double_swing_door.py b/building_map_tools/building_map/doors/double_swing_door.py
similarity index 100%
rename from building_map/doors/double_swing_door.py
rename to building_map_tools/building_map/doors/double_swing_door.py
diff --git a/building_map/doors/sliding_door.py b/building_map_tools/building_map/doors/sliding_door.py
similarity index 100%
rename from building_map/doors/sliding_door.py
rename to building_map_tools/building_map/doors/sliding_door.py
diff --git a/building_map/doors/swing_door.py b/building_map_tools/building_map/doors/swing_door.py
similarity index 100%
rename from building_map/doors/swing_door.py
rename to building_map_tools/building_map/doors/swing_door.py
diff --git a/building_map/edge.py b/building_map_tools/building_map/edge.py
similarity index 100%
rename from building_map/edge.py
rename to building_map_tools/building_map/edge.py
diff --git a/building_map/etree_utils.py b/building_map_tools/building_map/etree_utils.py
similarity index 100%
rename from building_map/etree_utils.py
rename to building_map_tools/building_map/etree_utils.py
diff --git a/building_map/fiducial.py b/building_map_tools/building_map/fiducial.py
similarity index 100%
rename from building_map/fiducial.py
rename to building_map_tools/building_map/fiducial.py
diff --git a/building_map/floor.py b/building_map_tools/building_map/floor.py
similarity index 100%
rename from building_map/floor.py
rename to building_map_tools/building_map/floor.py
diff --git a/building_map/generator.py b/building_map_tools/building_map/generator.py
similarity index 100%
rename from building_map/generator.py
rename to building_map_tools/building_map/generator.py
diff --git a/building_map/hole.py b/building_map_tools/building_map/hole.py
similarity index 100%
rename from building_map/hole.py
rename to building_map_tools/building_map/hole.py
diff --git a/building_map/level.py b/building_map_tools/building_map/level.py
similarity index 100%
rename from building_map/level.py
rename to building_map_tools/building_map/level.py
diff --git a/building_map/lift.py b/building_map_tools/building_map/lift.py
similarity index 100%
rename from building_map/lift.py
rename to building_map_tools/building_map/lift.py
diff --git a/building_map/model.py b/building_map_tools/building_map/model.py
similarity index 100%
rename from building_map/model.py
rename to building_map_tools/building_map/model.py
diff --git a/building_map/param_value.py b/building_map_tools/building_map/param_value.py
similarity index 100%
rename from building_map/param_value.py
rename to building_map_tools/building_map/param_value.py
diff --git a/building_map/templates/gz_world.sdf b/building_map_tools/building_map/templates/gz_world.sdf
similarity index 100%
rename from building_map/templates/gz_world.sdf
rename to building_map_tools/building_map/templates/gz_world.sdf
diff --git a/building_map/templates/ign_world.sdf b/building_map_tools/building_map/templates/ign_world.sdf
similarity index 100%
rename from building_map/templates/ign_world.sdf
rename to building_map_tools/building_map/templates/ign_world.sdf
diff --git a/building_map/transform.py b/building_map_tools/building_map/transform.py
similarity index 100%
rename from building_map/transform.py
rename to building_map_tools/building_map/transform.py
diff --git a/building_map/utils.py b/building_map_tools/building_map/utils.py
similarity index 100%
rename from building_map/utils.py
rename to building_map_tools/building_map/utils.py
diff --git a/building_map/vertex.py b/building_map_tools/building_map/vertex.py
similarity index 100%
rename from building_map/vertex.py
rename to building_map_tools/building_map/vertex.py
diff --git a/building_map/wall.py b/building_map_tools/building_map/wall.py
similarity index 100%
rename from building_map/wall.py
rename to building_map_tools/building_map/wall.py
diff --git a/building_map_generator/__init__.py b/building_map_tools/building_map_generator/__init__.py
similarity index 100%
rename from building_map_generator/__init__.py
rename to building_map_tools/building_map_generator/__init__.py
diff --git a/building_map_generator/_init_argparse.py b/building_map_tools/building_map_generator/_init_argparse.py
similarity index 100%
rename from building_map_generator/_init_argparse.py
rename to building_map_tools/building_map_generator/_init_argparse.py
diff --git a/building_map_generator/building_map_generator.py b/building_map_tools/building_map_generator/building_map_generator.py
similarity index 100%
rename from building_map_generator/building_map_generator.py
rename to building_map_tools/building_map_generator/building_map_generator.py
diff --git a/building_map_generator/textures/beige.png b/building_map_tools/building_map_generator/textures/beige.png
similarity index 100%
rename from building_map_generator/textures/beige.png
rename to building_map_tools/building_map_generator/textures/beige.png
diff --git a/building_map_generator/textures/beige_black_marble_tiles.png b/building_map_tools/building_map_generator/textures/beige_black_marble_tiles.png
similarity index 100%
rename from building_map_generator/textures/beige_black_marble_tiles.png
rename to building_map_tools/building_map_generator/textures/beige_black_marble_tiles.png
diff --git a/building_map_generator/textures/beige_tiles.png b/building_map_tools/building_map_generator/textures/beige_tiles.png
similarity index 100%
rename from building_map_generator/textures/beige_tiles.png
rename to building_map_tools/building_map_generator/textures/beige_tiles.png
diff --git a/building_map_generator/textures/black_concrete.png b/building_map_tools/building_map_generator/textures/black_concrete.png
similarity index 100%
rename from building_map_generator/textures/black_concrete.png
rename to building_map_tools/building_map_generator/textures/black_concrete.png
diff --git a/building_map_generator/textures/black_glitter_marble.png b/building_map_tools/building_map_generator/textures/black_glitter_marble.png
similarity index 100%
rename from building_map_generator/textures/black_glitter_marble.png
rename to building_map_tools/building_map_generator/textures/black_glitter_marble.png
diff --git a/building_map_generator/textures/blue_linoleum.png b/building_map_tools/building_map_generator/textures/blue_linoleum.png
similarity index 100%
rename from building_map_generator/textures/blue_linoleum.png
rename to building_map_tools/building_map_generator/textures/blue_linoleum.png
diff --git a/building_map_generator/textures/blue_linoleum_high_contrast.png b/building_map_tools/building_map_generator/textures/blue_linoleum_high_contrast.png
similarity index 100%
rename from building_map_generator/textures/blue_linoleum_high_contrast.png
rename to building_map_tools/building_map_generator/textures/blue_linoleum_high_contrast.png
diff --git a/building_map_generator/textures/brown_marble.png b/building_map_tools/building_map_generator/textures/brown_marble.png
similarity index 100%
rename from building_map_generator/textures/brown_marble.png
rename to building_map_tools/building_map_generator/textures/brown_marble.png
diff --git a/building_map_generator/textures/carpark_walkway.png b/building_map_tools/building_map_generator/textures/carpark_walkway.png
similarity index 100%
rename from building_map_generator/textures/carpark_walkway.png
rename to building_map_tools/building_map_generator/textures/carpark_walkway.png
diff --git a/building_map_generator/textures/concrete.png b/building_map_tools/building_map_generator/textures/concrete.png
similarity index 100%
rename from building_map_generator/textures/concrete.png
rename to building_map_tools/building_map_generator/textures/concrete.png
diff --git a/building_map_generator/textures/concrete2.png b/building_map_tools/building_map_generator/textures/concrete2.png
similarity index 100%
rename from building_map_generator/textures/concrete2.png
rename to building_map_tools/building_map_generator/textures/concrete2.png
diff --git a/building_map_generator/textures/concrete3.png b/building_map_tools/building_map_generator/textures/concrete3.png
similarity index 100%
rename from building_map_generator/textures/concrete3.png
rename to building_map_tools/building_map_generator/textures/concrete3.png
diff --git a/building_map_generator/textures/concrete4.png b/building_map_tools/building_map_generator/textures/concrete4.png
similarity index 100%
rename from building_map_generator/textures/concrete4.png
rename to building_map_tools/building_map_generator/textures/concrete4.png
diff --git a/building_map_generator/textures/default.png b/building_map_tools/building_map_generator/textures/default.png
similarity index 100%
rename from building_map_generator/textures/default.png
rename to building_map_tools/building_map_generator/textures/default.png
diff --git a/building_map_generator/textures/gray_flooring.png b/building_map_tools/building_map_generator/textures/gray_flooring.png
similarity index 100%
rename from building_map_generator/textures/gray_flooring.png
rename to building_map_tools/building_map_generator/textures/gray_flooring.png
diff --git a/building_map_generator/textures/metal.png b/building_map_tools/building_map_generator/textures/metal.png
similarity index 100%
rename from building_map_generator/textures/metal.png
rename to building_map_tools/building_map_generator/textures/metal.png
diff --git a/building_map_generator/textures/red_tiles.png b/building_map_tools/building_map_generator/textures/red_tiles.png
similarity index 100%
rename from building_map_generator/textures/red_tiles.png
rename to building_map_tools/building_map_generator/textures/red_tiles.png
diff --git a/building_map_generator/textures/rubber_pieces.png b/building_map_tools/building_map_generator/textures/rubber_pieces.png
similarity index 100%
rename from building_map_generator/textures/rubber_pieces.png
rename to building_map_tools/building_map_generator/textures/rubber_pieces.png
diff --git a/building_map_generator/textures/wall.png b/building_map_tools/building_map_generator/textures/wall.png
similarity index 100%
rename from building_map_generator/textures/wall.png
rename to building_map_tools/building_map_generator/textures/wall.png
diff --git a/building_map_generator/textures/white_beige_tiles.png b/building_map_tools/building_map_generator/textures/white_beige_tiles.png
similarity index 100%
rename from building_map_generator/textures/white_beige_tiles.png
rename to building_map_tools/building_map_generator/textures/white_beige_tiles.png
diff --git a/building_map_generator/textures/white_brick.png b/building_map_tools/building_map_generator/textures/white_brick.png
similarity index 100%
rename from building_map_generator/textures/white_brick.png
rename to building_map_tools/building_map_generator/textures/white_brick.png
diff --git a/building_map_generator/textures/white_marble.png b/building_map_tools/building_map_generator/textures/white_marble.png
similarity index 100%
rename from building_map_generator/textures/white_marble.png
rename to building_map_tools/building_map_generator/textures/white_marble.png
diff --git a/building_map_model_downloader/__init__.py b/building_map_tools/building_map_model_downloader/__init__.py
similarity index 100%
rename from building_map_model_downloader/__init__.py
rename to building_map_tools/building_map_model_downloader/__init__.py
diff --git a/building_map_model_downloader/building_map_model_downloader.py b/building_map_tools/building_map_model_downloader/building_map_model_downloader.py
similarity index 100%
rename from building_map_model_downloader/building_map_model_downloader.py
rename to building_map_tools/building_map_model_downloader/building_map_model_downloader.py
diff --git a/building_map_server/__init__.py b/building_map_tools/building_map_server/__init__.py
similarity index 100%
rename from building_map_server/__init__.py
rename to building_map_tools/building_map_server/__init__.py
diff --git a/building_map_server/building_map_server.py b/building_map_tools/building_map_server/building_map_server.py
similarity index 100%
rename from building_map_server/building_map_server.py
rename to building_map_tools/building_map_server/building_map_server.py
diff --git a/building_map_server/test/test_map_client.py b/building_map_tools/building_map_server/test/test_map_client.py
similarity index 100%
rename from building_map_server/test/test_map_client.py
rename to building_map_tools/building_map_server/test/test_map_client.py
diff --git a/model_downloader/__init__.py b/building_map_tools/model_downloader/__init__.py
similarity index 100%
rename from model_downloader/__init__.py
rename to building_map_tools/model_downloader/__init__.py
diff --git a/model_downloader/model_downloader.py b/building_map_tools/model_downloader/model_downloader.py
similarity index 100%
rename from model_downloader/model_downloader.py
rename to building_map_tools/model_downloader/model_downloader.py
diff --git a/package.xml b/building_map_tools/package.xml
similarity index 100%
rename from package.xml
rename to building_map_tools/package.xml
diff --git a/pit_crew/__init__.py b/building_map_tools/pit_crew/__init__.py
similarity index 100%
rename from pit_crew/__init__.py
rename to building_map_tools/pit_crew/__init__.py
diff --git a/pit_crew/pit_crew.py b/building_map_tools/pit_crew/pit_crew.py
similarity index 100%
rename from pit_crew/pit_crew.py
rename to building_map_tools/pit_crew/pit_crew.py
diff --git a/pit_crew/usage_examples.py b/building_map_tools/pit_crew/usage_examples.py
similarity index 100%
rename from pit_crew/usage_examples.py
rename to building_map_tools/pit_crew/usage_examples.py
diff --git a/resource/building_map_tools b/building_map_tools/resource/building_map_tools
similarity index 100%
rename from resource/building_map_tools
rename to building_map_tools/resource/building_map_tools
diff --git a/setup.cfg b/building_map_tools/setup.cfg
similarity index 100%
rename from setup.cfg
rename to building_map_tools/setup.cfg
diff --git a/setup.py b/building_map_tools/setup.py
similarity index 100%
rename from setup.py
rename to building_map_tools/setup.py
diff --git a/test/building_crowdsim/config_test.yaml b/building_map_tools/test/building_crowdsim/config_test.yaml
similarity index 100%
rename from test/building_crowdsim/config_test.yaml
rename to building_map_tools/test/building_crowdsim/config_test.yaml
diff --git a/test/building_crowdsim/test_build_configfile.py b/building_map_tools/test/building_crowdsim/test_build_configfile.py
similarity index 100%
rename from test/building_crowdsim/test_build_configfile.py
rename to building_map_tools/test/building_crowdsim/test_build_configfile.py
diff --git a/test/building_crowdsim/test_build_navmesh.py b/building_map_tools/test/building_crowdsim/test_build_navmesh.py
similarity index 100%
rename from test/building_crowdsim/test_build_navmesh.py
rename to building_map_tools/test/building_crowdsim/test_build_navmesh.py
diff --git a/test/building_crowdsim/test_build_navmesh_result.nav b/building_map_tools/test/building_crowdsim/test_build_navmesh_result.nav
similarity index 100%
rename from test/building_crowdsim/test_build_navmesh_result.nav
rename to building_map_tools/test/building_crowdsim/test_build_navmesh_result.nav
diff --git a/building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst b/building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst
new file mode 100644
index 0000000..655a614
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst
@@ -0,0 +1,50 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package building_gazebo_plugins
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.2.0 (2021-01-06)
+------------------
+* Merge branch 'release-1.1'
+* Control slotcar with model velocity cmds in place of joint velocity cmds (`#236 <https://github.com/osrf/traffic_editor/issues/236>`_)
+* Implement battery drain and recharge for slotcars (`#242 <https://github.com/osrf/traffic_editor/issues/242>`_)
+* Implement animation switching in crowd simulation (`#238 <https://github.com/osrf/traffic_editor/issues/238>`_)
+* Building_crowdsim for generating the navmesh file and required configuration files for menge (`#224 <https://github.com/osrf/traffic_editor/issues/224>`_)
+* Contributors: Geoffrey Biggs, Guoliang (Fred) Shao, Marco A. Gutierrez, Marco A. Gutiérrez, Rushyendra Maganty
+
+* Add animation switch to crowd simulation plugin (`#238 <https://github.com/osrf/traffic_editor/pull/238>`_)
+
+1.1.0 (2020-09-24)
+------------------
+* Implement model visibility toggling (`#226 <https://github.com/osrf/traffic_editor/issues/226>`_)
+* Add crowd simulation plugin (`#218 <https://github.com/osrf/traffic_editor/issues/218>`_)
+* Foxy support (`#194 <https://github.com/osrf/traffic_editor/issues/194>`_)
+* Add field in lift dialog for initial floor, handle invalid initial floor
+* Modularization of doors and slotcar `#138 <https://github.com/osrf/traffic_editor/issues/138>`_
+* Add gazebo lift plugin
+* Contributors: Charayaphan Nakorn Boon Han, Guoliang (Fred) Shao, Kevin_Skywalker, Luca Della Vedova, MakinoharaShouko, Yadu
+
+1.0.0 (2020-06-22)
+------------------
+* Merge pull request `#151 <https://github.com/osrf/traffic_editor/issues/151>`_ from osrf/fix/slotcar_level_name
+  Slotcar update
+* Level name inferred from elevation. Set publish rate to 2hz.
+* merging master
+* Merge pull request `#139 <https://github.com/osrf/traffic_editor/issues/139>`_ from osrf/feature/adapter_error
+  Report when a new path request is out of date
+* Report when a new path request is out of date
+* Merge pull request `#119 <https://github.com/osrf/traffic_editor/issues/119>`_ from osrf/fix/slotcar_level_name
+  Level name populated in Slotcar RobotState msg
+* Cleanup
+* Level name populated in RobotState msg
+* Merge pull request `#95 <https://github.com/osrf/traffic_editor/issues/95>`_ from osrf/fix/plugin-link-missing
+  changed to using target_link_libraries to be specific
+* changed to using target_link_libraries to be specific
+* Merge pull request `#90 <https://github.com/osrf/traffic_editor/issues/90>`_ from osrf/feature/single-doors
+  Feature/single doors
+* WIP open/close positions flipped at -90 and -1
+* migrated single door changes to plugin
+* Merge branch 'master' into feature/single-doors
+* Merge pull request `#89 <https://github.com/osrf/traffic_editor/issues/89>`_ from osrf/add_gazebo_plugins
+  add gazebo plugins used by building_map_tools generators
+* add gazebo plugins used by building_map_tools generators
+* Contributors: Aaron, Aaron Chong, Michael X. Grey, Morgan Quigley, Yadu, Yadunund
diff --git a/building_sim_plugins/building_gazebo_plugins/CMakeLists.txt b/building_sim_plugins/building_gazebo_plugins/CMakeLists.txt
new file mode 100644
index 0000000..8848c0d
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/CMakeLists.txt
@@ -0,0 +1,211 @@
+cmake_minimum_required(VERSION 3.5)
+project(building_gazebo_plugins)
+
+find_package(Qt5 COMPONENTS Widgets REQUIRED)
+set(CMAKE_AUTOMOC ON)
+
+# Default to C99
+if(NOT CMAKE_C_STANDARD)
+  set(CMAKE_C_STANDARD 99)
+endif()
+
+# Default to C++17
+if(NOT CMAKE_CXX_STANDARD)
+  set(CMAKE_CXX_STANDARD 17)
+endif()
+
+
+if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  add_compile_options(-Wall -Wextra -Wpedantic)
+endif()
+
+# find dependencies
+find_package(ament_cmake REQUIRED)
+find_package(rclcpp REQUIRED)
+find_package(gazebo REQUIRED)
+find_package(gazebo_ros REQUIRED)
+find_package(gazebo_dev REQUIRED)
+find_package(OpenCV REQUIRED )
+find_package(gazebo_msgs REQUIRED)
+find_package(tf2_ros REQUIRED)
+find_package(geometry_msgs REQUIRED)
+find_package(std_msgs REQUIRED)
+find_package(std_srvs REQUIRED)
+find_package(rmf_fleet_msgs REQUIRED)
+find_package(rmf_door_msgs REQUIRED)
+find_package(rmf_lift_msgs REQUIRED)
+find_package(building_map_msgs REQUIRED)
+find_package(building_sim_common REQUIRED)
+find_package(menge QUIET)
+
+# TODO this is a dependency of building_sim_common, it shouldn't be needed
+find_package(Eigen3 REQUIRED)
+
+include(GNUInstallDirs)
+
+add_library(slotcar SHARED ${PROJECT_SOURCE_DIR}/src/slotcar.cpp)
+
+ament_target_dependencies(slotcar
+  Eigen3
+  building_sim_common
+  rmf_fleet_msgs
+  rclcpp
+  gazebo_ros
+  std_msgs
+  geometry_msgs
+  tf2_ros
+  building_map_msgs
+)
+
+target_include_directories(slotcar
+  PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+    ${EIGEN3_INCLUDE_DIRS}
+    ${GAZEBO_INCLUDE_DIRS}
+)
+
+###############################
+# door stuff
+###############################
+
+add_library(door SHARED src/door.cpp)
+
+ament_target_dependencies(door
+  building_sim_common
+  rmf_fleet_msgs
+  rclcpp
+  gazebo_ros
+  rmf_door_msgs
+)
+
+target_include_directories(door
+  PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+    ${GAZEBO_INCLUDE_DIRS}
+)
+
+###############################
+# lift stuff
+###############################
+
+add_library(lift SHARED src/lift.cpp)
+
+ament_target_dependencies(lift
+    building_sim_common
+    rmf_fleet_msgs
+    rclcpp
+    gazebo_ros
+    rmf_door_msgs
+    rmf_lift_msgs
+)
+
+target_include_directories(lift
+  PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+    ${GAZEBO_INCLUDE_DIRS}
+)
+
+###############################
+# toggle floor stuff
+###############################
+
+add_library(toggle_floors SHARED src/toggle_floors.cpp)
+
+ament_target_dependencies(toggle_floors
+    Qt5
+    gazebo_ros
+    rmf_fleet_msgs
+    rclcpp
+)
+
+target_include_directories(toggle_floors
+  PUBLIC
+    ${GAZEBO_INCLUDE_DIRS}
+    #${building_sim_common_INCLUDE_DIRS}
+    ${Qt5Core_INCLUDE_DIRS}
+)
+
+###############################
+# toggle charging
+###############################
+
+add_library(toggle_charging SHARED src/toggle_charging.cpp)
+
+ament_target_dependencies(toggle_charging
+    Qt5
+    gazebo_ros
+    rmf_fleet_msgs
+    rclcpp
+)
+
+target_include_directories(toggle_charging
+  PUBLIC
+    ${GAZEBO_INCLUDE_DIRS}
+    ${Qt5Core_INCLUDE_DIRS}
+)
+
+
+###############################
+# thumbnail generation stuff
+###############################
+
+add_library(thumbnail_generator SHARED src/thumbnail_generator.cpp)
+
+target_include_directories(thumbnail_generator
+  PUBLIC
+    ${GAZEBO_INCLUDE_DIRS}
+    ${OpenCV_INCLUDE_DIRS}
+)
+
+target_link_libraries(thumbnail_generator
+  PUBLIC
+    ${OpenCV_LIBS}
+)
+
+###############################
+# crowd simulator stuff
+###############################
+if (menge_FOUND)
+  add_library(crowd_simulator
+    SHARED
+      src/crowd_simulator.cpp
+  )
+
+  ament_target_dependencies(crowd_simulator
+    building_sim_common
+    rclcpp
+    menge
+  )
+
+  target_include_directories(crowd_simulator
+    PUBLIC
+      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+      ${GAZEBO_INCLUDE_DIRS}
+      ${menge_INCLUDE_DIRS}
+      ${building_sim_common_INCLUDE_DIRS}   
+  )
+
+  #install
+  install(
+    TARGETS crowd_simulator
+    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  )
+else (NOT menge_FOUND)
+  message("menge-cmake not found, skipping crowd_simulation gazebo plugins")
+endif()
+
+###############################
+# install stuff
+###############################
+
+install(
+  TARGETS slotcar door lift toggle_floors toggle_charging thumbnail_generator
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
+
+ament_package()
diff --git a/building_sim_plugins/building_gazebo_plugins/QUALITY_DECLARATION.md b/building_sim_plugins/building_gazebo_plugins/QUALITY_DECLARATION.md
new file mode 100644
index 0000000..406614d
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/QUALITY_DECLARATION.md
@@ -0,0 +1,183 @@
+This document is a declaration of software quality for the `building_gazebo_plugins` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+# `building_gazebo_plugins` Quality Declaration
+
+The package `building_gazebo_plugins` claims to be in the **Quality Level 4** category.
+
+Below are the detailed rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+## Version Policy [1]
+
+### Version Scheme [1.i]
+
+`building_gazebo_plugins` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).
+
+### Version Stability [1.ii]
+
+`building_gazebo_plugins` is at a stable version, i.e. `>= 1.0.0`.
+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).
+
+### Public API Declaration [1.iii]
+
+`building_gazebo_plugins` does not have a public API.
+
+### API Stability Policy [1.iv]
+
+`building_gazebo_plugins` does not have a public API.
+
+### ABI Stability Policy [1.v]
+
+`building_gazebo_plugins` does not have a public API.
+
+### API and ABI Stability Within a Released ROS Distribution [1.vi]
+
+`building_gazebo_plugins` does not have a public API.
+
+## Change Control Process [2]
+
+`building_gazebo_plugins` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).
+
+### Change Requests [2.i]
+
+`building_gazebo_plugins` requires that all changes occur through a pull request.
+
+### Contributor Origin [2.ii]
+
+`building_gazebo_plugins` does not require a confirmation of contributor origin.
+
+### Peer Review Policy [2.iii]
+
+All pull requests must have at least 1 peer review.
+
+### Continuous Integration [2.iv]
+
+All pull requests must pass CI on all platforms supported by RMF.
+The CI checks only that the package builds.
+The most recent CI results can be seen on [the workflow page](https://github.com/osrf/traffic_editor/actions).
+
+### Documentation Policy [2.v]
+
+All pull requests must resolve related documentation changes before merging.
+
+## Documentation [3]
+
+### Feature Documentation [3.i]
+
+`building_gazebo_plugins` does not provide feature documentation.
+
+### Public API Documentation [3.ii]
+
+`building_gazebo_plugins` does not have a public API.
+
+### License [3.iii]
+
+The license for `building_gazebo_plugins` is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.
+
+### Copyright Statement [3.iv]
+
+The copyright holders each provide a statement of copyright in each source code file in `rmf_demo_tasks`.
+
+### Quality declaration document [3.v]
+
+This quality declaration is linked in the [README file](README.md).
+
+This quality declaration has not been externally peer-reviewed and is not registered on any Level 4 lists.
+
+## Testing [4]
+
+### Feature Testing [4.i]
+
+`building_gazebo_plugins` does not have any tests.
+
+### Public API Testing [4.ii]
+
+`building_gazebo_plugins` does not have a public API.
+
+### Coverage [4.iii]
+
+`building_gazebo_plugins` does not track coverage statistics.
+
+### Performance [4.iv]
+
+`building_gazebo_plugins` does not have performance tests.
+
+### Linters and Static Analysis [4.v]
+
+`building_gazebo_plugins` does not use the standard linters and static analysis tools for its CMake code to ensure it follows the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).
+
+## Dependencies [5]
+
+### Direct Runtime ROS Dependencies [5.i]
+
+`building_gazebo_plugins` has the following direct runtime ROS dependencies.
+
+#### rclcpp
+
+`rclcpp` is [**Quality Level 3**](https://github.com/ros2/rclcpp/blob/master/rclcpp/QUALITY_DECLARATION.md).
+
+#### gazebo\_ros
+
+`gazebo_ros` does not declare a Quality Level.
+It is assumed tobe at **Quality Level 4** based on its widespread use.
+
+#### gazebo\_msgs
+
+`gazebo_ros_msgs` does not declare a Quality Level.
+It is assumed tobe at **Quality Level 4** based on its widespread use.
+
+#### gazebo\_dev
+
+`gazebo_dev` does not declare a Quality Level.
+It is assumed tobe at **Quality Level 4** based on its widespread use.
+
+#### rmf\_fleet\_msgs
+
+`rmf_fleet_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_fleet_msgs/QUALITY_DECLARATION.md).
+
+#### rmf\_door\_msgs
+
+`rmf_door_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_door_msgs/QUALITY_DECLARATION.md).
+
+#### rmf\_lift\_msgs
+
+`rmf_lift_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_lift_msgs/QUALITY_DECLARATION.md).
+
+#### tf2\_ros
+
+`gazebo_dev` does not declare a Quality Level.
+It is assumed tobe at **Quality Level 4** based on its widespread use and use of CI.
+
+#### geometry\_msgs
+
+`geometry_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/geometry_msgs/QUALITY_DECLARATION.md).
+
+#### std\_msgs
+
+`std_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/std_msgs/QUALITY_DECLARATION.md).
+
+#### std\_srvs
+
+`std_srvs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/std_srvs/QUALITY_DECLARATION.md).
+
+#### building\_sim\_common
+
+`building_sim_common` is [**Quality Level 4**](https://github.com/osrf/traffic_editor/blob/master/building_sim_plugins/building_sim_common/QUALITY_DECLARATION.md).
+
+### Optional Direct Runtime ROS Dependencies [5.ii]
+
+`building_gazebo_plugins` does not have any optional direct runtime ROS dependencies.
+
+### Direct Runtime non-ROS Dependency [5.iii]
+
+`building_gazebo_plugins` does not have any runtime non-ROS dependencies.
+
+## Platform Support [6]
+
+`building_gazebo_plugins` does not support all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers).
+`building_gazebo_plugins` supports ROS Eloquent and ROS Foxy.
+
+## Security [7]
+
+### Vulnerability Disclosure Policy [7.i]
+
+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).
diff --git a/building_sim_plugins/building_gazebo_plugins/README.md b/building_sim_plugins/building_gazebo_plugins/README.md
new file mode 100644
index 0000000..d462077
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/README.md
@@ -0,0 +1,7 @@
+# building\_gazebo\_plugins
+
+This package provides Gazebo simulator plugins for allowing simulated building infrastructure to communicate with a ROS system.
+
+## Quality Declaration
+
+This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.
diff --git a/building_sim_plugins/building_gazebo_plugins/package.xml b/building_sim_plugins/building_gazebo_plugins/package.xml
new file mode 100644
index 0000000..3911e4f
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/package.xml
@@ -0,0 +1,38 @@
+<package format="3">
+  <name>building_gazebo_plugins</name>
+  <version>1.2.0</version>
+  <description>
+    Gazebo plugins so that buildings generated by building_map_tools can
+    talk to the ROS 2-based systems in the rmf_core package.
+  </description>
+  <author>Morgan Quigley</author>
+  <author>Michael Grey</author>
+  <author>Roselle Carmen</author>
+  <author>Aaron Chong</author>
+  <author>Brandon Ong</author>
+  <author>Kevin Ma</author>
+  <author>Rushyendra Maganty</author>
+  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
+  <license>Apache 2.0</license>
+
+  <buildtool_depend>ament_cmake</buildtool_depend>
+
+  <depend>rclcpp</depend>
+  <depend>gazebo_ros</depend>
+  <depend>gazebo_msgs</depend>
+  <depend>gazebo_dev</depend>
+  <depend>rmf_fleet_msgs</depend>
+  <depend>rmf_door_msgs</depend>
+  <depend>rmf_lift_msgs</depend>
+  <depend>tf2_ros</depend>
+  <depend>geometry_msgs</depend>
+  <depend>std_msgs</depend>
+  <depend>std_srvs</depend>
+  <depend>building_sim_common</depend>
+  <depend>libopencv-dev</depend>
+
+  <export>
+    <build_type>ament_cmake</build_type>
+  </export>
+
+</package>
diff --git a/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp b/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp
new file mode 100644
index 0000000..e909023
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <memory>
+#include <unordered_set>
+#include <regex>
+#include <cstdlib>
+
+#include <ignition/math/Pose3.hh>
+
+#include "crowd_simulator.hpp"
+
+namespace crowd_simulation_gazebo {
+
+//============================================
+//WorldPlugin
+void CrowdSimulatorPlugin::Load(
+  gazebo::physics::WorldPtr world,
+  sdf::ElementPtr sdf)
+{
+  _world = world;
+
+  if (!_crowd_sim_interface->read_sdf(sdf))
+  {
+    exit(EXIT_FAILURE);
+  }
+
+  if (!_crowd_sim_interface->init_crowd_sim())
+  {
+    RCLCPP_ERROR(
+      _crowd_sim_interface->logger(),
+      "Crowd simulation failed to initialize.");
+    exit(EXIT_FAILURE);
+  }
+
+  if (!_spawn_agents_in_world())
+  {
+    RCLCPP_ERROR(
+      _crowd_sim_interface->logger(),
+      "Crowd simulation failed to spawn agents in the world.");
+    exit(EXIT_FAILURE);
+  }
+
+  _update_connection_ptr = gazebo::event::Events::ConnectWorldUpdateBegin(
+    [this](gazebo::common::UpdateInfo update_info)
+    {
+      _update(update_info);
+    }
+  );
+}
+
+//============================================
+void CrowdSimulatorPlugin::_update(
+  const gazebo::common::UpdateInfo& update_info)
+{
+  //first round do nothing, initialize time stamp
+  if (_last_sim_time == gazebo::common::Time::Zero)
+  {
+    _last_sim_time = update_info.simTime;
+  }
+
+  if (!_initialized)
+  {
+    // not initizalied
+    _init_spawned_agents();
+    return;
+  }
+
+  auto delta_sim_time = (update_info.simTime - _last_sim_time).Double();
+  if (delta_sim_time > _crowd_sim_interface->get_sim_time_step())
+  {
+    _last_sim_time = update_info.simTime;
+    _crowd_sim_interface->one_step_sim();
+    _update_all_objects(delta_sim_time);
+  }
+}
+
+//============================================
+void CrowdSimulatorPlugin::_update_all_objects(double delta_sim_time)
+{
+  for (size_t id = 0; id < _objects_count; id++)
+  {
+    ObjectPtr obj_ptr = _crowd_sim_interface->get_object_by_id(id);
+    gazebo::physics::ModelPtr model_ptr = _world->ModelByName(
+      obj_ptr->model_name);
+
+    //update external agents
+    if (obj_ptr->agent_ptr->_external)
+    {
+      ignition::math::Pose3d pose = model_ptr->WorldPose();
+      _crowd_sim_interface->update_external_agent<ignition::math::Pose3d>(
+        obj_ptr->agent_ptr, pose);
+      continue;
+    }
+
+    //update internal agents
+    auto type_ptr = _crowd_sim_interface->_model_type_db_ptr->get(
+      obj_ptr->type_name);
+    _update_internal_object(delta_sim_time, obj_ptr,
+      model_ptr, type_ptr);
+  }
+}
+
+//============================================
+void CrowdSimulatorPlugin::_update_internal_object(
+  double delta_sim_time,
+  const ObjectPtr object_ptr,
+  const gazebo::physics::ModelPtr model_ptr,
+  const crowd_simulator::ModelTypeDatabase::RecordPtr type_ptr)
+{
+  if (!object_ptr)
+  {
+    RCLCPP_ERROR(
+      _crowd_sim_interface->logger(), "Null objectPtr when update Object!");
+    return;
+  }
+  if (!model_ptr)
+  {
+    RCLCPP_ERROR(
+      _crowd_sim_interface->logger(), "Null modelPtr when update Object!");
+    return;
+  }
+
+  //update pose from menge to gazebo
+  ignition::math::Pose3d pose =
+    _crowd_sim_interface->get_agent_pose<ignition::math::Pose3d>(
+    object_ptr->agent_ptr,
+    delta_sim_time);
+
+  gazebo::physics::ActorPtr actor_ptr =
+    boost::dynamic_pointer_cast<gazebo::physics::Actor>(model_ptr);
+
+  auto delta_dist_vector = pose.Pos() - actor_ptr->WorldPose().Pos();
+  // might need future work on 3D case
+  // the center of human has a z_elevation, which will make the human keep walking even if he reached the target
+  delta_dist_vector.Z(0.0);
+  double delta_dist = delta_dist_vector.Length();
+
+  auto init_pose = type_ptr->pose;
+  ignition::math::Pose3d anim_pose(
+    init_pose.x(), init_pose.y(), init_pose.z(),
+    init_pose.pitch(), init_pose.roll(), init_pose.yaw());
+  //update x and y coordinates
+  anim_pose.Pos().X(pose.Pos().X());
+  anim_pose.Pos().Y(pose.Pos().Y());
+
+  AnimState next_state = object_ptr->get_next_state(
+    delta_dist < _crowd_sim_interface->get_switch_anim_distance_th() &&
+    !type_ptr->idle_animation.empty());
+
+  auto traj_info = actor_ptr->CustomTrajectory();
+  switch (next_state)
+  {
+    case AnimState::WALK:
+      actor_ptr->SetScriptTime(
+        actor_ptr->ScriptTime() + delta_dist / type_ptr->animation_speed);
+      anim_pose.Rot() = pose.Rot();
+      if (object_ptr->current_state != next_state)
+        traj_info->type = type_ptr->animation;
+      break;
+
+    case AnimState::IDLE:
+      actor_ptr->SetScriptTime(
+        actor_ptr->ScriptTime() + delta_sim_time);
+      anim_pose.Rot() = actor_ptr->WorldPose().Rot();
+      if (object_ptr->current_state != next_state)
+        traj_info->type = type_ptr->idle_animation;
+      break;
+  }
+  object_ptr->current_state = next_state;
+  actor_ptr->SetWorldPose(anim_pose);
+}
+
+//============================================
+void CrowdSimulatorPlugin::_init_spawned_agents()
+{
+  _objects_count = _crowd_sim_interface->get_num_objects();
+  for (size_t id = 0; id < _objects_count; ++id)
+  {
+    ObjectPtr obj_ptr = _crowd_sim_interface->get_object_by_id(id);
+    // spawned agents are not fully loaded
+    if (!_world->ModelByName(obj_ptr->model_name))
+    {
+      _initialized = false;
+      return;
+    }
+    // all agents are loaded, set internal actors as non-static model and set custom trajectory
+    // because only non-static model can interact with slotcars
+    if (!obj_ptr->is_external)
+    {
+      gazebo::physics::ModelPtr model_ptr = _world->ModelByName(
+        obj_ptr->model_name);
+      gazebo::physics::ActorPtr actor_ptr =
+        boost::dynamic_pointer_cast<gazebo::physics::Actor>(model_ptr);
+      gazebo::physics::TrajectoryInfoPtr trajectory_info(new gazebo::physics::
+        TrajectoryInfo()); //matches the actor skeleton
+
+      crowd_simulator::ModelTypeDatabase::RecordPtr type_ptr =
+        _crowd_sim_interface->_model_type_db_ptr->get(obj_ptr->type_name);
+      trajectory_info->type = type_ptr->animation;
+      // set each keyframe duration as the sim_time_step
+      trajectory_info->duration = _crowd_sim_interface->get_sim_time_step();
+      actor_ptr->SetCustomTrajectory(trajectory_info);
+      actor_ptr->SetStatic(false);
+
+      //check actor has idle animation
+      for (auto idle_anim : _crowd_sim_interface->get_switch_anim_name())
+      {
+        if (actor_ptr->SkeletonAnimations().find(idle_anim) !=
+          actor_ptr->SkeletonAnimations().end())
+        {
+          type_ptr->idle_animation = idle_anim;
+          break;
+        }
+      }
+    }
+  }
+  _initialized = true;
+  RCLCPP_INFO(
+    _crowd_sim_interface->logger(),
+    "Gazebo models all loaded! Start simulating...");
+}
+
+//============================================
+bool CrowdSimulatorPlugin::_spawn_agents_in_world()
+{
+  //create model in world for each internal agents
+  _objects_count = _crowd_sim_interface->get_num_objects();
+  for (size_t id = 0; id < _objects_count; id++)
+  {
+    if (!_crowd_sim_interface->get_object_by_id(id)->is_external)
+    {
+      auto object_ptr = _crowd_sim_interface->get_object_by_id(id);
+      assert(object_ptr);
+      auto type_ptr = _crowd_sim_interface->_model_type_db_ptr->get(
+        object_ptr->type_name);
+      assert(type_ptr);
+      if (!_create_model(object_ptr->model_name, type_ptr,
+        object_ptr->agent_ptr) )
+      {
+        RCLCPP_INFO(_crowd_sim_interface->logger(),
+          "Failed to insert model [" + object_ptr->model_name + "] in world");
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+//============================================
+bool CrowdSimulatorPlugin::_create_model(
+  const std::string& model_name,
+  const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr,
+  const crowd_simulator::AgentPtr agent_ptr)
+{
+  sdf::ElementPtr model_element(new sdf::Element());
+  model_element->SetName("include");
+
+  sdf::ElementPtr name_element(new sdf::Element());
+  name_element->SetName("name");
+  name_element->AddValue("string", model_name, true);
+  model_element->InsertElement(name_element);
+
+  sdf::ElementPtr uri_element(new sdf::Element());
+  uri_element->SetName("uri");
+  uri_element->AddValue("string", model_type_ptr->file_name, true);
+  model_element->InsertElement(uri_element);
+
+  sdf::ElementPtr static_element(new sdf::Element());
+  static_element->SetName("static");
+  static_element->AddValue("string", "False", true);
+  model_element->InsertElement(static_element);
+
+  sdf::ElementPtr pose_element(new sdf::Element());
+  pose_element->SetName("pose");
+  std::ostringstream oss;
+  oss << agent_ptr->_pos.x() << " " << agent_ptr->_pos.y() << " " << "0 0 0 0";
+  pose_element->AddValue("pose", oss.str(), true);
+  model_element->InsertElement(pose_element);
+
+  sdf::SDFPtr sdf(new sdf::SDF());
+  sdf->Root(model_element);
+
+  assert(sdf);
+  _world->InsertModelSDF(*sdf);
+  RCLCPP_INFO(_crowd_sim_interface->logger(),
+    "Insert actor for crowd simulator agent: [" + model_name + "] at ["+ oss.str() +
+    "].");
+  return true;
+}
+
+// insert the plugin
+GZ_REGISTER_WORLD_PLUGIN(CrowdSimulatorPlugin)
+} //namespace crowd_simulation_gazebo
\ No newline at end of file
diff --git a/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp b/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp
new file mode 100644
index 0000000..5af9bc6
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_SIM_COMMON__CROWD_SIMULATOR_GAZEBO_HPP
+#define BUILDING_SIM_COMMON__CROWD_SIMULATOR_GAZEBO_HPP
+
+#include <memory>
+#include <unordered_map>
+
+#include <rclcpp/rclcpp.hpp>
+
+#include <ignition/math/Pose3.hh>
+
+#include <gazebo/common/Plugin.hh>
+#include <gazebo/common/UpdateInfo.hh>
+#include <gazebo/common/Events.hh>
+#include <gazebo/common/Mesh.hh>
+#include <gazebo/common/Skeleton.hh>
+#include <gazebo/common/SkeletonAnimation.hh>
+#include <gazebo/physics/Actor.hh>
+#include <gazebo/physics/physics.hh>
+
+#include <building_sim_common/crowd_simulator_common.hpp>
+
+
+namespace crowd_simulation_gazebo {
+
+using ObjectPtr = crowd_simulator::CrowdSimInterface::ObjectPtr;
+//================================================================
+/*
+* class CrowdSimulatorPlugin
+*/
+
+class CrowdSimulatorPlugin : public gazebo::WorldPlugin
+{
+  using AnimState = crowd_simulator::CrowdSimInterface::AnimState;
+public:
+  CrowdSimulatorPlugin()
+  : _crowd_sim_interface(std::make_shared<crowd_simulator::CrowdSimInterface>()),
+    _initialized(false),
+    _objects_count(0)
+  {}
+
+  void Load(gazebo::physics::WorldPtr world, sdf::ElementPtr sdf) override;
+
+private:
+  std::shared_ptr<crowd_simulator::CrowdSimInterface> _crowd_sim_interface;
+  bool _initialized;
+  size_t _objects_count;
+  gazebo::physics::WorldPtr _world;
+  gazebo::event::ConnectionPtr _update_connection_ptr;
+  gazebo::common::Time _last_sim_time;
+
+  bool _spawn_agents_in_world();
+  void _init_spawned_agents();
+  void _update(const gazebo::common::UpdateInfo& update_info); //Update trigger function
+  void _update_all_objects(double delta_sim_time);
+  void _update_internal_object(
+    double delta_sim_time,
+    const ObjectPtr object_ptr,
+    const gazebo::physics::ModelPtr model_ptr,
+    const crowd_simulator::ModelTypeDatabase::RecordPtr type_ptr);
+  bool _create_model(
+    const std::string& model_name,
+    const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr,
+    const crowd_simulator::AgentPtr agent_ptr);
+};
+
+} //namespace crowd_simulation_gazebo
+
+#endif // CROWD_SIMULATION_GAZEBO__CROWD_SIMULATOR_GAZEBO_HPP
\ No newline at end of file
diff --git a/building_sim_plugins/building_gazebo_plugins/src/door.cpp b/building_sim_plugins/building_gazebo_plugins/src/door.cpp
new file mode 100644
index 0000000..8835047
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/door.cpp
@@ -0,0 +1,110 @@
+#include <gazebo/common/Plugin.hh>
+#include <gazebo/physics/Model.hh>
+#include <gazebo/physics/World.hh>
+#include <gazebo/physics/Joint.hh>
+#include <gazebo_ros/node.hpp>
+#include <rclcpp/rclcpp.hpp>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/door_common.hpp>
+
+using namespace building_sim_common;
+
+namespace building_gazebo_plugins {
+//==============================================================================
+
+class DoorPlugin : public gazebo::ModelPlugin
+{
+private:
+  gazebo::event::ConnectionPtr _update_connection;
+  gazebo::physics::ModelPtr _model;
+  std::unordered_map<std::string, gazebo::physics::JointPtr> _joints;
+
+  std::shared_ptr<DoorCommon> _door_common = nullptr;
+
+  bool _initialized = false;
+
+public:
+  DoorPlugin()
+  {
+    // Do nothing
+  }
+
+  void Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf) override
+  {
+    auto _ros_node = gazebo_ros::Node::Get(sdf);
+    _model = model;
+
+    RCLCPP_INFO(
+      _ros_node->get_logger(),
+      "Loading DoorPlugin for [%s]",
+      _model->GetName().c_str());
+
+    _door_common = DoorCommon::make(
+      _model->GetName(),
+      _ros_node,
+      sdf);
+
+    if (!_door_common)
+      return;
+
+    for (const auto& joint_name : _door_common->joint_names())
+    {
+      const auto joint = _model->GetJoint(joint_name);
+      if (!joint)
+      {
+        RCLCPP_ERROR(_ros_node->get_logger(),
+          " -- Model is missing the joint [%s]",
+          joint_name.c_str());
+        return;
+      }
+      _joints.insert(std::make_pair(joint_name, joint));
+    }
+
+    _initialized = true;
+
+    _update_connection = gazebo::event::Events::ConnectWorldUpdateBegin(
+      std::bind(&DoorPlugin::on_update, this));
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Finished loading [%s]",
+      _model->GetName().c_str());
+  }
+
+private:
+
+  void on_update()
+  {
+    if (!_initialized)
+      return;
+
+    const double t = _model->GetWorld()->SimTime().Double();
+
+    // Create DoorUpdateRequest
+    std::vector<DoorCommon::DoorUpdateRequest> requests;
+    for (const auto& joint : _joints)
+    {
+      DoorCommon::DoorUpdateRequest request;
+      request.joint_name = joint.first;
+      request.position = joint.second->Position(0);
+      request.velocity = joint.second->GetVelocity(0);
+      requests.push_back(request);
+    }
+
+    auto results = _door_common->update(t, requests);
+
+    // Apply motions to the joints
+    for (const auto& result : results)
+    {
+      const auto it = _joints.find(result.joint_name);
+      assert(it != _joints.end());
+      it->second->SetParam("vel", 0, result.velocity);
+      it->second->SetParam("fmax", 0, result.fmax);
+    }
+  }
+
+};
+
+GZ_REGISTER_MODEL_PLUGIN(DoorPlugin)
+
+} // namespace building_gazebo_plugins
diff --git a/building_sim_plugins/building_gazebo_plugins/src/lift.cpp b/building_sim_plugins/building_gazebo_plugins/src/lift.cpp
new file mode 100644
index 0000000..684a645
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/lift.cpp
@@ -0,0 +1,95 @@
+#include <gazebo/common/Plugin.hh>
+#include <gazebo/physics/Model.hh>
+#include <gazebo/physics/World.hh>
+#include <gazebo/physics/Joint.hh>
+#include <gazebo_ros/node.hpp>
+#include <rclcpp/rclcpp.hpp>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/lift_common.hpp>
+
+using namespace building_sim_common;
+
+namespace building_sim_gazebo {
+//==============================================================================
+
+class LiftPlugin : public gazebo::ModelPlugin
+{
+private:
+  // Gazebo items
+  gazebo::event::ConnectionPtr _update_connection;
+  gazebo::physics::ModelPtr _model;
+  gazebo::physics::JointPtr _cabin_joint_ptr;
+  gazebo_ros::Node::SharedPtr _ros_node;
+
+  std::unique_ptr<LiftCommon> _lift_common = nullptr;
+
+  bool _initialized;
+
+public:
+  LiftPlugin()
+  {
+    _initialized = false;
+  }
+
+  void Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf) override
+  {
+    _ros_node = gazebo_ros::Node::Get(sdf);
+    _model = model;
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Loading LiftPlugin for [%s]",
+      _model->GetName().c_str());
+
+    // load Lift object
+    _lift_common = LiftCommon::make(_model->GetName(), _ros_node, sdf);
+    if (!_lift_common)
+    {
+      RCLCPP_ERROR(_ros_node->get_logger(),
+        "Failed when loading [%s]",
+        _model->GetName().c_str());
+      return;
+    }
+
+    _cabin_joint_ptr = _model->GetJoint(_lift_common->get_joint_name());
+    if (!_cabin_joint_ptr)
+    {
+      RCLCPP_ERROR(_ros_node->get_logger(),
+        " -- Model is missing the joint [%s]",
+        _lift_common->get_joint_name().c_str());
+      return;
+    }
+
+    _update_connection = gazebo::event::Events::ConnectWorldUpdateBegin(
+      std::bind(&LiftPlugin::on_update, this));
+
+    _cabin_joint_ptr->SetPosition(0, _lift_common->get_elevation());
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Finished loading [%s]",
+      _model->GetName().c_str());
+
+    _initialized = true;
+  }
+
+private:
+  void on_update()
+  {
+    if (!_initialized)
+      return;
+
+    const double t = _model->GetWorld()->SimTime().Double();
+    const double position = _cabin_joint_ptr->Position(0);
+    const double velocity = _cabin_joint_ptr->GetVelocity(0);
+
+    // Send update request
+    auto result = _lift_common->update(t, position, velocity);
+
+    _cabin_joint_ptr->SetParam("vel", 0, result.velocity);
+    _cabin_joint_ptr->SetParam("fmax", 0, result.fmax);
+  }
+};
+
+GZ_REGISTER_MODEL_PLUGIN(LiftPlugin)
+
+} // namespace building_sim_gazebo
diff --git a/building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp b/building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp
new file mode 100644
index 0000000..3e03f61
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp
@@ -0,0 +1,168 @@
+#include <gazebo/physics/World.hh>
+#include <gazebo/physics/Model.hh>
+#include <gazebo/physics/Joint.hh>
+#include <gazebo_ros/node.hpp>
+
+#include <gazebo/common/Plugin.hh>
+#include <gazebo/transport/transport.hh>
+#include <gazebo/msgs/msgs.hh>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/slotcar_common.hpp>
+
+using namespace building_sim_common;
+
+class SlotcarPlugin : public gazebo::ModelPlugin
+{
+public:
+  SlotcarPlugin();
+  ~SlotcarPlugin();
+
+  void Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf) override;
+  void OnUpdate();
+
+private:
+  std::unique_ptr<SlotcarCommon> dataPtr;
+
+  gazebo::transport::NodePtr _gazebo_node;
+  gazebo::transport::SubscriberPtr _charge_state_sub;
+
+  gazebo::event::ConnectionPtr _update_connection;
+  gazebo::physics::ModelPtr _model;
+
+  std::array<gazebo::physics::JointPtr, 2> joints;
+
+  std::unordered_set<gazebo::physics::Model*> infrastructure;
+
+  // Book keeping
+  double last_update_time = 0.0;
+
+  void init_infrastructure();
+
+  std::vector<Eigen::Vector3d> get_obstacle_positions(
+    const gazebo::physics::WorldPtr& world);
+
+  void charge_state_cb(ConstSelectionPtr& msg);
+
+  void send_control_signals(const std::pair<double, double>& velocities,
+    const double dt)
+  {
+    std::array<double, 2> w_tire;
+    for (std::size_t i = 0; i < 2; ++i)
+      w_tire[i] = joints[i]->GetVelocity(0);
+    auto joint_signals = dataPtr->calculate_joint_control_signals(w_tire,
+        velocities, dt);
+    for (std::size_t i = 0; i < 2; ++i)
+    {
+      joints[i]->SetParam("vel", 0, joint_signals[i]);
+      joints[i]->SetParam("fmax", 0, 10000000.0); // TODO(MXG): Replace with realistic torque limit
+    }
+  }
+};
+
+SlotcarPlugin::SlotcarPlugin()
+: dataPtr(std::make_unique<SlotcarCommon>())
+{
+  // Listen for messages that enable/disable charging
+  _gazebo_node = gazebo::transport::NodePtr(new gazebo::transport::Node());
+  _gazebo_node->Init();
+  _charge_state_sub = _gazebo_node->Subscribe("/charge_state",
+      &SlotcarPlugin::charge_state_cb, this);
+  // We do rest of initialization during ::Load
+}
+
+SlotcarPlugin::~SlotcarPlugin()
+{
+}
+
+void SlotcarPlugin::Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf)
+{
+  _model = model;
+  dataPtr->set_model_name(_model->GetName());
+  dataPtr->read_sdf(sdf);
+  gazebo_ros::Node::SharedPtr _ros_node = gazebo_ros::Node::Get(sdf);
+  dataPtr->init_ros_node(_ros_node);
+
+  RCLCPP_INFO(dataPtr->logger(),
+    "Initialising slotcar for " + model->GetName());
+
+  _update_connection = gazebo::event::Events::ConnectWorldUpdateBegin(
+    std::bind(&SlotcarPlugin::OnUpdate, this));
+
+  joints[0] = _model->GetJoint("joint_tire_left");
+  if (!joints[0])
+    RCLCPP_ERROR(dataPtr->logger(),
+      "Could not find tire for [joint_tire_left]");
+
+  joints[1] = _model->GetJoint("joint_tire_right");
+  if (!joints[1])
+    RCLCPP_ERROR(dataPtr->logger(),
+      "Could not find tire for [joint_tire_right]");
+
+}
+
+void SlotcarPlugin::charge_state_cb(ConstSelectionPtr& msg)
+{
+  dataPtr->charge_state_cb(msg->name(), msg->selected());
+}
+
+void SlotcarPlugin::init_infrastructure()
+{
+  const auto& world = _model->GetWorld();
+  infrastructure.insert(_model.get());
+  const auto& all_models = world->Models();
+  for (const auto& m : all_models)
+  {
+    // Object should not be static and part of infrastructure
+    if (!m->IsStatic())
+    {
+      std::string name = m->GetName();
+      std::for_each(name.begin(), name.end(), [](char& c)
+        {
+          c = ::tolower(c);
+        });
+      if (name.find("door") != std::string::npos ||
+        name.find("lift") != std::string::npos)
+        infrastructure.insert(m.get());
+    }
+  }
+}
+
+std::vector<Eigen::Vector3d> SlotcarPlugin::get_obstacle_positions(
+  const gazebo::physics::WorldPtr& world)
+{
+  std::vector<Eigen::Vector3d> obstacle_positions;
+
+  for (const auto& m : world->Models())
+  {
+    // Object should not be static, not part of infrastructure
+    // and close than a threshold (checked by common function)
+    const auto p_obstacle = m->WorldPose().Pos();
+    if (m->IsStatic() == false &&
+      infrastructure.find(m.get()) == infrastructure.end())
+      obstacle_positions.push_back(convert_vec(p_obstacle));
+  }
+
+  return obstacle_positions;
+}
+
+void SlotcarPlugin::OnUpdate()
+{
+  const auto& world = _model->GetWorld();
+  if (infrastructure.empty())
+    init_infrastructure();
+
+  const double time = world->SimTime().Double();
+  const double dt = time - last_update_time;
+  last_update_time = time;
+
+  auto pose = _model->WorldPose();
+  auto obstacle_positions = get_obstacle_positions(world);
+
+  auto velocities =
+    dataPtr->update(convert_pose(pose), obstacle_positions, time);
+
+  send_control_signals(velocities, dt);
+}
+
+GZ_REGISTER_MODEL_PLUGIN(SlotcarPlugin)
diff --git a/building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp b/building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp
new file mode 100644
index 0000000..584a92f
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp
@@ -0,0 +1,317 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <string>
+#include <iostream>
+#include <functional>
+#include <boost/program_options.hpp>
+#include <ignition/transport/Node.hh>
+#include <opencv2/opencv.hpp>
+
+#include "gazebo/msgs/msgs.hh"
+#include "gazebo/transport/transport.hh"
+#include "gazebo/sensors/SensorsIface.hh"
+#include "gazebo/common/Plugin.hh"
+#include "gazebo/rendering/rendering.hh"
+#include "gazebo/util/system.hh"
+
+using namespace gazebo;
+namespace po = boost::program_options;
+
+class GZ_PLUGIN_VISIBLE ThumbnailGenerator : public SystemPlugin
+{
+
+public:
+  /////////////////////////////////////////////
+  virtual ~ThumbnailGenerator()
+  {
+    rendering::fini();
+  }
+
+  /////////////////////////////////////////////
+  void Load(int _argc, char** _argv)
+  {
+    // System arguments Parser
+    try
+    {
+      po::options_description option{"Options"};
+      po::options_description config("Optional Configs");
+      po::options_description all_options{"Allowed Options"};
+
+      option.add_options()("input", po::value<std::string>(),
+        "Path of input sdf model")("output", po::value<std::string>(),
+        "Path of output directory");
+
+      config.add_options()("img-size", po::value<int>()->default_value(4000),
+        "Output thumbnail Image pixel size")("cam-height",
+        po::value<double>()->default_value(200),
+        "Scene camara height")("cam-hfov",
+        po::value<double>()->default_value(0.08),
+        "Scene camera horizontal FOV");
+
+      all_options.add(option).add(config);
+      _print_options_stream << all_options;
+
+      po::variables_map vm;
+      po::store(po::command_line_parser(_argc, _argv).options(
+          all_options).allow_unregistered().run(), vm);
+      po::notify(vm);
+
+      _model_path = vm["input"].as<std::string>();
+      _output_path = boost::filesystem::path(vm["output"].as<std::string>());
+      _img_size = vm["img-size"].as<int>();
+      _cam_height = vm["cam-height"].as<double>();
+      _cam_hfov = vm["cam-hfov"].as<double>();
+
+      printf(" - input model: %s \n", _model_path.c_str());
+      printf(" - output dir: %s \n", _output_path.c_str());
+      printf(" - configs: %d, %f, %f \n", _img_size, _cam_height, _cam_hfov);
+    }
+    catch (boost::exception& _e)
+    {
+      std::cerr << "\nError: Invalid arguments\n"<<std::endl;
+      this->PrintHelp();
+      _exit_flag = true;
+      return;
+    }
+
+    if (!boost::filesystem::exists(_output_path))
+      boost::filesystem::create_directories(_output_path);
+
+    std::ifstream ifs(_model_path.c_str());
+    if (!ifs)
+    {
+      std::cerr << "Error: Unable to open file[" << _model_path << "]\n";
+      this->PrintHelp();
+      _exit_flag = true;
+      return;
+    }
+
+    this->_sdf_model.reset(new sdf::SDF());
+    if (!sdf::init(this->_sdf_model))
+    {
+      std::cerr << "ERROR: SDF parsing the xml failed" << std::endl;
+      this->PrintHelp();
+      _exit_flag = true;
+      return;
+    }
+
+    if (!sdf::readFile(_model_path, this->_sdf_model))
+    {
+      std::cerr << "Error: SDF parsing the xml failed\n";
+      this->PrintHelp();
+      _exit_flag = true;
+      return;
+    }
+
+    sdf::ElementPtr model_elem = this->_sdf_model->Root()->GetElement("model");
+    this->_model_name = model_elem->Get<std::string>("name");
+    _exit_flag = false;
+  }
+
+  /////////////////////////////////////////////
+  void Init()
+  {
+    gazebo::sensors::disable();
+
+    this->_world_created_conn = event::Events::ConnectWorldCreated(
+      std::bind(&ThumbnailGenerator::OnWorldCreated, this));
+
+    this->_update_conn = event::Events::ConnectWorldUpdateBegin(
+      std::bind(&ThumbnailGenerator::Update, this));
+
+    this->_transport_node = transport::NodePtr(new transport::Node());
+    this->_transport_node->Init();
+    this->_factory_pub = this->_transport_node->Advertise<msgs::Factory>(
+      "~/factory");
+    this->_server_control_pub =
+      this->_transport_node->Advertise<msgs::ServerControl>(
+      "/gazebo/server/control");
+  }
+
+  /////////////////////////////////////////////
+  void OnWorldCreated()
+  {
+    this->_factory_pub->WaitForConnection();
+
+    if (this->_sdf_model)
+    {
+      msgs::Factory msg;
+      msg.set_sdf(this->_sdf_model->ToString());
+      this->_factory_pub->Publish(msg, true);
+    }
+  }
+
+  /////////////////////////////////////////////
+  void Update()
+  {
+    if (_exit_flag)
+    {
+      // Clean up Connections and Cameras
+      this->_world_created_conn.reset();
+      this->_update_conn.reset();
+      this->_camera.reset();
+
+      // Tell the server to stop.
+      msgs::ServerControl msg;
+      msg.set_stop(true);
+      this->_server_control_pub->Publish(msg);
+      printf(" Done, Exiting \n");
+      return;
+    }
+
+    // Make sure to initialize the rendering engine in the same thread that will
+    // capture images.
+    if (!this->_scene)
+    {
+      printf(" Initializing Thumbnails Gen Plugin \n");
+      rendering::load();
+      rendering::init();
+
+      sdf::ElementPtr cameraSDF(new sdf::Element);
+      sdf::initFile("camera.sdf", cameraSDF);
+
+      this->_scene = rendering::create_scene("default", false, true);
+      this->_camera = this->_scene->CreateCamera("viewing_cam", true);
+      this->_camera->SetCaptureData(true);
+      this->_camera->Load(cameraSDF);
+      this->_camera->Init();
+      this->_camera->SetHFOV(static_cast<ignition::math::Angle>(_cam_hfov));
+      this->_camera->SetImageWidth(_img_size);
+      this->_camera->SetImageHeight(_img_size);
+      this->_camera->CreateRenderTexture("RenderTex");
+      this->_camera->SetClipDist(100, 1000);
+
+      gazebo::rendering::RTShaderSystem::Instance()->UpdateShaders();
+      return;
+    }
+
+    // Main Thumbnail generation
+    if (this->_camera && this->_scene)
+    {
+      printf(" Generating Thumbnail for %s \n", this->_model_name.c_str());
+      event::Events::preRender();
+
+      unsigned char* img_ptr;
+      cv::Mat mask;
+
+      // Render scene with green background
+      this->_scene->SetAmbientColor(ignition::math::Color(1, 1, 1, 1));
+      this->_scene->SetBackgroundColor(ignition::math::Color(0, 1, 0, 1));
+      this->_scene->SetShadowsEnabled(false);
+      this->RenderCameraVisual();
+
+      // Create Mask acording from image with green background
+      // Get Image data from camera in scene
+      img_ptr = (unsigned char*)this->_camera->ImageData();
+      cv::Mat green_img(cv::Size(_img_size, _img_size), CV_8UC3, img_ptr);
+      cv::inRange(green_img, cv::Scalar(0, 245, 0),
+        cv::Scalar(5, 255, 5), mask);
+      cv::bitwise_not(mask, mask);
+
+      // Render scene with white background
+      // then apply "green" mask to white image to avoid green-fringe effects
+      this->_scene->SetAmbientColor(ignition::math::Color(1, 1, 1, 1));
+      this->_scene->SetBackgroundColor(ignition::math::Color(1, 1, 1, 1));
+      this->_scene->SetShadowsEnabled(false);
+      this->RenderCameraVisual();
+
+      // Get Image data from camera in scene
+      img_ptr = (unsigned char*)this->_camera->ImageData();
+      cv::Mat white_img(cv::Size(_img_size, _img_size), CV_8UC3, img_ptr);
+      cv::cvtColor(white_img, white_img, cv::COLOR_BGR2RGB);
+
+      // Created masked img with alpha val, then crop it!
+      cv::Mat masked_img(cv::Size(_img_size, _img_size), CV_8UC4);
+      cv::cvtColor(white_img, masked_img, cv::COLOR_RGB2RGBA);
+      std::vector<cv::Mat> channels;
+      cv::split(white_img, channels);
+      channels.push_back(mask);
+      cv::merge(channels, masked_img);
+      cv::Rect r = cv::boundingRect(channels[3]);
+
+      // output thumbnail png
+      std::string img_name = this->_model_name + ".png";
+      cv::imwrite((_output_path / img_name).string(), masked_img(r));
+      std::cout << img_name << " saved!" << std::endl;
+      _exit_flag = true;
+    }
+  }
+
+  /////////////////////////////////////////////
+  void RenderCameraVisual()
+  {
+    rendering::VisualPtr vis = this->_scene->GetVisual(this->_model_name);
+
+    // unfortunately, IGNITION_MATH_MAJOR_VERSION doesn't seem to be defined.
+    // we'll use the Gazebo version instead, since they usually (always?)
+    // move in lockstep
+#if GAZEBO_MAJOR_VERSION <= 9
+    ignition::math::Box bbox = vis->BoundingBox();
+#else
+    ignition::math::AxisAlignedBox bbox = vis->BoundingBox();
+#endif
+
+    // Place the visual at the origin
+    ignition::math::Vector3d trans = bbox.Center();
+    vis->SetWorldPose(
+      ignition::math::Pose3d(trans.X(), trans.Y(), trans.Z(), 0, 0, 0));
+    bbox = vis->BoundingBox();
+
+    // Generate Top view PNG Img
+    ignition::math::Pose3d pose;
+    pose.Pos().Set(0, 0, _cam_height);
+    pose.Rot().Euler(0, IGN_DTOR(90), 0);
+    this->_camera->SetWorldPose(pose);
+    this->_camera->Update();
+    this->_camera->Render(true);
+    this->_camera->PostRender();
+  }
+
+  /////////////////////////////////////////////
+  void PrintHelp()
+  {
+    std::cout << "Usage: gzserver -s libthumbnail_gen.so empty.world "
+              << "[Options] [Optional Configs] \n"
+              << std::endl;
+    std::cout << _print_options_stream.str() << std::endl;
+  }
+
+private:
+  event::ConnectionPtr _update_conn;
+  event::ConnectionPtr _world_created_conn;
+  transport::NodePtr _transport_node;
+  transport::PublisherPtr _server_control_pub;
+  transport::PublisherPtr _factory_pub;
+  rendering::ScenePtr _scene;
+  rendering::CameraPtr _camera;
+  sdf::SDFPtr _sdf_model;
+
+  bool _exit_flag;
+  std::stringstream _print_options_stream;
+  std::string _model_name;
+  std::string _model_path;
+  boost::filesystem::path _output_path;
+
+  // Optional Configs
+  int _img_size;
+  double _cam_hfov;
+  double _cam_height;
+};
+
+// Register this plugin with the simulator
+GZ_REGISTER_SYSTEM_PLUGIN(ThumbnailGenerator)
diff --git a/building_sim_plugins/building_gazebo_plugins/src/toggle_charging.cpp b/building_sim_plugins/building_gazebo_plugins/src/toggle_charging.cpp
new file mode 100644
index 0000000..bc649f6
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/toggle_charging.cpp
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <functional>
+
+#include <gazebo/common/Plugin.hh>
+#include <gazebo/gui/GuiPlugin.hh>
+
+#include <gazebo/transport/transport.hh>
+#include <gazebo/msgs/msgs.hh>
+
+#include <rclcpp/rclcpp.hpp>
+#include <gazebo_ros/node.hpp>
+
+#include <rmf_fleet_msgs/msg/fleet_state.hpp>
+#include <rmf_fleet_msgs/msg/robot_state.hpp>
+
+// GUI Plugin that creates buttons for enabling/disabling slotcar charging
+// and publishes any change in state
+class ToggleCharging : public gazebo::GUIPlugin
+{
+  Q_OBJECT
+  gazebo::transport::NodePtr _node;
+  gazebo::transport::PublisherPtr _charge_state_pub;
+
+  bool _enable_charge = true;
+  bool _enable_instant_charge = false;
+  bool _enable_drain = true;
+  const std::string _enable_charge_str = "_enable_charge";
+  const std::string _enable_instant_charge_str = "_enable_instant_charge";
+  const std::string _enable_drain_str = "_enable_drain";
+
+public:
+  ToggleCharging()
+  {
+    printf("ToggleCharging::ToggleCharging()\n");
+    _node = gazebo::transport::NodePtr(new gazebo::transport::Node());
+    _node->Init();
+    _charge_state_pub = _node->Advertise<gazebo::msgs::Selection>(
+      "/charge_state");
+
+    QVBoxLayout* vbox = new QVBoxLayout;
+
+    QPushButton* charge_button = create_button(
+      "Allow Charging", _enable_charge);
+    connect(
+      charge_button,
+      &QAbstractButton::clicked,
+      [this]()
+      {
+        this->_enable_charge = !this->_enable_charge;
+        this->button_clicked(_enable_charge_str, this->_enable_charge);
+      });
+    vbox->addWidget(charge_button);
+
+    QPushButton* instant_charge_button = create_button(
+      "Instant Charging", _enable_instant_charge);
+    connect(
+      instant_charge_button,
+      &QAbstractButton::clicked,
+      [this]()
+      {
+        this->_enable_instant_charge = !this->_enable_instant_charge;
+        this->button_clicked(_enable_instant_charge_str,
+        this->_enable_instant_charge);
+      });
+    vbox->addWidget(instant_charge_button);
+
+    QPushButton* drain_button = create_button(
+      "Allow Battery Drain", _enable_drain);
+    connect(
+      drain_button,
+      &QAbstractButton::clicked,
+      [this]()
+      {
+        this->_enable_drain = !this->_enable_drain;
+        this->button_clicked(_enable_drain_str, this->_enable_drain);
+      });
+    vbox->addWidget(drain_button);
+
+    setLayout(vbox);
+    this->move(0, 80);
+  }
+
+  virtual ~ToggleCharging()
+  {
+  }
+
+  void button_clicked(const std::string& name, bool selected)
+  {
+    gazebo::msgs::Selection charge_state_msg;
+    charge_state_msg.set_name(name);
+    charge_state_msg.set_selected(selected);
+    charge_state_msg.set_id(1); // id not necessary for current use case
+    _charge_state_pub->Publish(charge_state_msg);
+  }
+
+private:
+  QPushButton* create_button(const std::string& button_nm, bool init_val)
+  {
+    auto new_btn = new QPushButton(QString::fromStdString(button_nm));
+    new_btn->setCheckable(true);
+    new_btn->setChecked(init_val);
+    return new_btn;
+  }
+};
+
+#include "toggle_charging.moc"
+
+GZ_REGISTER_GUI_PLUGIN(ToggleCharging)
diff --git a/building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp b/building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp
new file mode 100644
index 0000000..5ea1f67
--- /dev/null
+++ b/building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp
@@ -0,0 +1,136 @@
+#include <functional>
+#include <gazebo/common/Plugin.hh>
+#include <gazebo/gui/GuiPlugin.hh>
+#include <gazebo/transport/transport.hh>
+
+#include <gazebo/msgs/msgs.hh>
+#include <gazebo/rendering/rendering.hh>
+
+#include <rclcpp/rclcpp.hpp>
+#include <gazebo_ros/node.hpp>
+#include <rmf_fleet_msgs/msg/fleet_state.hpp>
+#include <rmf_fleet_msgs/msg/robot_state.hpp>
+
+#include <string>
+#include <unordered_map>
+
+using std::string;
+using FleetState = rmf_fleet_msgs::msg::FleetState;
+using RobotState = rmf_fleet_msgs::msg::RobotState;
+
+class ToggleFloors : public gazebo::GUIPlugin
+{
+  Q_OBJECT
+  gazebo::transport::NodePtr node;
+  gazebo::transport::PublisherPtr visual_pub;
+  std::unordered_map<string, std::atomic<bool>> floor_visibility;
+  gazebo_ros::Node::SharedPtr ros_node;
+  rclcpp::Subscription<FleetState>::SharedPtr fleet_state_sub;
+
+public:
+  ToggleFloors()
+  : GUIPlugin()
+  {
+    printf("ToggleFloors::ToggleFloors()\n");
+    node = gazebo::transport::NodePtr(new gazebo::transport::Node());
+    node->Init();
+    visual_pub = node->Advertise<gazebo::msgs::Visual>("~/visual");
+  }
+
+  virtual ~ToggleFloors()
+  {
+  }
+
+  void Load(sdf::ElementPtr sdf)
+  {
+    printf("ToggleFloors::Load()\n");
+    ros_node = gazebo_ros::Node::Get(sdf);
+
+    // toggle non-static robots
+    fleet_state_sub = ros_node->create_subscription<FleetState>(
+      "/fleet_states", rclcpp::SystemDefaultsQoS(),
+      [&](FleetState::UniquePtr msg)
+      {
+        bool visible;
+        gazebo::msgs::Visual visual_msg;
+        visual_msg.set_parent_name("world");
+        for (const RobotState& robot : msg->robots)
+        {
+          visible = floor_visibility[robot.location.level_name];
+          visual_msg.set_name(robot.name);
+          visual_msg.set_visible(visible);
+          visual_pub->Publish(visual_msg);
+        }
+      });
+
+    QHBoxLayout* hbox = new QHBoxLayout;
+
+    for (sdf::ElementPtr floor_ele = sdf->GetFirstElement();
+      floor_ele;
+      floor_ele = floor_ele->GetNextElement("floor"))
+    {
+      if (floor_ele->GetName() != string("floor"))
+        continue;
+      string floor_name = floor_ele->GetAttribute("name")->GetAsString();
+      string model_name =
+        floor_ele->GetAttribute("model_name")->GetAsString();
+
+      std::vector<string> models;
+      auto model_ele = floor_ele->GetElement("model");
+      while (model_ele)
+      {
+        if (model_ele->HasAttribute("name"))
+          models.push_back(model_ele->GetAttribute("name")->GetAsString());
+        model_ele = model_ele->GetNextElement("model");
+      }
+      floor_visibility[floor_name] = true;
+
+      printf(
+        "ToggleFloors::Load found a floor element: [%s]->[%s]\n",
+        floor_name.c_str(),
+        model_name.c_str());
+
+      QPushButton* button =
+        new QPushButton(QString::fromStdString(floor_name));
+      button->setCheckable(true);
+      button->setChecked(true);
+      connect(
+        button,
+        &QAbstractButton::clicked,
+        [this, button, floor_name, model_name, models]()
+        {
+          this->button_clicked(button, floor_name, model_name, models);
+        });
+      hbox->addWidget(button);
+    }
+    setLayout(hbox);
+  }
+
+  void button_clicked(
+    QPushButton* button,
+    string floor_name,
+    string model_name,
+    std::vector<string> models)
+  {
+    bool visible = button->isChecked();
+    floor_visibility[floor_name] = visible;
+    printf(
+      "clicked: [%s] %s\n",
+      model_name.c_str(),
+      visible ? "SHOW" : "HIDE");
+    gazebo::msgs::Visual visual_msg;
+    visual_msg.set_parent_name("world");
+    visual_msg.set_name(model_name);
+    visual_msg.set_visible(visible);
+    visual_pub->Publish(visual_msg);
+    for (const string& model : models)
+    {
+      visual_msg.set_name(model);
+      visual_pub->Publish(visual_msg);
+    }
+  }
+};
+
+#include "toggle_floors.moc"
+
+GZ_REGISTER_GUI_PLUGIN(ToggleFloors)
diff --git a/building_sim_plugins/building_ignition_plugins/CHANGELOG.rst b/building_sim_plugins/building_ignition_plugins/CHANGELOG.rst
new file mode 100644
index 0000000..db9d250
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/CHANGELOG.rst
@@ -0,0 +1,27 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package building_ignition_plugins
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.2.0 (2021-01-06)
+------------------
+* Remove Slotcar/Lift AABB component when not required to speed up demos (`#271 <https://github.com/osrf/traffic_editor/issues/271>`_)
+* Migrate ignition plugins to ament_target_dependencies (`#262 <https://github.com/osrf/traffic_editor/issues/262>`_)
+* Enable lifts to work with TPE (`#250 <https://github.com/osrf/traffic_editor/issues/250>`_)
+  Modifies lift plugin to issue either joint or model velocity commands
+  based on the physics engine used.
+* Control slotcar with model velocity cmds in place of joint velocity cmds (`#236 <https://github.com/osrf/traffic_editor/issues/236>`_)
+* Implement battery drain and recharge for slotcars (`#242 <https://github.com/osrf/traffic_editor/issues/242>`_)
+* Implement animation switching in crowd simulation (`#238 <https://github.com/osrf/traffic_editor/issues/238>`_)
+* Add first pass of quality declarations for all packages (`#235 <https://github.com/osrf/traffic_editor/issues/235>`_)
+* Building_crowdsim for generating the navmesh file and required configuration files for menge (`#224 <https://github.com/osrf/traffic_editor/issues/224>`_)
+* Add animation switch to crowd simulation plugin (`#238 <https://github.com/osrf/traffic_editor/pull/238>`_)
+* Contributors: Geoffrey Biggs, Guoliang (Fred) Shao, Luca Della Vedova, Marco A. Gutierrez, Marco A. Gutiérrez, Rushyendra Maganty
+
+1.0.0 (2020-09-24)
+------------------
+* Focal / Ignition dome dependencies update (`#230 <https://github.com/osrf/traffic_editor/issues/230>`_)
+* Ignition crowd simulation plugin (`#218 <https://github.com/osrf/traffic_editor/issues/218>`_)
+* Create AxisAlignedBox component for slotcar (`#227 <https://github.com/osrf/traffic_editor/issues/227>`_)
+* Ignition plugins and modularization of doors and slotcar `#138 <https://github.com/osrf/traffic_editor/issues/138>`_
+* Adding lift plugin for ignition `#171 <https://github.com/osrf/traffic_editor/issues/171>`_
+* Contributors: Guoliang (Fred) Shao, Luca Della Vedova, Rushyendra Maganty, kevinskwk
diff --git a/building_sim_plugins/building_ignition_plugins/CMakeLists.txt b/building_sim_plugins/building_ignition_plugins/CMakeLists.txt
new file mode 100644
index 0000000..61afae9
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/CMakeLists.txt
@@ -0,0 +1,218 @@
+cmake_minimum_required(VERSION 3.5)
+project(building_ignition_plugins)
+
+set (CMAKE_AUTOMOC ON)
+
+# Default to C99
+if(NOT CMAKE_C_STANDARD)
+  set(CMAKE_C_STANDARD 99)
+endif()
+
+# Default to C++14
+if(NOT CMAKE_CXX_STANDARD)
+  set(CMAKE_CXX_STANDARD 17)
+endif()
+
+if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  add_compile_options(-Wall -Wextra -Wpedantic)
+endif()
+
+# find dependencies
+find_package(ament_cmake REQUIRED)
+find_package(rclcpp REQUIRED)
+
+find_package(ignition-cmake2 QUIET)
+if (NOT ignition-cmake2_FOUND)
+  message("ignition-cmake not found, skipping ignition gazebo plugins")
+  return()
+endif()
+ign_find_package(ignition-gazebo4 QUIET)
+if (NOT ignition-gazebo4_FOUND)
+  message("Wrong ignition-gazebo version found. Plugins require ignition-gazebo4 (dome)")
+  # To generate a setup.bash and avoid CMake warnings
+  ament_package()
+  return()
+endif()
+set(IGN_GAZEBO_VER 4)
+ign_find_package(ignition-plugin1 REQUIRED COMPONENTS register)
+set(IGN_PLUGIN_VER 1)
+ign_find_package(ignition-common3 REQUIRED)
+set(IGN_COMMON_VER 3)
+ign_find_package(ignition-math6 REQUIRED)
+set(IGN_MATH_VER 6)
+ign_find_package(ignition-gui4 REQUIRED)
+set(IGN_GUI_VER 4)
+ign_find_package(ignition-msgs6 REQUIRED)
+set(IGN_MSGS_VER 6)
+ign_find_package(ignition-transport9 REQUIRED)
+set(IGN_TRANSPORT_VER 9)
+ign_find_package(sdformat10 REQUIRED)
+
+find_package(tf2_ros REQUIRED)
+find_package(geometry_msgs REQUIRED)
+find_package(std_msgs REQUIRED)
+find_package(std_srvs REQUIRED)
+find_package(rmf_fleet_msgs REQUIRED)
+find_package(rmf_door_msgs REQUIRED)
+find_package(rmf_lift_msgs REQUIRED)
+find_package(building_map_msgs REQUIRED)
+find_package(building_sim_common REQUIRED)
+find_package (Qt5
+  COMPONENTS
+    Core
+    Qml
+    Quick
+  REQUIRED
+)
+find_package(menge QUIET)
+
+include(GNUInstallDirs)
+
+add_library(slotcar SHARED ${PROJECT_SOURCE_DIR}/src/slotcar.cpp)
+
+ament_target_dependencies(slotcar
+  PUBLIC
+    ignition-gazebo${IGN_GAZEBO_VER}
+    ignition-plugin${IGN_PLUGIN_VER}
+    building_sim_common
+    rmf_fleet_msgs
+    rclcpp
+    geometry_msgs
+    tf2_ros
+)
+
+target_include_directories(slotcar
+  PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+    ${building_sim_common_INCLUDE_DIRS}
+    ${geometry_msgs_INCLUDE_DIRS}
+    ${std_msgs_INCLUDE_DIRS}
+    ${rmf_fleet_msgs_INCLUDE_DIRS}
+    ${building_map_msgs_INCLUDE_DIRS}
+    ${tf2_ros_INCLUDE_DIRS}
+)
+
+###############################
+# door stuff
+###############################
+
+add_library(door SHARED src/door.cpp)
+
+target_include_directories(door
+  PUBLIC
+    ${building_sim_common_INCLUDE_DIRS}
+    ${geometry_msgs_INCLUDE_DIRS}
+    ${rmf_door_msgs_INCLUDE_DIRS}
+)
+
+ament_target_dependencies(door
+  PUBLIC
+    rclcpp
+    ignition-gazebo${IGN_GAZEBO_VER}
+    ignition-plugin${IGN_PLUGIN_VER}
+    building_sim_common
+    rmf_door_msgs
+    rmf_fleet_msgs
+)
+
+###############################
+# lift stuff
+###############################
+
+add_library(lift SHARED src/lift.cpp)
+
+target_include_directories(lift
+  PUBLIC
+    ${building_sim_common_INCLUDE_DIRS}
+    ${geometry_msgs_INCLUDE_DIRS}
+    ${rmf_door_msgs_INCLUDE_DIRS}
+    ${rmf_lift_msgs_INCLUDE_DIRS}
+)
+
+ament_target_dependencies(lift
+  PUBLIC
+    rclcpp
+    ignition-gazebo${IGN_GAZEBO_VER}
+    ignition-plugin${IGN_PLUGIN_VER}
+    building_sim_common
+    rmf_door_msgs
+    rmf_lift_msgs
+    rmf_fleet_msgs
+)
+
+###############################
+# crowd simulator stuff
+###############################
+if (menge_FOUND)
+  add_library(crowd_simulator
+    SHARED
+    src/crowd_simulator.cpp
+  )
+
+  target_include_directories(crowd_simulator
+    PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    ${building_sim_common_INCLUDE_DIRS}
+    ${rclcpp_INCLUDE_DIRS}
+    ${menge_INCLUDE_DIRS}
+    ${IGNITION-COMMON_INCLUDE_DIRS}
+  )
+
+  ament_target_dependencies(crowd_simulator
+    ignition-gazebo${IGN_GAZEBO_VER}
+    ignition-plugin${IGN_PLUGIN_VER}
+    rclcpp
+    building_sim_common
+    menge
+  )
+
+  #install
+  install(
+    TARGETS crowd_simulator
+    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  )
+else (NOT menge_FOUND)
+  message("menge-cmake not found, skipping crowd_simulation ignition plugins")
+endif()
+
+###############################
+# toggle charging
+###############################
+
+QT5_ADD_RESOURCES(resources_RCC src/toggle_charging/toggle_charging.qrc)
+
+add_library(toggle_charging SHARED ${headers_MOC}
+  src/toggle_charging/toggle_charging.cpp
+  ${resources_RCC}
+)
+
+ament_target_dependencies(toggle_charging
+  ignition-gui${IGN_GUI_VER}
+  ignition-msgs${IGN_MSGS_VER}
+  ignition-transport${IGN_TRANSPORT_VER}
+  Qt5Core
+  Qt5Qml
+  Qt5Quick
+  rclcpp
+)
+
+target_include_directories(toggle_charging
+  PUBLIC
+  ${Qt5Core_INCLUDE_DIRS}
+  ${Qt5Qml_INCLUDE_DIRS}
+  ${Qt5Quick_INCLUDE_DIRS}
+)
+
+###############################
+# install stuff
+###############################
+
+install(
+  TARGETS slotcar door lift toggle_charging
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
+
+ament_package()
diff --git a/building_sim_plugins/building_ignition_plugins/QUALITY_DECLARATION.md b/building_sim_plugins/building_ignition_plugins/QUALITY_DECLARATION.md
new file mode 100644
index 0000000..b2eb98f
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/QUALITY_DECLARATION.md
@@ -0,0 +1,168 @@
+This document is a declaration of software quality for the `building_ignition_plugins` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+# `building_ignition_plugins` Quality Declaration
+
+The package `building_ignition_plugins` claims to be in the **Quality Level 4** category.
+
+Below are the detailed rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+## Version Policy [1]
+
+### Version Scheme [1.i]
+
+`building_ignition_plugins` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).
+
+### Version Stability [1.ii]
+
+`building_ignition_plugins` is at a stable version, i.e. `>= 1.0.0`.
+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).
+
+### Public API Declaration [1.iii]
+
+`building_ignition_plugins` does not have a public API.
+
+### API Stability Policy [1.iv]
+
+`building_ignition_plugins` does not have a public API.
+
+### ABI Stability Policy [1.v]
+
+`building_ignition_plugins` does not have a public API.
+
+### API and ABI Stability Within a Released ROS Distribution [1.vi]
+
+`building_ignition_plugins` does not have a public API.
+
+## Change Control Process [2]
+
+`building_ignition_plugins` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).
+
+### Change Requests [2.i]
+
+`building_ignition_plugins` requires that all changes occur through a pull request.
+
+### Contributor Origin [2.ii]
+
+`building_ignition_plugins` does not require a confirmation of contributor origin.
+
+### Peer Review Policy [2.iii]
+
+All pull requests must have at least 1 peer review.
+
+### Continuous Integration [2.iv]
+
+All pull requests must pass CI on all platforms supported by RMF.
+The CI checks only that the package builds.
+The most recent CI results can be seen on [the workflow page](https://github.com/osrf/traffic_editor/actions).
+
+### Documentation Policy [2.v]
+
+All pull requests must resolve related documentation changes before merging.
+
+## Documentation [3]
+
+### Feature Documentation [3.i]
+
+`building_ignition_plugins` does not provide feature documentation.
+
+### Public API Documentation [3.ii]
+
+`building_ignition_plugins` does not have a public API.
+
+### License [3.iii]
+
+The license for `building_ignition_plugins` is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.
+
+### Copyright Statement [3.iv]
+
+The copyright holders each provide a statement of copyright in each source code file in `rmf_demo_tasks`.
+
+### Quality declaration document [3.v]
+
+This quality declaration is linked in the [README file](README.md).
+
+This quality declaration has not been externally peer-reviewed and is not registered on any Level 4 lists.
+
+## Testing [4]
+
+### Feature Testing [4.i]
+
+`building_ignition_plugins` does not have any tests.
+
+### Public API Testing [4.ii]
+
+`building_ignition_plugins` does not have a public API.
+
+### Coverage [4.iii]
+
+`building_ignition_plugins` does not track coverage statistics.
+
+### Performance [4.iv]
+
+`building_ignition_plugins` does not have performance tests.
+
+### Linters and Static Analysis [4.v]
+
+`building_ignition_plugins` does not use the standard linters and static analysis tools for its CMake code to ensure it follows the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).
+
+## Dependencies [5]
+
+### Direct Runtime ROS Dependencies [5.i]
+
+`building_ignition_plugins` has the following direct runtime ROS dependencies.
+
+#### rclcpp
+
+`rclcpp` is [**Quality Level 3**](https://github.com/ros2/rclcpp/blob/master/rclcpp/QUALITY_DECLARATION.md).
+
+#### rmf\_fleet\_msgs
+
+`rmf_fleet_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_fleet_msgs/QUALITY_DECLARATION.md).
+
+#### rmf\_door\_msgs
+
+`rmf_door_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_door_msgs/QUALITY_DECLARATION.md).
+
+#### rmf\_lift\_msgs
+
+`rmf_lift_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_lift_msgs/QUALITY_DECLARATION.md).
+
+#### tf2\_ros
+
+`ignition_dev` does not declare a Quality Level.
+It is assumed tobe at **Quality Level 4** based on its widespread use and use of CI.
+
+#### geometry\_msgs
+
+`geometry_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/geometry_msgs/QUALITY_DECLARATION.md).
+
+#### std\_msgs
+
+`std_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/std_msgs/QUALITY_DECLARATION.md).
+
+#### std\_srvs
+
+`std_srvs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/std_srvs/QUALITY_DECLARATION.md).
+
+#### building\_sim\_common
+
+`building_sim_common` is [**Quality Level 4**](https://github.com/osrf/traffic_editor/blob/master/building_sim_plugins/building_sim_common/QUALITY_DECLARATION.md).
+
+### Optional Direct Runtime ROS Dependencies [5.ii]
+
+`building_ignition_plugins` does not have any optional direct runtime ROS dependencies.
+
+### Direct Runtime non-ROS Dependency [5.iii]
+
+`building_ignition_plugins` does not have any runtime non-ROS dependencies.
+
+## Platform Support [6]
+
+`building_ignition_plugins` does not support all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers).
+`building_ignition_plugins` supports ROS Eloquent and ROS Foxy.
+
+## Security [7]
+
+### Vulnerability Disclosure Policy [7.i]
+
+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).
diff --git a/building_sim_plugins/building_ignition_plugins/README.md b/building_sim_plugins/building_ignition_plugins/README.md
new file mode 100644
index 0000000..66a9a6c
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/README.md
@@ -0,0 +1,7 @@
+# building\_gazebo\_plugins
+
+This package provides Ignition plugins for allowing simulated building infrastructure to communicate with a ROS system.
+
+## Quality Declaration
+
+This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.
diff --git a/building_sim_plugins/building_ignition_plugins/package.xml b/building_sim_plugins/building_ignition_plugins/package.xml
new file mode 100644
index 0000000..90e2ae1
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/package.xml
@@ -0,0 +1,31 @@
+<package format="3">
+  <name>building_ignition_plugins</name>
+  <version>1.2.0</version>
+  <description>
+    Ignition gazebo plugins for building infrastructure simulation
+  </description>
+  <author>Luca Della Vedova</author>
+  <author>Kevin Ma</author>
+  <author>Rushyendra Maganty</author>
+  <maintainer email="luca@openrobotics.org">Luca Della Vedova</maintainer>
+  <license>Apache 2.0</license>
+
+  <buildtool_depend>ament_cmake</buildtool_depend>
+
+  <!-- TODO fix dependencies -->
+  <depend>rclcpp</depend>
+  <depend>rmf_fleet_msgs</depend>
+  <depend>rmf_door_msgs</depend>
+  <depend>rmf_lift_msgs</depend>
+  <depend>tf2_ros</depend>
+  <depend>geometry_msgs</depend>
+  <depend>std_msgs</depend>
+  <depend>std_srvs</depend>
+
+  <depend>building_sim_common</depend>
+
+  <export>
+    <build_type>ament_cmake</build_type>
+  </export>
+
+</package>
diff --git a/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp b/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp
new file mode 100644
index 0000000..fd78acf
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp
@@ -0,0 +1,467 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <regex>
+#include <cstdlib>
+
+#include <sdf/Actor.hh>
+
+#include <ignition/math/Pose3.hh>
+
+#include <ignition/gazebo/components/Name.hh>
+#include <ignition/gazebo/components/Model.hh>
+#include <ignition/gazebo/components/Actor.hh>
+#include <ignition/gazebo/components/Pose.hh>
+#include <ignition/gazebo/components/Static.hh>
+
+#include "crowd_simulator.hpp"
+
+namespace crowd_simulation_ign {
+
+//=================================================
+void CrowdSimulatorPlugin::Configure(
+  const ignition::gazebo::Entity& entity,
+  const std::shared_ptr<const sdf::Element>& sdf,
+  ignition::gazebo::EntityComponentManager& ecm,
+  ignition::gazebo::EventManager& event_mgr)
+{
+  _world = std::make_shared<ignition::gazebo::Model>(entity);
+  RCLCPP_INFO(_crowd_sim_interface->logger(),
+    "Initializing world plugin with name: " + _world->Name(ecm));
+  _world_name = _world->Name(ecm);
+
+  if (!_crowd_sim_interface->read_sdf(sdf))
+  {
+    RCLCPP_ERROR(_crowd_sim_interface->logger(),
+      "Error loading crowd simulator plugin. Load params failed!");
+    exit(EXIT_FAILURE);
+  }
+
+  if (!_crowd_sim_interface->init_crowd_sim())
+  {
+    RCLCPP_ERROR(_crowd_sim_interface->logger(),
+      "Error loading crowd simulator plugin. Load [ Menge ] failed!");
+    exit(EXIT_FAILURE);
+  }
+
+  if (!_spawn_agents_in_world(ecm))
+  {
+    RCLCPP_ERROR(
+      _crowd_sim_interface->logger(),
+      "Error loading crowd simulator plugin. Crowd Simulator failed to spawn agents in the world!");
+    exit(EXIT_FAILURE);
+  }
+
+}
+
+//=================================================
+void CrowdSimulatorPlugin::PreUpdate(
+  const ignition::gazebo::UpdateInfo& info,
+  ignition::gazebo::EntityComponentManager& ecm)
+{
+  // wait for all the models and actors loaded in ignition rendering
+  if (!_initialized)
+  {
+    _init_spawned_agents(ecm);
+    return;
+  }
+
+  std::chrono::duration<double> delta_sim_time_tmp = info.simTime -
+    _last_sim_time;
+  double delta_sim_time = delta_sim_time_tmp.count();
+  if (_crowd_sim_interface->get_sim_time_step() <= delta_sim_time)
+  {
+    _last_sim_time = info.simTime;
+    _crowd_sim_interface->one_step_sim();
+    _update_all_objects(delta_sim_time, ecm);
+  }
+}
+
+//==========================================================
+bool CrowdSimulatorPlugin::_spawn_agents_in_world(
+  ignition::gazebo::EntityComponentManager& ecm)
+{
+  size_t object_count = this->_crowd_sim_interface->get_num_objects();
+  for (size_t id = 0; id < object_count; ++id)
+  {
+    auto object_ptr = this->_crowd_sim_interface->get_object_by_id(id);
+    assert(object_ptr);
+    _object_dic[object_ptr->model_name] = id;
+
+    if (!object_ptr->is_external)
+    {
+      auto type_ptr = _crowd_sim_interface->_model_type_db_ptr->get(
+        object_ptr->type_name);
+      assert(type_ptr);
+      if (!this->_create_entity(ecm, object_ptr->model_name, type_ptr) )
+      {
+        RCLCPP_ERROR(_crowd_sim_interface->logger(),
+          "Failed to insert model [ " + object_ptr->model_name + " ] in world");
+        return false;
+      }
+    }
+  }
+  return true;
+}
+
+//==========================================================
+void CrowdSimulatorPlugin::_init_spawned_agents(
+  ignition::gazebo::EntityComponentManager& ecm)
+{
+  // check all the models are in the world
+  std::unordered_map<std::string, size_t> objects_name;
+  size_t object_count = _crowd_sim_interface->get_num_objects();
+  for (size_t id = 0; id < object_count; id++)
+  {
+    auto obj = _crowd_sim_interface->get_object_by_id(id);
+    // already found in the Dic
+    if (_entity_dic.find(obj->model_name) != _entity_dic.end())
+      continue;
+    objects_name.insert({obj->model_name, id});
+  }
+  // for external agent
+  ecm.Each<ignition::gazebo::components::Model,
+    ignition::gazebo::components::Name>(
+    [&](const ignition::gazebo::Entity& entity,
+    const ignition::gazebo::components::Model*,
+    const ignition::gazebo::components::Name* name) -> bool
+    {
+      auto it_objects_name = objects_name.find(name->Data());
+      if (it_objects_name != objects_name.end())
+      {
+        // update in entityDic
+        _entity_dic[name->Data()] = entity;
+        auto obj_ptr =
+        _crowd_sim_interface->get_object_by_id(it_objects_name->second);
+        // config internal spawned agent for custom trajectory
+        if (!obj_ptr->is_external)
+        {
+          _config_spawned_agents(obj_ptr, entity, ecm);
+        }
+        objects_name.erase(name->Data());
+        RCLCPP_INFO(_crowd_sim_interface->logger(),
+        "Crowd Simulator found agent: " + name->Data() );
+      }
+      return true;
+    }
+    );
+  // for internal agent
+  ecm.Each<ignition::gazebo::components::Actor,
+    ignition::gazebo::components::Name>(
+    [&](const ignition::gazebo::Entity& entity,
+    const ignition::gazebo::components::Actor*,
+    const ignition::gazebo::components::Name* name) -> bool
+    {
+      auto it_objects_name = objects_name.find(name->Data());
+      if (it_objects_name != objects_name.end())
+      {
+        // update in entityDic
+        _entity_dic[name->Data()] = entity;
+        auto obj_ptr =
+        _crowd_sim_interface->get_object_by_id(it_objects_name->second);
+        // config internal spawned agent for custom trajectory
+        if (!obj_ptr->is_external)
+        {
+          _config_spawned_agents(obj_ptr, entity, ecm);
+        }
+        objects_name.erase(name->Data());
+        RCLCPP_INFO(_crowd_sim_interface->logger(),
+        "Crowd Simulator found agent: " + name->Data() );
+      }
+      return true;
+    }
+    );
+
+  // external agents not found or not loaded yet
+  if (objects_name.size() != 0)
+  {
+    _initialized = false;
+    return;
+  }
+  _initialized = true;
+  RCLCPP_INFO(
+    _crowd_sim_interface->logger(),
+    "Ignition Models are all loaded! Start simulating...");
+}
+
+//===================================================================
+bool CrowdSimulatorPlugin::_create_entity(
+  ignition::gazebo::EntityComponentManager& ecm,
+  const std::string& model_name,
+  const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr) const
+{
+  // Use ignition create service to spawn actors
+  // calling ignition gazebo create service, you can use "ign service -l" to check the service available
+  assert(model_type_ptr);
+  std::string service = "/world/" + this->_world_name + "/create";
+  ignition::msgs::EntityFactory request;
+  request.set_sdf_filename(model_type_ptr->file_name);
+  request.set_name(model_name);
+  ignition::math::Pose3d pose(0, 0, 0, 0, 0, 0);
+
+  ignition::msgs::Boolean response;
+  bool result;
+  uint32_t timeout = 5000;
+  bool executed = this->_transport_node_ptr->Request(service, request, timeout,
+      response, result);
+  if (executed)
+  {
+    if (result && response.data())
+    {
+      RCLCPP_INFO(_crowd_sim_interface->logger(),
+        "Requested creation of entity: " + model_name);
+      return true;
+    }
+    else
+    {
+      RCLCPP_ERROR(_crowd_sim_interface->logger(),
+        "Failed request to create entity.\n" + request.DebugString());
+    }
+  }
+  else
+  {
+    RCLCPP_ERROR(
+      _crowd_sim_interface->logger(),
+      "Request to create entity from service " + service + "timer out ...\n" +
+      request.DebugString());
+  }
+  return false;
+}
+
+//==================================================
+void CrowdSimulatorPlugin::_config_spawned_agents(
+  const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
+  const ignition::gazebo::Entity& entity,
+  ignition::gazebo::EntityComponentManager& ecm) const
+{
+  assert(obj_ptr);
+  auto agent_ptr = obj_ptr->agent_ptr;
+  auto model_type = _crowd_sim_interface->_model_type_db_ptr->get(
+    obj_ptr->type_name);
+  // different from gazebo plugin, the pose component is the origin of the trajPose
+  ignition::math::Pose3d actor_pose(
+    static_cast<double>(agent_ptr->_pos.x()),
+    static_cast<double>(agent_ptr->_pos.y()), 0.0,
+    0, 0, 0
+  );
+
+  // get pose component for entity
+  auto pose_comp = ecm.Component<ignition::gazebo::components::Pose>(entity);
+  if (nullptr == pose_comp)
+  {
+    // use the initial_pose for actor type
+    ignition::math::Pose3d initial_pose =
+      model_type->pose.convert_to_ign_math_pose_3d<ignition::math::Pose3d>();
+    ecm.CreateComponent(entity,
+      ignition::gazebo::components::Pose(initial_pose));
+  }
+  else
+  {
+    // original pose in the world
+    *pose_comp =
+      ignition::gazebo::components::Pose(ignition::math::Pose3d(0, 0, 0, 0, 0,
+        0));
+  }
+
+  // initialize agent animationName
+  std::string animation_name = model_type->animation;
+  assert(!animation_name.empty());
+
+  auto animation_name_comp =
+    ecm.Component<ignition::gazebo::components::AnimationName>(entity);
+  if (nullptr == animation_name_comp)
+  {
+    ecm.CreateComponent(entity,
+      ignition::gazebo::components::AnimationName(animation_name));
+  }
+  else
+  {
+    *animation_name_comp = ignition::gazebo::components::AnimationName(
+      animation_name);
+  }
+  // check idle animation name
+  auto actor_comp =
+    ecm.Component<ignition::gazebo::components::Actor>(entity);
+  for (auto idle_anim : _crowd_sim_interface->get_switch_anim_name())
+  {
+    if (actor_comp->Data().AnimationNameExists(idle_anim))
+    {
+      model_type->idle_animation = idle_anim;
+      break;
+    }
+  }
+
+  // mark as one-time-change
+  ecm.SetChanged(
+    entity,
+    ignition::gazebo::components::AnimationName::typeId,
+    ignition::gazebo::ComponentState::OneTimeChange);
+  // initialize agent animationTime
+  auto anim_time_comp =
+    ecm.Component<ignition::gazebo::components::AnimationTime>(entity);
+  if (nullptr == anim_time_comp)
+  {
+    ecm.CreateComponent(entity, ignition::gazebo::components::AnimationTime());
+  }
+  // having a trajectory pose prevents the actor from moving with the sdf script
+  auto traj_pose_comp =
+    ecm.Component<ignition::gazebo::components::TrajectoryPose>(entity);
+  if (nullptr == traj_pose_comp)
+  {
+    ecm.CreateComponent(entity,
+      ignition::gazebo::components::TrajectoryPose(actor_pose));
+  }
+}
+
+//============================================================================
+void CrowdSimulatorPlugin::_update_all_objects(
+  double delta_sim_time,
+  ignition::gazebo::EntityComponentManager& ecm) const
+{
+  auto objects_count = _crowd_sim_interface->get_num_objects();
+  for (size_t id = 0; id < objects_count; id++)
+  {
+    auto obj_ptr = _crowd_sim_interface->get_object_by_id(id);
+    auto it_entity = _entity_dic.find(obj_ptr->model_name);
+    if (it_entity == _entity_dic.end())   //safe check
+    {
+      RCLCPP_ERROR(_crowd_sim_interface->logger(),
+        "Didn't initialize external agent [" + obj_ptr->model_name + "]");
+      exit(EXIT_FAILURE);
+    }
+    auto entity = it_entity->second;
+
+    // for external agent
+    if (obj_ptr->is_external)
+    {
+      auto model_pose =
+        ecm.Component<ignition::gazebo::components::Pose>(entity)->Data();
+      _crowd_sim_interface->update_external_agent(obj_ptr->agent_ptr,
+        model_pose);
+      continue;
+    }
+
+    // for internal agent
+    _update_internal_object(delta_sim_time, obj_ptr, entity, ecm);
+  }
+}
+
+void CrowdSimulatorPlugin::_update_internal_object(
+  double delta_sim_time,
+  const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
+  const ignition::gazebo::Entity& entity,
+  ignition::gazebo::EntityComponentManager& ecm) const
+{
+  double animation_speed = _crowd_sim_interface->_model_type_db_ptr->get(
+    obj_ptr->type_name)->animation_speed;
+  ignition::math::Pose3d initial_pose =
+    _crowd_sim_interface->_model_type_db_ptr->get(obj_ptr->type_name)->pose.
+    convert_to_ign_math_pose_3d<ignition::math::Pose3d>();
+  ignition::math::Pose3d agent_pose =
+    _crowd_sim_interface->get_agent_pose<ignition::math::Pose3d>(
+    obj_ptr->agent_ptr, delta_sim_time);
+  agent_pose += initial_pose;
+
+  // get components to be updated
+  auto traj_pose_comp =
+    ecm.Component<ignition::gazebo::components::TrajectoryPose>(entity);
+  if (nullptr == traj_pose_comp)
+  {
+    RCLCPP_ERROR(_crowd_sim_interface->logger(),
+      "Model [" + obj_ptr->model_name + "] has no TrajectoryPose component.");
+    exit(EXIT_FAILURE);
+  }
+  auto anim_name_comp =
+    ecm.Component<ignition::gazebo::components::AnimationName>(entity);
+  if (nullptr == anim_name_comp)
+  {
+    RCLCPP_ERROR(_crowd_sim_interface->logger(),
+      "Model [" + obj_ptr->model_name + "] has no AnimationName component.");
+    exit(EXIT_FAILURE);
+  }
+  auto anim_time_comp =
+    ecm.Component<ignition::gazebo::components::AnimationTime>(entity);
+  if (nullptr == anim_name_comp)
+  {
+    RCLCPP_ERROR(_crowd_sim_interface->logger(),
+      "Model [" + obj_ptr->model_name + "] has no AnimationTime component.");
+    exit(EXIT_FAILURE);
+  }
+  auto actor_comp =
+    ecm.Component<ignition::gazebo::components::Actor>(entity);
+
+  ignition::math::Pose3d current_pose = traj_pose_comp->Data();
+  auto distance_traveled_vector = agent_pose.Pos() - current_pose.Pos();
+  // might need future work on 3D case
+  // the center of human has a z_elevation, which will make the human keep walking even if he reached the target
+  distance_traveled_vector.Z(0.0);
+  double distance_traveled = distance_traveled_vector.Length();
+
+  // switch animation
+  auto model_type = _crowd_sim_interface->_model_type_db_ptr->get(
+    obj_ptr->type_name);
+  AnimState next_state = obj_ptr->get_next_state(
+    distance_traveled < _crowd_sim_interface->get_switch_anim_distance_th() &&
+    !model_type->idle_animation.empty());
+
+  switch (next_state)
+  {
+    case AnimState::WALK:
+      anim_time_comp->Data() +=
+        std::chrono::duration_cast<std::chrono::steady_clock::duration>(
+        std::chrono::duration<double>(distance_traveled / animation_speed));
+      if (obj_ptr->current_state != next_state)
+        anim_name_comp->Data() = model_type->animation;
+      break;
+
+    case AnimState::IDLE:
+      anim_time_comp->Data() +=
+        std::chrono::duration_cast<std::chrono::steady_clock::duration>(
+        std::chrono::duration<double>(delta_sim_time));
+      agent_pose.Rot() = current_pose.Rot();
+      if (obj_ptr->current_state != next_state)
+        anim_name_comp->Data() = model_type->idle_animation;
+      break;
+  }
+
+  if (obj_ptr->current_state != next_state)
+    ecm.SetChanged(entity,
+      ignition::gazebo::components::AnimationName::typeId,
+      ignition::gazebo::ComponentState::OneTimeChange);
+  obj_ptr->current_state = next_state;
+
+  // set trajectory
+  traj_pose_comp->Data() = agent_pose;
+  ecm.SetChanged(entity,
+    ignition::gazebo::components::TrajectoryPose::typeId,
+    ignition::gazebo::ComponentState::OneTimeChange);
+  ecm.SetChanged(entity,
+    ignition::gazebo::components::AnimationTime::typeId,
+    ignition::gazebo::ComponentState::OneTimeChange);
+}
+
+} //namespace crowd_simulation_ign
+
+IGNITION_ADD_PLUGIN(
+  crowd_simulation_ign::CrowdSimulatorPlugin,
+  ignition::gazebo::System,
+  crowd_simulation_ign::CrowdSimulatorPlugin::ISystemConfigure,
+  crowd_simulation_ign::CrowdSimulatorPlugin::ISystemPreUpdate)
+
+// TODO would prefer namespace
+IGNITION_ADD_PLUGIN_ALIAS(crowd_simulation_ign::CrowdSimulatorPlugin,
+  "crowd_simulation")
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp b/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp
new file mode 100644
index 0000000..1cb7919
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <unordered_map>
+
+#include <rclcpp/rclcpp.hpp>
+
+#include <ignition/plugin/Register.hh>
+#include <ignition/gazebo/System.hh>
+#include <ignition/gazebo/Model.hh>
+
+#include <ignition/transport/Node.hh>
+
+#include <building_sim_common/crowd_simulator_common.hpp>
+
+
+namespace crowd_simulation_ign {
+
+class IGNITION_GAZEBO_VISIBLE CrowdSimulatorPlugin
+  : public ignition::gazebo::System,
+  public ignition::gazebo::ISystemConfigure,
+  public ignition::gazebo::ISystemPreUpdate
+{
+  using AnimState = crowd_simulator::CrowdSimInterface::AnimState;
+public:
+  CrowdSimulatorPlugin()
+  : _transport_node_ptr(std::make_shared<ignition::transport::Node>()),
+    _crowd_sim_interface(std::make_shared<crowd_simulator::CrowdSimInterface>()),
+    _initialized(false)
+  {}
+
+  // inherit from ISystemConfigure
+  void Configure(const ignition::gazebo::Entity& entity,
+    const std::shared_ptr<const sdf::Element>& sdf,
+    ignition::gazebo::EntityComponentManager& ecm,
+    ignition::gazebo::EventManager& event_mgr) override;
+
+  // inherit from ISystemPreUpdate
+  void PreUpdate(const ignition::gazebo::UpdateInfo& info,
+    ignition::gazebo::EntityComponentManager& ecm) override;
+
+private:
+  std::shared_ptr<ignition::transport::Node> _transport_node_ptr;
+  std::shared_ptr<crowd_simulator::CrowdSimInterface> _crowd_sim_interface;
+  bool _initialized;
+  std::chrono::steady_clock::duration _last_sim_time{0};
+
+  std::shared_ptr<ignition::gazebo::Model> _world;
+  std::string _world_name;
+
+  // map for <model_name, object_id>, contains both external (models) and internal agents (actors)
+  std::unordered_map<std::string, size_t> _object_dic;
+  // map for <model_name, entity_id> contains external and internal agents
+  std::unordered_map<std::string, ignition::gazebo::Entity> _entity_dic;
+
+  bool _spawn_agents_in_world(ignition::gazebo::EntityComponentManager& ecm);
+  void _init_spawned_agents(ignition::gazebo::EntityComponentManager& ecm);
+  void _config_spawned_agents(
+    const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
+    const ignition::gazebo::Entity& enity,
+    ignition::gazebo::EntityComponentManager& ecm) const;
+  bool _create_entity(
+    ignition::gazebo::EntityComponentManager& ecm,
+    const std::string& model_name,
+    const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr) const;
+  void _update_all_objects(
+    double delta_sim_time,
+    ignition::gazebo::EntityComponentManager& ecm) const;
+  void _update_internal_object(
+    double delta_sim_time,
+    const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
+    const ignition::gazebo::Entity& enity,
+    ignition::gazebo::EntityComponentManager& ecm) const;
+};
+
+} //namespace crowd_simulation_ign
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/door.cpp b/building_sim_plugins/building_ignition_plugins/src/door.cpp
new file mode 100644
index 0000000..4f1c67f
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/door.cpp
@@ -0,0 +1,158 @@
+#include <ignition/plugin/Register.hh>
+
+#include <ignition/gazebo/System.hh>
+#include <ignition/gazebo/Model.hh>
+#include <ignition/gazebo/components/JointAxis.hh>
+#include <ignition/gazebo/components/JointPosition.hh>
+#include <ignition/gazebo/components/JointVelocity.hh>
+#include <ignition/gazebo/components/JointVelocityCmd.hh>
+
+#include <rclcpp/rclcpp.hpp>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/door_common.hpp>
+
+// TODO remove this
+using namespace ignition;
+using namespace gazebo;
+using namespace systems;
+
+using namespace building_sim_common;
+
+namespace building_ignition_plugins {
+
+//==============================================================================
+
+class IGNITION_GAZEBO_VISIBLE DoorPlugin
+  : public System,
+  public ISystemConfigure,
+  public ISystemPreUpdate
+{
+private:
+  rclcpp::Node::SharedPtr _ros_node;
+  std::unordered_map<std::string, Entity> _joints;
+
+  std::shared_ptr<DoorCommon> _door_common = nullptr;
+
+  bool _initialized = false;
+
+  void create_entity_components(Entity entity, EntityComponentManager& ecm)
+  {
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointPosition().TypeId()))
+      ecm.CreateComponent(entity, components::JointPosition({0}));
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointVelocity().TypeId()))
+      ecm.CreateComponent(entity, components::JointVelocity({0}));
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointVelocityCmd().TypeId()))
+      ecm.CreateComponent(entity, components::JointVelocityCmd({0}));
+  }
+
+public:
+  DoorPlugin()
+  {
+    // TODO init ros node
+    // Do nothing
+  }
+
+  void Configure(const Entity& entity,
+    const std::shared_ptr<const sdf::Element>& sdf,
+    EntityComponentManager& ecm, EventManager& /*_eventMgr*/) override
+  {
+    //_ros_node = gazebo_ros::Node::Get(sdf);
+    // TODO get properties from sdf instead of hardcoded (will fail for multiple instantiations)
+    // TODO proper rclcpp init (only once and pass args)
+    auto model = Model(entity);
+    char const** argv = NULL;
+    std::string name;
+    auto door_ele = sdf->GetElementImpl("door");
+    get_sdf_attribute_required<std::string>(door_ele, "name", name);
+    if (!rclcpp::is_initialized())
+      rclcpp::init(0, argv);
+    std::string plugin_name("plugin_" + name);
+    ignwarn << "Initializing plugin with name " << plugin_name << std::endl;
+    _ros_node = std::make_shared<rclcpp::Node>(plugin_name);
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Loading DoorPlugin for [%s]",
+      name.c_str());
+
+    _door_common = DoorCommon::make(
+      name,
+      _ros_node,
+      sdf);
+
+    if (!_door_common)
+      return;
+
+    for (const auto& joint_name : _door_common->joint_names())
+    {
+      const auto joint = model.JointByName(ecm, joint_name);
+      if (!joint)
+      {
+        RCLCPP_ERROR(_ros_node->get_logger(),
+          " -- Model is missing the joint [%s]",
+          joint_name.c_str());
+        return;
+      }
+      create_entity_components(joint, ecm);
+      _joints.insert({joint_name, joint});
+    }
+
+    _initialized = true;
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Finished loading [%s]",
+      name.c_str());
+  }
+
+  void PreUpdate(const UpdateInfo& info, EntityComponentManager& ecm) override
+  {
+    // TODO parallel thread executor?
+    rclcpp::spin_some(_ros_node);
+    if (!_initialized)
+      return;
+
+    double t =
+      (std::chrono::duration_cast<std::chrono::nanoseconds>(info.simTime).
+      count()) * 1e-9;
+
+    // Create DoorUpdateRequest
+    std::vector<DoorCommon::DoorUpdateRequest> requests;
+    for (const auto& joint : _joints)
+    {
+      DoorCommon::DoorUpdateRequest request;
+      request.joint_name = joint.first;
+      request.position = ecm.Component<components::JointPosition>(
+        joint.second)->Data()[0];
+      request.velocity = ecm.Component<components::JointVelocity>(
+        joint.second)->Data()[0];
+      requests.push_back(request);
+    }
+
+    auto results = _door_common->update(t, requests);
+
+    // Apply motions to the joints
+    for (const auto& result : results)
+    {
+      const auto it = _joints.find(result.joint_name);
+      assert(it != _joints.end());
+      auto vel_cmd = ecm.Component<components::JointVelocityCmd>(
+        it->second);
+      vel_cmd->Data()[0] = result.velocity;
+    }
+  }
+
+};
+
+IGNITION_ADD_PLUGIN(
+  DoorPlugin,
+  System,
+  DoorPlugin::ISystemConfigure,
+  DoorPlugin::ISystemPreUpdate)
+
+// TODO would prefer namespaced
+IGNITION_ADD_PLUGIN_ALIAS(DoorPlugin, "door")
+
+} // namespace building_ignition_plugins
diff --git a/building_sim_plugins/building_ignition_plugins/src/lift.cpp b/building_sim_plugins/building_ignition_plugins/src/lift.cpp
new file mode 100644
index 0000000..79b87fa
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/lift.cpp
@@ -0,0 +1,328 @@
+#include <ignition/plugin/Register.hh>
+
+#include <ignition/gazebo/System.hh>
+#include <ignition/gazebo/Model.hh>
+#include <ignition/gazebo/components/Model.hh>
+#include <ignition/gazebo/components/Name.hh>
+#include <ignition/gazebo/components/Pose.hh>
+#include <ignition/gazebo/components/Static.hh>
+#include <ignition/gazebo/components/AxisAlignedBox.hh>
+#include <ignition/gazebo/components/JointAxis.hh>
+#include <ignition/gazebo/components/JointPosition.hh>
+#include <ignition/gazebo/components/JointVelocity.hh>
+#include <ignition/gazebo/components/JointVelocityCmd.hh>
+#include <ignition/gazebo/components/JointPositionReset.hh>
+#include <ignition/gazebo/components/LinearVelocityCmd.hh>
+#include <ignition/gazebo/components/AngularVelocityCmd.hh>
+#include <ignition/gazebo/components/PoseCmd.hh>
+#include <ignition/gazebo/components/PhysicsEnginePlugin.hh>
+
+#include <rclcpp/rclcpp.hpp>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/lift_common.hpp>
+
+// TODO remove this
+using namespace ignition;
+using namespace gazebo;
+using namespace systems;
+
+using namespace building_sim_common;
+
+namespace building_sim_ign {
+
+enum class PhysEnginePlugin {DEFAULT, TPE};
+std::unordered_map<std::string, PhysEnginePlugin> plugin_names {
+  {"ignition-physics-tpe-plugin", PhysEnginePlugin::TPE}};
+
+//==============================================================================
+
+class IGNITION_GAZEBO_VISIBLE LiftPlugin
+  : public System,
+  public ISystemConfigure,
+  public ISystemPreUpdate
+{
+private:
+  rclcpp::Node::SharedPtr _ros_node;
+  Entity _cabin_joint;
+  Entity _lift_entity;
+  std::vector<Entity> _payloads;
+  ignition::math::AxisAlignedBox _initial_aabb;
+  ignition::math::Pose3d _initial_pose;
+  bool _read_aabb_dimensions = true;
+
+  PhysEnginePlugin _phys_plugin = PhysEnginePlugin::DEFAULT;
+  bool _first_iteration = true;
+
+  std::unique_ptr<LiftCommon> _lift_common = nullptr;
+
+  bool _initialized = false;
+
+  void create_entity_components(Entity entity, EntityComponentManager& ecm)
+  {
+    if (!ecm.EntityHasComponentType(entity,
+      components::LinearVelocityCmd().TypeId()))
+      ecm.CreateComponent(entity, components::LinearVelocityCmd({0, 0, 0}));
+    if (!ecm.EntityHasComponentType(entity,
+      components::WorldPoseCmd().TypeId()))
+    {
+      auto pos = ecm.Component<components::Pose>(entity);
+      if (pos) // Set Pose cmd to current pose, instead of default location
+      {
+        ecm.CreateComponent(entity, components::WorldPoseCmd(pos->Data()));
+      }
+      else
+      {
+        ecm.CreateComponent(entity, components::WorldPoseCmd());
+      }
+    }
+  }
+
+  void create_joint_components(Entity entity, EntityComponentManager& ecm)
+  {
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointPosition().TypeId()))
+      ecm.CreateComponent(entity, components::JointPosition({0}));
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointPositionReset().TypeId()))
+      ecm.CreateComponent(entity, components::JointPositionReset({0}));
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointVelocity().TypeId()))
+      ecm.CreateComponent(entity, components::JointVelocity({0}));
+    if (!ecm.EntityHasComponentType(entity,
+      components::JointVelocityCmd().TypeId()))
+      ecm.CreateComponent(entity, components::JointVelocityCmd({0}));
+  }
+
+  void fill_physics_engine(Entity entity, EntityComponentManager& ecm)
+  {
+    Entity parent = entity;
+    while (ecm.ParentEntity(parent))
+    {
+      parent = ecm.ParentEntity(parent);
+    }
+    if (ecm.EntityHasComponentType(parent,
+      components::PhysicsEnginePlugin().TypeId()))
+    {
+      const std::string physics_plugin_name =
+        ecm.Component<components::PhysicsEnginePlugin>(parent)->Data();
+      const auto it = plugin_names.find(physics_plugin_name);
+      if (it != plugin_names.end())
+      {
+        _phys_plugin = it->second;
+      }
+    }
+  }
+
+  std::vector<Entity> get_payloads(EntityComponentManager& ecm)
+  {
+    const auto& lift_pose =
+      ecm.Component<components::Pose>(_lift_entity)->Data();
+    const ignition::math::Vector3d displacement =
+      lift_pose.CoordPositionSub(_initial_pose);
+    // Calculate current AABB of lift assuming it hasn't tilted/deformed
+    ignition::math::AxisAlignedBox lift_aabb = _initial_aabb + displacement;
+
+    std::vector<Entity> payloads;
+    ecm.Each<components::Model, components::Pose>(
+      [&](const Entity& entity,
+      const components::Model*,
+      const components::Pose* pose
+      ) -> bool
+      {
+        const auto payload_position = pose->Data().Pos();
+        if (entity != _lift_entity)
+        { // Could possibly check bounding box intersection too, but this suffices
+          if (lift_aabb.Contains(payload_position))
+          {
+            payloads.push_back(entity);
+          }
+        }
+        return true;
+      });
+    return payloads;
+  }
+
+public:
+  LiftPlugin()
+  {
+    // TODO init ros node
+    // Do nothing
+  }
+
+  void Configure(const Entity& entity,
+    const std::shared_ptr<const sdf::Element>& sdf,
+    EntityComponentManager& ecm, EventManager& /*_eventMgr*/) override
+  {
+    _lift_entity = entity;
+    //_ros_node = gazebo_ros::Node::Get(sdf);
+    // TODO get properties from sdf instead of hardcoded (will fail for multiple instantiations)
+    // TODO proper rclcpp init (only once and pass args)
+    auto model = Model(entity);
+    char const** argv = NULL;
+    if (!rclcpp::ok())
+      rclcpp::init(0, argv);
+    std::string plugin_name("plugin_" + model.Name(ecm));
+    ignwarn << "Initializing plugin with name " << plugin_name << std::endl;
+    _ros_node = std::make_shared<rclcpp::Node>(plugin_name);
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Loading LiftPlugin for [%s]",
+      model.Name(ecm).c_str());
+
+    _lift_common = LiftCommon::make(
+      model.Name(ecm),
+      _ros_node,
+      sdf);
+
+    if (!_lift_common)
+      return;
+
+    if (!ecm.EntityHasComponentType(_lift_entity,
+      components::AxisAlignedBox().TypeId()))
+    {
+      ecm.CreateComponent(_lift_entity, components::AxisAlignedBox());
+    }
+
+    _cabin_joint = model.JointByName(ecm, _lift_common->get_joint_name());
+    if (!_cabin_joint)
+    {
+      RCLCPP_ERROR(_ros_node->get_logger(),
+        " -- Model is missing the joint [%s]",
+        _lift_common->get_joint_name().c_str());
+      return;
+    }
+
+    _initialized = true;
+
+    RCLCPP_INFO(_ros_node->get_logger(),
+      "Finished loading [%s]",
+      model.Name(ecm).c_str());
+  }
+
+  void PreUpdate(const UpdateInfo& info, EntityComponentManager& ecm) override
+  {
+    // Read from components that may not have been initialized in configure()
+    if (_first_iteration)
+    {
+      fill_physics_engine(_lift_entity, ecm);
+
+      double lift_elevation = _lift_common->get_elevation();
+      if (_phys_plugin == PhysEnginePlugin::DEFAULT)
+      {
+        create_joint_components(_cabin_joint, ecm);
+        auto position_cmd = ecm.Component<components::JointPositionReset>(
+          _cabin_joint);
+        position_cmd->Data()[0] = lift_elevation;
+      }
+      else
+      {
+        create_entity_components(_lift_entity, ecm);
+        auto position_cmd = ecm.Component<components::WorldPoseCmd>(
+          _lift_entity);
+        position_cmd->Data().Pos().Z() = lift_elevation;
+      }
+
+      _first_iteration = false;
+    }
+
+    // Optimization: Read and store lift's pose and AABB whenever available, then
+    // delete the AABB component once read. Not deleting it causes rtf to drop by
+    // a 3-4x factor whenever the lift moves.
+    if (_read_aabb_dimensions)
+    {
+      const auto& aabb_component =
+        ecm.Component<components::AxisAlignedBox>(_lift_entity);
+      const auto& pose_component =
+        ecm.Component<components::Pose>(_lift_entity);
+
+      if (aabb_component && pose_component)
+      {
+        const double volume = aabb_component->Data().Volume();
+        if (volume > 0 && volume != std::numeric_limits<double>::infinity())
+        {
+          _initial_aabb = aabb_component->Data();
+          _initial_pose = pose_component->Data();
+          ecm.RemoveComponent(_lift_entity,
+            components::AxisAlignedBox().TypeId());
+          _read_aabb_dimensions = false;
+        }
+      }
+    }
+
+    // TODO parallel thread executor?
+    rclcpp::spin_some(_ros_node);
+    if (!_initialized)
+      return;
+
+    // Send update request
+    const double t =
+      (std::chrono::duration_cast<std::chrono::nanoseconds>(info.simTime).
+      count()) * 1e-9;
+    double position = 0.0;
+    double velocity = 0.0;
+
+    // Read from either joint data or model data based on physics engine
+    if (_phys_plugin == PhysEnginePlugin::DEFAULT)
+    {
+      position = ecm.Component<components::JointPosition>(
+        _cabin_joint)->Data()[0];
+      velocity = ecm.Component<components::JointVelocity>(
+        _cabin_joint)->Data()[0];
+    }
+    else
+    {
+      position = ecm.Component<components::Pose>(
+        _lift_entity)->Data().Pos().Z();
+      auto lift_vel_cmd = ecm.Component<components::LinearVelocityCmd>(
+        _lift_entity);
+      velocity = lift_vel_cmd->Data()[2];
+    }
+
+    auto result = _lift_common->update(t, position, velocity);
+
+    // Move either joint or lift cabin based on physics engine used
+    if (_phys_plugin == PhysEnginePlugin::DEFAULT)
+    {
+      auto vel_cmd = ecm.Component<components::JointVelocityCmd>(
+        _cabin_joint);
+      vel_cmd->Data()[0] = result.velocity;
+    }
+    else
+    {
+      auto lift_vel_cmd = ecm.Component<components::LinearVelocityCmd>(
+        _lift_entity);
+      lift_vel_cmd->Data()[2] = result.velocity;
+    }
+
+    // Move any payloads that need to be manually moved
+    // (i.e. have a LinearVelocityCmd component that exists)
+    if (_lift_common->motion_state_changed())
+    {
+      _payloads = get_payloads(ecm);
+    }
+
+    for (const Entity& payload : _payloads)
+    {
+      if (ecm.EntityHasComponentType(payload,
+        components::LinearVelocityCmd().TypeId()))
+      {
+        auto lin_vel_cmd =
+          ecm.Component<components::LinearVelocityCmd>(payload);
+        lin_vel_cmd->Data()[2] = result.velocity;
+      }
+    }
+  }
+};
+
+
+IGNITION_ADD_PLUGIN(
+  LiftPlugin,
+  System,
+  LiftPlugin::ISystemConfigure,
+  LiftPlugin::ISystemPreUpdate)
+
+// TODO would prefer namespaced
+IGNITION_ADD_PLUGIN_ALIAS(LiftPlugin, "lift")
+
+} // namespace building_sim_ign
diff --git a/building_sim_plugins/building_ignition_plugins/src/slotcar.cpp b/building_sim_plugins/building_ignition_plugins/src/slotcar.cpp
new file mode 100644
index 0000000..aed21bf
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/slotcar.cpp
@@ -0,0 +1,360 @@
+#include <unordered_map>
+
+#include <ignition/plugin/Register.hh>
+
+#include <ignition/gazebo/System.hh>
+#include <ignition/gazebo/Model.hh>
+#include <ignition/gazebo/components/JointVelocity.hh>
+#include <ignition/gazebo/components/JointVelocityCmd.hh>
+#include <ignition/gazebo/components/Model.hh>
+#include <ignition/gazebo/components/Name.hh>
+#include <ignition/gazebo/components/Pose.hh>
+#include <ignition/gazebo/components/Static.hh>
+#include <ignition/gazebo/components/AxisAlignedBox.hh>
+#include <ignition/gazebo/components/LinearVelocityCmd.hh>
+#include <ignition/gazebo/components/AngularVelocityCmd.hh>
+#include <ignition/gazebo/components/PhysicsEnginePlugin.hh>
+
+#include <ignition/msgs.hh>
+#include <ignition/transport.hh>
+#include <rclcpp/rclcpp.hpp>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/slotcar_common.hpp>
+
+using namespace ignition::gazebo;
+
+using namespace building_sim_common;
+
+enum class PhysEnginePlugin {DEFAULT, TPE};
+std::unordered_map<std::string, PhysEnginePlugin> plugin_names {
+  {"ignition-physics-tpe-plugin", PhysEnginePlugin::TPE}};
+
+class IGNITION_GAZEBO_VISIBLE SlotcarPlugin
+  : public System,
+  public ISystemConfigure,
+  public ISystemPreUpdate
+{
+public:
+  SlotcarPlugin();
+  ~SlotcarPlugin();
+
+  void Configure(const Entity& entity,
+    const std::shared_ptr<const sdf::Element>& sdf,
+    EntityComponentManager& ecm, EventManager& eventMgr) override;
+  void PreUpdate(const UpdateInfo& info, EntityComponentManager& ecm) override;
+
+private:
+  std::unique_ptr<SlotcarCommon> dataPtr;
+  ignition::transport::Node _ign_node;
+  rclcpp::Node::SharedPtr _ros_node;
+
+  Entity _entity;
+  std::unordered_set<Entity> _payloads;
+  std::unordered_set<Entity> _infrastructure;
+  double _height = 0;
+
+  PhysEnginePlugin phys_plugin = PhysEnginePlugin::DEFAULT;
+
+  bool first_iteration = true; // Flag for checking if it is first PreUpdate() call
+  bool _read_aabb_dimensions = true;
+
+  void charge_state_cb(const ignition::msgs::Selection& msg);
+
+  void send_control_signals(EntityComponentManager& ecm,
+    const std::pair<double, double>& velocities,
+    const std::unordered_set<Entity> payloads,
+    const double dt);
+  void init_infrastructure(EntityComponentManager& ecm);
+  void item_dispensed_cb(const ignition::msgs::UInt64_V& msg);
+  void item_ingested_cb(const ignition::msgs::Entity& msg);
+  bool get_slotcar_height(const ignition::msgs::Entity& req,
+    ignition::msgs::Double& rep);
+  std::vector<Eigen::Vector3d> get_obstacle_positions(
+    EntityComponentManager& ecm);
+};
+
+SlotcarPlugin::SlotcarPlugin()
+: dataPtr(std::make_unique<SlotcarCommon>())
+{
+  // Listen for messages that enable/disable charging
+  if (!_ign_node.Subscribe("/charge_state", &SlotcarPlugin::charge_state_cb,
+    this))
+  {
+    std::cerr << "Error subscribing to topic [/charge_state]" << std::endl;
+  }
+  // We do rest of initialization during ::Configure
+}
+
+SlotcarPlugin::~SlotcarPlugin()
+{
+}
+
+void SlotcarPlugin::Configure(const Entity& entity,
+  const std::shared_ptr<const sdf::Element>& sdf,
+  EntityComponentManager& ecm, EventManager&)
+{
+  _entity = entity;
+  auto model = Model(entity);
+  std::string model_name = model.Name(ecm);
+  dataPtr->set_model_name(model_name);
+  dataPtr->read_sdf(sdf);
+
+  // TODO proper argc argv
+  char const** argv = NULL;
+  if (!rclcpp::ok())
+    rclcpp::init(0, argv);
+  std::string plugin_name("plugin_" + model_name);
+  _ros_node = std::make_shared<rclcpp::Node>(plugin_name);
+  // TODO Check if executor is getting callbacks
+  //executor = std::make_unique<rclcpp::executors::MultiThreadedExecutor>();
+  //executor->add_node(_ros_node);
+  //executor->spin();
+  dataPtr->init_ros_node(_ros_node);
+
+  // Initialize Pose3d component
+  if (!ecm.EntityHasComponentType(entity, components::Pose().TypeId()))
+    ecm.CreateComponent(entity, components::Pose());
+  // Initialize Bounding Box component
+  if (!ecm.EntityHasComponentType(entity,
+    components::AxisAlignedBox().TypeId()))
+    ecm.CreateComponent(entity, components::AxisAlignedBox());
+  // Initialize Linear/AngularVelocityCmd components to drive slotcar
+  if (!ecm.EntityHasComponentType(_entity,
+    components::LinearVelocityCmd().TypeId()))
+    ecm.CreateComponent(_entity, components::LinearVelocityCmd());
+  if (!ecm.EntityHasComponentType(_entity,
+    components::AngularVelocityCmd().TypeId()))
+    ecm.CreateComponent(_entity, components::AngularVelocityCmd());
+
+  // Keep track of when a payload is dispensed onto/ingested from slotcar
+  // Needed for TPE Plugin to know when to manually move payload via this plugin
+  if (!_ign_node.Subscribe("/item_dispensed", &SlotcarPlugin::item_dispensed_cb,
+    this))
+  {
+    std::cerr << "Error subscribing to topic [/item_dispensed]" << std::endl;
+  }
+  if (!_ign_node.Subscribe("/item_ingested", &SlotcarPlugin::item_ingested_cb,
+    this))
+  {
+    std::cerr << "Error subscribing to topic [/item_ingested]" << std::endl;
+  }
+  // Respond to requests asking for height (e.g. for dispenser to dispense object)
+  const std::string height_srv_name =
+    "/slotcar_height_" + std::to_string(entity);
+  if (!_ign_node.Advertise(height_srv_name, &SlotcarPlugin::get_slotcar_height,
+    this))
+  {
+    std::cerr << "Error subscribing to topic [/slotcar_height]" << std::endl;
+  }
+}
+
+void SlotcarPlugin::send_control_signals(EntityComponentManager& ecm,
+  const std::pair<double, double>& velocities,
+  const std::unordered_set<Entity> payloads,
+  const double dt)
+{
+  auto lin_vel_cmd =
+    ecm.Component<components::LinearVelocityCmd>(_entity);
+  auto ang_vel_cmd =
+    ecm.Component<components::AngularVelocityCmd>(_entity);
+
+  double v_robot = lin_vel_cmd->Data()[0];
+  double w_robot = ang_vel_cmd->Data()[2];
+  std::array<double, 2> target_vels;
+  target_vels = dataPtr->calculate_model_control_signals({v_robot, w_robot},
+      velocities, dt);
+
+  lin_vel_cmd->Data()[0] = target_vels[0];
+  ang_vel_cmd->Data()[2] = target_vels[1];
+
+  if (phys_plugin == PhysEnginePlugin::TPE) // Need to manually move any payloads
+  {
+    for (const Entity& payload : payloads)
+    {
+      if (!ecm.EntityHasComponentType(payload,
+        components::LinearVelocityCmd().TypeId()))
+      {
+        ecm.CreateComponent(payload,
+          components::LinearVelocityCmd({0, 0, 0}));
+      }
+      if (!ecm.EntityHasComponentType(payload,
+        components::AngularVelocityCmd().TypeId()))
+      {
+        ecm.CreateComponent(payload,
+          components::AngularVelocityCmd({0, 0, 0}));
+      }
+      ecm.Component<components::LinearVelocityCmd>(payload)->Data() =
+        lin_vel_cmd->Data();
+      ecm.Component<components::AngularVelocityCmd>(payload)->Data() =
+        ang_vel_cmd->Data();
+    }
+  }
+}
+
+void SlotcarPlugin::init_infrastructure(EntityComponentManager& ecm)
+{
+  // Cycle through all the static entities with Model and Name components
+  ecm.Each<components::Model, components::Name, components::Pose,
+    components::Static>(
+    [&](const Entity& entity,
+    const components::Model*,
+    const components::Name* name,
+    const components::Pose*,
+    const components::Static* is_static
+    ) -> bool
+    {
+      if (is_static->Data() == false)
+      {
+        std::string n = name->Data();
+        std::for_each(n.begin(), n.end(), [](char& c)
+        {
+          c = ::tolower(c);
+        });
+        if (n.find("door") != std::string::npos ||
+        n.find("lift") != std::string::npos)
+          _infrastructure.insert(entity);
+      }
+      return true;
+    });
+  // Also add itself
+  _infrastructure.insert(_entity);
+}
+
+std::vector<Eigen::Vector3d> SlotcarPlugin::get_obstacle_positions(
+  EntityComponentManager& ecm)
+{
+  std::vector<Eigen::Vector3d> obstacle_positions;
+  ecm.Each<components::Model, components::Name, components::Pose,
+    components::Static>(
+    [&](const Entity& entity,
+    const components::Model*,
+    const components::Name*,
+    const components::Pose* pose,
+    const components::Static* is_static
+    ) -> bool
+    {
+      // Object should not be static
+      // It should not be part of infrastructure (doors / lifts)
+      // And it should be closer than the "stop" range (checked by common)
+      const auto obstacle_position = pose->Data().Pos();
+      if (is_static->Data() == false &&
+      _infrastructure.find(entity) == _infrastructure.end())
+      {
+        obstacle_positions.push_back(convert_vec(obstacle_position));
+      }
+      return true;
+    });
+  return obstacle_positions;
+}
+
+void SlotcarPlugin::charge_state_cb(const ignition::msgs::Selection& msg)
+{
+  dataPtr->charge_state_cb(msg.name(), msg.selected());
+}
+
+// First element of msg should be the slotcar, and the second should be the payload
+void SlotcarPlugin::item_dispensed_cb(const ignition::msgs::UInt64_V& msg)
+{
+  if (msg.data_size() == 2 && msg.data(0) == _entity)
+  {
+    Entity new_payload = msg.data(1);
+    this->_payloads.insert(new_payload);
+  }
+}
+
+void SlotcarPlugin::item_ingested_cb(const ignition::msgs::Entity& msg)
+{
+  if (msg.IsInitialized())
+  {
+    const std::unordered_set<Entity>::iterator it = _payloads.find(msg.id());
+    if (it != _payloads.end())
+    {
+      _payloads.erase(it);
+    }
+  }
+}
+
+bool SlotcarPlugin::get_slotcar_height(const ignition::msgs::Entity& req,
+  ignition::msgs::Double& rep)
+{
+  if (req.id() == _entity)
+  {
+    rep.set_data(_height);
+    return true;
+  }
+  return false;
+}
+
+void SlotcarPlugin::PreUpdate(const UpdateInfo& info,
+  EntityComponentManager& ecm)
+{
+  // Read from components that may not have been initialized in configure()
+  if (first_iteration)
+  {
+    Entity parent = _entity;
+    while (ecm.ParentEntity(parent))
+    {
+      parent = ecm.ParentEntity(parent);
+    }
+    if (ecm.EntityHasComponentType(parent,
+      components::PhysicsEnginePlugin().TypeId()))
+    {
+      const std::string physics_plugin_name =
+        ecm.Component<components::PhysicsEnginePlugin>(parent)->Data();
+      const auto it = plugin_names.find(physics_plugin_name);
+      if (it != plugin_names.end())
+      {
+        phys_plugin = it->second;
+      }
+    }
+    first_iteration = false;
+  }
+
+  // Optimization: Read and store slotcar's dimensions whenever available, then
+  // delete the AABB component once read. Not deleting it causes rtf to drop by
+  // a 3-4x factor whenever the slotcar moves.
+  if (_read_aabb_dimensions)
+  {
+    const auto& aabb_component =
+      ecm.Component<components::AxisAlignedBox>(_entity);
+    if (aabb_component)
+    {
+      const double volume = aabb_component->Data().Volume();
+      if (volume > 0 && volume != std::numeric_limits<double>::infinity())
+      {
+        _height = aabb_component->Data().ZLength();
+        ecm.RemoveComponent(_entity, components::AxisAlignedBox().TypeId());
+        _read_aabb_dimensions = false;
+      }
+    }
+  }
+
+  // TODO parallel thread executor?
+  rclcpp::spin_some(_ros_node);
+  if (_infrastructure.empty())
+    init_infrastructure(ecm);
+
+  double dt =
+    (std::chrono::duration_cast<std::chrono::nanoseconds>(info.dt).count()) *
+    1e-9;
+  double time =
+    (std::chrono::duration_cast<std::chrono::nanoseconds>(info.simTime).count())
+    * 1e-9;
+
+  auto pose = ecm.Component<components::Pose>(_entity)->Data();
+  auto obstacle_positions = get_obstacle_positions(ecm);
+
+  auto velocities =
+    dataPtr->update(convert_pose(pose), obstacle_positions, time);
+
+  send_control_signals(ecm, velocities, _payloads, dt);
+}
+
+IGNITION_ADD_PLUGIN(
+  SlotcarPlugin,
+  System,
+  SlotcarPlugin::ISystemConfigure,
+  SlotcarPlugin::ISystemPreUpdate)
+
+IGNITION_ADD_PLUGIN_ALIAS(SlotcarPlugin, "slotcar")
diff --git a/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.config b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.config
new file mode 100644
index 0000000..54c37e7
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.config
@@ -0,0 +1,3 @@
+<plugin filename="toggle_charging">
+  <title>Toggle Charging</title>
+</plugin>
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.cpp b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.cpp
new file mode 100644
index 0000000..aace3ac
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.cpp
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <string>
+#include <iostream>
+
+#include <ignition/plugin/Register.hh>
+#include <ignition/gui/qt.h>
+#include <ignition/gui/Plugin.hh>
+
+#include <ignition/msgs.hh>
+#include <ignition/transport.hh>
+
+using namespace ignition;
+using namespace gui;
+
+class toggle_charging : public Plugin
+{
+  Q_OBJECT
+
+private:
+  bool _enable_charge = true;
+  bool _enable_instant_charge = false;
+  bool _enable_drain = true;
+  const std::string _enable_charge_str = "_enable_charge";
+  const std::string _enable_instant_charge_str = "_enable_instant_charge";
+  const std::string _enable_drain_str = "_enable_drain";
+
+  ignition::transport::Node _node;
+  ignition::transport::Node::Publisher _charge_state_pub;
+
+  void checkbox_checked(const std::string& name, bool checked);
+
+protected slots:
+  void OnEnableCharge(bool);
+  void OnEnableInstantCharge(bool);
+  void OnEnableDrain(bool);
+
+public:
+  toggle_charging();
+
+  virtual void LoadConfig(const tinyxml2::XMLElement* _pluginElem)
+  override;
+};
+
+toggle_charging::toggle_charging()
+{
+  _charge_state_pub = _node.Advertise<ignition::msgs::Selection>(
+    "/charge_state");
+  if (!_charge_state_pub)
+  {
+    std::cerr << "Error advertising topic [/charge_state]" << std::endl;
+  }
+}
+
+void toggle_charging::LoadConfig(const tinyxml2::XMLElement* _pluginElem)
+{
+  if (!_pluginElem)
+    return;
+
+  if (this->title.empty())
+    this->title = "Toggle Charging";
+}
+
+void toggle_charging::OnEnableCharge(bool checked)
+{
+  _enable_charge = checked;
+  checkbox_checked(_enable_charge_str, checked);
+}
+
+void toggle_charging::OnEnableInstantCharge(bool checked)
+{
+  _enable_instant_charge = checked;
+  checkbox_checked(_enable_instant_charge_str, _enable_instant_charge);
+}
+
+void toggle_charging::OnEnableDrain(bool checked)
+{
+  _enable_drain = checked;
+  checkbox_checked(_enable_drain_str, _enable_drain);
+}
+
+void toggle_charging::checkbox_checked(
+  const std::string& name, bool checked)
+{
+  ignition::msgs::Selection selection;
+  selection.set_name(name);
+  selection.set_selected(checked);
+  selection.set_id(1); // Id not necessary for current use case
+  _charge_state_pub.Publish(selection);
+}
+
+// Register this plugin
+IGNITION_ADD_PLUGIN(toggle_charging,
+  ignition::gui::Plugin)
+
+
+#include "toggle_charging.moc"
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qml b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qml
new file mode 100644
index 0000000..faf9ac1
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qml
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+import QtQuick 2.9
+import QtQuick.Window 2.2
+import QtQuick.Controls 2.1
+import QtQuick.Controls.Material 2.2
+import QtQuick.Controls.Material.impl 2.2
+import QtQuick.Layouts 1.3
+import QtQuick.Controls.Styles 1.4
+
+ToolBar {
+  Layout.minimumWidth: 280
+  Layout.minimumHeight: 370
+
+  background: Rectangle {
+    color: "transparent"
+  }
+
+  ButtonGroup {
+    id: group
+  }
+
+  GridLayout {
+    anchors.fill: parent
+    columns: 1
+    rows: 3
+    columnSpacing: 5
+    CheckBox {
+      text: qsTr("Allow Charging")
+      Layout.columnSpan: 1
+      Layout.alignment: Qt.AlignVCenter | Qt.AlignLeft
+      Layout.leftMargin: 2
+      checked: true
+      onClicked: {
+        toggle_charging.OnEnableCharge(checked)
+      }
+    }
+
+    CheckBox {
+      text: qsTr("Instant Charging")
+      Layout.columnSpan: 1
+      Layout.alignment: Qt.AlignVCenter | Qt.AlignLeft
+      Layout.leftMargin: 2
+      checked: false
+      onClicked: {
+        toggle_charging.OnEnableInstantCharge(checked)
+      }
+    }
+
+    CheckBox {
+      text: qsTr("Allow Battery Drain")
+      Layout.columnSpan: 1
+      Layout.alignment: Qt.AlignVCenter | Qt.AlignLeft
+      Layout.leftMargin: 2
+      checked: true
+      onClicked: {
+        toggle_charging.OnEnableDrain(checked)
+      }
+    }
+
+  }
+}
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qrc b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qrc
new file mode 100644
index 0000000..a967418
--- /dev/null
+++ b/building_sim_plugins/building_ignition_plugins/src/toggle_charging/toggle_charging.qrc
@@ -0,0 +1,5 @@
+<!DOCTYPE RCC><RCC version="1.0">
+  <qresource prefix="toggle_charging/">
+    <file>toggle_charging.qml</file>
+  </qresource>
+</RCC>
\ No newline at end of file
diff --git a/building_sim_plugins/building_plugins_common/CHANGELOG.rst b/building_sim_plugins/building_plugins_common/CHANGELOG.rst
new file mode 100644
index 0000000..f54598a
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/CHANGELOG.rst
@@ -0,0 +1,35 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package building_sim_common
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.2.0 (2021-01-06)
+------------------
+* Add animation switch to crowd simulation plugin (`#238 <https://github.com/osrf/traffic_editor/pull/238>`_)
+* Add pausing feature to slotcar plugin: [`#267 <https://github.com/osrf/traffic_editor/pull/267>`_]
+* undo features
+* dropping eloquent support (`#277 <https://github.com/osrf/traffic_editor/issues/277>`_)
+* Fix undefined initialization of _old_ang_vel and _old_lin_vel (`#274 <https://github.com/osrf/traffic_editor/issues/274>`_)
+* idle mode when slotcar is stationary (`#264 <https://github.com/osrf/traffic_editor/issues/264>`_)
+* Add pausing feature (`#267 <https://github.com/osrf/traffic_editor/issues/267>`_)
+* Debug/slotcar battery and mode (`#261 <https://github.com/osrf/traffic_editor/issues/261>`_)
+* Added ament exports for crowd simulation common (`#260 <https://github.com/osrf/traffic_editor/issues/260>`_)
+* Merge branch 'release-1.1'
+* Make slotcar rotations follow trajectory yaw angle (`#254 <https://github.com/osrf/traffic_editor/issues/254>`_)
+* Fixed RobotMode (`#252 <https://github.com/osrf/traffic_editor/issues/252>`_)
+* Fix namespace for rmf charging plugin (`#253 <https://github.com/osrf/traffic_editor/issues/253>`_)
+* Control slotcar with model velocity cmds in place of joint velocity cmds (`#236 <https://github.com/osrf/traffic_editor/issues/236>`_)
+* Implement battery drain and recharge for slotcars (`#242 <https://github.com/osrf/traffic_editor/issues/242>`_)
+* Implement animation switching in crowd simulation (`#238 <https://github.com/osrf/traffic_editor/issues/238>`_)
+* Contributors: Geoffrey Biggs, Grey, Guoliang (Fred) Shao, Luca Della Vedova, Marco A. Gutiérrez, Morgan Quigley, Rushyendra Maganty, Yadu, youliang
+
+1.1.0 (2020-09-24)
+------------------
+* Crowd simulation plugin (`#218 <https://github.com/osrf/traffic_editor/issues/218>`_)
+* Improve lift initial floor definition `#221 <https://github.com/osrf/traffic_editor/issues/221>`_
+* Update lift session id in lift plugin (`#223 <https://github.com/osrf/traffic_editor/issues/223>`_)
+* Add field in lift dialog for initial floor, handle invalid initial floor
+* Ignition plugins and modularization of doors and slotcar `#138 <https://github.com/osrf/traffic_editor/issues/138>`_
+* Adding lift plugin for ignition `#171 <https://github.com/osrf/traffic_editor/issues/171>`_
+* spawn lifts at respective reference floors
+* stagger door_state publishing
+* Contributors: Charayaphan Nakorn Boon Han, Guoliang (Fred) Shao, Kevin_Skywalker, Luca Della Vedova, MakinoharaShouko
diff --git a/building_sim_plugins/building_plugins_common/CMakeLists.txt b/building_sim_plugins/building_plugins_common/CMakeLists.txt
new file mode 100644
index 0000000..2e603b8
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/CMakeLists.txt
@@ -0,0 +1,166 @@
+cmake_minimum_required(VERSION 3.5)
+project(building_sim_common)
+
+find_package(Qt5 COMPONENTS Widgets REQUIRED)
+set(CMAKE_AUTOMOC ON)
+
+# Default to C99
+if(NOT CMAKE_C_STANDARD)
+  set(CMAKE_C_STANDARD 99)
+endif()
+
+# Default to C++14
+if(NOT CMAKE_CXX_STANDARD)
+  set(CMAKE_CXX_STANDARD 14)
+endif()
+
+
+if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+  add_compile_options(-Wall -Wextra -Wpedantic)
+endif()
+
+# find dependencies
+find_package(ament_cmake REQUIRED)
+find_package(rclcpp REQUIRED)
+find_package(Eigen3 REQUIRED)
+find_package(tf2_ros REQUIRED)
+find_package(geometry_msgs REQUIRED)
+find_package(std_msgs REQUIRED)
+find_package(std_srvs REQUIRED)
+find_package(rmf_fleet_msgs REQUIRED)
+find_package(rmf_door_msgs REQUIRED)
+find_package(rmf_lift_msgs REQUIRED)
+find_package(building_map_msgs REQUIRED)
+find_package(menge QUIET)
+
+include(GNUInstallDirs)
+
+add_library(slotcar_common SHARED ${PROJECT_SOURCE_DIR}/src/slotcar_common.cpp)
+
+ament_target_dependencies(slotcar_common
+    Eigen3
+    rmf_fleet_msgs
+    building_map_msgs
+    rclcpp
+    std_msgs
+    geometry_msgs
+    tf2_ros
+)
+
+target_include_directories(slotcar_common
+  PUBLIC
+    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+    ${EIGEN3_INCLUDE_DIRS}
+    ${GAZEBO_INCLUDE_DIRS}
+)
+
+###############################
+# door stuff
+###############################
+
+add_library(door_common SHARED src/door_common.cpp)
+
+ament_target_dependencies(door_common
+    rmf_fleet_msgs
+    rclcpp
+    rmf_door_msgs
+)
+
+target_include_directories(door_common
+ PUBLIC
+   $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+   $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+)
+
+###############################
+# lift stuff
+###############################
+
+add_library(lift_common SHARED src/lift_common.cpp)
+
+ament_target_dependencies(lift_common
+   rmf_fleet_msgs
+   rclcpp
+   rmf_door_msgs
+   rmf_lift_msgs
+)
+
+
+target_include_directories(lift_common
+ PUBLIC
+   $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+   $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+)
+
+###############################
+# crowd simulator stuff
+###############################
+if (menge_FOUND)
+  add_library(crowd_simulator_common
+    SHARED
+    src/crowd_simulator_common.cpp  
+  )
+
+  target_include_directories(crowd_simulator_common
+    PUBLIC
+      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
+      $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
+      ${menge_INCLUDE_DIRS}
+  )
+  
+  ament_target_dependencies(crowd_simulator_common
+    menge
+    rclcpp
+  )
+
+  #crowd_simulation_common_install
+  ament_export_targets(crowd_simulator_common HAS_LIBRARY_TARGET)
+  install(
+    TARGETS crowd_simulator_common
+    EXPORT crowd_simulator_common
+    LIBRARY DESTINATION lib
+    ARCHIVE DESTINATION lib
+  )
+else(NOT menge_FOUND)
+  message("menge-cmake not found, skipping crowd_simulation plugins")
+endif()
+
+###############################
+# install stuff
+###############################
+ament_export_include_directories(include)
+
+ament_export_targets(slotcar_common HAS_LIBRARY_TARGET)
+ament_export_targets(door_common HAS_LIBRARY_TARGET)
+ament_export_targets(lift_common HAS_LIBRARY_TARGET)
+
+ament_export_dependencies(Eigen3)
+
+install(
+  TARGETS slotcar_common 
+  EXPORT slotcar_common
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib
+)
+
+install(
+  TARGETS door_common 
+  EXPORT door_common 
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib
+)
+
+install(
+  TARGETS lift_common
+  EXPORT lift_common 
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib
+)
+
+install(
+  DIRECTORY include/building_sim_common
+  DESTINATION include
+)
+
+ament_package()
diff --git a/building_sim_plugins/building_plugins_common/QUALITY_DECLARATION.md b/building_sim_plugins/building_plugins_common/QUALITY_DECLARATION.md
new file mode 100644
index 0000000..086cee2
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/QUALITY_DECLARATION.md
@@ -0,0 +1,172 @@
+This document is a declaration of software quality for the `building_plugins_common` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+# `building_plugins_common` Quality Declaration
+
+The package `building_plugins_common` claims to be in the **Quality Level 4** category.
+
+Below are the detailed rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+## Version Policy [1]
+
+### Version Scheme [1.i]
+
+`building_plugins_common` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).
+
+### Version Stability [1.ii]
+
+`building_plugins_common` is at a stable version, i.e. `>= 1.0.0`.
+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).
+
+### Public API Declaration [1.iii]
+
+All symbols in the installed headers are considered part of the public API.
+
+All installed headers are in the `include` directory of the package.
+Headers in any other folders are not installed and are considered private.
+
+### API Stability Policy [1.iv]
+
+`building_plugins_common` will not break public API within a major version number.
+
+### ABI Stability Policy [1.v]
+
+`building_plugins_common` will not break public ABI within a major version number.
+
+### API and ABI Stability Within a Released ROS Distribution [1.vi]
+
+`building_plugins_common` will not break public API or ABI within a released ROS distribution, i.e. no major releases into the same ROS distribution once that ROS distribution is released.
+
+## Change Control Process [2]
+
+`building_plugins_common` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).
+
+### Change Requests [2.i]
+
+`building_plugins_common` requires that all changes occur through a pull request.
+
+### Contributor Origin [2.ii]
+
+`building_plugins_common` does not require a confirmation of contributor origin.
+
+### Peer Review Policy [2.iii]
+
+All pull requests must have at least 1 peer review.
+
+### Continuous Integration [2.iv]
+
+All pull requests must pass CI on all platforms supported by RMF.
+The CI checks only that the package builds.
+The most recent CI results can be seen on [the workflow page](https://github.com/osrf/traffic_editor/actions).
+
+### Documentation Policy [2.v]
+
+All pull requests must resolve related documentation changes before merging.
+
+## Documentation [3]
+
+### Feature Documentation [3.i]
+
+`building_plugins_common` does not provide feature documentation.
+
+### Public API Documentation [3.ii]
+
+`building_plugins_common` does not provide API documentation.
+
+### License [3.iii]
+
+The license for `building_plugins_common` is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.
+
+### Copyright Statement [3.iv]
+
+The copyright holders each provide a statement of copyright in each source code file in `rmf_demo_tasks`.
+
+### Quality declaration document [3.v]
+
+This quality declaration is linked in the [README file](README.md).
+
+This quality declaration has not been externally peer-reviewed and is not registered on any Level 4 lists.
+
+## Testing [4]
+
+### Feature Testing [4.i]
+
+`building_plugins_common` does not have any feature tests.
+
+### Public API Testing [4.ii]
+
+`building_plugins_common` does not have any API tests.
+
+### Coverage [4.iii]
+
+`building_plugins_common` does not track coverage statistics.
+
+### Performance [4.iv]
+
+`building_plugins_common` does not have performance tests.
+
+### Linters and Static Analysis [4.v]
+
+`building_plugins_common` does not use the standard linters and static analysis tools for its CMake code to ensure it follows the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).
+
+## Dependencies [5]
+
+### Direct Runtime ROS Dependencies [5.i]
+
+`building_plugins_common` has the following direct runtime ROS dependencies.
+
+#### rclcpp
+
+`rclcpp` is [**Quality Level 3**](https://github.com/ros2/rclcpp/blob/master/rclcpp/QUALITY_DECLARATION.md).
+
+#### rmf\_fleet\_msgs
+
+`rmf_fleet_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_fleet_msgs/QUALITY_DECLARATION.md).
+
+#### rmf\_door\_msgs
+
+`rmf_door_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_door_msgs/QUALITY_DECLARATION.md).
+
+#### rmf\_lift\_msgs
+
+`rmf_lift_msgs` is [**Quality Level 3**](https://github.com/osrf/rmf_core/blob/master/rmf_lift_msgs/QUALITY_DECLARATION.md).
+
+#### tf2\_ros
+
+`gazebo_dev` does not declare a Quality Level.
+It is assumed tobe at **Quality Level 4** based on its widespread use and use of CI.
+
+#### geometry\_msgs
+
+`geometry_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/geometry_msgs/QUALITY_DECLARATION.md).
+
+#### std\_msgs
+
+`std_msgs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/std_msgs/QUALITY_DECLARATION.md).
+
+#### std\_srvs
+
+`std_srvs` is [**Quality Level 3**](https://github.com/ros2/common_interfaces/blob/master/std_srvs/QUALITY_DECLARATION.md).
+
+#### building_map_msgs
+
+`building_map_msgs` is [**Quality Level 3**](https://github.com/osrf/traffic_editor/blob/master/building_map_msgs/QUALITY_DECLARATION.md).
+
+### Optional Direct Runtime ROS Dependencies [5.ii]
+
+`building_plugins_common` does not have any optional direct runtime ROS dependencies.
+
+### Direct Runtime non-ROS Dependency [5.iii]
+
+`building_plugins_common` depends on `menge`.
+`menge` is assumed to be **Quality Level 4**.
+
+## Platform Support [6]
+
+`building_plugins_common` does not support all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers).
+`building_plugins_common` supports ROS Eloquent and ROS Foxy.
+
+## Security [7]
+
+### Vulnerability Disclosure Policy [7.i]
+
+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).
diff --git a/building_sim_plugins/building_plugins_common/README.md b/building_sim_plugins/building_plugins_common/README.md
new file mode 100644
index 0000000..57f1f2e
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/README.md
@@ -0,0 +1,7 @@
+# building\_plugins\_common
+
+This package provides a common library for the Ignition and Gazebo simulator plugins for simulated building infrastructure.
+
+## Quality Declaration
+
+This package claims to be in the **Quality Level 4** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp
new file mode 100644
index 0000000..2317668
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp
@@ -0,0 +1,449 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_SIM_COMMON__CROWD_SIMULATOR_COMMON_HPP
+#define BUILDING_SIM_COMMON__CROWD_SIMULATOR_COMMON_HPP
+
+#include <functional>
+#include <list>
+#include <queue>
+#include <memory>
+#include <regex> //for parsing initial_pose
+
+#include <MengeCore/Runtime/SimulatorDB.h>
+#include <MengeCore/Orca/ORCADBEntry.h>
+#include <MengeCore/Orca/ORCASimulator.h>
+#include <MengeCore/PluginEngine/CorePluginEngine.h>
+
+#include <rclcpp/rclcpp.hpp>
+
+namespace crowd_simulator {
+
+using AgentPtr = std::shared_ptr<Menge::Agents::BaseAgent>;
+
+class AgentPose3d
+{
+public:
+  AgentPose3d()
+  : _x(0), _y(0), _z(0), _roll(0), _pitch(0), _yaw(0)
+  {}
+  AgentPose3d(double x, double y, double z, double roll, double pitch,
+    double yaw)
+  : _x(x), _y(y), _z(z), _roll(roll), _pitch(pitch), _yaw(yaw)
+  {}
+
+  double x() const {return _x;}
+  double y() const {return _y;}
+  double z() const {return _z;}
+  double roll() const {return _roll;}
+  double pitch() const {return _pitch;}
+  double yaw() const {return _yaw;}
+
+  void x(double x) {_x = x;}
+  void y(double y) {_y = y;}
+  void z(double z) {_z = z;}
+  void roll(double roll) {_roll = roll;}
+  void pitch(double pitch) {_pitch = pitch;}
+  void yaw(double yaw) {_yaw = yaw;}
+
+  template<typename IgnMathPose3d>
+  IgnMathPose3d convert_to_ign_math_pose_3d()
+  {
+    return IgnMathPose3d(_x, _y, _z, _roll, _pitch, _yaw);
+  }
+
+private:
+  double _x, _y, _z, _roll, _pitch, _yaw;
+};
+
+//================================================================
+/*
+* class MengeHandle, provides a wrap-up class handle for actual menge lib
+* only exposing several menge function interface
+*/
+class MengeHandle : public std::enable_shared_from_this<MengeHandle>
+{
+public:
+
+  static std::shared_ptr<MengeHandle> init_and_make(
+    const std::string& resource_path,
+    const std::string& behavior_file,
+    const std::string& scene_file,
+    const float sim_time_step
+  );
+
+  MengeHandle(const std::string& resource_path,
+    const std::string& behavior_file,
+    const std::string& scene_file,
+    const float sim_time_step = 0.0
+  )
+  : _resource_path(resource_path),
+    _behavior_file(behavior_file),
+    _scene_file(scene_file),
+    _sim_time_step(sim_time_step),
+    _agent_count(0)
+  {
+    _behavior_file = this->_resource_file_path(_behavior_file);
+    _scene_file = this->_resource_file_path(_scene_file);
+  }
+
+  void set_sim_time_step(float sim_time_step);
+  float get_sim_time_step() const;
+  size_t get_agent_count();
+  void sim_step() const; //proceed one-time simulation step in _sim
+  AgentPtr get_agent(size_t id) const;
+
+private:
+  std::string _resource_path;
+  std::string _behavior_file;
+  std::string _scene_file;
+  float _sim_time_step;
+  size_t _agent_count;
+  std::shared_ptr<Menge::Agents::SimulatorInterface> _sim;
+
+  std::string _resource_file_path(const std::string& relative_path) const;
+  bool _load_simulation(); //initialize simulatorinterface
+};
+
+//================================================================
+/*
+* class ModelTypeDatabase
+*/
+class ModelTypeDatabase
+{
+public:
+  struct Record
+  {
+    std::string type_name;
+    std::string file_name;
+    AgentPose3d pose;
+    std::string animation;
+    std::string idle_animation;
+    double animation_speed;
+  };
+
+  using RecordPtr = std::shared_ptr<Record>;
+
+  //Create a new record and returns a reference to the record
+  RecordPtr emplace(std::string type_name, RecordPtr record_ptr);
+  size_t size() const;
+  RecordPtr get(const std::string& type_name) const;
+
+private:
+  std::unordered_map<std::string, RecordPtr> _records;
+};
+
+//================================================================
+/*
+* class CrowdSimInterface
+* provides the relationship between menge agents and gazebo models
+* provides the interface to set position between gazebo models and menge agents
+*/
+class CrowdSimInterface
+{
+public:
+  enum class AnimState
+  {
+    WALK,
+    IDLE,
+  };
+
+  struct Object
+  {
+    AgentPtr agent_ptr;
+    std::string model_name;
+    std::string type_name;
+    bool is_external = false;
+    AnimState current_state;
+    AnimState get_next_state(bool condition);
+  };
+  using ObjectPtr = std::shared_ptr<Object>;
+
+  CrowdSimInterface()
+  : _model_type_db_ptr(std::make_shared<crowd_simulator::ModelTypeDatabase>()),
+    _sdf_loaded(false),
+    _switch_anim_distance_th(0.01),
+    _switch_anim_name({"idle", "stand"})
+  {}
+
+  std::shared_ptr<ModelTypeDatabase> _model_type_db_ptr;
+  rclcpp::Logger logger() const;
+  void init_ros_node(const rclcpp::Node::SharedPtr node);
+
+  bool init_crowd_sim();
+  double get_sim_time_step() const;
+  size_t get_num_objects() const;
+  ObjectPtr get_object_by_id(size_t id) const;
+  void one_step_sim() const;
+  double get_switch_anim_distance_th() const;
+  std::vector<std::string> get_switch_anim_name() const;
+
+  template<typename SdfPtrT>
+  bool read_sdf(SdfPtrT& sdf);
+
+  template<typename IgnMathPose3d>
+  void update_external_agent(
+    size_t id, const IgnMathPose3d& model_pose);
+
+  template<typename IgnMathPose3d>
+  void update_external_agent(
+    const AgentPtr agent_ptr, const IgnMathPose3d& model_pose);
+
+  template<typename IgnMathPose3d>
+  IgnMathPose3d get_agent_pose(
+    size_t id, double delta_sim_time);
+
+  template<typename IgnMathPose3d>
+  IgnMathPose3d get_agent_pose(
+    const AgentPtr agent_ptr, double delta_sim_time);
+
+private:
+  bool _sdf_loaded;
+  double _switch_anim_distance_th;
+  std::vector<std::string> _switch_anim_name;
+  std::vector<ObjectPtr> _objects; //Database, use id to access ObjectPtr
+  std::shared_ptr<MengeHandle> _menge_handle;
+  float _sim_time_step;
+  std::string _resource_path;
+  std::string _behavior_file;
+  std::string _scene_file;
+  std::vector<std::string> _external_agents;
+  rclcpp::Node::SharedPtr _ros_node;
+
+  template<typename SdfPtrT>
+  bool _load_model_init_pose(
+    SdfPtrT& model_type_element, AgentPose3d& result) const;
+
+  bool _spawn_object();
+  void _add_object(
+    AgentPtr agent_ptr, const std::string& model_name,
+    const std::string& type_name, bool is_external);
+};
+
+template<typename SdfPtrT>
+bool CrowdSimInterface::read_sdf(
+  SdfPtrT& sdf)
+{
+  if (!sdf->template HasElement("resource_path"))
+  {
+    char* menge_resource_path;
+    menge_resource_path = getenv("MENGE_RESOURCE_PATH");
+    RCLCPP_WARN(logger(),
+      "No resource path provided! <env MENGE_RESOURCE_PATH> " +
+      std::string(menge_resource_path) + " will be used.");
+    _resource_path = std::string(menge_resource_path);
+  }
+  else
+  {
+    _resource_path =
+      sdf->template GetElementImpl("resource_path")->template Get<std::string>();
+  }
+
+  if (!sdf->template HasElement("behavior_file"))
+  {
+    RCLCPP_ERROR(logger(),
+      "No behavior file found! <behavior_file> Required!");
+    return false;
+  }
+  _behavior_file =
+    sdf->template GetElementImpl("behavior_file")->template Get<std::string>();
+
+  if (!sdf->template HasElement("scene_file"))
+  {
+    RCLCPP_ERROR(logger(),
+      "No scene file found! <scene_file> Required!");
+    return false;
+  }
+  _scene_file =
+    sdf->template GetElementImpl("scene_file")->template Get<std::string>();
+
+  if (!sdf->template HasElement("update_time_step"))
+  {
+    RCLCPP_ERROR(logger(),
+      "No update_time_step found! <update_time_step> Required!");
+    return false;
+  }
+  _sim_time_step =
+    sdf->template GetElementImpl("update_time_step")->template Get<float>();
+
+  if (!sdf->template HasElement("model_type"))
+  {
+    RCLCPP_ERROR(logger(),
+      "No model type for agents found! <model_type> element Required!");
+    return false;
+  }
+  auto model_type_element = sdf->template GetElementImpl("model_type");
+  while (model_type_element)
+  {
+    std::string s;
+    if (!model_type_element->template Get<std::string>("typename", s, ""))
+    {
+      RCLCPP_ERROR(logger(),
+        "No model type name configured in <model_type>! <typename> Required");
+      return false;
+    }
+
+    auto model_type_ptr = this->_model_type_db_ptr->emplace(s,
+        std::make_shared<ModelTypeDatabase::Record>() ); //unordered_map
+    model_type_ptr->type_name = s;
+
+    if (!model_type_element->template Get<std::string>("filename",
+      model_type_ptr->file_name, ""))
+    {
+      RCLCPP_ERROR(logger(),
+        "No actor skin configured in <model_type>! <filename> Required");
+      return false;
+    }
+
+    if (!model_type_element->template Get<std::string>("animation",
+      model_type_ptr->animation, ""))
+    {
+      RCLCPP_ERROR(logger(),
+        "No animation configured in <model_type>! <animation> Required");
+      return false;
+    }
+
+    if (!model_type_element->template Get<double>("animation_speed",
+      model_type_ptr->animation_speed, 0.0))
+    {
+      RCLCPP_ERROR(
+        logger(),
+        "No animation speed configured in <model_type>! <animation_speed> Required");
+      return false;
+    }
+
+    if (!model_type_element->template HasElement("initial_pose"))
+    {
+      RCLCPP_ERROR(
+        logger(),
+        "No model initial pose configured in <model_type>! <initial_pose> Required [" + s +
+        "]");
+      return false;
+    }
+    if (!_load_model_init_pose(model_type_element, model_type_ptr->pose))
+    {
+      RCLCPP_ERROR(
+        logger(),
+        "Error loading model initial pose in <model_type>! Check <initial_pose> in [" + s +
+        "]");
+      return false;
+    }
+
+    model_type_element = model_type_element->template GetNextElement(
+      "model_type");
+  }
+
+  if (!sdf->template HasElement("external_agent"))
+  {
+    RCLCPP_ERROR(
+      logger(),
+      "No external agent provided. <external_agent> is needed with a unique name defined above.");
+  }
+  auto external_agent_element = sdf->template GetElementImpl("external_agent");
+  while (external_agent_element)
+  {
+    auto ex_agent_name = external_agent_element->template Get<std::string>();
+    RCLCPP_INFO(logger(),
+      "Added external agent: [ " + ex_agent_name + " ].");
+    _external_agents.emplace_back(ex_agent_name); //just store the name
+    external_agent_element = external_agent_element->template GetNextElement(
+      "external_agent");
+  }
+
+  _sdf_loaded = true;
+  return true;
+}
+
+template<typename SdfPtrT>
+bool CrowdSimInterface::_load_model_init_pose(
+  SdfPtrT& model_type_element, AgentPose3d& result) const
+{
+  std::string pose_str;
+  if (model_type_element->template Get<std::string>(
+      "initial_pose", pose_str, ""))
+  {
+    std::regex ws_re("\\s+"); //whitespace
+    std::vector<std::string> parts(
+      std::sregex_token_iterator(pose_str.begin(), pose_str.end(), ws_re, -1),
+      std::sregex_token_iterator());
+
+    if (parts.size() != 6)
+    {
+      RCLCPP_ERROR(
+        logger(),
+        "Error loading <initial_pose> in <model_type>, 6 floats (x, y, z, pitch, roll, yaw) expected.");
+      return false;
+    }
+
+    result.x(std::stod(parts[0]) );
+    result.y(std::stod(parts[1]) );
+    result.z(std::stod(parts[2]) );
+    result.pitch(std::stod(parts[3]) );
+    result.roll(std::stod(parts[4]) );
+    result.yaw(std::stod(parts[5]) );
+  }
+  return true;
+}
+
+template<typename IgnMathPose3d>
+IgnMathPose3d CrowdSimInterface::get_agent_pose(
+  size_t id, double delta_sim_time)
+{
+  assert(id < get_num_objects());
+  auto agent_ptr = _objects[id]->agent_ptr;
+  return get_agent_pose<IgnMathPose3d>(agent_ptr, delta_sim_time);
+}
+
+template<typename IgnMathPose3d>
+IgnMathPose3d CrowdSimInterface::get_agent_pose(
+  const AgentPtr agent_ptr, double delta_sim_time)
+{
+  //calculate future position in delta_sim_time. currently in 2d
+  assert(agent_ptr);
+  double px = static_cast<double>(agent_ptr->_pos.x()) +
+    static_cast<double>(agent_ptr->_vel.x()) * delta_sim_time;
+  double py = static_cast<double>(agent_ptr->_pos.y()) +
+    static_cast<double>(agent_ptr->_vel.y()) * delta_sim_time;
+
+  double x_rot = static_cast<double>(agent_ptr->_orient.x());
+  double y_rot = static_cast<double>(agent_ptr->_orient.y());
+
+  IgnMathPose3d agent_pose(px, py, 0, 0, 0, std::atan2(y_rot, x_rot));
+  return agent_pose;
+}
+
+template<typename IgnMathPose3d>
+void CrowdSimInterface::update_external_agent(
+  size_t id, const IgnMathPose3d& model_pose)
+{
+  assert(id < get_num_objects());
+  auto agent_ptr = _objects[id]->agent_ptr;
+  update_external_agent<IgnMathPose3d>(agent_ptr, model_pose);
+}
+
+template<typename IgnMathPose3d>
+void CrowdSimInterface::update_external_agent(
+  const AgentPtr agent_ptr, const IgnMathPose3d& model_pose)
+{
+  assert(agent_ptr);
+  agent_ptr->_pos.setX(model_pose.Pos().X());
+  agent_ptr->_pos.setY(model_pose.Pos().Y());
+}
+
+} // namespace crowd_simulator
+
+#endif // CROWD_SIMULATION_COMMON__CROWD_SIMULATOR_COMMON_HPP
\ No newline at end of file
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp
new file mode 100644
index 0000000..c7ae844
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp
@@ -0,0 +1,265 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_SIM_COMMON__DOOR_COMMON_HPP
+#define BUILDING_SIM_COMMON__DOOR_COMMON_HPP
+
+#include <rclcpp/rclcpp.hpp>
+#include <rclcpp/logger.hpp>
+
+#include <rmf_door_msgs/msg/door_mode.hpp>
+#include <rmf_door_msgs/msg/door_state.hpp>
+#include <rmf_door_msgs/msg/door_request.hpp>
+
+#include "utils.hpp"
+
+#include <vector>
+#include <unordered_map>
+#include <unordered_set>
+
+namespace building_sim_common {
+
+using DoorMode = rmf_door_msgs::msg::DoorMode;
+using DoorState = rmf_door_msgs::msg::DoorState;
+using DoorRequest = rmf_door_msgs::msg::DoorRequest;
+
+//==============================================================================
+class DoorCommon
+{
+
+public:
+
+  struct DoorUpdateRequest
+  {
+    std::string joint_name;
+    double position;
+    double velocity;
+  };
+
+  struct DoorUpdateResult
+  {
+    std::string joint_name;
+    double velocity;
+    double fmax;
+  };
+
+  template<typename SdfPtrT>
+  static std::shared_ptr<DoorCommon> make(
+    const std::string& door_name,
+    rclcpp::Node::SharedPtr node,
+    SdfPtrT& sdf);
+
+  rclcpp::Logger logger() const;
+
+  std::vector<std::string> joint_names() const;
+
+  MotionParams& params();
+
+  std::vector<DoorUpdateResult> update(const double time,
+    const std::vector<DoorUpdateRequest>& request);
+
+private:
+
+  struct DoorElement
+  {
+    double closed_position;
+    double open_position;
+    double current_position;
+    double current_velocity;
+
+    DoorElement() {}
+
+    DoorElement(
+      const double lower_limit,
+      const double upper_limit,
+      const bool flip_direction = false)
+    : current_position(0.0),
+      current_velocity(0.0)
+    {
+      if (flip_direction)
+      {
+        closed_position = lower_limit;
+        open_position = upper_limit;
+      }
+      else
+      {
+        closed_position = upper_limit;
+        open_position = lower_limit;
+      }
+    }
+  };
+
+  // Map joint name to its DoorElement
+  using Doors = std::unordered_map<std::string, DoorElement>;
+
+  DoorMode requested_mode() const;
+
+  void publish_state(const uint32_t door_value, const rclcpp::Time& time);
+
+  double calculate_target_velocity(
+    const double target,
+    const double current_position,
+    const double current_velocity,
+    const double dt);
+
+  DoorCommon(const std::string& door_name,
+    rclcpp::Node::SharedPtr node,
+    const MotionParams& params,
+    const Doors& doors);
+
+  bool all_doors_open();
+
+  bool all_doors_closed();
+
+  rclcpp::Node::SharedPtr _ros_node;
+  rclcpp::Publisher<DoorState>::SharedPtr _door_state_pub;
+  rclcpp::Subscription<DoorRequest>::SharedPtr _door_request_sub;
+
+  DoorState _state;
+  DoorRequest _request;
+
+  MotionParams _params;
+
+  double _last_update_time = 0.0;
+  // random start time offset to prevent state message crossfire
+  double _last_pub_time = ((double) std::rand()) / ((double) (RAND_MAX));
+
+  bool _initialized = false;
+
+  // Map of joint_name and corresponding DoorElement
+  Doors _doors;
+};
+
+template<typename SdfPtrT>
+std::shared_ptr<DoorCommon> DoorCommon::make(
+  const std::string& door_name,
+  rclcpp::Node::SharedPtr node,
+  SdfPtrT& sdf)
+{
+  // We work with a clone to avoid const correctness issues with
+  // get_sdf_param functions in utils.hpp
+  auto sdf_clone = sdf->Clone();
+
+  MotionParams params;
+  get_sdf_param_if_available<double>(sdf_clone, "v_max_door", params.v_max);
+  get_sdf_param_if_available<double>(sdf_clone, "a_max_door", params.a_max);
+  get_sdf_param_if_available<double>(sdf_clone, "a_nom_door", params.a_nom);
+  get_sdf_param_if_available<double>(sdf_clone, "dx_min_door", params.dx_min);
+  get_sdf_param_if_available<double>(sdf_clone, "f_max_door", params.f_max);
+
+  auto door_element = sdf_clone;
+  std::string left_door_joint_name;
+  std::string right_door_joint_name;
+  std::string door_type;
+
+  // Get the joint names and door type
+  if (!get_element_required(sdf_clone, "door", door_element) ||
+    !get_sdf_attribute_required<std::string>(
+      door_element, "left_joint_name", left_door_joint_name) ||
+    !get_sdf_attribute_required<std::string>(
+      door_element, "right_joint_name", right_door_joint_name) ||
+    !get_sdf_attribute_required<std::string>(
+      door_element, "type", door_type))
+  {
+    RCLCPP_ERROR(node->get_logger(),
+      " -- Missing required parameters for [%s] plugin",
+      door_name.c_str());
+    return nullptr;
+  }
+
+  if ((left_door_joint_name == "empty_joint" &&
+    right_door_joint_name == "empty_joint") ||
+    (left_door_joint_name.empty() && right_door_joint_name.empty()))
+  {
+    RCLCPP_ERROR(node->get_logger(),
+      " -- Both door joint names are missing for [%s] plugin, at least one"
+      " is required", door_name.c_str());
+    return nullptr;
+  }
+
+  std::unordered_set<std::string> joint_names;
+  if (!left_door_joint_name.empty() && left_door_joint_name != "empty_joint")
+    joint_names.insert(left_door_joint_name);
+  if (!right_door_joint_name.empty() && right_door_joint_name != "empty_joint")
+    joint_names.insert(right_door_joint_name);
+
+  Doors doors;
+
+  auto extract_door = [&](SdfPtrT& joint_sdf)
+    {
+      auto joint_sdf_clone = joint_sdf->Clone();
+      std::string joint_name;
+      get_sdf_attribute_required<std::string>(
+        joint_sdf_clone, "name", joint_name);
+      const auto it = joint_names.find(joint_name);
+      if (it != joint_names.end())
+      {
+        auto element = joint_sdf_clone;
+        get_element_required(joint_sdf_clone, "axis", element);
+        get_element_required(element, "limit", element);
+        double lower_limit = -1.57;
+        double upper_limit = 0.0;
+        get_sdf_param_if_available<double>(element, "lower", lower_limit);
+        get_sdf_param_if_available<double>(element, "upper", upper_limit);
+        DoorCommon::DoorElement door_element;
+        if (joint_name == right_door_joint_name)
+          door_element =
+            DoorCommon::DoorElement{lower_limit, upper_limit, true};
+        else if (joint_name == left_door_joint_name)
+          door_element = DoorCommon::DoorElement{lower_limit, upper_limit};
+        doors.insert({joint_name, door_element});
+      }
+    };
+
+  // Get the joint limits from parent sdf
+  auto parent = sdf->GetParent();
+  if (!parent)
+  {
+    RCLCPP_ERROR(node->get_logger(),
+      "Unable to access parent sdf to retrieve joint limits");
+    return nullptr;
+  }
+
+  auto joint_element = parent->GetElement("joint");
+  if (!joint_element)
+  {
+    RCLCPP_ERROR(node->get_logger(),
+      "Parent sdf missing required joint element");
+    return nullptr;
+  }
+
+  extract_door(joint_element);
+  // Find next joint element if present
+  while (joint_element)
+  {
+    extract_door(joint_element);
+    joint_element = joint_element->GetNextElement("joint");
+  }
+
+  std::shared_ptr<DoorCommon> door_common(new DoorCommon(
+      door_name,
+      node,
+      params,
+      doors));
+
+  return door_common;
+
+}
+
+} // namespace building_sim_common
+
+#endif // BUILDING_SIM_COMMON__DOOR_COMMON_HPP
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp
new file mode 100644
index 0000000..5212bc8
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_SIM_COMMON__LIFT_COMMON_HPP
+#define BUILDING_SIM_COMMON__LIFT_COMMON_HPP
+
+#include <rclcpp/rclcpp.hpp>
+#include <rclcpp/logger.hpp>
+
+#include <rmf_lift_msgs/msg/lift_state.hpp>
+#include <rmf_lift_msgs/msg/lift_request.hpp>
+#include <rmf_door_msgs/msg/door_mode.hpp>
+#include <rmf_door_msgs/msg/door_state.hpp>
+#include <rmf_door_msgs/msg/door_request.hpp>
+
+#include "utils.hpp"
+
+#include <vector>
+#include <utility>
+#include <unordered_map>
+
+namespace building_sim_common {
+
+using LiftState = rmf_lift_msgs::msg::LiftState;
+using LiftRequest = rmf_lift_msgs::msg::LiftRequest;
+using DoorRequest = rmf_door_msgs::msg::DoorRequest;
+using DoorState = rmf_door_msgs::msg::DoorState;
+using DoorMode = rmf_door_msgs::msg::DoorMode;
+
+//==============================================================================
+class LiftCommon
+{
+
+public:
+
+  struct LiftUpdateResult
+  {
+    double velocity;
+    double fmax;
+  };
+
+  template<typename SdfPtrT>
+  static std::unique_ptr<LiftCommon> make(
+    const std::string& lift_name,
+    rclcpp::Node::SharedPtr node,
+    SdfPtrT& sdf);
+
+  rclcpp::Logger logger() const;
+
+  LiftUpdateResult update(const double time, const double position,
+    const double velocity);
+
+  std::string get_joint_name() const;
+
+  double get_elevation() const;
+
+  bool motion_state_changed();
+
+private:
+
+  rclcpp::Node::SharedPtr _ros_node;
+  rclcpp::Publisher<LiftState>::SharedPtr _lift_state_pub;
+  rclcpp::Publisher<DoorRequest>::SharedPtr _door_request_pub;
+  rclcpp::Subscription<LiftRequest>::SharedPtr _lift_request_sub;
+  rclcpp::Subscription<DoorState>::SharedPtr _door_state_sub;
+
+  std::string _lift_name;
+  std::string _cabin_joint_name;
+
+  MotionParams _cabin_motion_params;
+  LiftState::_motion_state_type _old_motion_state;
+
+  std::vector<std::string> _floor_names;
+  std::unordered_map<std::string, double> _floor_name_to_elevation;
+  std::unordered_map<std::string,
+    std::vector<std::string>> _floor_name_to_shaft_door_name;
+  std::unordered_map<std::string,
+    std::vector<std::string>> _floor_name_to_cabin_door_name;
+  std::unordered_map<std::string, DoorState::SharedPtr> _shaft_door_states;
+  std::unordered_map<std::string, DoorState::SharedPtr> _cabin_door_states;
+
+  LiftState _lift_state;
+  LiftRequest::UniquePtr _lift_request;
+
+  double _last_update_time = 0.0;
+  // random start time offset to prevent state message crossfire
+  double _last_pub_time = ((double) std::rand()) / ((double) (RAND_MAX));
+
+  void publish_door_request(const double time, std::string door_name,
+    uint32_t door_state);
+
+  LiftCommon(rclcpp::Node::SharedPtr node,
+    const std::string& lift_name,
+    const std::string& joint_name,
+    const MotionParams& cabin_motion_params,
+    const std::vector<std::string>& floor_names,
+    const std::unordered_map<std::string, double>& floor_name_to_elevation,
+    std::unordered_map<
+      std::string, std::vector<std::string>> floor_name_to_shaft_door_name,
+    std::unordered_map<
+      std::string, std::vector<std::string>> floor_name_to_cabin_door_name,
+    std::unordered_map<std::string, DoorState::SharedPtr> shaft_door_states,
+    std::unordered_map<std::string, DoorState::SharedPtr> cabin_door_states,
+    std::string initial_floor_name);
+
+  double get_step_velocity(const double dt, const double position,
+    const double velocity);
+
+  void update_cabin_state(const double position, const double velocity);
+
+  void move_doors(const double time, uint32_t door_mode);
+
+  void open_doors(const double time);
+
+  void close_doors(const double time);
+
+  uint32_t get_door_state(
+    const std::unordered_map<std::string,
+    std::vector<std::string>>& floor_to_door_map,
+    const std::unordered_map<std::string, DoorState::SharedPtr>& door_states);
+
+  void pub_lift_state(const double time);
+
+  void update_lift_door_state();
+
+};
+
+template<typename SdfPtrT>
+std::unique_ptr<LiftCommon> LiftCommon::make(
+  const std::string& lift_name,
+  rclcpp::Node::SharedPtr node,
+  SdfPtrT& sdf)
+{
+  MotionParams cabin_motion_params;
+  std::string joint_name;
+  std::vector<std::string> floor_names;
+  std::unordered_map<std::string, double> floor_name_to_elevation;
+  std::unordered_map<std::string,
+    std::vector<std::string>> floor_name_to_shaft_door_name;
+  std::unordered_map<std::string,
+    std::vector<std::string>> floor_name_to_cabin_door_name;
+  std::unordered_map<std::string, DoorState::SharedPtr> shaft_door_states;
+  std::unordered_map<std::string, DoorState::SharedPtr> cabin_door_states;
+
+
+  auto sdf_clone = sdf->Clone();
+
+  // load lift cabin motion parameters
+  get_sdf_param_if_available<double>(sdf_clone, "v_max_cabin",
+    cabin_motion_params.v_max);
+  get_sdf_param_if_available<double>(sdf_clone, "a_max_cabin",
+    cabin_motion_params.a_max);
+  get_sdf_param_if_available<double>(sdf_clone, "a_nom_cabin",
+    cabin_motion_params.a_nom);
+  get_sdf_param_if_available<double>(sdf_clone, "dx_min_cabin",
+    cabin_motion_params.dx_min);
+  get_sdf_param_if_available<double>(sdf_clone, "f_max_cabin",
+    cabin_motion_params.f_max);
+  if (!get_sdf_param_required(sdf_clone, "cabin_joint_name",
+    joint_name))
+    return nullptr;
+
+  // load the floor name and elevation for each floor
+  auto floor_element = sdf_clone;
+  if (!get_element_required(sdf, "floor", floor_element))
+  {
+    RCLCPP_ERROR(node->get_logger(),
+      " -- Missing required floor element for [%s] plugin",
+      lift_name.c_str());
+    return nullptr;
+  }
+
+  while (floor_element)
+  {
+    std::string floor_name;
+    double floor_elevation;
+    if (!get_sdf_attribute_required<std::string>(floor_element, "name",
+      floor_name) ||
+      !get_sdf_attribute_required<double>(floor_element, "elevation",
+      floor_elevation))
+    {
+      RCLCPP_ERROR(
+        node->get_logger(),
+        " -- Missing required floor name or elevation attributes for [%s] plugin",
+        lift_name.c_str());
+      return nullptr;
+    }
+    floor_names.push_back(floor_name);
+    floor_name_to_elevation.insert({floor_name, floor_elevation});
+
+    auto door_pair_element = floor_element;
+    if (get_element_required(floor_element, "door_pair", door_pair_element))
+    {
+      while (door_pair_element)
+      {
+        std::string shaft_door_name;
+        std::string cabin_door_name;
+        if (!get_sdf_attribute_required<std::string>(door_pair_element,
+          "cabin_door", cabin_door_name) ||
+          !get_sdf_attribute_required<std::string>(door_pair_element,
+          "shaft_door", shaft_door_name))
+        {
+          RCLCPP_ERROR(node->get_logger(),
+            " -- Missing required lift door attributes for [%s] plugin",
+            lift_name.c_str());
+          return nullptr;
+        }
+        floor_name_to_cabin_door_name[floor_name].push_back(cabin_door_name);
+        floor_name_to_shaft_door_name[floor_name].push_back(shaft_door_name);
+        shaft_door_states.insert({shaft_door_name, nullptr});
+        cabin_door_states.insert({cabin_door_name, nullptr});
+
+        door_pair_element = door_pair_element->GetNextElement("door_pair");
+      }
+    }
+    floor_element = floor_element->GetNextElement("floor");
+  }
+
+  assert(!floor_names.empty());
+  std::string initial_floor_name = floor_names[0];
+  get_sdf_param_if_available<std::string>(sdf_clone, "initial_floor",
+    initial_floor_name);
+
+  if (std::find(floor_names.begin(), floor_names.end(), initial_floor_name) ==
+    floor_names.end())
+  {
+    RCLCPP_WARN(
+      node->get_logger(),
+      "Initial floor [%s] is not available, changing to deafult",
+      initial_floor_name.c_str());
+    initial_floor_name = floor_names[0];
+  }
+
+  std::unique_ptr<LiftCommon> lift(new LiftCommon(
+      node,
+      lift_name,
+      joint_name,
+      cabin_motion_params,
+      floor_names,
+      floor_name_to_elevation,
+      floor_name_to_shaft_door_name,
+      floor_name_to_cabin_door_name,
+      shaft_door_states,
+      cabin_door_states,
+      initial_floor_name));
+
+  return lift;
+}
+
+} // namespace building_sim_common
+
+#endif // BUILDING_SIM_COMMON__LIFT_COMMON_HPP
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp
new file mode 100644
index 0000000..3714b13
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_SIM_COMMON__SLOTCAR_COMMON_HPP
+#define BUILDING_SIM_COMMON__SLOTCAR_COMMON_HPP
+
+#include <sstream>
+
+#include <rclcpp/rclcpp.hpp>
+#include <Eigen/Geometry>
+#include <tf2_ros/transform_broadcaster.h>
+
+#include <geometry_msgs/msg/transform_stamped.hpp>
+#include <rmf_fleet_msgs/msg/robot_mode.hpp>
+#include <rmf_fleet_msgs/msg/robot_state.hpp>
+#include <rmf_fleet_msgs/msg/path_request.hpp>
+#include <rmf_fleet_msgs/msg/pause_request.hpp>
+#include <rmf_fleet_msgs/msg/mode_request.hpp>
+#include <building_map_msgs/msg/building_map.hpp>
+
+namespace building_sim_common {
+
+// TODO migrate ign-math-eigen conversions when upgrading to ign-math5
+
+// Edit reference of parameter for template type deduction
+template<typename IgnQuatT>
+inline void convert(const Eigen::Quaterniond& _q, IgnQuatT& quat)
+{
+  quat.W() = _q.w();
+  quat.X() = _q.x();
+  quat.Y() = _q.y();
+  quat.Z() = _q.z();
+}
+
+template<typename IgnVec3T>
+inline void convert(const Eigen::Vector3d& _v, IgnVec3T& vec)
+{
+  vec.X() = _v[0];
+  vec.Y() = _v[1];
+  vec.Z() = _v[2];
+}
+
+template<typename IgnVec3T>
+inline Eigen::Vector3d convert_vec(const IgnVec3T& _v)
+{
+  return Eigen::Vector3d(_v[0], _v[1], _v[2]);
+}
+
+template<typename IgnQuatT>
+inline Eigen::Quaterniond convert_quat(const IgnQuatT& _q)
+{
+  Eigen::Quaterniond quat;
+  quat.w() = _q.W();
+  quat.x() = _q.X();
+  quat.y() = _q.Y();
+  quat.z() = _q.Z();
+
+  return quat;
+}
+
+template<typename IgnPoseT>
+inline auto convert(const Eigen::Isometry3d& _tf)
+{
+  IgnPoseT pose;
+  convert(Eigen::Vector3d(_tf.translation()), pose.Pos());
+  convert(Eigen::Quaterniond(_tf.linear()), pose.Rot());
+
+  return pose;
+}
+
+template<typename IgnPoseT>
+inline Eigen::Isometry3d convert_pose(const IgnPoseT& _pose)
+{
+  Eigen::Isometry3d tf = Eigen::Isometry3d::Identity();
+  tf.translation() = convert_vec(_pose.Pos());
+  tf.linear() = Eigen::Matrix3d(convert_quat(_pose.Rot()));
+
+  return tf;
+}
+
+typedef struct TrajectoryPoint
+{
+  Eigen::Vector3d pos;
+  Eigen::Quaterniond quat;
+  TrajectoryPoint(const Eigen::Vector3d& _pos, const Eigen::Quaterniond& _quat)
+  : pos(_pos), quat(_quat) {}
+} TrajectoryPoint;
+
+class SlotcarCommon
+{
+public:
+  SlotcarCommon();
+
+  rclcpp::Logger logger() const;
+
+  template<typename SdfPtrT>
+  void read_sdf(SdfPtrT& sdf);
+
+  void set_model_name(const std::string& model_name);
+
+  std::string model_name() const;
+
+  void init_ros_node(const rclcpp::Node::SharedPtr node);
+
+  std::pair<double, double> update(const Eigen::Isometry3d& pose,
+    const std::vector<Eigen::Vector3d>& obstacle_positions,
+    const double time);
+
+  bool emergency_stop(const std::vector<Eigen::Vector3d>& obstacle_positions,
+    const Eigen::Vector3d& current_heading);
+
+  std::array<double, 2> calculate_control_signals(const std::array<double,
+    2>& curr_velocities,
+    const std::pair<double, double>& velocities,
+    const double dt) const;
+
+  std::array<double, 2> calculate_joint_control_signals(
+    const std::array<double, 2>& w_tire,
+    const std::pair<double, double>& velocities,
+    const double dt) const;
+
+  std::array<double, 2> calculate_model_control_signals(
+    const std::array<double, 2>& curr_velocities,
+    const std::pair<double, double>& velocities,
+    const double dt) const;
+
+  void charge_state_cb(const std::string& name, bool selected);
+
+  void publish_robot_state(const double time);
+
+private:
+  // Paramters needed for power dissipation and charging calculations
+  // Default values may be overriden using values from sdf file
+  struct PowerParams
+  {
+    double nominal_voltage = 12; // V
+    double nominal_capacity = 24; // Ah
+    double charging_current = 2; // A
+    double mass = 20;
+    double inertia = 10;
+    double friction_coefficient = 0.3;
+    double nominal_power = 10;
+  };
+
+  struct ChargerWaypoint
+  {
+    double x;
+    double y;
+    ChargerWaypoint(double x, double y)
+    : x(x), y(y)
+    {
+    }
+  };
+
+  // Constants for update rate of tf2 and robot_state topic
+  static constexpr float TF2_RATE = 100.0;
+  static constexpr float STATE_TOPIC_RATE = 2.0;
+
+  // Initial distance threshold over which a fleet adapter error is reported
+  static constexpr float INITIAL_DISTANCE_THRESHOLD = 1.0;
+
+  rclcpp::Node::SharedPtr _ros_node;
+
+  double _last_update_time = 0.0;
+  double last_tf2_pub = 0.0;
+  double last_topic_pub = 0.0;
+  std::size_t _sequence = 0;
+
+  std::vector<Eigen::Isometry3d> trajectory;
+  std::size_t _traj_wp_idx;
+
+  rmf_fleet_msgs::msg::PauseRequest pause_request;
+
+  std::vector<rclcpp::Time> _hold_times;
+
+  std::mutex _mutex;
+
+  std::string _model_name;
+  bool _emergency_stop = false;
+  bool _adapter_error = false;
+
+  bool _initialized_pose = false; // True if at least 1 call to update() has been made
+  Eigen::Isometry3d _old_pose; // Pose at previous time step
+  // Assumes robot is stationary upon initialization
+  Eigen::Vector3d _old_lin_vel = Eigen::Vector3d::Zero(); // Linear velocity at previous time step
+  double _old_ang_vel = 0.0; // Angular velocity at previous time step
+  Eigen::Isometry3d _pose; // Pose at current time step
+  int _rot_dir = 1; // Current direction of rotation
+
+  std::unordered_map<std::string, double> _level_to_elevation;
+  bool _initialized_levels = false;
+
+  std::shared_ptr<tf2_ros::TransformBroadcaster> _tf2_broadcaster;
+  rclcpp::Publisher<rmf_fleet_msgs::msg::RobotState>::SharedPtr _robot_state_pub;
+
+  rclcpp::Subscription<rmf_fleet_msgs::msg::PathRequest>::SharedPtr _traj_sub;
+  rclcpp::Subscription<rmf_fleet_msgs::msg::PauseRequest>::SharedPtr _pause_sub;
+  rclcpp::Subscription<rmf_fleet_msgs::msg::ModeRequest>::SharedPtr _mode_sub;
+  rclcpp::Subscription<building_map_msgs::msg::BuildingMap>::SharedPtr
+    _building_map_sub;
+
+  rmf_fleet_msgs::msg::RobotMode _current_mode;
+
+  std::string _current_task_id;
+  std::vector<rmf_fleet_msgs::msg::Location> _remaining_path;
+
+  // Vehicle dynamic constants
+  // TODO(MXG): Consider fetching these values from model data
+  // Radius of a tire
+  double _tire_radius = 0.1;
+  // Distance of a tire from the origin
+  double _base_width = 0.52;
+
+  double _nominal_drive_speed = 0.5;         // nominal robot velocity (m/s)
+  double _nominal_drive_acceleration = 0.05; // nominal robot forward acceleration (m/s^2)
+  double _max_drive_acceleration = 0.1;      // maximum robot forward acceleration (m/s^2)
+
+  double _nominal_turn_speed = M_PI / 8.0;         // nominal robot turning speed (half a rotation per 8 seconds)
+  double _nominal_turn_acceleration = M_PI / 10.0; // nominal robot turning acceleration (rad/s^2)
+
+  double _max_turn_acceleration = M_PI; // maximum robot turning acceleration (rad/s^2)
+
+  double _stop_distance = 1.0;
+  double _stop_radius = 1.0;
+
+  PowerParams _params;
+  bool _enable_charge = true;
+  bool _enable_instant_charge = false;
+  bool _enable_drain = true;
+  // Used for comparing with name argument of charge_state_cb to identify button selected
+  const std::string _enable_charge_str = "_enable_charge";
+  const std::string _enable_instant_charge_str = "_enable_instant_charge";
+  const std::string _enable_drain_str = "_enable_drain";
+  const double _soc_max = 1.0;
+  double _soc = _soc_max;
+  std::unordered_map<std::string, std::vector<ChargerWaypoint>>
+  _charger_waypoints;
+  // Straight line distance to charging waypoint within which charging can occur
+  static constexpr double _charger_dist_thres = 0.3;
+
+  bool _docking = false;
+
+  std::string get_level_name(const double z) const;
+
+  double compute_change_in_rotation(
+    const Eigen::Vector3d& heading_vec,
+    const Eigen::Vector3d& dpos,
+    const Eigen::Vector3d* traj_vec = nullptr,
+    double* const dir = nullptr) const;
+
+  void publish_tf2(const rclcpp::Time& t);
+
+  void publish_state_topic(const rclcpp::Time& t);
+
+  bool path_request_valid(
+    const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg);
+
+  void path_request_cb(const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg);
+
+  void pause_request_cb(const rmf_fleet_msgs::msg::PauseRequest::SharedPtr msg);
+
+  void mode_request_cb(const rmf_fleet_msgs::msg::ModeRequest::SharedPtr msg);
+
+  void map_cb(const building_map_msgs::msg::BuildingMap::SharedPtr msg);
+
+  bool near_charger(const Eigen::Isometry3d& pose) const;
+
+  double compute_charge(const double run_time) const;
+
+  double compute_discharge(
+    const Eigen::Vector3d lin_vel, const double ang_vel,
+    const Eigen::Vector3d lin_acc, const double ang_acc,
+    const double run_time) const;
+};
+
+template<typename SdfPtrT, typename valueT>
+bool get_element_val_if_present(
+  SdfPtrT& _sdf,
+  const std::string& _element_name,
+  valueT& _val)
+{
+  if (!_sdf->HasElement(_element_name))
+  {
+    return false;
+  }
+  _val = _sdf->template Get<valueT>(_element_name);
+  return true;
+}
+
+template<typename SdfPtrT>
+void SlotcarCommon::read_sdf(SdfPtrT& sdf)
+{
+  get_element_val_if_present<SdfPtrT, double>(sdf, "nominal_drive_speed",
+    this->_nominal_drive_speed);
+  RCLCPP_INFO(logger(),
+    "Setting nominal drive speed to: " +
+    std::to_string(_nominal_drive_speed));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "nominal_drive_acceleration", this->_nominal_drive_acceleration);
+  RCLCPP_INFO(logger(),
+    "Setting nominal drive acceleration to: " + std::to_string(
+      _nominal_drive_acceleration));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "max_drive_acceleration", this->_max_drive_acceleration);
+  RCLCPP_INFO(logger(),
+    "Setting max drive acceleration to: "
+    + std::to_string(_max_drive_acceleration));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "nominal_turn_speed", this->_nominal_turn_speed);
+  RCLCPP_INFO(logger(),
+    "Setting nominal turn speed to:"
+    + std::to_string(_nominal_turn_speed));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "nominal_turn_acceleration", this->_nominal_turn_acceleration);
+  RCLCPP_INFO(logger(), "Setting nominal turn acceleration to:" + std::to_string(
+      _nominal_turn_acceleration));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "max_turn_acceleration", this->_max_turn_acceleration);
+  RCLCPP_INFO(logger(),
+    "Setting max turn acceleration to:"
+    + std::to_string(_max_turn_acceleration));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "stop_distance", this->_stop_distance);
+  RCLCPP_INFO(logger(),
+    "Setting stop distance to:" + std::to_string(_stop_distance));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "stop_radius", this->_stop_radius);
+  RCLCPP_INFO(logger(),
+    "Setting stop radius to:" + std::to_string(_stop_radius));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "tire_radius", this->_tire_radius);
+  RCLCPP_INFO(logger(),
+    "Setting tire radius to:" + std::to_string(_tire_radius));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "base_width", this->_base_width);
+  RCLCPP_INFO(logger(),
+    "Setting base width to: " + std::to_string(_base_width));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "nominal_voltage", this->_params.nominal_voltage);
+  RCLCPP_INFO(logger(),
+    "Setting nominal voltage to: " + std::to_string(_params.nominal_voltage));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "nominal_capacity", this->_params.nominal_capacity);
+  RCLCPP_INFO(logger(),
+    "Setting nominal capacity to: " + std::to_string(_params.nominal_capacity));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "charging_current", this->_params.charging_current);
+  RCLCPP_INFO(logger(),
+    "Setting charging current to: " + std::to_string(_params.charging_current));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "mass", this->_params.mass);
+  RCLCPP_INFO(logger(), "Setting mass to: " + std::to_string(_params.mass));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "inertia", this->_params.inertia);
+  RCLCPP_INFO(logger(),
+    "Setting inertia to: " + std::to_string(_params.inertia));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "friction_coefficient", this->_params.friction_coefficient);
+  RCLCPP_INFO(logger(),
+    "Setting friction coefficient to: "
+    + std::to_string(_params.friction_coefficient));
+
+  get_element_val_if_present<SdfPtrT, double>(sdf,
+    "nominal_power", this->_params.nominal_power);
+  RCLCPP_INFO(logger(),
+    "Setting nominal power to: " + std::to_string(_params.nominal_power));
+
+  // Charger Waypoint coordinates are in child element of top level world element
+  if (sdf->GetParent() && sdf->GetParent()->GetParent())
+  {
+    auto parent = sdf->GetParent()->GetParent();
+    if (parent->HasElement("rmf_charger_waypoints"))
+    {
+      auto waypoints = parent->GetElement("rmf_charger_waypoints");
+      if (waypoints->HasElement("rmf_vertex"))
+      {
+        auto waypoint = waypoints->GetElement("rmf_vertex");
+        while (waypoint)
+        {
+          if (waypoint->HasAttribute("x") && waypoint->HasAttribute("y") &&
+            waypoint->HasAttribute("level"))
+          {
+            std::string lvl_name;
+            double x, y;
+            waypoint->GetAttribute("x")->Get(x);
+            waypoint->GetAttribute("y")->Get(y);
+            waypoint->GetAttribute("level")->Get(lvl_name);
+            _charger_waypoints[lvl_name].push_back(ChargerWaypoint(x, y));
+          }
+          waypoint = waypoint->GetNextElement("rmf_vertex");
+        }
+      }
+    }
+    else
+    {
+      RCLCPP_INFO(logger(), "No charger waypoints found.");
+    }
+  }
+
+  RCLCPP_INFO(logger(), "Setting name to: " + _model_name);
+}
+} // namespace building_sim_common
+
+#endif // BUILDING_SIM_COMMON__SLOTCAR_COMMON_HPP
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp
new file mode 100644
index 0000000..c1379fc
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp
@@ -0,0 +1,234 @@
+#ifndef SRC__BUILDING_SIM_COMMON__UTILS_HPP
+#define SRC__BUILDING_SIM_COMMON__UTILS_HPP
+
+#include <cmath>
+#include <iostream>
+
+namespace building_sim_common {
+
+// TODO(MXG): Refactor the use of this function to replace it with
+// compute_desired_rate_of_change()
+double compute_ds(
+  double s_target,
+  double v_actual,
+  double v_max,
+  double accel_nom,
+  double accel_max,
+  double dt);
+
+struct MotionParams
+{
+  double v_max = 0.2;
+  double a_max = 0.1;
+  double a_nom = 0.08;
+  double dx_min = 0.01;
+  double f_max = 10000000.0;
+};
+
+//==============================================================================
+double compute_ds(
+  double s_target,
+  double v_actual,
+  const double v_max,
+  const double accel_nom,
+  const double accel_max,
+  const double dt)
+{
+  double sign = 1.0;
+  if (s_target < 0.0)
+  {
+    // Limits get confusing when we need to go backwards, so we'll flip signs
+    // here so that we pretend the target is forwards
+    s_target *= -1.0;
+    v_actual *= -1.0;
+    sign = -1.0;
+  }
+
+  // We should try not to shoot past the targstd::vector<event::ConnectionPtr> connections;et
+  double next_s = s_target / dt;
+
+  // Test velocity limit
+  next_s = std::min(next_s, v_max);
+
+  // Test acceleration limit
+  next_s = std::min(next_s, accel_nom * dt + v_actual);
+
+  if (v_actual > 0.0 && s_target > 0.0)
+  {
+    // This is what our deceleration should be if we want to begin a constant
+    // deceleration from now until we reach the goal
+    double deceleration = pow(v_actual, 2) / s_target;
+    deceleration = std::min(deceleration, accel_max);
+
+    if (accel_nom <= deceleration)
+    {
+      // If the smallest constant deceleration for reaching the goal is
+      // greater than
+      next_s = -deceleration * dt + v_actual;
+    }
+  }
+
+  // Flip the sign the to correct direction before returning the value
+  return sign * next_s;
+}
+
+//==============================================================================
+double compute_desired_rate_of_change(
+  double _s_target,
+  double _v_actual,
+  const MotionParams& _motion_params,
+  const double _dt)
+{
+  double sign = 1.0;
+  if (_s_target < 0.0)
+  {
+    // Limits get confusing when we need to go backwards, so we'll flip signs
+    // here so that we pretend the target is forwards
+    _s_target *= -1.0;
+    _v_actual *= -1.0;
+    sign = -1.0;
+  }
+
+  // We should try not to shoot past the target
+  double v_next = _s_target / _dt;
+
+  // Test velocity limit
+  v_next = std::min(v_next, _motion_params.v_max);
+
+  // Test acceleration limit
+  v_next = std::min(v_next, _motion_params.a_nom * _dt + _v_actual);
+
+  if (_v_actual > 0.0 && _s_target > 0.0)
+  {
+    // This is what our deceleration should be if we want to begin a constant
+    // deceleration from now until we reach the goal
+    double deceleration = pow(_v_actual, 2) / (2.0 * _s_target);
+    deceleration = std::min(deceleration, _motion_params.a_max);
+
+    if (_motion_params.a_nom <= deceleration)
+    {
+      // If the smallest constant deceleration for reaching the goal is
+      // greater than the nominal acceleration, then we should begin
+      // decelerating right away so that we can smoothly reach the goal while
+      // decelerating as close to the nominal acceleration as possible.
+      v_next = -deceleration * _dt + _v_actual;
+    }
+  }
+
+  // Flip the sign the to correct direction before returning the value
+  return sign * v_next;
+}
+
+//==============================================================================
+template<typename SdfPtrT, typename SdfElementPtrT>
+bool get_element_required(
+  SdfPtrT& _sdf,
+  const std::string& _element_name,
+  SdfElementPtrT& _element)
+{
+  if (!_sdf->HasElement(_element_name))
+  {
+    std::cerr << "Element [" << _element_name << "] not found" << std::endl;
+    return false;
+  }
+  // using GetElementImpl() because for sdf::v9 GetElement() is not const
+  _element = _sdf->GetElementImpl(_element_name);
+  return true;
+}
+
+/*
+double compute_desired_rate_of_change(
+    double _s_target,
+    double _v_actual,
+    const MotionParams& _motion_params,
+    const double _dt);
+
+bool get_element_required(
+    const sdf::ElementPtr& _sdf,
+    const std::string& _element_name,
+    sdf::ElementPtr& _element);
+*/
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+template<typename T, typename SdfPtrT>
+bool get_sdf_attribute_required(SdfPtrT& sdf, const std::string& attribute_name,
+  T& value)
+{
+  if (sdf->HasAttribute(attribute_name))
+  {
+    if (sdf->GetAttribute(attribute_name)->Get(value))
+    {
+      std::cout << "Using specified attribute value [" << value
+                << "] for property [" << attribute_name << "]"
+                << std::endl;
+      return true;
+    }
+    else
+    {
+      std::cerr << "Failed to parse sdf attribute for [" << attribute_name
+                << "]" << std::endl;
+    }
+  }
+  else
+  {
+    std::cerr << "Attribute [" << attribute_name << "] not found" << std::endl;
+  }
+
+  return false;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+template<typename T, typename SdfPtrT>
+bool get_sdf_param_required(SdfPtrT& sdf, const std::string& parameter_name,
+  T& value)
+{
+  if (sdf->HasElement(parameter_name))
+  {
+    if (sdf->GetElement(parameter_name)->GetValue()->Get(value))
+    {
+      std::cout << "Using specified value [" << value << "] for property ["
+                << parameter_name << "]" << std::endl;
+      return true;
+    }
+    else
+    {
+      std::cerr << "Failed to parse sdf value for [" << parameter_name << "]"
+                <<std::endl;
+    }
+  }
+  else
+  {
+    std::cerr << "Property [" << parameter_name << "] not found" << std::endl;
+  }
+
+  return false;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////
+template<typename T, typename SdfPtrT>
+void get_sdf_param_if_available(SdfPtrT& sdf, const std::string& parameter_name,
+  T& value)
+{
+  if (sdf->HasElement(parameter_name))
+  {
+    if (sdf->GetElement(parameter_name)->GetValue()->Get(value))
+    {
+      std::cout << "Using specified value [" << value << "] for property ["
+                << parameter_name << "]" << std::endl;
+    }
+    else
+    {
+      std::cerr << "Failed to parse sdf value for [" << parameter_name
+                << "]" << std::endl;
+    }
+  }
+  else
+  {
+    std::cout << "Using default value [" << value << "] for property ["
+              << parameter_name << "]" << std::endl;
+  }
+}
+
+} // namespace building_sim_common
+
+#endif // SRC__BUILDING_SIM_COMMON__UTILS_HPP
diff --git a/building_sim_plugins/building_plugins_common/package.xml b/building_sim_plugins/building_plugins_common/package.xml
new file mode 100644
index 0000000..857ea74
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/package.xml
@@ -0,0 +1,38 @@
+<package format="3">
+  <name>building_sim_common</name>
+  <version>1.2.0</version>
+  <description>
+    Common utility functions for Gazebo and ignition building plugins
+  </description>
+  <author>Morgan Quigley</author>
+  <author>Michael Grey</author>
+  <author>Roselle Carmen</author>
+  <author>Aaron Chong</author>
+  <author>Brandon Ong</author>
+  <author>Kevin Ma</author>
+  <author>Rushyendra Maganty</author>
+  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
+  <license>Apache 2.0</license>
+
+  <buildtool_depend>ament_cmake</buildtool_depend>
+
+  <build_depend>eigen</build_depend>
+
+  <depend>rclcpp</depend>
+  <depend>rmf_fleet_msgs</depend>
+  <depend>rmf_door_msgs</depend>
+  <depend>rmf_lift_msgs</depend>
+  <depend>building_map_msgs</depend>
+  <depend>tf2_ros</depend>
+  <depend>geometry_msgs</depend>
+  <depend>std_msgs</depend>
+  <depend>std_srvs</depend>
+  <depend>menge</depend>
+  <depend>libqt5-widgets</depend>
+  <depend>qtbase5-dev</depend>
+
+  <export>
+    <build_type>ament_cmake</build_type>
+  </export>
+
+</package>
diff --git a/building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp b/building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp
new file mode 100644
index 0000000..a5a7c53
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp
@@ -0,0 +1,266 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <fstream>
+#include <cmath>
+
+#include <rclcpp/logger.hpp>
+
+#include <building_sim_common/crowd_simulator_common.hpp>
+
+namespace crowd_simulator {
+
+//================================================================
+std::shared_ptr<MengeHandle> MengeHandle::init_and_make(
+  const std::string& resource_path,
+  const std::string& behavior_file,
+  const std::string& scene_file,
+  const float sim_time_step
+)
+{
+  auto menge_handle = std::make_shared<MengeHandle>(
+    resource_path, behavior_file, scene_file, sim_time_step);
+  if (!menge_handle->_load_simulation())
+  {
+    return nullptr;
+  }
+  return menge_handle;
+}
+
+void MengeHandle::set_sim_time_step(float sim_time_step)
+{
+  this->_sim_time_step = sim_time_step;
+}
+
+float MengeHandle::get_sim_time_step() const
+{
+  return this->_sim_time_step;
+}
+
+size_t MengeHandle::get_agent_count()
+{
+  if (this->_agent_count == 0)
+  {
+    this->_agent_count = this->_sim->getNumAgents();
+  }
+  return this->_agent_count;
+}
+
+void MengeHandle::sim_step() const
+{
+  this->_sim->step();
+}
+
+AgentPtr MengeHandle::get_agent(size_t id) const
+{
+  return AgentPtr(this->_sim->getAgent(id));
+}
+
+std::string MengeHandle::_resource_file_path(const std::string& relative_path)
+const
+{
+  std::string full_path = this->_resource_path + "/" + relative_path;
+  std::cout << "Finding resource file: " << full_path << std::endl;
+  std::ifstream ifile(full_path);
+  if (!static_cast<bool>(ifile))
+  {
+    std::cerr << "File not found! " << full_path << std::endl;
+    assert(static_cast<bool>(ifile));
+  }
+  std::cout << "Found." << std::endl;
+  return full_path;
+}
+
+bool MengeHandle::_load_simulation()
+{
+  Menge::SimulatorDB sim_db;
+  Menge::PluginEngine::CorePluginEngine engine(&sim_db);
+
+  std::cout << "Start CrowdSimulator initializing [Menge]..." << std::endl;
+
+  this->_sim = std::shared_ptr<Menge::Agents::SimulatorInterface>(
+    sim_db.getDBEntry("orca")->getSimulator(
+      this->_agent_count,
+      this->_sim_time_step,
+      0,
+      std::numeric_limits<float>::infinity(),
+      this->_behavior_file,
+      this->_scene_file,
+      "",
+      "",
+      false)
+  );
+
+  if (this->_sim)
+  {
+    std::cout << std::endl << "Crowd Simulator initialized success [Menge]. " <<
+      std::endl;
+    return true;
+  }
+  std::cout <<
+    "Error in provided navmesh. Menge simulator initialized false." <<
+    std::endl;
+  return false;
+}
+
+//============================================
+ModelTypeDatabase::RecordPtr ModelTypeDatabase::emplace(
+  std::string type_name,
+  RecordPtr record_ptr)
+{
+  auto pair = this->_records.emplace(type_name, record_ptr); //return pair<iterator, bool>
+  assert(pair.second);
+  return pair.first->second;
+}
+
+ModelTypeDatabase::RecordPtr ModelTypeDatabase::get(
+  const std::string& type_name)
+const
+{
+  auto it = this->_records.find(type_name);
+  if (it == this->_records.end())
+  {
+    std::cout << "The model type [ " << type_name <<
+      " ] is not defined in scene file!" << std::endl;
+    return nullptr;
+  }
+  return it->second;
+}
+
+size_t ModelTypeDatabase::size() const
+{
+  return this->_records.size();
+}
+
+//================================================================
+
+rclcpp::Logger CrowdSimInterface::logger() const
+{
+  return rclcpp::get_logger("crowdsim");
+}
+
+void CrowdSimInterface::init_ros_node(const rclcpp::Node::SharedPtr node)
+{
+  _ros_node = std::move(node);
+}
+
+bool CrowdSimInterface::init_crowd_sim()
+{
+  _menge_handle = MengeHandle::init_and_make(
+    _resource_path,
+    _behavior_file,
+    _scene_file,
+    _sim_time_step);
+
+  if (!_sdf_loaded)
+  {
+    RCLCPP_ERROR(
+      logger(),
+      "Please load the sdf before initialize the crowd_sim interface!");
+    return false;
+  }
+  _spawn_object();
+  return true;
+}
+
+double CrowdSimInterface::get_sim_time_step() const
+{
+  return static_cast<double>(_sim_time_step);
+}
+
+bool CrowdSimInterface::_spawn_object()
+{
+  //External models are loaded first in scene file
+  size_t external_count = _external_agents.size();
+  size_t total_agent_count = _menge_handle->get_agent_count();
+
+  //external model must be included in scene file
+  assert(external_count <= total_agent_count);
+
+  for (size_t i = 0; i < external_count; ++i)
+  {
+    auto agent_ptr = _menge_handle->get_agent(i);
+    agent_ptr->_external = true;
+    _add_object(agent_ptr, _external_agents[i], "0", true);
+  }
+
+  for (size_t i = external_count; i < total_agent_count; ++i)
+  {
+    auto agent_ptr = this->_menge_handle->get_agent(i);
+    agent_ptr->_external = false;
+    std::string model_name = "agent" + std::to_string(i);
+    _add_object(agent_ptr, model_name, agent_ptr->_typeName, false);
+  }
+  return true;
+}
+
+void CrowdSimInterface::_add_object(AgentPtr agent_ptr,
+  const std::string& model_name,
+  const std::string& type_name,
+  bool is_external = false)
+{
+  assert(agent_ptr);
+  // must provide a model name in gazebo if it's an external agent
+  if (is_external)
+  {
+    assert(!model_name.empty());
+  }
+  _objects.emplace_back(
+    new Object{agent_ptr, model_name, type_name, is_external,
+      AnimState::WALK});
+}
+
+size_t CrowdSimInterface::get_num_objects() const
+{
+  return _objects.size();
+}
+
+CrowdSimInterface::ObjectPtr CrowdSimInterface::get_object_by_id(size_t id)
+const
+{
+  assert(id < _objects.size());
+  return _objects[id];
+}
+
+void CrowdSimInterface::one_step_sim() const
+{
+  _menge_handle->sim_step();
+}
+
+double CrowdSimInterface::get_switch_anim_distance_th() const
+{
+  return _switch_anim_distance_th;
+}
+
+std::vector<std::string> CrowdSimInterface::get_switch_anim_name() const
+{
+  return _switch_anim_name;
+}
+
+//=============================================
+CrowdSimInterface::AnimState CrowdSimInterface::Object::get_next_state(
+  bool condition)
+{
+  if (condition)
+    return AnimState::IDLE;
+  else
+    return AnimState::WALK;
+
+  return current_state;
+}
+
+} //namespace crowd_simulator
diff --git a/building_sim_plugins/building_plugins_common/src/door_common.cpp b/building_sim_plugins/building_plugins_common/src/door_common.cpp
new file mode 100644
index 0000000..5d431f1
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/src/door_common.cpp
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <memory>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/door_common.hpp>
+
+using namespace std::chrono_literals;
+
+namespace building_sim_common {
+
+rclcpp::Logger DoorCommon::logger() const
+{
+  return rclcpp::get_logger("door_" + _state.door_name);
+}
+
+DoorMode DoorCommon::requested_mode() const
+{
+  return _request.requested_mode;
+}
+
+std::vector<std::string> DoorCommon::joint_names() const
+{
+  std::vector<std::string> joint_names;
+  for (const auto& door : _doors)
+    joint_names.push_back(door.first);
+
+  return joint_names;
+}
+
+MotionParams& DoorCommon::params()
+{
+  return _params;
+}
+
+void DoorCommon::publish_state(const uint32_t door_value,
+  const rclcpp::Time& time)
+{
+  if (!_initialized)
+    return;
+
+  _state.current_mode.value = door_value;
+  _state.door_time = time;
+  _door_state_pub->publish(_state);
+}
+
+
+DoorCommon::DoorCommon(const std::string& door_name,
+  rclcpp::Node::SharedPtr node,
+  const MotionParams& params,
+  const Doors& doors)
+: _ros_node(std::move(node)),
+  _params(params),
+  _doors(doors)
+{
+  _state.door_name = door_name;
+  _request.requested_mode.value = DoorMode::MODE_CLOSED;
+
+  _door_state_pub = _ros_node->create_publisher<DoorState>(
+    "/door_states", rclcpp::SystemDefaultsQoS());
+
+  _door_request_sub = _ros_node->create_subscription<DoorRequest>(
+    "/door_requests", rclcpp::SystemDefaultsQoS(),
+    [&](DoorRequest::UniquePtr msg)
+    {
+      if (msg->door_name == _state.door_name)
+        _request = *msg;
+    });
+
+  _initialized = true;
+}
+
+bool DoorCommon::all_doors_open()
+{
+  for (const auto& door : _doors)
+    if (std::abs(door.second.open_position
+      - door.second.current_position) > _params.dx_min)
+      return false;
+
+
+
+  return true;
+}
+
+bool DoorCommon::all_doors_closed()
+{
+  for (const auto& door : _doors)
+    if (std::abs(door.second.closed_position
+      - door.second.current_position) > _params.dx_min)
+      return false;
+
+
+
+  return true;
+}
+
+double DoorCommon::calculate_target_velocity(
+  const double target,
+  const double current_position,
+  const double current_velocity,
+  const double dt)
+{
+  double dx = target - current_position;
+  if (std::abs(dx) < _params.dx_min/2.0)
+    dx = 0.0;
+
+  double door_v = compute_desired_rate_of_change(
+    dx, current_velocity, _params, dt);
+
+  return door_v;
+}
+
+std::vector<DoorCommon::DoorUpdateResult> DoorCommon::update(
+  const double time,
+  const std::vector<DoorCommon::DoorUpdateRequest>& requests)
+{
+  double dt = time - _last_update_time;
+  _last_update_time = time;
+
+  // Update simulation position and velocity of each joint and
+  // calcuate target velocity for the same
+  std::vector<DoorCommon::DoorUpdateResult> results;
+  for (const auto& request : requests)
+  {
+    const auto it = _doors.find(request.joint_name);
+    if (it != _doors.end())
+    {
+      it->second.current_position = request.position;
+      it->second.current_velocity = request.velocity;
+      DoorCommon::DoorUpdateResult result;
+      result.joint_name = request.joint_name;
+      result.fmax = _params.f_max;
+      if (requested_mode().value == DoorMode::MODE_OPEN)
+      {
+        result.velocity = calculate_target_velocity(
+          it->second.open_position,
+          request.position,
+          request.velocity,
+          dt);
+      }
+      else
+      {
+        result.velocity = calculate_target_velocity(
+          it->second.closed_position,
+          request.position,
+          request.velocity,
+          dt);
+      }
+      results.push_back(result);
+    }
+    else
+    {
+      RCLCPP_ERROR(logger(),
+        "Received update request for uninitialized joint [%s]",
+        request.joint_name.c_str());
+    }
+  }
+
+  // Publishing door states
+  if (time - _last_pub_time >= 1.0)
+  {
+    _last_pub_time = time;
+    const int32_t t_sec = static_cast<int32_t>(time);
+    const uint32_t t_nsec =
+      static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
+    const rclcpp::Time now{t_sec, t_nsec, RCL_ROS_TIME};
+
+    if (all_doors_open())
+    {
+      publish_state(DoorMode::MODE_OPEN, now);
+    }
+    else if (all_doors_closed())
+    {
+      publish_state(DoorMode::MODE_CLOSED, now);
+    }
+    else
+    {
+      publish_state(DoorMode::MODE_MOVING, now);
+    }
+  }
+
+  return results;
+}
+
+
+} // namespace building_sim_common
diff --git a/building_sim_plugins/building_plugins_common/src/lift_common.cpp b/building_sim_plugins/building_plugins_common/src/lift_common.cpp
new file mode 100644
index 0000000..e795b51
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/src/lift_common.cpp
@@ -0,0 +1,350 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <memory>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/lift_common.hpp>
+
+namespace building_sim_common {
+
+rclcpp::Logger LiftCommon::logger() const
+{
+  return rclcpp::get_logger("lift_" + _lift_state.lift_name);
+}
+
+std::string LiftCommon::get_joint_name() const
+{
+  return _cabin_joint_name;
+}
+
+double LiftCommon::get_elevation() const
+{
+  return _floor_name_to_elevation.at(_lift_state.destination_floor);
+}
+
+void LiftCommon::publish_door_request(const double time, std::string door_name,
+  uint32_t door_state)
+{
+  DoorRequest request;
+  request.request_time = rclcpp::Time(time);
+  request.requester_id = _lift_name;
+  request.door_name = door_name;
+  request.requested_mode.value = door_state;
+
+  _door_request_pub->publish(request);
+}
+
+double LiftCommon::get_step_velocity(const double dt, const double position,
+  const double velocity)
+{
+  double desired_elevation = get_elevation();
+  double dz = desired_elevation - position;
+
+  if (abs(dz) < _cabin_motion_params.dx_min / 2.0)
+    dz = 0;
+
+  return compute_desired_rate_of_change(
+    dz, velocity, _cabin_motion_params, dt);
+}
+
+// Compares current lift motion state to the last time this function was called
+bool LiftCommon::motion_state_changed()
+{
+  bool changed = _lift_state.motion_state != _old_motion_state;
+  _old_motion_state = _lift_state.motion_state;
+  return changed;
+}
+
+void LiftCommon::update_cabin_state(const double position,
+  const double velocity)
+{
+  // TODO update current_floor only when lift reaches its destination
+  double smallest_error = std::numeric_limits<double>::max();
+  std::string closest_floor_name;
+  for (const auto& floor : _floor_name_to_elevation)
+  {
+    double tmp_error = abs(position - floor.second);
+    if (tmp_error < smallest_error)
+    {
+      smallest_error = tmp_error;
+      closest_floor_name = floor.first;
+    }
+  }
+  _lift_state.current_floor = closest_floor_name;
+
+  // Set motion state
+  if (abs(velocity) < 0.01)
+    _lift_state.motion_state = LiftState::MOTION_STOPPED;
+  else if (velocity > 0)
+    _lift_state.motion_state = LiftState::MOTION_UP;
+  else
+    _lift_state.motion_state = LiftState::MOTION_DOWN;
+}
+
+void LiftCommon::move_doors(const double time, uint32_t door_mode)
+{
+  auto cabin_door_names =
+    _floor_name_to_cabin_door_name[_lift_state.current_floor];
+  for (const auto& cabin_door : cabin_door_names)
+  {
+    const auto it = _cabin_door_states.find(cabin_door);
+    if (it == _cabin_door_states.end())
+      continue;
+    if (it->second && it->second->current_mode.value != door_mode)
+      publish_door_request(time, cabin_door, door_mode);
+  }
+  auto shaft_door_names =
+    _floor_name_to_shaft_door_name[_lift_state.current_floor];
+  for (const auto& shaft_door : shaft_door_names)
+  {
+    const auto it = _shaft_door_states.find(shaft_door);
+    if (it == _shaft_door_states.end())
+      continue;
+    if (it->second && it->second->current_mode.value != door_mode)
+      publish_door_request(time, shaft_door, door_mode);
+  }
+}
+
+void LiftCommon::open_doors(const double time)
+{
+  move_doors(time, DoorMode::MODE_OPEN);
+}
+
+void LiftCommon::close_doors(const double time)
+{
+  move_doors(time, DoorMode::MODE_CLOSED);
+}
+
+uint32_t LiftCommon::get_door_state(
+  const std::unordered_map<std::string,
+  std::vector<std::string>>& floor_to_door_map,
+  const std::unordered_map<std::string, DoorState::SharedPtr>& door_states)
+{
+  std::size_t open_count = 0;
+  std::size_t closed_count = 0;
+  const auto doors = floor_to_door_map.find(
+    _lift_state.current_floor)->second;
+  const std::size_t num = doors.size();
+  for (const std::string door : doors)
+  {
+    const auto& door_state = door_states.find(door)->second;
+    if ((door_state) &&
+      (door_state->current_mode.value == DoorMode::MODE_CLOSED))
+      closed_count++;
+
+    else if ((door_state) &&
+      (door_state->current_mode.value == DoorMode::MODE_OPEN))
+      open_count++;
+  }
+  if (open_count == num)
+    return DoorMode::MODE_OPEN;
+
+  else if (closed_count == num)
+    return DoorMode::MODE_CLOSED;
+
+  else
+    return DoorMode::MODE_MOVING;
+}
+
+void LiftCommon::update_lift_door_state()
+{
+  uint32_t cabin_door_state = get_door_state(
+    _floor_name_to_cabin_door_name, _cabin_door_states);
+  uint32_t shaft_door_state = get_door_state(
+    _floor_name_to_shaft_door_name, _shaft_door_states);
+
+  _lift_state.door_state = (cabin_door_state == shaft_door_state) ?
+    cabin_door_state : LiftState::DOOR_MOVING;
+}
+
+LiftCommon::LiftCommon(rclcpp::Node::SharedPtr node,
+  const std::string& lift_name,
+  const std::string& joint_name,
+  const MotionParams& cabin_motion_params,
+  const std::vector<std::string>& floor_names,
+  const std::unordered_map<std::string, double>& floor_name_to_elevation,
+  std::unordered_map<
+    std::string, std::vector<std::string>> floor_name_to_shaft_door_name,
+  std::unordered_map<
+    std::string, std::vector<std::string>> floor_name_to_cabin_door_name,
+  std::unordered_map<std::string, DoorState::SharedPtr> shaft_door_states,
+  std::unordered_map<std::string, DoorState::SharedPtr> cabin_door_states,
+  std::string initial_floor_name)
+: _ros_node(node),
+  _lift_name(lift_name),
+  _cabin_joint_name(joint_name),
+  _cabin_motion_params(cabin_motion_params),
+  _floor_names(floor_names),
+  _floor_name_to_elevation(floor_name_to_elevation),
+  _floor_name_to_shaft_door_name(floor_name_to_shaft_door_name),
+  _floor_name_to_cabin_door_name(floor_name_to_cabin_door_name),
+  _shaft_door_states(shaft_door_states),
+  _cabin_door_states(cabin_door_states)
+{
+  // prints out available floors for this lift
+  std::cout << "Loaded lift: " << _lift_name << std::endl;
+  std::cout << "Names  |  Elevations" << std::endl;
+  for (const auto& it : _floor_name_to_elevation)
+    std::cout << it.first << "  |  " << it.second << std::endl;
+
+  // initialize pub & sub
+  _lift_state_pub = _ros_node->create_publisher<LiftState>(
+    "/lift_states", rclcpp::SystemDefaultsQoS());
+
+  _door_request_pub = _ros_node->create_publisher<DoorRequest>(
+    "/adapter_door_requests", rclcpp::SystemDefaultsQoS());
+
+  _lift_request_sub = _ros_node->create_subscription<LiftRequest>(
+    "/lift_requests", rclcpp::SystemDefaultsQoS(),
+    [&](LiftRequest::UniquePtr msg)
+    {
+      if (msg->lift_name != _lift_name)
+        return;
+
+      if (_floor_name_to_elevation.find(
+        msg->destination_floor) == _floor_name_to_elevation.end())
+      {
+        RCLCPP_INFO(logger(),
+        "Received request for unavailable floor [%s]",
+        msg->destination_floor.c_str());
+        return;
+      }
+
+      if (_lift_request)  // Lift is still processing a previous request
+      {
+        RCLCPP_INFO(logger(),
+        "Failed to request: [%s] is busy at the moment",
+        _lift_name.c_str());
+        return;
+      }
+
+      _lift_request = std::move(msg);
+      RCLCPP_INFO(logger(),
+      "Lift [%s] requested at level [%s]",
+      _lift_name.c_str(), _lift_request->destination_floor.c_str());
+    });
+
+  _door_state_sub = _ros_node->create_subscription<DoorState>(
+    "/door_states", rclcpp::SystemDefaultsQoS(),
+    [&](DoorState::SharedPtr msg)
+    {
+      std::string name = msg->door_name;
+      if (_cabin_door_states.find(name) != _cabin_door_states.end())
+        _cabin_door_states[name] = std::move(msg);
+      else if (_shaft_door_states.find(name) != _shaft_door_states.end())
+        _shaft_door_states[name] = std::move(msg);
+    });
+
+  // Initial lift state
+  _lift_state.lift_name = _lift_name;
+  _lift_state.current_floor = _floor_names[0];
+  _lift_state.destination_floor = initial_floor_name;
+  _lift_state.door_state = LiftState::DOOR_CLOSED;
+  _lift_state.motion_state = LiftState::MOTION_STOPPED;
+  for (const std::string& floor_name : _floor_names)
+    _lift_state.available_floors.push_back(floor_name);
+}
+
+void LiftCommon::pub_lift_state(const double time)
+{
+  _last_pub_time = time;
+  const int32_t t_sec = static_cast<int32_t>(time);
+  const uint32_t t_nsec =
+    static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
+  const rclcpp::Time now{t_sec, t_nsec, RCL_ROS_TIME};
+  _lift_state.lift_time = now;
+  _lift_state_pub->publish(_lift_state);
+}
+
+LiftCommon::LiftUpdateResult LiftCommon::update(const double time,
+  const double position, const double velocity)
+{
+  const double dt = time - _last_update_time;
+  _last_update_time = time;
+
+  // Update lift state
+  update_cabin_state(position, velocity);
+  update_lift_door_state();
+
+  // Construct LiftUpdateResult
+  LiftCommon::LiftUpdateResult result;
+  result.velocity = 0.0;
+  result.fmax = _cabin_motion_params.f_max;
+
+  // Handle lift request
+  if (_lift_request)
+  {
+    std::string desired_floor = _lift_request->destination_floor;
+    uint8_t desired_door_state = _lift_request->door_state;
+    if (_lift_request->request_type == LiftRequest::REQUEST_END_SESSION)
+      _lift_state.session_id = "";
+    else
+      _lift_state.session_id = _lift_request->session_id;
+
+    if ((_lift_state.current_floor == desired_floor) &&
+      (_lift_state.door_state == desired_door_state) &&
+      (_lift_state.motion_state == LiftState::MOTION_STOPPED))
+    {
+      RCLCPP_INFO(logger(),
+        "Reached floor %s with doors %s",
+        desired_floor.c_str(), desired_door_state == 0 ? "closed" : "open");
+      _lift_request = nullptr;
+    }
+    else
+    {
+      _lift_state.destination_floor = desired_floor;
+
+      if (_lift_state.current_floor != _lift_state.destination_floor)
+      {
+        if (_lift_state.door_state != LiftState::DOOR_CLOSED)
+        {
+          close_doors(time);
+        }
+        else
+        {
+          result.velocity = get_step_velocity(dt, position, velocity);
+        }
+      }
+      else
+      {
+        if (_lift_state.motion_state != LiftState::MOTION_STOPPED)
+        {
+          result.velocity = get_step_velocity(dt, position, velocity);
+        }
+        else
+        {
+          if (desired_door_state == LiftState::DOOR_OPEN)
+          {
+            open_doors(time);
+          }
+          else if (desired_door_state == LiftState::DOOR_CLOSED)
+          {
+            close_doors(time);
+          }
+        }
+      }
+    }
+  }
+  // Publish lift state at 1 Hz
+  if (time - _last_pub_time >= 1.0)
+    pub_lift_state(time);
+
+  return result;
+}
+
+} // namespace building_sim_common
diff --git a/building_sim_plugins/building_plugins_common/src/slotcar_common.cpp b/building_sim_plugins/building_plugins_common/src/slotcar_common.cpp
new file mode 100644
index 0000000..e6e81b3
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/src/slotcar_common.cpp
@@ -0,0 +1,801 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <memory>
+
+#include <geometry_msgs/msg/transform_stamped.hpp>
+#include <rmf_fleet_msgs/msg/destination_request.hpp>
+#include <rclcpp/logger.hpp>
+
+#include <building_sim_common/utils.hpp>
+#include <building_sim_common/slotcar_common.hpp>
+
+using namespace building_sim_common;
+
+static double compute_yaw(const Eigen::Isometry3d& pose)
+{
+  auto quat = Eigen::Quaterniond(pose.linear());
+  // Taken from ignition math quaternion Euler()
+  double yaw = std::atan2(2 * (quat.x()*quat.y() + quat.w()*quat.z()),
+      (quat.w() * quat.w()) + (quat.x() * quat.x()) - (quat.y() * quat.y()) -
+      (quat.z() * quat.z()));
+  return yaw;
+}
+
+// Computes change in yaw angle from old_pose to pose
+static double compute_yaw(const Eigen::Isometry3d& pose,
+  const Eigen::Isometry3d& old_pose, int rot_dir)
+{
+  const double yaw = compute_yaw(pose);
+  const double old_yaw = compute_yaw(old_pose);
+
+  double disp = yaw - old_yaw;
+  double eps = 0.01;
+  // Account for edge cases where the robot rotates past -PI rad to PI rad, or vice versa
+  if (rot_dir > 0 && yaw < (old_yaw - eps))
+  {
+    disp = (M_PI - old_yaw) + (yaw + M_PI);
+  }
+  else if (rot_dir < 0 && yaw > (old_yaw + eps))
+  {
+    disp = (M_PI - yaw) + (old_yaw + M_PI);
+  }
+  return disp;
+}
+
+static Eigen::Vector3d compute_heading(const Eigen::Isometry3d& pose)
+{
+  double yaw = compute_yaw(pose);
+  return Eigen::Vector3d(std::cos(yaw), std::sin(yaw), 0.0);
+}
+
+inline static Eigen::Vector3d compute_dist(const Eigen::Isometry3d& old_pos,
+  const Eigen::Isometry3d& new_pos)
+{
+  return new_pos.translation() - old_pos.translation();
+}
+
+inline static auto compute_dpos(const Eigen::Isometry3d& target,
+  const Eigen::Isometry3d& actual)
+{
+  Eigen::Vector3d dpos(compute_dist(actual, target));
+  dpos(2) = 0.0;
+  return dpos;
+}
+
+double compute_friction_energy(
+  const double f,
+  const double m,
+  const double v,
+  const double dt)
+{
+  const double g = 9.81; // ms-1
+  return f * m * g * v * dt;
+}
+
+SlotcarCommon::SlotcarCommon()
+{
+  // Make sure we initialize this message to TYPE_RESUME, or else the robot
+  // might just sit and wait around unintentionally.
+  pause_request = rmf_fleet_msgs::build<rmf_fleet_msgs::msg::PauseRequest>()
+    .fleet_name("")
+    .robot_name("")
+    .mode_request_id(0)
+    .type(rmf_fleet_msgs::msg::PauseRequest::TYPE_RESUME)
+    .at_checkpoint(0);
+}
+
+rclcpp::Logger SlotcarCommon::logger() const
+{
+  return rclcpp::get_logger("slotcar_" + _model_name);
+}
+
+void SlotcarCommon::set_model_name(const std::string& model_name)
+{
+  _model_name = model_name;
+}
+
+std::string SlotcarCommon::model_name() const
+{
+  return _model_name;
+}
+
+void SlotcarCommon::init_ros_node(const rclcpp::Node::SharedPtr node)
+{
+  _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_MOVING;
+  _ros_node = std::move(node);
+
+  _tf2_broadcaster = std::make_shared<tf2_ros::TransformBroadcaster>(_ros_node);
+
+  _robot_state_pub =
+    _ros_node->create_publisher<rmf_fleet_msgs::msg::RobotState>(
+    "/robot_state", 10);
+
+  auto qos_profile = rclcpp::QoS(10);
+  qos_profile.transient_local();
+  _building_map_sub =
+    _ros_node->create_subscription<building_map_msgs::msg::BuildingMap>(
+    "/map",
+    qos_profile,
+    std::bind(&SlotcarCommon::map_cb, this, std::placeholders::_1));
+
+  _traj_sub = _ros_node->create_subscription<rmf_fleet_msgs::msg::PathRequest>(
+    "/robot_path_requests",
+    10,
+    std::bind(&SlotcarCommon::path_request_cb, this, std::placeholders::_1));
+
+  using PauseRequest = rmf_fleet_msgs::msg::PauseRequest;
+  _pause_sub = _ros_node->create_subscription<PauseRequest>(
+    "/robot_pause_requests",
+    10,
+    std::bind(&SlotcarCommon::pause_request_cb, this, std::placeholders::_1));
+
+  _mode_sub = _ros_node->create_subscription<rmf_fleet_msgs::msg::ModeRequest>(
+    "/robot_mode_requests",
+    10,
+    std::bind(&SlotcarCommon::mode_request_cb, this, std::placeholders::_1));
+}
+
+bool SlotcarCommon::path_request_valid(
+  const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg)
+{
+  // Request is for another robot
+  if (msg->robot_name != _model_name)
+    return false;
+
+  // Repeated task request
+  if (msg->task_id == _current_task_id)
+  {
+    RCLCPP_INFO(
+      logger(), "%s already received task [%s] -- continuing as normal",
+      _current_task_id.c_str(), _model_name.c_str());
+    return false;
+  }
+
+  // Empty task request
+  if (msg->path.size() == 0)
+  {
+    RCLCPP_WARN(logger(), "%s received a path with no waypoints",
+      _model_name.c_str());
+    return false;
+  }
+  return true;
+}
+
+void SlotcarCommon::path_request_cb(
+  const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg)
+{
+  if (path_request_valid(msg) == false)
+    return;
+
+  const auto old_path = _remaining_path;
+
+  RCLCPP_INFO(
+    logger(),
+    "%s received a path request with %d waypoints",
+    _model_name.c_str(), (int)msg->path.size());
+
+  std::lock_guard<std::mutex> lock(_mutex);
+  // Reset this if we aren't at the final waypoint
+  trajectory.resize(msg->path.size());
+  _hold_times.resize(msg->path.size());
+  for (size_t i = 0; i < msg->path.size(); ++i)
+  {
+    Eigen::Vector3d v3(
+      msg->path[i].x,
+      msg->path[i].y,
+      0);
+
+    Eigen::Vector3d yaw_euler(
+      0,
+      0,
+      msg->path[i].yaw);
+
+    Eigen::Quaterniond quat(
+      Eigen::AngleAxisd(msg->path[i].yaw, Eigen::Vector3d::UnitZ()));
+    trajectory.at(i).translation() = v3;
+    trajectory.at(i).linear() = Eigen::Matrix3d(quat);
+
+    _hold_times.at(i) = msg->path[i].t;
+  }
+  _remaining_path = msg->path;
+  _traj_wp_idx = 0;
+
+  _current_task_id = msg->task_id;
+  _adapter_error = false;
+
+  const double initial_dist = compute_dpos(trajectory.front(), _pose).norm();
+
+  if (initial_dist > INITIAL_DISTANCE_THRESHOLD)
+  {
+    trajectory.clear();
+    trajectory.push_back(_pose);
+
+    _hold_times.clear();
+    _hold_times.push_back(rclcpp::Time((int64_t)0, RCL_ROS_TIME));
+
+    // We'll stick with the old path when an adapter error happens so that the
+    // fleet adapter knows where the robot currently is along its previous path.
+    _remaining_path = old_path;
+
+    _adapter_error = true;
+  }
+  else
+  {
+    trajectory.erase(trajectory.begin());
+    _hold_times.erase(_hold_times.begin());
+    _remaining_path.erase(_remaining_path.begin());
+  }
+}
+
+void SlotcarCommon::pause_request_cb(
+  const rmf_fleet_msgs::msg::PauseRequest::SharedPtr msg)
+{
+  if (msg->robot_name != _model_name)
+    return;
+
+  std::lock_guard<std::mutex> lock(_mutex);
+  pause_request = *msg;
+}
+
+std::array<double, 2> SlotcarCommon::calculate_control_signals(
+  const std::array<double, 2>& curr_velocities,
+  const std::pair<double, double>& velocities,
+  const double dt) const
+{
+  const double v_robot = curr_velocities[0];
+  const double w_robot = curr_velocities[1];
+
+  const double v_target = compute_ds(velocities.first, v_robot,
+      _nominal_drive_speed,
+      _nominal_drive_acceleration, _max_drive_acceleration, dt);
+
+  const double w_target = compute_ds(velocities.second, w_robot,
+      _nominal_turn_speed,
+      _nominal_turn_acceleration, _max_turn_acceleration, dt);
+
+  return std::array<double, 2>{v_target, w_target};
+}
+
+std::array<double, 2> SlotcarCommon::calculate_model_control_signals(
+  const std::array<double, 2>& curr_velocities,
+  const std::pair<double, double>& velocities,
+  const double dt) const
+{
+  return calculate_control_signals(curr_velocities, velocities, dt);
+}
+
+std::array<double, 2> SlotcarCommon::calculate_joint_control_signals(
+  const std::array<double, 2>& w_tire,
+  const std::pair<double, double>& velocities,
+  const double dt) const
+{
+  std::array<double, 2> curr_velocities;
+  curr_velocities[0] = (w_tire[0] + w_tire[1]) * _tire_radius / 2.0;
+  curr_velocities[1] = (w_tire[1] - w_tire[0]) * _tire_radius / _base_width;
+
+  std::array<double, 2> new_velocities = calculate_control_signals(
+    curr_velocities, velocities, dt);
+
+  std::array<double, 2> joint_signals;
+  for (std::size_t i = 0; i < 2; ++i)
+  {
+    const double yaw_sign = i == 0 ? -1.0 : 1.0;
+    joint_signals[i] = (new_velocities[0] / _tire_radius) + (yaw_sign *
+      new_velocities[1] * _base_width / (2.0 * _tire_radius));
+  }
+  return joint_signals;
+}
+
+std::string to_str(uint32_t type)
+{
+  if (rmf_fleet_msgs::msg::PauseRequest::TYPE_RESUME == type)
+    return "resume";
+  else if (rmf_fleet_msgs::msg::PauseRequest::TYPE_PAUSE_IMMEDIATELY == type)
+    return "pause immediately";
+  else if (rmf_fleet_msgs::msg::PauseRequest::TYPE_PAUSE_AT_CHECKPOINT == type)
+    return "pause at checkpoint";
+
+  return "UNKNOWN: " + std::to_string(type) + "??";
+}
+
+// First value of par is x_target, second is yaw_target
+std::pair<double, double> SlotcarCommon::update(const Eigen::Isometry3d& pose,
+  const std::vector<Eigen::Vector3d>& obstacle_positions,
+  const double time)
+{
+  std::lock_guard<std::mutex> lock(_mutex);
+  std::pair<double, double> velocities;
+  const int32_t t_sec = static_cast<int32_t>(time);
+  const uint32_t t_nsec =
+    static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
+  const rclcpp::Time now{t_sec, t_nsec, RCL_ROS_TIME};
+  double dt = time - _last_update_time;
+  _last_update_time = time;
+
+  _pose = pose;
+  publish_robot_state(time);
+
+  // Update battery state of charge
+  if (_initialized_pose)
+  {
+    const Eigen::Vector3d dist = compute_dpos(_old_pose, _pose); // Ignore movement along z-axis
+    const Eigen::Vector3d lin_vel = dist / dt;
+    double ang_disp = compute_yaw(_pose, _old_pose, _rot_dir);
+    const double ang_vel = ang_disp / dt;
+
+    // Try charging battery
+    double eps = 0.01;
+    bool stationary = lin_vel.norm() < eps && std::abs(ang_vel) < eps;
+    bool in_charger_vicinity = near_charger(_pose);
+    if (stationary && in_charger_vicinity)
+    {
+      if (_enable_instant_charge)
+      {
+        _soc = _soc_max;
+      }
+      else if (_enable_charge)
+      {
+        _soc += compute_charge(dt);
+        _soc = std::min(_soc_max, _soc);
+      }
+    }
+    // Discharge battery
+    if (_enable_drain)
+    {
+      const Eigen::Vector3d lin_acc = (lin_vel - _old_lin_vel) / dt;
+      const double ang_acc = (ang_vel - _old_ang_vel) / dt;
+      _soc -= compute_discharge(lin_vel, ang_vel, lin_acc, ang_acc, dt);
+      _soc = std::max(0.0, _soc);
+    }
+    // Update mode
+    if (stationary && in_charger_vicinity &&
+      (_enable_instant_charge || _enable_charge))
+    {
+      _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_CHARGING;
+    }
+    else if (_docking)
+    {
+      _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_DOCKING;
+    }
+    else if (stationary)
+    {
+      _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_IDLE;
+    }
+    else
+    {
+      _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_MOVING;
+    }
+    _old_lin_vel = lin_vel;
+    _old_ang_vel = ang_vel;
+  }
+  _old_pose = _pose;
+  _initialized_pose = true;
+
+  if (trajectory.empty())
+    return velocities;
+
+  Eigen::Vector3d current_heading = compute_heading(_pose);
+
+  if (_traj_wp_idx < trajectory.size())
+  {
+    const Eigen::Vector3d dpos = compute_dpos(
+      trajectory.at(_traj_wp_idx), _pose);
+
+    if (_hold_times.size() != trajectory.size())
+    {
+      throw std::runtime_error(
+              "Mismatch between trajectory size ["
+              + std::to_string(trajectory.size()) + "] and holding time size ["
+              + std::to_string(_hold_times.size()) + "]");
+    }
+
+    auto dpos_mag = dpos.norm();
+    // TODO(MXG): Some kind of crazy nonsense bug is somehow altering the
+    // clock type value for the _hold_times. I don't know where this could
+    // possibly be happening, but I suspect it must be caused by undefined
+    // behavior. For now we deal with this by explicitly setting the clock type.
+    const auto hold_time =
+      rclcpp::Time(_hold_times.at(_traj_wp_idx), RCL_ROS_TIME);
+
+    const bool close_enough = (dpos_mag < 0.02);
+
+    const bool checkpoint_pause =
+      pause_request.type == pause_request.TYPE_PAUSE_AT_CHECKPOINT
+      && pause_request.at_checkpoint <= _remaining_path.front().index;
+    const bool immediate_pause =
+      pause_request.type == pause_request.TYPE_PAUSE_IMMEDIATELY;
+    const bool pause = checkpoint_pause || immediate_pause;
+
+    const bool hold = now < hold_time;
+
+    const bool rotate_towards_next_target = close_enough && (hold || pause);
+
+    if (rotate_towards_next_target)
+    {
+      if (_traj_wp_idx+1 < trajectory.size())
+      {
+        const auto dpos_next =
+          compute_dpos(trajectory.at(_traj_wp_idx+1), _pose);
+
+        const auto goal_heading =
+          compute_heading(trajectory.at(_traj_wp_idx+1));
+
+        double dir = 1.0;
+        velocities.second = compute_change_in_rotation(
+          current_heading, dpos_next, &goal_heading, &dir);
+
+        if (dir < 0.0)
+          current_heading *= -1.0;
+      }
+      else
+      {
+        const auto goal_heading = compute_heading(trajectory.at(_traj_wp_idx));
+        velocities.second = compute_change_in_rotation(
+          current_heading, goal_heading);
+      }
+
+      _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_PAUSED;
+    }
+    else if (close_enough)
+    {
+      _traj_wp_idx++;
+      if (_remaining_path.empty())
+        return velocities;
+
+      _remaining_path.erase(_remaining_path.begin());
+      RCLCPP_INFO(logger(),
+        "%s reached waypoint %d/%d",
+        _model_name.c_str(),
+        _traj_wp_idx,
+        (int)trajectory.size());
+      if (_traj_wp_idx == trajectory.size())
+      {
+        RCLCPP_INFO(
+          logger(),
+          "%s reached goal -- rotating to face target",
+          _model_name.c_str());
+      }
+    }
+
+    if (!rotate_towards_next_target && _traj_wp_idx < trajectory.size())
+    {
+      const double d_yaw_tolerance = 5.0 * M_PI / 180.0;
+      auto goal_heading = compute_heading(trajectory.at(_traj_wp_idx));
+      double dir = 1.0;
+      velocities.second =
+        compute_change_in_rotation(current_heading, dpos, &goal_heading, &dir);
+      if (dir < 0.0)
+        current_heading *= -1.0;
+
+      // If d_yaw is less than a certain tolerance (i.e. we don't need to spin
+      // too much), then we'll include the forward velocity. Otherwise, we will
+      // only spin in place until we are oriented in the desired direction.
+      velocities.first = std::abs(velocities.second) <
+        d_yaw_tolerance ? dir * dpos_mag : 0.0;
+    }
+  }
+  else
+  {
+    const auto goal_heading = compute_heading(trajectory.back());
+    velocities.second = compute_change_in_rotation(
+      current_heading,
+      goal_heading);
+
+    // Put in a deadzone if yaw is small enough. This essentially locks the
+    // tires. COMMENTED OUT as it breaks rotations for some reason...
+    // if(std::abs(velocities.second) < std::max(0.1*M_PI/180.00, goal_yaw_tolerance))
+    // {
+    //   velocities.second = 0.0;
+    // }
+
+    velocities.first = 0.0;
+  }
+
+  const bool immediate_pause =
+    pause_request.type == pause_request.TYPE_PAUSE_IMMEDIATELY;
+
+  const bool stop =
+    immediate_pause || emergency_stop(obstacle_positions, current_heading);
+
+  if (immediate_pause)
+  {
+    // If we are required to immediately pause, report that we are in paused
+    // mode
+    _current_mode.mode = _current_mode.MODE_PAUSED;
+  }
+  else if (stop)
+  {
+    // If we are not required to pause but we are being forced to emergency stop
+    // because of an obstacle, report that we are in waiting mode.
+    _current_mode.mode = _current_mode.MODE_WAITING;
+  }
+
+  if (stop)
+  {
+    // Allow spinning but not translating
+    velocities.first = 0.0;
+  }
+
+  _rot_dir = velocities.second >= 0 ? 1 : -1;
+  return velocities;
+}
+
+bool SlotcarCommon::emergency_stop(
+  const std::vector<Eigen::Vector3d>& obstacle_positions,
+  const Eigen::Vector3d& current_heading)
+{
+  const Eigen::Vector3d stop_zone =
+    _pose.translation() + _stop_distance * current_heading;
+
+  bool need_to_stop = false;
+  for (const auto& obstacle_pos : obstacle_positions)
+  {
+    const double dist = (obstacle_pos - stop_zone).norm();
+    if (dist < _stop_radius)
+    {
+      need_to_stop = true;
+      break;
+    }
+  }
+
+  if (need_to_stop != _emergency_stop)
+  {
+    _emergency_stop = need_to_stop;
+    // TODO flush logger here
+    // TODO get collision object name
+    if (need_to_stop)
+      RCLCPP_INFO_STREAM(logger(), "Stopping [" << _model_name <<
+          "] to avoid a collision");
+    else
+      RCLCPP_INFO_STREAM(logger(), "No more obstacles; resuming course for [" <<
+          _model_name << "]");
+  }
+
+  return _emergency_stop;
+}
+
+std::string SlotcarCommon::get_level_name(const double z) const
+{
+  std::string level_name = "";
+  if (!_initialized_levels)
+    return level_name;
+  auto min_distance = std::numeric_limits<double>::max();
+  for (auto it = _level_to_elevation.begin(); it != _level_to_elevation.end();
+    ++it)
+  {
+    const double disp = std::abs(it->second - z);
+    if (disp < min_distance)
+    {
+      min_distance = disp;
+      level_name = it->first;
+    }
+  }
+  return level_name;
+}
+
+double SlotcarCommon::compute_change_in_rotation(
+  const Eigen::Vector3d& heading_vec,
+  const Eigen::Vector3d& dpos,
+  const Eigen::Vector3d* traj_vec,
+  double* const dir) const
+{
+  if (dpos.norm() < 1e-3)
+  {
+    // We're right next to the waypoint, so we don't really need any heading
+    // to reach it.
+    return 0.0;
+  }
+
+  Eigen::Vector3d target = dpos;
+  // If a traj_vec is provided, of the two possible headings (dpos/-dpos),
+  // choose the one closest to traj_vec
+  if (traj_vec)
+  {
+    const double dot = traj_vec->dot(dpos);
+    target = dot < 0 ? -dpos : dpos;
+    // dir is negative if slotcar will need to reverse to go towards target
+    if (dir)
+    {
+      *dir = dot < 0 ? -1.0 : 1.0;
+    }
+  }
+
+  const auto cross = heading_vec.cross(target);
+  const double direction = cross(2) < 0.0 ? -1.0 : 1.0;
+  const double denom = heading_vec.norm() * target.norm();
+  const double d_yaw = direction * std::asin(cross.norm() / denom);
+
+  return d_yaw;
+}
+
+void SlotcarCommon::publish_robot_state(const double time)
+{
+  const int32_t t_sec = static_cast<int32_t>(time);
+  const uint32_t t_nsec =
+    static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
+  const rclcpp::Time ros_time{t_sec, t_nsec, RCL_ROS_TIME};
+  if ((time - last_tf2_pub) > (1.0 / TF2_RATE))
+  {
+    // Publish tf2
+    publish_tf2(ros_time);
+    last_tf2_pub = time;
+  }
+  if ((time - last_topic_pub) > (1.0 / STATE_TOPIC_RATE))
+  {
+    // Publish state topic
+    publish_state_topic(ros_time);
+    last_topic_pub = time;
+  }
+}
+
+void SlotcarCommon::publish_tf2(const rclcpp::Time& t)
+{
+  geometry_msgs::msg::TransformStamped tf_stamped;
+  Eigen::Quaterniond quat(_pose.linear());
+  tf_stamped.header.stamp = t;
+  tf_stamped.header.frame_id = "world";
+  tf_stamped.child_frame_id = _model_name + "/base_link";
+  tf_stamped.transform.translation.x = _pose.translation()[0];
+  tf_stamped.transform.translation.y = _pose.translation()[1];
+  tf_stamped.transform.translation.z = _pose.translation()[2];
+  tf_stamped.transform.rotation.x = quat.x();
+  tf_stamped.transform.rotation.y = quat.y();
+  tf_stamped.transform.rotation.z = quat.z();
+  tf_stamped.transform.rotation.w = quat.w();
+  _tf2_broadcaster->sendTransform(tf_stamped);
+}
+
+void SlotcarCommon::publish_state_topic(const rclcpp::Time& t)
+{
+  rmf_fleet_msgs::msg::RobotState robot_state_msg;
+  robot_state_msg.name = _model_name;
+  robot_state_msg.battery_percent = 100 * _soc;
+
+  robot_state_msg.location.x = _pose.translation()[0];
+  robot_state_msg.location.y = _pose.translation()[1];
+  robot_state_msg.location.yaw = compute_yaw(_pose);
+  robot_state_msg.location.t = t;
+  robot_state_msg.location.level_name = get_level_name(_pose.translation()[2]);
+
+  robot_state_msg.task_id = _current_task_id;
+  robot_state_msg.path = _remaining_path;
+  robot_state_msg.mode = _current_mode;
+  robot_state_msg.mode.mode_request_id = pause_request.mode_request_id;
+
+  if (_adapter_error)
+  {
+    robot_state_msg.mode.mode =
+      rmf_fleet_msgs::msg::RobotMode::MODE_ADAPTER_ERROR;
+  }
+
+  robot_state_msg.seq = ++_sequence;
+  _robot_state_pub->publish(robot_state_msg);
+}
+
+void SlotcarCommon::mode_request_cb(
+  const rmf_fleet_msgs::msg::ModeRequest::SharedPtr msg)
+{
+  // Request is for another robot
+  if (msg->robot_name != _model_name)
+    return;
+
+  _current_mode = msg->mode;
+  if (msg->mode.mode == msg->mode.MODE_DOCKING)
+    _docking = true;
+  else
+    _docking = false;
+}
+
+void SlotcarCommon::map_cb(
+  const building_map_msgs::msg::BuildingMap::SharedPtr msg)
+{
+  if (msg->levels.empty())
+  {
+    RCLCPP_ERROR(logger(), "Received empty building map");
+    return;
+  }
+
+  for (const auto& level : msg->levels)
+  {
+    _level_to_elevation.insert({level.name, level.elevation});
+  }
+  _initialized_levels = true;
+
+}
+
+// Enables/disables charge when called from Ignition/Gazebo plugin
+void SlotcarCommon::charge_state_cb(
+  const std::string& name, bool selected)
+{
+  if (name == _enable_charge_str)
+  {
+    _enable_charge = selected;
+  }
+  else if (name == _enable_instant_charge_str)
+  {
+    _enable_instant_charge = selected;
+  }
+  else if (name == _enable_drain_str)
+  {
+    _enable_drain = selected;
+  }
+  else
+  {
+    std::cerr << "Invalid button selected. " << std::endl;
+  }
+}
+
+bool SlotcarCommon::near_charger(const Eigen::Isometry3d& pose) const
+{
+  std::string lvl_name = get_level_name(pose.translation()[2]);
+  auto waypoints_it = _charger_waypoints.find(lvl_name);
+  if (waypoints_it != _charger_waypoints.end())
+  {
+    const std::vector<ChargerWaypoint>& waypoints = waypoints_it->second;
+    for (const ChargerWaypoint& waypoint : waypoints)
+    {
+      // Assumes it is on the same Z-plane
+      double dist =
+        sqrt(pow(waypoint.x - pose.translation()[0], 2)
+          + pow(waypoint.y - pose.translation()[1], 2));
+      if (dist < _charger_dist_thres)
+      {
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+double SlotcarCommon::compute_charge(const double run_time) const
+{
+  const double dQ = _params.charging_current * run_time; // Coulombs
+  const double dSOC = dQ / (_params.nominal_capacity * 3600.0);
+  return dSOC;
+}
+
+double SlotcarCommon::compute_discharge(
+  const Eigen::Vector3d lin_vel, const double ang_vel,
+  const Eigen::Vector3d lin_acc, const double ang_acc,
+  const double run_time) const
+{
+  const double v = std::min(lin_vel.norm(), _nominal_drive_speed);
+  const double w = std::min(std::abs(ang_vel), _nominal_turn_speed);
+  const double a = std::min(lin_acc.norm(), _max_drive_acceleration);
+  const double alpha = std::min(std::abs(ang_acc), _max_turn_acceleration);
+
+  // Loss through acceleration
+  const double EA = ((_params.mass * a * v) +
+    (_params.inertia * alpha * w)) * run_time;
+
+  // Loss through friction. Ignores friction due to rotation in place
+  const double EF = compute_friction_energy(_params.friction_coefficient,
+      _params.mass, v, run_time);
+
+  // Change in energy as a result of motion
+  const double dEM = EA + EF;
+  // Change in energy due to any onboard device over the time period `run_time`
+  const double dED = _params.nominal_power * run_time;
+
+  // The charge consumed
+  const double dQ = (dEM + dED) / _params.nominal_voltage;
+  // The depleted state of charge as a fraction in range [0,1]
+  double dSOC = dQ / (_params.nominal_capacity * 3600.0);
+
+  return dSOC;
+}
diff --git a/building_sim_plugins/building_plugins_common/src/utils.cpp b/building_sim_plugins/building_plugins_common/src/utils.cpp
new file mode 100644
index 0000000..d1125f3
--- /dev/null
+++ b/building_sim_plugins/building_plugins_common/src/utils.cpp
@@ -0,0 +1,117 @@
+#include <cmath>
+#include <algorithm>
+
+#include <building_sim_common/utils.hpp>
+
+namespace building_gazebo_plugins {
+
+//==============================================================================
+double compute_ds(
+  double s_target,
+  double v_actual,
+  const double v_max,
+  const double accel_nom,
+  const double accel_max,
+  const double dt)
+{
+  double sign = 1.0;
+  if (s_target < 0.0)
+  {
+    // Limits get confusing when we need to go backwards, so we'll flip signs
+    // here so that we pretend the target is forwards
+    s_target *= -1.0;
+    v_actual *= -1.0;
+    sign = -1.0;
+  }
+
+  // We should try not to shoot past the targstd::vector<event::ConnectionPtr> connections;et
+  double next_s = s_target / dt;
+
+  // Test velocity limit
+  next_s = std::min(next_s, v_max);
+
+  // Test acceleration limit
+  next_s = std::min(next_s, accel_nom * dt + v_actual);
+
+  if (v_actual > 0.0 && s_target > 0.0)
+  {
+    // This is what our deceleration should be if we want to begin a constant
+    // deceleration from now until we reach the goal
+    double deceleration = pow(v_actual, 2) / s_target;
+    deceleration = std::min(deceleration, accel_max);
+
+    if (accel_nom <= deceleration)
+    {
+      // If the smallest constant deceleration for reaching the goal is
+      // greater than
+      next_s = -deceleration * dt + v_actual;
+    }
+  }
+
+  // Flip the sign the to correct direction before returning the value
+  return sign * next_s;
+}
+
+//==============================================================================
+double compute_desired_rate_of_change(
+  double _s_target,
+  double _v_actual,
+  const MotionParams& _motion_params,
+  const double _dt)
+{
+  double sign = 1.0;
+  if (_s_target < 0.0)
+  {
+    // Limits get confusing when we need to go backwards, so we'll flip signs
+    // here so that we pretend the target is forwards
+    _s_target *= -1.0;
+    _v_actual *= -1.0;
+    sign = -1.0;
+  }
+
+  // We should try not to shoot past the target
+  double v_next = _s_target / _dt;
+
+  // Test velocity limit
+  v_next = std::min(v_next, _motion_params.v_max);
+
+  // Test acceleration limit
+  v_next = std::min(v_next, _motion_params.a_nom * _dt + _v_actual);
+
+  if (_v_actual > 0.0 && _s_target > 0.0)
+  {
+    // This is what our deceleration should be if we want to begin a constant
+    // deceleration from now until we reach the goal
+    double deceleration = pow(_v_actual, 2) / (2.0 * _s_target);
+    deceleration = std::min(deceleration, _motion_params.a_max);
+
+    if (_motion_params.a_nom <= deceleration)
+    {
+      // If the smallest constant deceleration for reaching the goal is
+      // greater than the nominal acceleration, then we should begin
+      // decelerating right away so that we can smoothly reach the goal while
+      // decelerating as close to the nominal acceleration as possible.
+      v_next = -deceleration * _dt + _v_actual;
+    }
+  }
+
+  // Flip the sign to the correct direction before returning the value
+  return sign * v_next;
+}
+
+//==============================================================================
+bool get_element_required(
+  const sdf::ElementPtr& _sdf,
+  const std::string& _element_name,
+  sdf::ElementPtr& _element)
+{
+  if (!_sdf->HasElement(_element_name))
+  {
+    std::cerr << "Element [" << _element_name << "] not found" << std::endl;
+    return false;
+  }
+  _element = _sdf->GetElement(_element_name);
+  return true;
+}
+
+} // namespace building_gazebo_plugins
diff --git a/test_maps/CHANGELOG.rst b/test_maps/CHANGELOG.rst
new file mode 100644
index 0000000..11c4a05
--- /dev/null
+++ b/test_maps/CHANGELOG.rst
@@ -0,0 +1,28 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package test_maps
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.2.0 (2021-01-05)
+------------------
+* Add first pass of quality declarations for all packages (`#235 <https://github.com/osrf/traffic_editor/issues/235>`_)
+* Contributors: Geoffrey Biggs, Marco A. Gutiérrez
+
+1.1.0 (2020-09-24)
+-----------------
+* Move message call outside of custom command cal `#184 <https://github.com/osrf/traffic_editor/issues/184>`_
+* Fix/separate model download `#183 <https://github.com/osrf/traffic_editor/issues/183>`_
+* Using custom commands within if condition due to required OUTPUT or TARGET cmake variable
+* Invoking model downloading with a separate custom command
+* Fixing build dependency (`#172 <https://github.com/osrf/traffic_editor/issues/172>`_)
+* Contributors: Aaron Chong, Luca Della Vedova, Marco A. Gutiérrez
+
+1.0.0 (2020-06-22)
+------------------
+* merging master
+* Merge pull request `#132 <https://github.com/osrf/traffic_editor/issues/132>`_ from methylDragon/ch3/author-namespaced-thumbnails
+  Support Author-namedspaced Thumbnails and Revamp building_map_generator
+* Fix build and import bug
+* Merge pull request `#100 <https://github.com/osrf/traffic_editor/issues/100>`_ from osrf/double_swing_doors_directions
+  branch on double swing door direction for sim generation
+* branch on double swing door direction for sim generation
+* Contributors: Aaron Chong, Morgan Quigley, methylDragon
diff --git a/test_maps/CMakeLists.txt b/test_maps/CMakeLists.txt
new file mode 100644
index 0000000..f53696d
--- /dev/null
+++ b/test_maps/CMakeLists.txt
@@ -0,0 +1,57 @@
+cmake_minimum_required(VERSION 3.5)
+
+project(test_maps)
+
+find_package(ament_cmake REQUIRED)
+
+install(DIRECTORY
+  maps/
+  DESTINATION share/${PROJECT_NAME}
+)
+
+ament_package()
+
+file(GLOB_RECURSE traffic_editor_paths "maps/*.building.yaml")
+
+foreach(path ${traffic_editor_paths})
+
+  # Get the output world name
+  string(REPLACE "." ";" list1 ${path})
+  list(GET list1 0 name)
+  string(REPLACE "/" ";" list2 ${name})
+  list(GET list2 -1 world_name)
+
+  set(map_path ${path})
+  set(output_world_name ${world_name})
+  set(output_dir ${CMAKE_CURRENT_BINARY_DIR}/maps/${output_world_name})
+  set(output_world_path ${output_dir}/${output_world_name}.world)
+  set(output_model_dir ${output_dir}/models)
+
+  # first, generate the world
+  message("BUILDING WORLDFILE WITH COMMAND: ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}")
+  if (NO_DOWNLOAD_MODELS)
+    add_custom_command(
+      DEPENDS ${map_path}
+      COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
+      OUTPUT ${output_world_path}
+    )
+  else()
+    message("DOWNLOADING MODELS WITH COMMAND: ros2 run building_map_tools building_map_model_downloader ${map_path}")
+    add_custom_command(
+      DEPENDS ${map_path}
+      COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
+      COMMAND ros2 run building_map_tools building_map_model_downloader ${map_path}
+      OUTPUT ${output_world_path}
+    )
+  endif()
+
+  add_custom_target(generate_${output_world_name} ALL
+    DEPENDS ${output_world_path}
+  )
+
+  install(
+    DIRECTORY ${output_dir}
+    DESTINATION share/${PROJECT_NAME}/maps
+  )
+
+endforeach()
diff --git a/test_maps/QUALITY_DECLARATION.md b/test_maps/QUALITY_DECLARATION.md
new file mode 100644
index 0000000..a20c222
--- /dev/null
+++ b/test_maps/QUALITY_DECLARATION.md
@@ -0,0 +1,133 @@
+This document is a declaration of software quality for the `test_maps` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+# `test_maps` Quality Declaration
+
+The package `test_maps` claims to be in the **Quality Level 3** category.
+The main rationale for this claim its its status as a collection of demonstration map files.
+
+Below are the detailed rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 3 in REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+## Version Policy [1]
+
+### Version Scheme [1.i]
+
+`test_maps` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).
+
+### Version Stability [1.ii]
+
+`test_maps` is at a stable version, i.e. `>= 1.0.0`.
+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).
+
+### Public API Declaration [1.iii]
+
+`test_maps` does not have a public API.
+
+### API Stability Policy [1.iv]
+
+`test_maps` does not have a public API.
+
+### ABI Stability Policy [1.v]
+
+`test_maps` does not have a public API.
+
+### API and ABI Stability Within a Released ROS Distribution [1.vi]
+
+`test_maps` does not have a public API.
+
+## Change Control Process [2]
+
+`test_maps` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).
+
+### Change Requests [2.i]
+
+`test_maps` requires that all changes occur through a pull request.
+
+### Contributor Origin [2.ii]
+
+`test_maps` does not require a confirmation of contributor origin.
+
+### Peer Review Policy [2.iii]
+
+All pull requests must have at least 1 peer review.
+
+### Continuous Integration [2.iv]
+
+All pull requests must pass CI on all platforms supported by RMF.
+The CI checks only that the package builds.
+The most recent CI results can be seen on [the workflow page](https://github.com/osrf/traffic_editor/actions).
+
+### Documentation Policy [2.v]
+
+All pull requests must resolve related documentation changes before merging.
+
+## Documentation [3]
+
+### Feature Documentation [3.i]
+
+`test_maps` is documented in the [parent repository's README.md file](https://github.com/osrf/traffic_editor/blob/master/README.md).
+
+### Public API Documentation [3.ii]
+
+`test_maps` does not have a public API.
+
+### License [3.iii]
+
+The license for `test_maps` is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.
+
+There are no source files that are currently copyrighted in this package so files are not checked for abbreviated license statements.
+
+### Copyright Statement [3.iv]
+
+There are no copyrighted source files in this package.
+
+### Quality declaration document [3.v]
+
+This quality declaration is linked in the [README file](README.md).
+
+This quality declaration has not been externally peer-reviewed and is not registered on any Level 3 lists.
+
+## Testing [4]
+
+### Feature Testing [4.i]
+
+`test_maps` is a package providing strictly resource files and therefore does not require associated tests.
+
+### Public API Testing [4.ii]
+
+`test_maps` is a package providing strictly resource files and therefore does not require associated tests.
+
+### Coverage [4.iii]
+
+`test_maps` is a package providing strictly resource files and therefore does not require associated tests.
+
+### Performance [4.iv]
+
+`test_maps` is a package providing strictly resource files and therefore does not require associated tests.
+
+### Linters and Static Analysis [4.v]
+
+`test_maps` has no files that require linting or static analysis.
+
+## Dependencies [5]
+
+### Direct Runtime ROS Dependencies [5.i]
+
+`test_maps` does not have any required direct runtime ROS dependencies.
+
+### Optional Direct Runtime ROS Dependencies [5.ii]
+
+`test_maps` does not have any optional direct runtime ROS dependencies.
+
+### Direct Runtime non-ROS Dependency [5.iii]
+
+`test_maps` does not have any runtime non-ROS dependencies.
+
+## Platform Support [6]
+
+As a pure resource package, `test_maps` supports all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers), but does not currently test each change against all of them.
+
+## Security [7]
+
+### Vulnerability Disclosure Policy [7.i]
+
+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).
diff --git a/test_maps/README.md b/test_maps/README.md
new file mode 100644
index 0000000..c862ff4
--- /dev/null
+++ b/test_maps/README.md
@@ -0,0 +1,7 @@
+# test\_maps
+
+This package provides maps for testing the traffic editor.
+
+## Quality Declaration
+
+This package claims to be in the **Quality Level 3** category, see the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.
diff --git a/test_maps/maps/door_madness/door_madness.building.yaml b/test_maps/maps/door_madness/door_madness.building.yaml
new file mode 100644
index 0000000..d160baf
--- /dev/null
+++ b/test_maps/maps/door_madness/door_madness.building.yaml
@@ -0,0 +1,49 @@
+levels:
+  L1:
+    doors:
+      - [10, 11, {motion_axis: [1, start], motion_degrees: [3, 90], motion_direction: [2, -1], name: [1, negative_motion], type: [1, double_hinged]}]
+      - [8, 9, {motion_axis: [1, start], motion_degrees: [3, 90], motion_direction: [2, 1], name: [1, positive_motion], type: [1, double_hinged]}]
+    elevation: 0
+    flattened_x_offset: 0
+    flattened_y_offset: 0
+    floors:
+      - parameters: {texture_name: [1, blue_linoleum], texture_rotation: [3, 0], texture_scale: [3, 1]}
+        vertices: [0, 3, 4, 7]
+    layers:
+      {}
+    measurements:
+      - [0, 7, {distance: [3, 4]}]
+    models:
+      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 62.373, y: 73.121, yaw: -3.1416, z: 0}
+      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 62.64, y: 112.802, yaw: -3.1416, z: 0}
+      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 111.89, y: 72.617, yaw: -3.1416, z: 0}
+      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 111.355, y: 108.893, yaw: -3.1416, z: 0}
+    vertices:
+      - [27.219, 60.337, 0, ""]
+      - [75.157, 60.87, 0, ""]
+      - [122.026, 60.739, 0, ""]
+      - [177.423, 60.604, 0, ""]
+      - [177.157, 124.787, 0, ""]
+      - [122.828, 124.787, 0, ""]
+      - [74.89, 125.585, 0, ""]
+      - [25.621, 126.118, 0, ""]
+      - [75.157, 107.742, 0, ""]
+      - [74.89, 77.116, 0, ""]
+      - [122.029, 73.92, 0, ""]
+      - [122.828, 104.813, 0, ""]
+    walls:
+      - [0, 1, {}]
+      - [1, 2, {}]
+      - [2, 3, {}]
+      - [7, 6, {}]
+      - [6, 5, {}]
+      - [5, 4, {}]
+      - [5, 11, {}]
+      - [6, 8, {}]
+      - [9, 1, {}]
+      - [10, 2, {}]
+    x_meters: 3.161074671053361
+    y_meters: 3.161074671053361
+lifts:
+  {}
+name: building
diff --git a/test_maps/maps/door_madness/door_madness.project.yaml b/test_maps/maps/door_madness/door_madness.project.yaml
new file mode 100644
index 0000000..06453c5
--- /dev/null
+++ b/test_maps/maps/door_madness/door_madness.project.yaml
@@ -0,0 +1,4 @@
+building:
+  filename: door_madness.building.yaml
+name: door_madness
+version: 1
diff --git a/test_maps/package.xml b/test_maps/package.xml
new file mode 100644
index 0000000..39144ef
--- /dev/null
+++ b/test_maps/package.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
+<package format="3">
+  <name>test_maps</name>
+  <version>1.2.0</version>
+  <description>
+    Some test maps for traffic_editor and building_map_tools.
+  </description>
+  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
+  <license>Apache License 2.0</license>
+
+  <buildtool_depend>ament_cmake</buildtool_depend>
+  <buildtool_depend>building_map_tools</buildtool_depend>
+  <buildtool_depend>ros2run</buildtool_depend>
+
+  <export>
+    <build_type>ament_cmake</build_type>
+  </export>
+</package>
diff --git a/traffic_editor/CHANGELOG.rst b/traffic_editor/CHANGELOG.rst
new file mode 100644
index 0000000..9c83fbf
--- /dev/null
+++ b/traffic_editor/CHANGELOG.rst
@@ -0,0 +1,370 @@
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+Changelog for package traffic_editor
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+1.2.0 (2021-01-05)
+------------------
+* Adds undo capability to a large part of the actions. (`#269 <https://github.com/osrf/traffic_editor/pull/269>`_) (`#266 <https://github.com/osrf/traffic_editor/pull/266>`_)
+* Contibutors: Arjo, Morgan Quigley, Yadu
+* Merge pull request `#276 <https://github.com/osrf/traffic_editor/issues/276>`_ from osrf/add_lane_vertex_snap_distance_scaling
+  scale add-lane vertex snap distance correctly
+* undo features
+* compute the click-to-merge treshold in pixels
+* Feature/undo: Undo for editor components (`#269 <https://github.com/osrf/traffic_editor/issues/269>`_)
+* scale add-lane vertex snap distance correctly
+* fix to compilation when no opencv (`#272 <https://github.com/osrf/traffic_editor/issues/272>`_)
+* Merge pull request `#266 <https://github.com/osrf/traffic_editor/issues/266>`_ from osrf/feature/undo
+* Merge branch 'feature/undo' of https://github.com/osrf/traffic_editor into feature/undo
+* Added "save" to newly updated transition entries (`#265 <https://github.com/osrf/traffic_editor/issues/265>`_)
+* Merge pull request `#263 <https://github.com/osrf/traffic_editor/issues/263>`_ from osrf/dont_crash_on_new_project_crowdsim
+* Merge pull request `#257 <https://github.com/osrf/traffic_editor/issues/257>`_ from Briancbn/pr-fix-disable-plugin-backwards-compatibility
+* Merge pull request `#255 <https://github.com/osrf/traffic_editor/issues/255>`_ from osrf/feature/remove-plugin-option
+* Configured gui to load and save proper parameters for plugins
+* Using just the Lift object to propagate the plugin removal option
+* Added option to remove plugins for doors on gui and building_map_tools generator
+* Add GUI to traffic editor for crowd simulation configuration (`#225 <https://github.com/osrf/traffic_editor/issues/225>`_)
+* Merge pull request `#249 <https://github.com/osrf/traffic_editor/issues/249>`_ from osrf/fix/lift_dialog_saving
+* Add first pass of quality declarations for all packages (`#235 <https://github.com/osrf/traffic_editor/issues/235>`_)
+* Contributors: Aaron Chong, Arjo Chakravarty, Chen Bainian, Geoffrey Biggs, Guoliang (Fred) Shao, Marco A. Gutiérrez, Morgan Quigley, Tian En
+
+1.1.0 (2020-09-24)
+------------------
+* Focal / Ignition dome support (`#230 <https://github.com/osrf/traffic_editor/issues/230>`_)
+* Adding lift operation range selection (`#220 <https://github.com/osrf/traffic_editor/issues/220>`_)
+* Add field in lift dialog for initial floor, handle invalid initial floor
+* Update lift display (`#216 <https://github.com/osrf/traffic_editor/issues/216>`_)
+* Allowing modification on vertex coordinates (`#215 <https://github.com/osrf/traffic_editor/issues/215>`_)
+* Merge pull request `#212 <https://github.com/osrf/traffic_editor/issues/212>`_ from osrf/feature/model-list-sort-script
+  Feature/model list sort script
+* Added helper script to sort model_list yamls
+* Support for adding and recognizing lift waypoints for multi-level navigation `#201 <https://github.com/osrf/traffic_editor/issues/201>`_
+* fix initial model angle, so it doesn't rotate 90 when placed (`#202 <https://github.com/osrf/traffic_editor/issues/202>`_)
+* Add button to generate lift waypoints in the GUI
+* Configurable texture and transparency for wall `#200 <https://github.com/osrf/traffic_editor/issues/200>`_
+* fix lifts not cleared when opening another project `#196 <https://github.com/osrf/traffic_editor/issues/196>`_ 
+* New traffic editor thumbnail generator `#191 <https://github.com/osrf/traffic_editor/issues/191>`_
+* View menu option to show/hide models `#174 <https://github.com/osrf/traffic_editor/issues/174>`_
+* Add add_edge shift alignment feature `#173 <https://github.com/osrf/traffic_editor/issues/173>`_
+* Contributors: Aaron Chong, Chen Bainian, Geoffrey Biggs, Kevin_Skywalker, Luca Della Vedova, MakinoharaShouko, Marco A. Gutierrez, Morgan Quigley, Yadu, Yadunund, kevinskwk, methylDragon, youliang
+
+1.0.0 (2020-06-22)
+------------------
+* Implement using thumbnails from installed traffic_editor_assets ament package (`#152 <https://github.com/osrf/traffic_editor/issues/152>`_)
+  * Implement parsing thumbnails from assets ament package
+  * Remove ExternalProject
+  * Update style
+  * Catch missing package error
+  Co-authored-by: Marco A. Gutiérrez <spyke.me@gmail.com>
+* Merge pull request `#153 <https://github.com/osrf/traffic_editor/issues/153>`_ from osrf/bug/model_orientation
+  Fixed orientation of model thumbnails in the gui
+* Fixed orientation of model thumbnails in the gui
+* Merge pull request `#149 <https://github.com/osrf/traffic_editor/issues/149>`_ from osrf/simulation_plugin_interface
+  process-flow sim plugin interface, and various other improvements
+* Merge pull request `#150 <https://github.com/osrf/traffic_editor/issues/150>`_ from osrf/update_style_check
+  Update style.yaml
+* Added braces around for in project.cpp
+* Update traffic_editor/package.xml
+  Co-authored-by: Marco A. Gutiérrez <marco@openrobotics.org>
+* let's not crash when loading an empty map
+* remove unused unique_ptr namespace inclusion
+* merging master
+* Merge pull request `#148 <https://github.com/osrf/traffic_editor/issues/148>`_ from osrf/fix_crop_python_style
+  merging since this is trivial (famous last words)
+* python line was too long
+* Merge pull request `#147 <https://github.com/osrf/traffic_editor/issues/147>`_ from MakinoharaShouko/master
+  Fix not generating cropped image with namespace
+* Fix not generating cropped image with namespace
+* Merge pull request `#1 <https://github.com/osrf/traffic_editor/issues/1>`_ from MakinoharaShouko/crop_fix
+  Fix not generating cropped image with namespace
+* Fix not generating cropped image with namespace
+* simplify by getting rid of pointers where possible
+* since opencv is only needed for video recording, it's now optional
+* hide the sim controls if there is no plugin present
+* Merge pull request `#132 <https://github.com/osrf/traffic_editor/issues/132>`_ from methylDragon/ch3/author-namespaced-thumbnails
+  Support Author-namedspaced Thumbnails and Revamp building_map_generator
+* Merge branch 'master' into ch3/author-namespaced-thumbnails
+* Correct README
+* Merge pull request `#128 <https://github.com/osrf/traffic_editor/issues/128>`_ from methylDragon/ch3/migrate-traffic-editor-thumbnails
+  Migrate thumbnails to traffic_editor_assets repo
+* Fix build and import bug
+* Revert default directory and make directories if they don't exist
+  Also make it less fragile by allowing expansion of the home shortcut "~"
+* Add dependency on buiding_map_tools
+  In order to ensure that pit_crew is accessible!
+* Unify building_map_generators
+  With argparse and pit_crew!
+* Pit-crewify thumbnail_generators
+* thumbnails::yeet()
+  Let's try this again..
+* Merge branch 'master' into ch3/migrate-traffic-editor-thumbnails
+* Merge pull request `#130 <https://github.com/osrf/traffic_editor/issues/130>`_ from osrf/fix/model-thumbnail-names
+  Fix/model thumbnail names
+* Corrected thumbnail for PotatoChipChair
+* Changed the name for model and thumbnail Table
+* Retarget thumbnail search path to ~/.traffic_editor
+* Implement git clone on build
+* avoid deadlock
+* adding debugging drawing hooks to simulation plugin interface
+* osrf repo
+* migrate behavior stuff into plugins, out of main tree
+* render mixed lane colors in a predictable z-stack
+* remove logging from the core traffic-editor, do it in plugins
+* option to release reserved lanes during waiting behavior node
+* adjust mutex: sim proceeds while video frame is writing to disk
+* helper function to retrieve model instances
+* WIP simplifying internal API and removing YAML scripting nonsense
+* add load function to configure simulation interface from yaml
+* epic restructuring of include files to allow a plugin interface for sim
+* Merge pull request `#118 <https://github.com/osrf/traffic_editor/issues/118>`_ from osrf/feature/teleport-dispenser
+  Feature/teleport dispenser
+* learn cmake
+* WIP trying to bring in ignition-plugin
+* log simulations to csv
+* models name instances can be edited, and saved
+* print less to the console
+* added teleport dispenser ingestor thumbnails, same as robot placeholder
+* allow editing of model instance name
+* on startup, restore editor to previous level
+* WIP process flow animation machinery
+* Merge pull request `#117 <https://github.com/osrf/traffic_editor/issues/117>`_ from osrf/master
+  bring in medium-size surgical trolley
+* Merge pull request `#116 <https://github.com/osrf/traffic_editor/issues/116>`_ from osrf/feature/surgical-trolley-med
+  added thumbnail for SurgicalTrolleyMed
+* added thumbnail for SurgicalTrolleyMed
+* restore rotation of StorageRack thumbnail
+* Merge pull request `#115 <https://github.com/osrf/traffic_editor/issues/115>`_ from osrf/master
+  bring new thumbnails to dev branch
+* Merge pull request `#114 <https://github.com/osrf/traffic_editor/issues/114>`_ from osrf/feature/trolley-bed-thumbnails
+  Feature/trolley bed thumbnails
+* copied to wrong places, replaced old thumbnails
+* added thumbnails
+* WIP teleporting other models for cargo pickup/dropoff
+* improve nav graph following, simplify creation of non-zero graph_idx
+* Merge pull request `#113 <https://github.com/osrf/traffic_editor/issues/113>`_ from osrf/master
+  merge in thumbnail improvements
+* Merge pull request `#112 <https://github.com/osrf/traffic_editor/issues/112>`_ from osrf/feature/more-thumbnails
+  added new thumbnails for hospital environment
+* added new thumbnails for hospital environment
+* WIP smarter NPC motions...
+* clean up compiler warnings
+* add string interpolation and a signaling method
+* set vertex label red if selected. try to fix github build workflow
+* checkboxes for show/hide internal traffic lanes. sim starts paused.
+* use opencv for video recording
+* loop at end of behavior schedule
+* rotate models to face the direction of travel
+* path traversal starting to work
+* basic a* planner seems ok
+* WIP agent planning
+* WIP scenario non-robot animation
+* WIP towards beginnings of 2d model scripting
+* load images concurrently on all CPU cores
+* Merge pull request `#111 <https://github.com/osrf/traffic_editor/issues/111>`_ from osrf/fix/robot-placeholder-thumbnails
+  fix model thumbnail and naming convention
+* fix model thumbnail and naming convention
+* Merge pull request `#110 <https://github.com/osrf/traffic_editor/issues/110>`_ from osrf/fix/thumbnail-name
+  fixed bookshelf thumbnail name
+* propagate unique_ptr usage to allow polymorphic compositions
+* fixed bookshelf thumbnail name
+* allow modifying of lanes in traffic mode and simplify renderings of bidirectional lanes.
+* don't insert scenario table twice
+* beginnings of sim thread
+* learning about elite c++11 memory features
+* working towards minimalist behavior sequencing
+* Merge pull request `#108 <https://github.com/osrf/traffic_editor/issues/108>`_ from osrf/feature/new-thumbnails
+  Feature/new thumbnails
+* removed empty newlines
+* changed back camera height
+* corrected thumbnail names to point to open source gazebo models
+* WIP external traffic files
+* more gazebo thumbnails, compressed largge thumbnails
+* add skeleton for traffic map dialog
+* render traffic map names in tablewidget
+* Merge pull request `#104 <https://github.com/osrf/traffic_editor/issues/104>`_ from osrf/feature/thumbnail-generation
+  Feature/thumbnail generation
+* save/load traffic-map references in project file
+* lint :sparkles:
+* added generation and merging utility scripts
+* removed ros2 launch
+* basic pipeline and docs added
+* start of external traffic map files in GUI
+* Merge pull request `#103 <https://github.com/osrf/traffic_editor/issues/103>`_ from osrf/feature/demo-assets
+  added new demo asset thumbnails
+* added new demo asset thumbnails
+* Merge pull request `#100 <https://github.com/osrf/traffic_editor/issues/100>`_ from osrf/double_swing_doors_directions
+  branch on double swing door direction for sim generation
+* branch on double swing door direction for sim generation
+* Merge pull request `#94 <https://github.com/osrf/traffic_editor/issues/94>`_ from osrf/static_parameter_for_models
+  Static parameter for models
+  Tested manually on a few worlds, looks OK
+* add static param to models in GUI
+* Merge pull request `#90 <https://github.com/osrf/traffic_editor/issues/90>`_ from osrf/feature/single-doors
+  Feature/single doors
+* abs values for motion degrees, use motion direction instead
+* fix merge conflict
+* Merge pull request `#81 <https://github.com/osrf/traffic_editor/issues/81>`_ from osrf/add_flattened_offsets
+  XY translation of each level in a 'flattened' world generation mode
+* XY translation of each level in a 'flattened' world generation mode
+* Merge pull request `#80 <https://github.com/osrf/traffic_editor/issues/80>`_ from osrf/floor_holes
+  Floor holes
+* click selects holes first, then other polygon types
+* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into floor_holes
+* Merge pull request `#79 <https://github.com/osrf/traffic_editor/issues/79>`_ from osrf/feature/model-elevation
+  Feature/model elevation
+* reverted back to using double for model::z, makes yaml parsing cleaner
+* clear all fields of project when creating a new one
+* added elevation/z param to model
+* WIP floor holes GUI tool
+* add some icons as we add a new tool for polygon-holes
+* only override drawing scale if >2 fiducials are present
+* more small fixes for levels without scale
+* trivial: update level table after adding a level
+* Merge pull request `#71 <https://github.com/osrf/traffic_editor/issues/71>`_ from osrf/fix_initial_creation_workflow
+  Fix initial creation workflow. Load drawing floorplan images immediately after they are specified in the level dialog, rather than only doing it when loading the building level from YAML.
+* refactor drawing loading so it can happen after level dialog also
+* fix crash when no levels are present
+* Merge pull request `#69 <https://github.com/osrf/traffic_editor/issues/69>`_ from osrf/create_vertex_when_starting_wall
+  create a new vertex if the add-edge click is not near an existing one
+* create a new vertex if the add-edge click is not near an existing one
+* Merge pull request `#67 <https://github.com/osrf/traffic_editor/issues/67>`_ from osrf/create_vertex_as_needed_for_edges
+  finish implementing `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ to allow continuous clicks for edge creation
+* finish implementing `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ to allow continuous clicks for edge creation
+* Merge pull request `#66 <https://github.com/osrf/traffic_editor/issues/66>`_ from osrf/click_walls_instead_of_drag
+  implement part of `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ so you can just keep clicking to chain vertices together
+* don't automatically chain doors/measurements in edge tool
+* implement part of `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ so you can just keep clicking to chain vertices together
+* Merge pull request `#64 <https://github.com/osrf/traffic_editor/issues/64>`_ from osrf/specify_floor_textures
+  Specify floor textures
+* allow specification of floor texture and scale
+* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into specify_floor_textures
+* fix `#62 <https://github.com/osrf/traffic_editor/issues/62>`_, scale vertex click and paint doorjamb last
+* add explicit polygon texture params for now
+* Merge pull request `#59 <https://github.com/osrf/traffic_editor/issues/59>`_ from osrf/scenario_roi_polygon_tool
+  lots of refactoring and cleanup to allow modifying scenario polygons
+* lots of refactoring and cleanup to allow modifying scenario polygons
+* Merge pull request `#58 <https://github.com/osrf/traffic_editor/issues/58>`_ from osrf/restore_viewport_center_and_zoom
+  restore viewport translation and scale on startup
+* restore viewport translation and scale on startup
+* update readme
+* draw traffic vertices in building coords still, for now
+* Merge pull request `#53 <https://github.com/osrf/traffic_editor/issues/53>`_ from osrf/correct_thumbnail_size
+  use cropped thumbnails. add four new models.
+* use cropped thumbnails. add four new models.
+* Merge pull request `#52 <https://github.com/osrf/traffic_editor/issues/52>`_ from osrf/separate_building_map_and_traffic_map_files
+  Separate building map and traffic map files
+* fix move-model bug
+* allow deleting vertices from scenario
+* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into separate_building_map_and_traffic_map_files
+* working towards adding vertices in scenarios
+* change toolbar in response to edit mode. add to scenario skeleton.
+* scenario save/load skeleton
+* start scenario data structure
+* add tabs
+* project dialog box to set the building path
+* starting to place building within a project...
+* Merge pull request `#51 <https://github.com/osrf/traffic_editor/issues/51>`_ from osrf/add_thumbnails
+  add some new office furniture thumbnails
+* add some new office furniture thumbnails
+* finish propagating and refactoring buildings, so things compile again
+* everything is now broken
+* migrate Map to Building class
+* Merge pull request `#49 <https://github.com/osrf/traffic_editor/issues/49>`_ from osrf/restore_window_position_and_size
+  use qsettings to save/restore window position and size
+* use qsettings to save/restore window position and size
+* Merge pull request `#48 <https://github.com/osrf/traffic_editor/issues/48>`_ from osrf/add_elevation_to_level_dialog
+  set level elevation via dialog box. Various cleanups.
+* set level elevation via dialog box. Various cleanups.
+* Merge pull request `#46 <https://github.com/osrf/traffic_editor/issues/46>`_ from osrf/calculate_and_show_scale_using_fiducials
+  Calculate and show scale using fiducials
+* use measurement data only on the reference level. otherwise, ficudials
+* fix QGraphicsView item lookup to fix regression in selecting doors/walls
+* specify reference level via map-dialog box
+* redraw scene immediately after adding level
+* Merge branch 'master' into calculate_and_show_scale_using_fiducials
+* Merge pull request `#45 <https://github.com/osrf/traffic_editor/issues/45>`_ from osrf/fix_new_document_problems
+  deal more gracefully with an empty world by not crashing
+* deal more gracefully with an empty world by not crashing
+* update docs to reflect new way to add levels
+* map dialog for 'global' model properties
+* factor level table into its own file. add meas+fiducial counts to it.
+* Merge pull request `#42 <https://github.com/osrf/traffic_editor/issues/42>`_ from osrf/align_lift_layer
+  Fiducials to align layers
+* level alignment starting to work hooray
+* WIP alignment
+* working towards fiducial alignment
+* Merge pull request `#41 <https://github.com/osrf/traffic_editor/issues/41>`_ from osrf/create_lifts
+  Lifts
+* make ficudials easier to see
+* add fiducial tool
+* rotate lift doors correctly. Fix lift door yaml load bug
+* copy lift-door checkbox matrix to data structure on OK button
+* change data structure to deal with multi-door scenario on same level
+* respond appropriately to edits in door table
+* push lift elements into QGraphicsGroup and don't transform in dialog rendering
+* live updates for lift preview
+* start rendering lifts on the map using modeless dialog param updates
+* save lift x,y,yaw,width,depth
+* update level-door table combo box options when a door name changes
+* add tables for editing doors and level-door mapping
+* start working on adding lifts
+* Merge pull request `#39 <https://github.com/osrf/traffic_editor/issues/39>`_ from osrf/some_toolbar_icons
+  add a few toolbar icons
+* add a few toolbar icons
+* Merge pull request `#38 <https://github.com/osrf/traffic_editor/issues/38>`_ from osrf/set_modified_flag
+  Set modified flag
+* Merge pull request `#37 <https://github.com/osrf/traffic_editor/issues/37>`_ from osrf/unify_move_tools
+  unify move-vertex and move-model tools. Toolbar on top.
+* ask to save changes on exit
+* unify move-vertex and move-model tools. Toolbar on top.
+* Merge pull request `#35 <https://github.com/osrf/traffic_editor/issues/35>`_ from osrf/levels_layers_tabs
+  migrate level selection from a button bar into a tabbed table
+* migrate level selection from a button bar into a tabbed table
+* Merge pull request `#34 <https://github.com/osrf/traffic_editor/issues/34>`_ from osrf/editor_ui_cleanup
+  Editor UI cleanup
+* allow deletion of vertices and models
+* refactoring model selection into its own dialog
+* Merge pull request `#33 <https://github.com/osrf/traffic_editor/issues/33>`_ from osrf/add_more_models
+  Add more models
+* trolley bed thumbnails
+* storage rack model thumbnail
+* add new model thumbnails
+* add storage rack thumbnails
+* trivial cleanup
+* Merge pull request `#32 <https://github.com/osrf/traffic_editor/issues/32>`_ from osrf/use_layer_visibility_checkboxes
+  use checkboxes to specify layer visibility
+* oops. optional parameter...
+* Merge pull request `#31 <https://github.com/osrf/traffic_editor/issues/31>`_ from osrf/rendering_layers_controls
+  Rendering layers controls
+* fix compile
+* rendering starting to work
+* render layers
+* layer yaml save/load, working towards layer dialog
+* annotate YAML document with flow styles, and emit them
+* add layer table and dialog for add/edit layers
+* working towards selectable layers
+* Merge pull request `#28 <https://github.com/osrf/traffic_editor/issues/28>`_ from osrf/generate_doors
+  Generate doors
+* add various door gazebo generation stuff and demo mock lift floor changes
+* Merge pull request `#27 <https://github.com/osrf/traffic_editor/issues/27>`_ from osrf/add_dock_points
+  add dock points and generate docking nav graph params
+* add dock points and generate docking nav graph params
+* Merge pull request `#25 <https://github.com/osrf/traffic_editor/issues/25>`_ from osrf/rotate_models_visually_with_discretization
+  show model pixmaps rotating, with optional discretization
+* show model pixmaps rotating, with optional discretization
+* Merge pull request `#21 <https://github.com/osrf/traffic_editor/issues/21>`_ from osrf/spawn_robot_parameters
+  robot parameters for spawning and Gazebo world generation
+* create vertex parameters for spawning robots in simulation
+* Merge pull request `#19 <https://github.com/osrf/traffic_editor/issues/19>`_ from osrf/redraw_after_new_file_create
+  redraw after file->new, also give explicit model path for gazebo gen
+* redraw after file->new, also give explicit model path for gazebo gen
+* Merge pull request `#18 <https://github.com/osrf/traffic_editor/issues/18>`_ from osrf/add_install_target
+  add install step in cmake
+* add install step in cmake
+* Merge pull request `#17 <https://github.com/osrf/traffic_editor/issues/17>`_ from osrf/ci_update_first
+  update before installing in github workflow
+* update before installing in github workflow
+* Merge pull request `#16 <https://github.com/osrf/traffic_editor/issues/16>`_ from osrf/repository_reorganization
+  Repository reorganization
+* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into repository_reorganization
+* grand reorganization as colcon-buildable packages for ros2 integration
+* Contributors: Aaron, Aaron Chong, MakinoharaShouko, Morgan Quigley, Yadu, Yadunund, methylDragon
diff --git a/traffic_editor/CMakeLists.txt b/traffic_editor/CMakeLists.txt
new file mode 100644
index 0000000..ea0e7b8
--- /dev/null
+++ b/traffic_editor/CMakeLists.txt
@@ -0,0 +1,173 @@
+cmake_minimum_required(VERSION 3.10.0)
+
+if(NOT CMAKE_CXX_STANDARD)
+  set(CMAKE_CXX_STANDARD 14)
+endif()
+
+project(traffic_editor)
+
+find_package(yaml-cpp REQUIRED)
+find_package(ament_cmake REQUIRED)
+
+set(CMAKE_BUILD_TYPE RelWithDebInfo)
+# set(CMAKE_VERBOSE_MAKEFILE TRUE)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wshadow -Wextra")
+
+set(CMAKE_AUTOMOC ON)
+set(CMAKE_AUTORCC ON)
+set(CMAKE_AUTOUIC ON)
+
+if(CMAKE_VERSION VERSION_LESS "3.7.0")
+  set(CMAKE_INCLUDE_CURRENT_DIR ON)
+endif()
+
+find_package(Qt5 COMPONENTS Widgets Concurrent REQUIRED)
+find_package(ignition-plugin1 QUIET COMPONENTS all)
+find_package(ignition-common3 QUIET)
+find_package(ament_index_cpp REQUIRED)
+
+# OpenCV is an optional dependency, only needed if you want to make videos
+# which is only really needed if you're using a process simulation plugin
+find_package(OpenCV QUIET)
+
+include_directories(.)
+include_directories(gui)
+include_directories(include)
+include_directories(${ament_index_cpp_INCLUDE_DIRS})
+
+set(traffic_editor_sources
+  gui/actions/add_edge.cpp
+  gui/actions/add_fiducial.cpp
+  gui/actions/add_model.cpp
+  gui/actions/add_polygon.cpp
+  gui/actions/add_property.cpp
+  gui/actions/add_vertex.cpp
+  gui/actions/delete.cpp
+  gui/actions/move_fiducial.cpp
+  gui/actions/move_model.cpp
+  gui/actions/move_vertex.cpp
+  gui/actions/polygon_remove_vertices.cpp
+  gui/actions/polygon_add_vertex.cpp
+  gui/actions/rotate_model.cpp
+  gui/add_param_dialog.cpp
+  gui/building.cpp
+  gui/building_dialog.cpp
+  gui/building_level.cpp
+  gui/building_level_dialog.cpp
+  gui/building_level_table.cpp
+  gui/edge.cpp
+  gui/editor.cpp
+  gui/editor_model.cpp
+  gui/fiducial.cpp
+  gui/layer.cpp
+  gui/layer_dialog.cpp
+  gui/level.cpp
+  gui/lift.cpp
+  gui/lift_dialog.cpp
+  gui/lift_door.cpp
+  gui/lift_table.cpp
+  gui/main.cpp
+  gui/map_view.cpp
+  gui/model.cpp
+  gui/model_dialog.cpp
+  gui/param.cpp
+  gui/polygon.cpp
+  gui/preferences_dialog.cpp
+  gui/preferences_keys.cpp
+  gui/project.cpp
+  gui/project_dialog.cpp
+  gui/scenario.cpp
+  gui/scenario_dialog.cpp
+  gui/scenario_level.cpp
+  gui/scenario_table.cpp
+  gui/table_list.cpp
+  gui/traffic_table.cpp
+  gui/traffic_map.cpp
+  gui/traffic_map_dialog.cpp
+  gui/vertex.cpp
+  gui/yaml_utils.cpp
+  resources/resource.qrc
+
+  #crowd_sim related
+  gui/multi_select_combo_box.cpp
+  gui/crowd_sim/agent_group.cpp
+  gui/crowd_sim/agent_group_table.cpp
+  gui/crowd_sim/agent_profile.cpp
+  gui/crowd_sim/agent_profile_table.cpp
+  gui/crowd_sim/condition.cpp
+  gui/crowd_sim/condition_dialog.cpp
+  gui/crowd_sim/crowd_sim_dialog.cpp
+  gui/crowd_sim/crowd_sim_editor_table.cpp
+  gui/crowd_sim/crowd_sim_impl.cpp
+  gui/crowd_sim/crowd_sim_table_base.cpp
+  gui/crowd_sim/goal_set.cpp
+  gui/crowd_sim/goal_set_table.cpp
+  gui/crowd_sim/model_type.cpp
+  gui/crowd_sim/model_type_table.cpp
+  gui/crowd_sim/state.cpp
+  gui/crowd_sim/state_table.cpp
+  gui/crowd_sim/to_state_dialog.cpp
+  gui/crowd_sim/to_state_table.cpp
+  gui/crowd_sim/transition.cpp
+  gui/crowd_sim/transition_table.cpp
+)
+
+set(traffic_editor_libs
+  Qt5::Widgets
+  Qt5::Concurrent
+  yaml-cpp
+  ${ament_index_cpp_LIBRARIES}
+  ${OpenCV_LIBS}
+)
+
+if (ignition-plugin1_VERSION)
+  set(traffic_editor_sources
+    ${traffic_editor_sources}
+    gui/sim_thread.cpp
+  )
+  set(traffic_editor_libs
+    ${traffic_editor_libs}
+    ignition-plugin1::core
+    ignition-plugin1::loader
+    ignition-common3::core
+  )
+endif()
+
+add_executable(traffic-editor ${traffic_editor_sources})
+target_link_libraries(traffic-editor ${traffic_editor_libs})
+
+if (ignition-plugin1_VERSION)
+  # sadly this if() block has to come after add_executable(), but
+  # the if() block determining the sources has to go before add_executable()
+  target_compile_definitions(traffic-editor PUBLIC "HAS_IGNITION_PLUGIN")
+endif()
+
+if (OpenCV_VERSION)
+  target_compile_definitions(traffic-editor PUBLIC "HAS_OPENCV")
+endif()
+
+set_property(TARGET traffic-editor PROPERTY ENABLE_EXPORTS 1)
+
+install(
+  TARGETS traffic-editor
+  LIBRARY DESTINATION lib
+  RUNTIME DESTINATION bin
+)
+
+install(
+  DIRECTORY
+    plugins
+  DESTINATION
+    include/traffic_editor)
+
+install(
+  DIRECTORY
+    include/traffic_editor
+  DESTINATION
+    include)
+
+
+ament_export_include_directories(include)
+
+ament_package()
diff --git a/traffic_editor/LICENSE b/traffic_editor/LICENSE
new file mode 100644
index 0000000..261eeb9
--- /dev/null
+++ b/traffic_editor/LICENSE
@@ -0,0 +1,201 @@
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/traffic_editor/QUALITY_DECLARATION.md b/traffic_editor/QUALITY_DECLARATION.md
new file mode 100644
index 0000000..bf7cc33
--- /dev/null
+++ b/traffic_editor/QUALITY_DECLARATION.md
@@ -0,0 +1,158 @@
+This document is a declaration of software quality for the `traffic_editor` package, based on the guidelines in [REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+# `traffic_editor` Quality Declaration
+
+The package `traffic_editor` claims to be in the **Quality Level 4** category.
+
+Below are the rationales, notes, and caveats for this claim, organized by each requirement listed in the [Package Requirements for Quality Level 4 in REP-2004](https://www.ros.org/reps/rep-2004.html).
+
+## Version Policy [1]
+
+### Version Scheme [1.i]
+
+`traffic_editor` uses `semver` according to the recommendation for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#versioning).
+
+### Version Stability [1.ii]
+
+`traffic_editor` is at a stable version, i.e. `>= 1.0.0`.
+The current version can be found in its [package.xml](package.xml), and its change history can be found in its [CHANGELOG](CHANGELOG.rst).
+
+### Public API Declaration [1.iii]
+
+All symbols in the installed headers are considered part of the public API.
+
+All installed headers are in the `include` directory of the package.
+Headers in any other folders are not installed and are considered private.
+
+### API Stability Policy [1.iv]
+
+`traffic_editor` will not break public API within a major version number.
+
+### ABI Stability Policy [1.v]
+
+`traffic_editor` will not break public ABI within a major version number.
+
+### API and ABI Stability Within a Released ROS Distribution [1.vi]
+
+`traffic_editor` will not break public API or ABI within a released ROS distribution, i.e. no major releases into the same ROS distribution once that ROS distribution is released.
+
+## Change Control Process [2]
+
+`traffic_editor` follows the recommended guidelines for ROS Core packages in the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#package-requirements).
+
+### Change Requests [2.i]
+
+`traffic_editor` requires that all changes occur through a pull request.
+
+### Contributor Origin [2.ii]
+
+`traffic_editor` does not require a confirmation of contributor origin.
+
+### Peer Review Policy [2.iii]
+
+All pull requests must have at least 1 peer review.
+
+### Continuous Integration [2.iv]
+
+All pull requests must pass CI on all platforms supported by RMF.
+The CI checks only that the package builds.
+The most recent CI results can be seen on [the workflow page](https://github.com/osrf/traffic_editor/actions).
+
+### Documentation Policy [2.v]
+
+All pull requests must resolve related documentation changes before merging.
+
+## Documentation [3]
+
+### Feature Documentation [3.i]
+
+`traffic_editor` provides usage documentation in its [README file](README.md).
+
+### Public API Documentation [3.ii]
+
+`traffic_editor` does not document its public API.
+
+### License [3.iii]
+
+The license for `traffic_editor` is Apache 2.0, the type is declared in the [package.xml](package.xml) manifest file, and a full copy of the license is in the repository level [LICENSE](../LICENSE) file.
+
+### Copyright Statement [3.iv]
+
+The copyright holders each provide a statement of copyright in each source code file in `traffic_editor`.
+
+### Quality declaration document [3.v]
+
+This quality declaration is linked in the [README file](README.md).
+
+This quality declaration has not been externally peer-reviewed and is not registered on any Level 4 lists.
+
+## Testing [4]
+
+### Feature Testing [4.i]
+
+`traffic_editor` does not have feature tests.
+
+### Public API Testing [4.ii]
+
+`traffic_editor` does not have API tests.
+
+### Coverage [4.iii]
+
+`traffic_editor` does not track coverage statistics.
+
+### Performance [4.iv]
+
+`traffic_editor` does not test performance.
+
+### Linters and Static Analysis [4.v]
+
+`traffic_editor` does not use the standard linters and static analysis tools for its CMake code to ensure it follows the [ROS 2 Developer Guide](https://index.ros.org/doc/ros2/Contributing/Developer-Guide/#linters).
+
+## Dependencies [5]
+
+### Direct Runtime ROS Dependencies [5.i]
+
+`traffic_editor` has no direct runtime ROS dependencies.
+
+### Optional Direct Runtime ROS Dependencies [5.ii]
+
+`traffic_editor` has no optional runtime ROS dependencies.
+
+### Direct Runtime non-ROS Dependency [5.iii]
+
+Below are the required direct runtime non-ROS dependencies of `traffic_editor` and their evaluations.
+
+#### ignition-plugin
+
+`ignition-plugin` is assumed to be **Quality Level 3** based on its change control process, CI, tests, and documentation.
+
+#### ignition-common3
+
+`ignition-common3` is assumed to be **Quality Level 3** based on its change control process, CI, tests, and documentation.
+
+#### yaml-cpp
+
+The [`yaml-cpp` library](https://github.com/jbeder/yaml-cpp) is assumed to be **Quality Level 3** due to its wide use, provided documentation, use of testing, and version number above 1.0.0.
+
+#### libqt5-concurrent
+
+`libqt5-concurrent` is widely-used third-party software for building graphical applications.
+Due to its wide use, documentation, and testing, it is assumed to be **Quality Level 3**.
+
+#### libqt5-widgets
+
+`libqt5-widgets` is widely-used third-party software for building graphical applications.
+Due to its wide use, documentation, and testing, it is assumed to be **Quality Level 3**.
+
+## Platform Support [6]
+
+### Target platforms [6.i]
+
+`traffic_editor` does not support all of the tier 1 platforms as described in [REP-2000](https://www.ros.org/reps/rep-2000.html#support-tiers).
+`traffic_editor` supports ROS Eloquent.
+
+## Security [7]
+
+### Vulnerability Disclosure Policy [7.i]
+
+This package conforms to the Vulnerability Disclosure Policy in [REP-2006](https://www.ros.org/reps/rep-2006.html).
diff --git a/traffic_editor/README.md b/traffic_editor/README.md
new file mode 100644
index 0000000..209b091
--- /dev/null
+++ b/traffic_editor/README.md
@@ -0,0 +1,151 @@
+![](https://github.com/osrf/traffic_editor/workflows/build/badge.svg)
+
+# Traffic Editor
+A graphical editor for robot traffic flows. The intent is to make it easy
+to annotate building floorplans with the desired robot traffic lanes and
+generate simulation models to test and evaluate different traffic schemes.
+
+## Quality Declaration
+
+This package claims to be in the **Quality Level 3** category.
+See the [Quality Declaration](./QUALITY_DECLARATION.md) for more details.
+
+## System Requirements
+
+This program is developed and tested on
+[Ubuntu 18.04 LTS](http://releases.ubuntu.com/18.04/), using
+[Qt 5](https://doc.qt.io/qt-5/qt5-intro.html) and
+[`yaml-cpp`](https://github.com/jbeder/yaml-cpp).
+
+## Compiling Instructions
+Traffic Editor is now structured as a Colcon package. After installing
+ROS 2 Eloquent, the following command sequence will create a colcon
+workspace in `~/colcon_workspace` and build `traffic-editor` there:
+
+```bash
+sudo apt update
+sudo apt install libyaml-cpp-dev qt5-default \
+  libopencv-dev libopencv-videoio-dev \
+  libignition-plugin-dev libignition-common3-dev
+mkdir -p ~/colcon_workspace/src
+cd ~/colcon_workspace/src
+git clone https://github.com/osrf/traffic_editor
+cd ~/colcon_workspace
+source /opt/ros/eloquent/setup.bash
+colcon build --packages-select traffic_editor
+```
+
+You are also **highly recommended** to also install the companion `traffic_editor_assets`
+package, which contains a nifty bunch of useful assets to use with `traffic_editor`.
+
+```bash
+cd ~/colcon_workspace/src
+git clone https://github.com/osrf/traffic_editor_assets
+cd ~/colcon_workspace
+source /opt/ros/eloquent/setup.bash
+colcon build --packages-select traffic_editor_assets
+```
+
+Then you should be able to run `traffic-editor` by sourcing the install
+space of that workspace, in a new "clean" terminal:
+```bash
+source ~/colcon_workspace/install/setup.bash
+traffic-editor
+```
+
+# Quick Start
+
+If it's the first time you are running it, starting the editor with
+`traffic-editor` should bring up a blank window.
+
+First, you'll need to make sure that `traffic-editor` knows where the
+model thumbnails are found. If you installed `traffic_editor_assets`,
+`traffic_editor` should find it automatically. The thumbnails are
+top-view renderings of various art assets that can be added to the
+environments, such as chairs.
+
+Click `Edit->Preferences...` and see if the path provided in the "Thumbnail Path" box looks reasonable. 
+
+If necessary, the "Find..." button can be used to browse the filesystem to point to any desired thumbnail directory.
+
+(If you installed the recommended `traffic_editor_assets` package, you will find its thumbnail directory in its install space at `<workspace_dir>/install/traffic_editor_assets/share/assets/thumbnails`.)
+
+### Creating a new Project and an empty Building Map
+
+Click `Project->New...` and save your new project as `test.project.yaml`
+
+Click `Edit->Project Properties...` and enter "test" as the project name and `test.building.yaml` as the building path. Then click OK.
+
+Click `Edit->Building Properties...` and enter "test" as the building name.
+Click OK.
+
+### Creating a level and adding some stuff
+
+Click the "Add..." button in the "levels" tab on the far right side of the main editor window. This will pop up a dialog where you can create a new level. Enter `L1` for the name and click OK. This will create a 10 meter square level.
+
+You can zoom in and out using the mouse wheel on the rendering on the left side of the main window. You can pan around by dragging the mouse around with the mouse wheel (or middle button) depressed.
+
+Now, you should be able to click the green dot toolbar icon, which is the "Add Vertex" tool (or press `V`) and click a few vertices in the white area. Press the `[Escape]` key to return to the "Select" tool.
+
+Now, you should be able to click the `add wall` tool (or press `W`) and drag from one vertex to another vertex to add wall segments.
+
+To delete wall segments or vertices, first press `[Escape]` to enter Select mode. Then, click on a wall segment or vertex, and press `[Delete]`.
+
+### Save your work
+
+Click `Project->Save` or press `Ctrl+S` to save the project and building map.
+
+### Adding real-world measurements to set the scale
+
+To set the scale of the drawing, click the `add measurement` tool (or press `M`) and drag from one vertex to another to add a real-world measurement line, which should show up as a pink line. Then click the `select` tool (or press `Esc`) and click on the line with the left button. This should populate the property-editor in the lower-right pane of the editor window. You can then specify the real-world length of the measurement line in meters. If you set more than one measurement line on a drawing, the editor will compute an average value of pixels-per-meter from all supplied measurements.
+
+Currently you need to re-load the document (closing the editor and re-opening) to re-compute the scale. This is not ideal, but is hopefully not a frequently-used feature. Typically the scale of a map is only set one time.
+
+### Adding lifts
+
+Click the "Add..." button in the "lifts" tab on the far right side of the main editor window. This will pop up a dialog where you can create a new lift. You can specify the name, position, size, and reference floor in the dialog.
+
+*Note: Do include the keywork "lift" in the lift name as for now this is how slotcars recognize lift models.*
+
+You can add lift doors by lick the "Add..." button below the box showing the lift. Set Door type to "Double sliding" (The only supported type for now!), and align the doors to the edge of the lift (represented by the green box). After that, select which door you want to use on each floor by simply checking the boxes on the left.
+
+Lift waypoints at the center of the lift on each level can also be generated using the "Add lift waypoints" button in the dialog. Note that waypoints will only be generated on levels that the lift is serving (has a door opening on that level).
+
+### Generating Custom Thumbnails
+
+Model thumbnails are used in `traffic_editor`. To generate a thumbnail, a simple working example is shown here to generate a `SUV`:
+```bash
+# Run as gz plugin, set --a for help options printout
+gzserver -s libthumbnail_generator.so empty.world --input ~/.gazebo/models/SUV/model.sdf --output .
+```
+After execution, you will notice a newly created `SUV.png` in your current working directory. This can be further placed into `traffic_editor_assets/assets/thumbnails`.
+
+To generate multiple model thumbnails listed in `model_list.yaml`, run this:
+```bash
+export GAZEBO_MODEL_PATH=/PATH/TO/MODELS; ./scripts/generate_thumbnails.py /PATH/TO/MODELS test/model_list.yaml ~/output
+```
+
+User can also change the script default configs:  `img_size`, `cam_height` and `fhov`, which will alter the `meters_per_pixel` value.
+
+Similarly, the generated thumbnails in `~/output` can then be added to `traffic_editor_assets/assets/thumbnails`, while also append `model_list.yaml`.
+
+### Utilities
+
+A new model list `.yaml` file can be generated using the utility script, where an optional blacklisted model names can be added, to avoid creating moving models or agents,
+
+```bash
+# e.g. MODEL_DIR = '~/.gazebo/models'
+./scripts/generate_model_list.py output_model_list.yaml -d MODEL_DIR -b test/model_blacklist.yaml
+```
+
+In the event that merging multiple model lists is required, a different utility script can be used,
+
+```bash
+./scripts/merge_model_lists.py output_model_list.yaml -s test/model_list.yaml
+```
+
+To sort the model list `.yaml` file,
+
+```bash
+./scripts/sort_model_list.py model_list.yaml
+```
diff --git a/traffic_editor/gui/actions/add_edge.cpp b/traffic_editor/gui/actions/add_edge.cpp
new file mode 100644
index 0000000..b7bd0e8
--- /dev/null
+++ b/traffic_editor/gui/actions/add_edge.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "add_edge.h"
+
+AddEdgeCommand::AddEdgeCommand(Project* project, int level_idx)
+{
+  _project = project;
+  _level_idx = level_idx;
+  _first_point_not_exist = false;
+  _first_point_drawn = false;
+  _second_point_not_exist = false;
+  _second_point_drawn = false;
+  _edge_snapshot = _project->building.levels[_level_idx].edges;
+  _vert_snapshot = _project->building.levels[_level_idx].vertices;
+}
+
+AddEdgeCommand::~AddEdgeCommand()
+{
+
+}
+
+void AddEdgeCommand::redo()
+{
+  _project->building.levels[_level_idx].vertices = _final_snapshot;
+  if (_type != Edge::LANE)
+  {
+    _project->building.add_edge(
+      _level_idx,
+      _vert_id_first,
+      _vert_id_second,
+      _type);
+  }
+  else
+  {
+    _project->add_lane(
+      _level_idx,
+      _vert_id_first,
+      _vert_id_second);
+  }
+}
+
+void AddEdgeCommand::undo()
+{
+  //Just use snapshots to keep things simpler
+  _project->building.levels[_level_idx].edges = _edge_snapshot;
+  _project->building.levels[_level_idx].vertices = _vert_snapshot;
+}
+
+int AddEdgeCommand::set_first_point(double x, double y)
+{
+  _first_x = x;
+  _first_y = y;
+
+  const double vertex_dist_thresh_pixels =
+    _vertex_radius_meters /
+    _project->building.levels[_level_idx].drawing_meters_per_pixel;
+
+  int clicked_idx = _project->building.nearest_item_index_if_within_distance(
+    _level_idx,
+    x,
+    y,
+    vertex_dist_thresh_pixels,
+    Building::VERTEX);
+
+  _first_point_drawn = true;
+  if (clicked_idx < 0)
+  {
+    _first_point_not_exist = true;
+    _project->building.add_vertex(_level_idx, x, y);
+    clicked_idx = _project->building.levels[_level_idx].vertices.size()-1;
+  }
+  _vert_id_first = clicked_idx;
+  _final_snapshot = _project->building.levels[_level_idx].vertices;
+  return clicked_idx;
+}
+
+int AddEdgeCommand::set_second_point(double x, double y)
+{
+  _second_x = x;
+  _second_y = y;
+
+  const double vertex_dist_thresh_pixels =
+    _vertex_radius_meters /
+    _project->building.levels[_level_idx].drawing_meters_per_pixel;
+
+  int clicked_idx = _project->building.nearest_item_index_if_within_distance(
+    _level_idx,
+    x,
+    y,
+    vertex_dist_thresh_pixels,
+    Building::VERTEX);
+
+  _second_point_drawn = true;
+
+  if (clicked_idx < 0)
+  {
+    _second_point_not_exist = true;
+    _second_point_drawn = true;
+    _project->building.add_vertex(_level_idx, x, y);
+    clicked_idx = _project->building.levels[_level_idx].vertices.size()-1;
+  }
+  _vert_id_second = clicked_idx;
+  _final_snapshot = _project->building.levels[_level_idx].vertices;
+  return clicked_idx;
+}
+
+void AddEdgeCommand::set_edge_type(Edge::Type type)
+{
+  _type = type;
+}
diff --git a/traffic_editor/gui/actions/add_edge.h b/traffic_editor/gui/actions/add_edge.h
new file mode 100644
index 0000000..394fc41
--- /dev/null
+++ b/traffic_editor/gui/actions/add_edge.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _ADD_EDGE_H_
+#define _ADD_EDGE_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class AddEdgeCommand : public QUndoCommand
+{
+
+public:
+  AddEdgeCommand(Project* project, int level_idx);
+  virtual ~AddEdgeCommand();
+  void undo() override;
+  void redo() override;
+  int set_first_point(double x, double y);
+  int set_second_point(double x, double y);
+  void set_edge_type(Edge::Type type);
+private:
+  Project* _project;
+  double _first_x, _first_y;
+  double _second_x, _second_y;
+  bool _first_point_not_exist, _first_point_drawn;
+  bool _second_point_not_exist, _second_point_drawn;
+  int _level_idx;
+  std::vector<Edge> _edge_snapshot;
+  std::vector<Vertex> _vert_snapshot, _final_snapshot;
+  int _vert_id_first, _vert_id_second;
+  Edge::Type _type;
+  const double _vertex_radius_meters = 0.1;
+};
+
+
+#endif
diff --git a/traffic_editor/gui/actions/add_fiducial.cpp b/traffic_editor/gui/actions/add_fiducial.cpp
new file mode 100644
index 0000000..81af457
--- /dev/null
+++ b/traffic_editor/gui/actions/add_fiducial.cpp
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "add_fiducial.h"
+
+AddFiducialCommand::AddFiducialCommand(
+  Project* project,
+  int level_idx,
+  double x,
+  double y)
+{
+  _project = project;
+  _x = x;
+  _y = y;
+  _level_idx = level_idx;
+}
+
+AddFiducialCommand::~AddFiducialCommand()
+{
+
+}
+
+void AddFiducialCommand::undo()
+{
+  int index_to_remove = -1;
+
+  for (size_t i = 0; i < _project->building.levels[_level_idx].fiducials.size();
+    i++)
+  {
+    if (_uuid == _project->building.levels[_level_idx].fiducials[i].uuid)
+    {
+      index_to_remove = i;
+    }
+  }
+  if (index_to_remove < 0)
+  {
+    //something wrong
+    return;
+  }
+
+  _project->building.levels[_level_idx].fiducials.erase(
+    _project->building.levels[_level_idx].fiducials.begin() + index_to_remove
+  );
+}
+
+void AddFiducialCommand::redo()
+{
+  _uuid = _project->building.add_fiducial(_level_idx, _x, _y);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_fiducial.h b/traffic_editor/gui/actions/add_fiducial.h
new file mode 100644
index 0000000..d522d9e
--- /dev/null
+++ b/traffic_editor/gui/actions/add_fiducial.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _ADD_FIDUCIAL_H_
+#define _ADD_FIDUCIAL_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class AddFiducialCommand : public QUndoCommand
+{
+
+public:
+  AddFiducialCommand(
+    Project* project,
+    int level_idx,
+    double x,
+    double y);
+  virtual ~AddFiducialCommand();
+  void undo() override;
+  void redo() override;
+private:
+  Project* _project;
+  double _x, _y;
+  int _level_idx;
+  QUuid _uuid;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_model.cpp b/traffic_editor/gui/actions/add_model.cpp
new file mode 100644
index 0000000..727e3c1
--- /dev/null
+++ b/traffic_editor/gui/actions/add_model.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "add_model.h"
+#include <math.h>
+
+AddModelCommand::AddModelCommand(
+  Project* project,
+  int level_idx,
+  double x,
+  double y,
+  std::string name)
+{
+  _project = project;
+  _level_idx = level_idx;
+  _x = x;
+  _y = y;
+  _name = name;
+}
+
+AddModelCommand::~AddModelCommand()
+{
+
+}
+
+void AddModelCommand::undo()
+{
+  for (size_t i = 0; i < _project->building.levels[_level_idx].models.size();
+    i++)
+  {
+    if (_project->building.levels[_level_idx].models[i].uuid == _uuid)
+    {
+      _project->building.levels[_level_idx].models.erase(
+        _project->building.levels[_level_idx].models.begin() + i
+      );
+      return;
+    }
+  }
+}
+
+
+void AddModelCommand::redo()
+{
+  _uuid = _project->building.add_model(
+    _level_idx,
+    _x,
+    _y,
+    0.0,
+    M_PI / 2.0,
+    _name);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_model.h b/traffic_editor/gui/actions/add_model.h
new file mode 100644
index 0000000..5c615b9
--- /dev/null
+++ b/traffic_editor/gui/actions/add_model.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#ifndef _ADD_MODEL_H_
+#define _ADD_MODEL_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class AddModelCommand : public QUndoCommand
+{
+
+public:
+  AddModelCommand(
+    Project* project,
+    int level_idx,
+    double x,
+    double y,
+    std::string name);
+  virtual ~AddModelCommand();
+  void undo() override;
+  void redo() override;
+private:
+  Project* _project;
+  double _x, _y;
+  int _level_idx;
+  QUuid _uuid;
+  std::string _name;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_polygon.cpp b/traffic_editor/gui/actions/add_polygon.cpp
new file mode 100644
index 0000000..65e393b
--- /dev/null
+++ b/traffic_editor/gui/actions/add_polygon.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#include "add_polygon.h"
+
+AddPolygonCommand::AddPolygonCommand(
+  Project* project,
+  EditorModeId mode,
+  Polygon polygon,
+  int level_idx)
+{
+  //In this case to keep polygon undoing simple we use simple snapshots;
+  _project = project;
+  _mode = mode;
+  _to_add = polygon;
+  _level_idx = level_idx;
+  if (_mode == MODE_BUILDING)
+    _previous_polygons = _project->building.levels[level_idx].polygons;
+  else if (mode == MODE_SCENARIO)
+    _previous_polygons = _project->scenario_level(level_idx)->polygons;
+}
+
+AddPolygonCommand::~AddPolygonCommand()
+{
+}
+
+void AddPolygonCommand::undo()
+{
+  if (_mode == MODE_BUILDING)
+    _project->building.levels[_level_idx].polygons = _previous_polygons;
+  else if (_mode == MODE_SCENARIO)
+    _project->scenario_level(_level_idx)->polygons = _previous_polygons;
+}
+
+void AddPolygonCommand::redo()
+{
+  if (_mode == MODE_BUILDING)
+    _project->building.levels[_level_idx].polygons.push_back(_to_add);
+  else if (_mode == MODE_SCENARIO)
+    _project->scenario_level(_level_idx)->polygons.push_back(_to_add);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_polygon.h b/traffic_editor/gui/actions/add_polygon.h
new file mode 100644
index 0000000..60e0f0b
--- /dev/null
+++ b/traffic_editor/gui/actions/add_polygon.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#ifndef _ADD_POLYGON_H_
+#define _ADD_POLYGON_H_
+
+#include <QUndoCommand>
+#include "editor_mode_id.h"
+#include "project.h"
+
+class AddPolygonCommand : public QUndoCommand
+{
+
+public:
+  AddPolygonCommand(
+    Project* project,
+    EditorModeId mode,
+    Polygon polygon,
+    int level_idx);
+  virtual ~AddPolygonCommand();
+  void undo() override;
+  void redo() override;
+private:
+  Project* _project;
+  EditorModeId _mode;
+  Polygon _to_add;
+  int _level_idx;
+  std::vector<Polygon> _previous_polygons;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_property.cpp b/traffic_editor/gui/actions/add_property.cpp
new file mode 100644
index 0000000..aa0019b
--- /dev/null
+++ b/traffic_editor/gui/actions/add_property.cpp
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#include "add_property.h"
+
+AddPropertyCommand::AddPropertyCommand(
+  Project* project,
+  std::string property,
+  Param value,
+  int level_idx)
+{
+  _project = project;
+  _prop = property;
+  _val = value;
+  _level_idx = level_idx;
+  _vert_id = -1;
+
+  for (std::size_t i = 0;
+    i < project->building.levels[level_idx].vertices.size();
+    i++)
+  {
+    if (project->building.levels[level_idx].vertices[i].selected)
+    {
+      _vert_id = i;
+    }
+  }
+}
+
+AddPropertyCommand::~AddPropertyCommand()
+{
+
+}
+
+int AddPropertyCommand::get_vertex_updated()
+{
+  return _vert_id;
+}
+
+void AddPropertyCommand::redo()
+{
+  if (_vert_id < 0)
+  {
+    return;
+  }
+  _project->building.levels[_level_idx]
+  .vertices[_vert_id].params[_prop] = _val;
+}
+
+void AddPropertyCommand::undo()
+{
+  auto v = _project->building.levels[_level_idx].vertices[_vert_id];
+  if (v.params.count(_prop) == 0)
+  {
+    return; //something went wrong
+  }
+  _project->building.levels[_level_idx]
+  .vertices[_vert_id].params.erase(_prop);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_property.h b/traffic_editor/gui/actions/add_property.h
new file mode 100644
index 0000000..e5dc543
--- /dev/null
+++ b/traffic_editor/gui/actions/add_property.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#ifndef _ADD_PROPERTY_H_
+#define _ADD_PROPERTY_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class AddPropertyCommand : public QUndoCommand
+{
+public:
+  AddPropertyCommand(Project* project,
+    std::string property,
+    Param value,
+    int level_idx);
+  virtual ~AddPropertyCommand();
+  int get_vertex_updated();
+  void undo() override;
+  void redo() override;
+
+private:
+  Project* _project;
+  std::string _prop;
+  Param _val;
+  int _vert_id, _level_idx;
+};
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_vertex.cpp b/traffic_editor/gui/actions/add_vertex.cpp
new file mode 100644
index 0000000..8e23cca
--- /dev/null
+++ b/traffic_editor/gui/actions/add_vertex.cpp
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "add_vertex.h"
+
+AddVertexCommand::AddVertexCommand(
+  Project* project,
+  EditorModeId mode,
+  int level_idx,
+  double x,
+  double y)
+{
+  _mode = mode;
+  _x = x;
+  _y = y;
+  _level_idx = level_idx; //TODO: Dependency on level_idx is dangerous.
+  _project = project;
+}
+
+AddVertexCommand::~AddVertexCommand()
+{
+  //Empty to make linker happy
+}
+
+void AddVertexCommand::undo()
+{
+  if (_mode == MODE_BUILDING || _mode == MODE_TRAFFIC)
+  {
+    size_t length = _project->building.levels[_level_idx].vertices.size();
+    //TODO: SLOW O(n) method... Need to rework datastructures.
+    for (size_t i = 0; i < length; i++)
+    {
+      if (_project->building.levels[_level_idx].vertices[i].uuid == _vert_id)
+      {
+        _project->building.levels[_level_idx].vertices.erase(
+          _project->building.levels[_level_idx].vertices.begin()+i);
+        break;
+      }
+    }
+  }
+}
+
+void AddVertexCommand::redo()
+{
+  if (_mode == MODE_BUILDING || _mode == MODE_TRAFFIC)
+  {
+    _project->building.add_vertex(_level_idx, _x, _y);
+    size_t sz = _project->building.levels[_level_idx].vertices.size();
+    _vert_id = _project->building.levels[_level_idx].vertices[sz-1].uuid;
+  }
+  else if (_mode == MODE_SCENARIO)
+  {
+    assert(_project->scenario_idx < 0);
+    _project->add_scenario_vertex(_level_idx, _x, _y);
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/add_vertex.h b/traffic_editor/gui/actions/add_vertex.h
new file mode 100644
index 0000000..38f0a0a
--- /dev/null
+++ b/traffic_editor/gui/actions/add_vertex.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _ADD_VERTEX_H_
+#define _ADD_VERTEX_H_
+
+#include <QUndoCommand>
+#include "editor_mode_id.h"
+#include "project.h"
+
+class AddVertexCommand : public QUndoCommand
+{
+
+public:
+  AddVertexCommand(
+    Project* project,
+    EditorModeId mode,
+    int level_idx,
+    double x,
+    double y);
+  virtual ~AddVertexCommand();
+  void undo() override;
+  void redo() override;
+private:
+  Project* _project;
+  EditorModeId _mode;
+  double _x, _y;
+  int _level_idx;
+  QUuid _vert_id;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/delete.cpp b/traffic_editor/gui/actions/delete.cpp
new file mode 100644
index 0000000..84e9e2f
--- /dev/null
+++ b/traffic_editor/gui/actions/delete.cpp
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "delete.h"
+
+DeleteCommand::DeleteCommand(Project* project, int level_idx)
+{
+  _project = project;
+  _level_idx = level_idx;
+}
+
+DeleteCommand::~DeleteCommand()
+{
+
+}
+
+void DeleteCommand::undo()
+{
+  for (size_t i = 0; i < _vertices.size(); i++)
+  {
+    _project->building.levels[_level_idx].vertices.insert(
+      _project->building.levels[_level_idx].vertices.begin() + _vertex_idx[i],
+      _vertices[i]);
+  }
+
+  for (size_t i = 0; i < _edges.size(); i++)
+  {
+    _project->building.levels[_level_idx].edges.insert(
+      _project->building.levels[_level_idx].edges.begin() + _edge_idx[i],
+      _edges[i]);
+  }
+
+  for (size_t i = 0; i < _models.size(); i++)
+  {
+    _project->building.levels[_level_idx].models.insert(
+      _project->building.levels[_level_idx].models.begin() + _model_idx[i],
+      _models[i]);
+  }
+
+  for (size_t i = 0; i < _fiducials.size(); i++)
+  {
+    _project->building.levels[_level_idx].fiducials.insert(
+      _project->building.levels[_level_idx].fiducials.begin() + _fiducial_idx[i],
+      _fiducials[i]);
+  }
+
+  for (size_t i = 0; i < _polygons.size(); i++)
+  {
+    _project->building.levels[_level_idx].polygons.insert(
+      _project->building.levels[_level_idx].polygons.begin() + _polygon_idx[i],
+      _polygons[i]);
+  }
+
+  _vertices.clear();
+  _vertex_idx.clear();
+  _edges.clear();
+  _edge_idx.clear();
+  _models.clear();
+  _model_idx.clear();
+  _fiducials.clear();
+  _fiducial_idx.clear();
+  _polygons.clear();
+  _polygon_idx.clear();
+}
+
+void DeleteCommand::redo()
+{
+  std::vector<BuildingLevel::SelectedItem> selected_items;
+  _project->get_selected_items(_level_idx, selected_items);
+
+  for (auto& item: selected_items)
+  {
+    if (item.model_idx >= 0)
+    {
+      _models.push_back(
+        _project->building.levels[_level_idx].models[item.model_idx]
+      );
+      _model_idx.push_back(item.model_idx);
+    }
+
+    if (item.vertex_idx >= 0)
+    {
+      _vertices.push_back(
+        _project->building.levels[_level_idx].vertices[item.vertex_idx]
+      );
+      _vertex_idx.push_back(item.vertex_idx);
+    }
+
+    if (item.fiducial_idx >= 0)
+    {
+      _fiducials.push_back(
+        _project->building.levels[_level_idx].fiducials[item.fiducial_idx]
+      );
+      _fiducial_idx.push_back(item.fiducial_idx);
+    }
+
+    if (item.edge_idx >= 0)
+    {
+      _edges.push_back(
+        _project->building.levels[_level_idx].edges[item.edge_idx]
+      );
+      _edge_idx.push_back(item.edge_idx);
+    }
+
+    if (item.polygon_idx >= 0)
+    {
+      _polygons.push_back(
+        _project->building.levels[_level_idx].polygons[item.polygon_idx]
+      );
+      _polygon_idx.push_back(item.edge_idx);
+    }
+  }
+  _project->delete_selected(_level_idx);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/delete.h b/traffic_editor/gui/actions/delete.h
new file mode 100644
index 0000000..f2b15d6
--- /dev/null
+++ b/traffic_editor/gui/actions/delete.h
@@ -0,0 +1,31 @@
+#ifndef _DELETE_H_
+#define _DELETE_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class DeleteCommand : public QUndoCommand
+{
+public:
+  DeleteCommand(Project* project, int level_idx);
+  virtual ~DeleteCommand();
+  void undo() override;
+  void redo() override;
+
+private:
+  std::vector<Vertex> _vertices;
+  std::vector<int> _vertex_idx;
+  std::vector<Edge> _edges;
+  std::vector<int> _edge_idx;
+  std::vector<Model> _models;
+  std::vector<int> _model_idx;
+  std::vector<Fiducial> _fiducials;
+  std::vector<int> _fiducial_idx;
+  std::vector<Polygon> _polygons;
+  std::vector<int> _polygon_idx;
+
+  Project* _project;
+  int _level_idx;
+};
+
+#endif
diff --git a/traffic_editor/gui/actions/move_fiducial.cpp b/traffic_editor/gui/actions/move_fiducial.cpp
new file mode 100644
index 0000000..585bd98
--- /dev/null
+++ b/traffic_editor/gui/actions/move_fiducial.cpp
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "move_fiducial.h"
+
+MoveFiducialCommand::MoveFiducialCommand(
+  Project* project,
+  int level,
+  int fiducial_id)
+{
+  _project = project;
+  Fiducial fiducial = project->building.levels[level].fiducials[fiducial_id];
+  _original_x = fiducial.x;
+  _original_y = fiducial.y;
+  _level_id = level;
+  _fiducial_id = fiducial_id;
+  has_moved = false;
+}
+
+MoveFiducialCommand::~MoveFiducialCommand()
+{
+}
+
+void MoveFiducialCommand::undo()
+{
+  Fiducial& fiducial =
+    _project->building.levels[_level_id].fiducials[_fiducial_id];
+  fiducial.x = _original_x;
+  fiducial.y = _original_y;
+}
+
+void MoveFiducialCommand::redo()
+{
+  Fiducial& fiducial =
+    _project->building.levels[_level_id].fiducials[_fiducial_id];
+  fiducial.x = _final_x;
+  fiducial.y = _final_y;
+}
+
+void MoveFiducialCommand::set_final_destination(double x, double y)
+{
+  _final_x = x;
+  _final_y = y;
+  has_moved = true;
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/move_fiducial.h b/traffic_editor/gui/actions/move_fiducial.h
new file mode 100644
index 0000000..3aa93be
--- /dev/null
+++ b/traffic_editor/gui/actions/move_fiducial.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _MOVE_FIDUCIAL_H_
+#define _MOVE_FIDUCIAL_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class MoveFiducialCommand : public QUndoCommand
+{
+public:
+  MoveFiducialCommand(
+    Project* project,
+    int level,
+    int fiducial_id
+  );
+  virtual ~MoveFiducialCommand();
+
+  void undo() override;
+  void redo() override;
+
+  void set_final_destination(double x, double y);
+
+  bool has_moved;
+private:
+  double _original_x, _original_y;
+  double _final_x, _final_y;
+  int _level_id, _fiducial_id;
+  Project* _project;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/move_model.cpp b/traffic_editor/gui/actions/move_model.cpp
new file mode 100644
index 0000000..775f82f
--- /dev/null
+++ b/traffic_editor/gui/actions/move_model.cpp
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "move_model.h"
+
+MoveModelCommand::MoveModelCommand(
+  Project* project,
+  int level,
+  int model_id
+)
+{
+  _project = project;
+  Model model = project->building.levels[level].models[model_id];
+  _original_x = model.state.x;
+  _original_y = model.state.y;
+  _level_id = level;
+  _model_id = model_id;
+  has_moved = false;
+}
+
+MoveModelCommand::~MoveModelCommand()
+{
+
+}
+
+void MoveModelCommand::undo()
+{
+  Model& model = _project->building.levels[_level_id].models[_model_id];
+  model.state.x = _original_x;
+  model.state.y = _original_y;
+}
+
+void MoveModelCommand::redo()
+{
+  Model& model = _project->building.levels[_level_id].models[_model_id];
+  model.state.x = _final_x;
+  model.state.y = _final_y;
+}
+
+void MoveModelCommand::set_final_destination(double x, double y)
+{
+  _final_x = x;
+  _final_y = y;
+  has_moved = true;
+}
diff --git a/traffic_editor/gui/actions/move_model.h b/traffic_editor/gui/actions/move_model.h
new file mode 100644
index 0000000..04d5464
--- /dev/null
+++ b/traffic_editor/gui/actions/move_model.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _MOVE_MODEL_H_
+#define _MOVE_MODEL_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class MoveModelCommand : public QUndoCommand
+{
+public:
+  MoveModelCommand(
+    Project* project,
+    int level,
+    int model_id
+  );
+  virtual ~MoveModelCommand();
+
+  void undo() override;
+  void redo() override;
+
+  void set_final_destination(double x, double y);
+
+  bool has_moved;
+private:
+  double _original_x, _original_y;
+  double _final_x, _final_y;
+  int _level_id, _model_id;
+  Project* _project;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/move_vertex.cpp b/traffic_editor/gui/actions/move_vertex.cpp
new file mode 100644
index 0000000..9695603
--- /dev/null
+++ b/traffic_editor/gui/actions/move_vertex.cpp
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "move_vertex.h"
+
+MoveVertexCommand::MoveVertexCommand(
+  Project* project,
+  int level_idx,
+  int mouse_vertex_idx)
+{
+  _to_move = project->building.levels[level_idx].vertices[mouse_vertex_idx];
+  _level_idx = level_idx;
+  _project = project;
+  has_moved = false;
+}
+
+MoveVertexCommand::~MoveVertexCommand()
+{
+
+}
+
+void MoveVertexCommand::set_final_destination(double x, double y)
+{
+  _x = x;
+  _y = y;
+  has_moved = true;
+}
+
+void MoveVertexCommand::undo()
+{
+  //Use ID because in future if we want to support photoshop style selective
+  //undo-redos it will be consistent even after deletion of intermediate vertices.
+  for (Vertex& vert: _project->building.levels[_level_idx].vertices)
+  {
+    if (vert.uuid == _to_move.uuid)
+    {
+      vert.x = _to_move.x;
+      vert.y = _to_move.y;
+    }
+  }
+}
+
+void MoveVertexCommand::redo()
+{
+  //Use ID because in future if we want to support photoshop style selective
+  //undo-redos it will be consistent even after deletion of intermediate vertices.
+  for (Vertex& vert: _project->building.levels[_level_idx].vertices)
+  {
+    if (vert.uuid == _to_move.uuid)
+    {
+      vert.x = _x;
+      vert.y = _y;
+    }
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/move_vertex.h b/traffic_editor/gui/actions/move_vertex.h
new file mode 100644
index 0000000..ff144c6
--- /dev/null
+++ b/traffic_editor/gui/actions/move_vertex.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef MOVE_VERTEX_H
+#define MOVE_VERTEX_H
+
+#include <QUndoCommand>
+#include "project.h"
+#include "traffic_editor/vertex.h"
+
+class MoveVertexCommand : public QUndoCommand
+{
+public:
+  bool has_moved;
+  MoveVertexCommand(Project* project, int level_idx, int mouse_vertex_idx);
+  virtual ~MoveVertexCommand();
+
+  void set_final_destination(double x, double y);
+  void undo() override;
+  void redo() override;
+
+private:
+  Project* _project;
+  int _level_idx;
+  Vertex _to_move;
+  double _x, _y;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/polygon_add_vertex.cpp b/traffic_editor/gui/actions/polygon_add_vertex.cpp
new file mode 100644
index 0000000..58b032b
--- /dev/null
+++ b/traffic_editor/gui/actions/polygon_add_vertex.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "polygon_add_vertex.h"
+
+PolygonAddVertCommand::PolygonAddVertCommand(
+  Polygon* polygon,
+  int position,
+  int vert_id)
+{
+  _polygon = polygon;
+  _old_vertices = polygon->vertices;
+  _position = position;
+  _vert_id = vert_id;
+}
+
+PolygonAddVertCommand::~PolygonAddVertCommand()
+{
+
+}
+
+void PolygonAddVertCommand::undo()
+{
+  _polygon->vertices.erase(_polygon->vertices.begin() + _position);
+}
+
+void PolygonAddVertCommand::redo()
+{
+  _polygon->vertices.insert(
+    _polygon->vertices.begin() + _position,
+    _vert_id);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/polygon_add_vertex.h b/traffic_editor/gui/actions/polygon_add_vertex.h
new file mode 100644
index 0000000..2f288f3
--- /dev/null
+++ b/traffic_editor/gui/actions/polygon_add_vertex.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _POLYGON_ADD_H_
+#define _POLYGON_ADD_H_
+
+#include <QUndoCommand>
+#include "editor_mode_id.h"
+#include "project.h"
+
+class PolygonAddVertCommand : public QUndoCommand
+{
+
+public:
+  PolygonAddVertCommand(
+    Polygon* polygon,
+    int position,
+    int vert_id);
+  virtual ~PolygonAddVertCommand();
+  void undo() override;
+  void redo() override;
+private:
+  Polygon* _polygon;
+  int _vert_id;
+  int _position;
+  std::vector<int> _old_vertices;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/polygon_remove_vertices.cpp b/traffic_editor/gui/actions/polygon_remove_vertices.cpp
new file mode 100644
index 0000000..8dbfa02
--- /dev/null
+++ b/traffic_editor/gui/actions/polygon_remove_vertices.cpp
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "polygon_remove_vertices.h"
+PolygonRemoveVertCommand::PolygonRemoveVertCommand(
+  Polygon* polygon,
+  int vert_id)
+{
+  _polygon = polygon;
+  _vert_id = vert_id;
+  _old_vertices = polygon->vertices;
+}
+
+PolygonRemoveVertCommand::~PolygonRemoveVertCommand()
+{
+}
+
+void PolygonRemoveVertCommand::undo()
+{
+  _polygon->vertices = _old_vertices;
+}
+
+void PolygonRemoveVertCommand::redo()
+{
+  _polygon->remove_vertex(_vert_id);
+}
diff --git a/traffic_editor/gui/actions/polygon_remove_vertices.h b/traffic_editor/gui/actions/polygon_remove_vertices.h
new file mode 100644
index 0000000..61b26f3
--- /dev/null
+++ b/traffic_editor/gui/actions/polygon_remove_vertices.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _POLYGON_REMOVE_H_
+#define _POLYGON_REMOVE_H_
+
+#include <QUndoCommand>
+#include "editor_mode_id.h"
+#include "project.h"
+
+class PolygonRemoveVertCommand : public QUndoCommand
+{
+
+public:
+  PolygonRemoveVertCommand(
+    Polygon* polygon,
+    int vert_id);
+  virtual ~PolygonRemoveVertCommand();
+  void undo() override;
+  void redo() override;
+private:
+  Polygon* _polygon;
+  int _vert_id;
+  std::vector<int> _old_vertices;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/rotate_model.cpp b/traffic_editor/gui/actions/rotate_model.cpp
new file mode 100644
index 0000000..cbb0918
--- /dev/null
+++ b/traffic_editor/gui/actions/rotate_model.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "rotate_model.h"
+
+RotateModelCommand::RotateModelCommand(
+  Project* project,
+  int level,
+  int model_id)
+{
+  has_moved = false;
+  _project = project;
+  _level_id = level;
+  _model_id = model_id;
+  _original_yaw =
+    _project->building.levels[_level_id].models[_model_id].state.yaw;
+}
+
+RotateModelCommand::~RotateModelCommand()
+{
+}
+
+void RotateModelCommand::undo()
+{
+  _project->building.set_model_yaw(_level_id, _model_id, _original_yaw);
+}
+
+void RotateModelCommand::redo()
+{
+  _project->building.set_model_yaw(_level_id, _model_id, _final_yaw);
+}
+
+void RotateModelCommand::set_final_destination(double yaw)
+{
+  has_moved = true;
+  _final_yaw = yaw;
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/actions/rotate_model.h b/traffic_editor/gui/actions/rotate_model.h
new file mode 100644
index 0000000..161c73f
--- /dev/null
+++ b/traffic_editor/gui/actions/rotate_model.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef _ROTATE_MODEL_H_
+#define _ROTATE_MODEL_H_
+
+#include <QUndoCommand>
+#include "project.h"
+
+class RotateModelCommand : public QUndoCommand
+{
+public:
+  RotateModelCommand(
+    Project* project,
+    int level,
+    int model_id
+  );
+  virtual ~RotateModelCommand();
+
+  void undo() override;
+  void redo() override;
+
+  void set_final_destination(double yaw);
+
+  bool has_moved;
+private:
+  double _original_yaw;
+  double _final_yaw;
+  int _level_id, _model_id;
+  Project* _project;
+};
+
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/add_param_dialog.cpp b/traffic_editor/gui/add_param_dialog.cpp
new file mode 100644
index 0000000..b0e1d3c
--- /dev/null
+++ b/traffic_editor/gui/add_param_dialog.cpp
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "add_param_dialog.h"
+#include <QtWidgets>
+
+
+AddParamDialog::AddParamDialog(
+  QWidget* parent,
+  const std::vector<std::pair<std::string, Param::Type>>& _param_names)
+: QDialog(parent),
+  param_names(_param_names)
+{
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  cancel_button = new QPushButton("Cancel", this);
+
+  QHBoxLayout* name_hbox_layout = new QHBoxLayout;
+  name_hbox_layout->addWidget(new QLabel("name:"));
+  name_combo_box = new QComboBox;
+  for (const auto& param_name : param_names)
+    name_combo_box->addItem(QString::fromStdString(param_name.first));
+  name_hbox_layout->addWidget(name_combo_box);
+
+  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
+  bottom_buttons_layout->addWidget(cancel_button);
+  bottom_buttons_layout->addWidget(ok_button);
+  connect(
+    ok_button, &QAbstractButton::clicked,
+    this, &AddParamDialog::ok_button_clicked);
+  connect(
+    cancel_button, &QAbstractButton::clicked,
+    this, &QDialog::reject);
+
+  QVBoxLayout* vbox_layout = new QVBoxLayout;
+  vbox_layout->addLayout(name_hbox_layout);
+  // todo: some sort of separator (?)
+  vbox_layout->addLayout(bottom_buttons_layout);
+
+  setLayout(vbox_layout);
+}
+
+AddParamDialog::~AddParamDialog()
+{
+}
+
+void AddParamDialog::ok_button_clicked()
+{
+  // todo: if this box becomes more complex in the future, validate it...
+  accept();
+}
+
+std::string AddParamDialog::get_param_name() const
+{
+  return name_combo_box->currentText().toStdString();
+}
+
+Param::Type AddParamDialog::get_param_type() const
+{
+  // loop through the allowed_params to find the name that is selected
+  // then return the type
+  for (const auto& param_name : param_names)
+  {
+    if (name_combo_box->currentText().toStdString() != param_name.first)
+      continue;
+    return param_name.second;
+  }
+  return Param::Type::UNDEFINED;
+}
diff --git a/traffic_editor/gui/add_param_dialog.h b/traffic_editor/gui/add_param_dialog.h
new file mode 100644
index 0000000..9eab2d1
--- /dev/null
+++ b/traffic_editor/gui/add_param_dialog.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef ADD_PARAM_DIALOG_H
+#define ADD_PARAM_DIALOG_H
+
+#include <vector>
+#include <QDialog>
+#include "traffic_editor/param.h"
+class QComboBox;
+
+
+class AddParamDialog : public QDialog
+{
+public:
+  AddParamDialog(
+    QWidget* parent,
+    const std::vector<std::pair<std::string, Param::Type>>& param_names);
+  ~AddParamDialog();
+
+  std::string get_param_name() const;
+  Param::Type get_param_type() const;
+
+private:
+  QComboBox* name_combo_box;
+  QPushButton* ok_button, * cancel_button;
+  const std::vector<std::pair<std::string, Param::Type>>& param_names;
+
+private slots:
+  void ok_button_clicked();
+};
+
+#endif
diff --git a/traffic_editor/gui/building.cpp b/traffic_editor/gui/building.cpp
new file mode 100644
index 0000000..85f8d10
--- /dev/null
+++ b/traffic_editor/gui/building.cpp
@@ -0,0 +1,687 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+#include <fstream>
+#include <iostream>
+#include <memory>
+#include <yaml-cpp/yaml.h>
+
+#include <QFileInfo>
+#include <QDir>
+#include <QThread>
+#include <QtConcurrent/QtConcurrent>
+#include <QElapsedTimer>
+
+#include "traffic_editor/building.h"
+#include "yaml_utils.h"
+
+using std::string;
+using std::vector;
+using std::make_pair;
+using std::unique_ptr;
+using std::shared_ptr;
+
+
+Building::Building()
+: name("building")
+{
+}
+
+Building::~Building()
+{
+}
+
+/// Load a YAML file description of a building map
+///
+/// This function replaces the contents of this object with what is
+/// in the YAML file.
+bool Building::load_yaml_file()
+{
+  printf("Building::load_yaml_file(%s)\n", filename.c_str());
+  YAML::Node y;
+  try
+  {
+    y = YAML::LoadFile(filename.c_str());
+  }
+  catch (const std::exception& e)
+  {
+    printf("couldn't parse %s: %s", filename.c_str(), e.what());
+    return false;
+  }
+
+  // change directory to the path of the file, so that we can correctly open
+  // relative paths recorded in the file
+
+  // TODO: save previous directory and restore it when leaving this function
+  // in case the building file is in a different path from the project file
+  QString dir(QFileInfo(QString::fromStdString(filename)).absolutePath());
+  qDebug("changing directory to [%s]", qUtf8Printable(dir));
+  if (!QDir::setCurrent(dir))
+  {
+    printf("couldn't change directory\n");
+    return false;
+  }
+
+  if (y["name"])
+    name = y["name"].as<string>();
+
+  if (y["reference_level_name"])
+    reference_level_name = y["reference_level_name"].as<string>();
+
+  // crowd_sim_impl is initialized when creating crowd_sim_table in editor.cpp
+  // just in case the pointer is not initialized
+  if (crowd_sim_impl == nullptr)
+    crowd_sim_impl = std::make_shared<crowd_sim::CrowdSimImplementation>();
+  if (y["crowd_sim"] && y["crowd_sim"].IsMap())
+  {
+    if (!crowd_sim_impl->from_yaml(y["crowd_sim"]))
+    {
+      printf(
+        "Error in loading crowd_sim configuration from yaml, re-initialize crowd_sim");
+      crowd_sim_impl->clear();
+      crowd_sim_impl->init_default_configure();
+    }
+  }
+
+  if (!y["levels"] || !y["levels"].IsMap())
+  {
+    printf("expected top-level dictionary named 'levels'");
+    return false;
+  }
+
+  levels.clear();
+  const YAML::Node yl = y["levels"];
+  for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
+  {
+    BuildingLevel level;
+    level.from_yaml(it->first.as<string>(), it->second);
+    levels.push_back(level);
+  }
+
+  QtConcurrent::blockingMap(
+    levels,
+    [&](auto& level) { level.load_drawing(); });
+
+  // now that all images are loaded, we can calculate scale for annotated
+  // measurement lanes
+  for (auto& level : levels)
+    level.calculate_scale();
+
+  lifts.clear();
+  if (y["lifts"] && y["lifts"].IsMap())
+  {
+    const YAML::Node& y_lifts = y["lifts"];
+    for (YAML::const_iterator it = y_lifts.begin(); it != y_lifts.end(); ++it)
+    {
+      Lift lift;
+      lift.from_yaml(it->first.as<string>(), it->second, levels);
+      lifts.push_back(lift);
+    }
+  }
+
+  calculate_all_transforms();
+  return true;
+}
+
+bool Building::save_yaml_file()
+{
+  printf("Building::save_yaml(%s)\n", filename.c_str());
+
+  YAML::Node y;
+  y["name"] = name;
+
+  if (!reference_level_name.empty())
+    y["reference_level_name"] = reference_level_name;
+
+  y["levels"] = YAML::Node(YAML::NodeType::Map);
+  for (const auto& level : levels)
+    y["levels"][level.name] = level.to_yaml();
+
+  y["lifts"] = YAML::Node(YAML::NodeType::Map);
+  for (const auto& lift : lifts)
+    y["lifts"][lift.name] = lift.to_yaml();
+
+  if (crowd_sim_impl == nullptr)
+    y["crowd_sim"] = crowd_sim_impl->to_yaml();
+
+  YAML::Emitter emitter;
+  yaml_utils::write_node(y, emitter);
+  std::ofstream fout(filename);
+  fout << emitter.c_str() << std::endl;
+
+  return true;
+}
+
+void Building::add_vertex(int level_index, double x, double y)
+{
+  if (level_index >= static_cast<int>(levels.size()))
+    return;
+  levels[level_index].add_vertex(x, y);
+}
+
+QUuid Building::add_fiducial(int level_index, double x, double y)
+{
+  if (level_index >= static_cast<int>(levels.size()))
+    return NULL;
+  levels[level_index].fiducials.push_back(Fiducial(x, y));
+  return levels[level_index].fiducials.rbegin()->uuid;
+}
+
+int Building::find_nearest_vertex_index(
+  int level_index,
+  double x,
+  double y,
+  double& distance)
+{
+  double min_dist = 1e100;
+  int min_index = -1;
+  for (size_t i = 0; i < levels[level_index].vertices.size(); i++)
+  {
+    const Vertex& v = levels[level_index].vertices[i];
+    const double dx = x - v.x;
+    const double dy = y - v.y;
+    const double dist2 = dx*dx + dy*dy;  // no need for sqrt each time
+    if (dist2 < min_dist)
+    {
+      min_dist = dist2;
+      min_index = i;
+    }
+  }
+  distance = sqrt(min_dist);
+  return min_index;  // will be -1 if vertices vector is empty
+}
+
+Building::NearestItem Building::nearest_items(
+  const int level_index,
+  const double x,
+  const double y)
+{
+  NearestItem ni;
+  if (level_index >= static_cast<int>(levels.size()))
+    return ni;
+  const BuildingLevel& level = levels[level_index];
+
+  for (size_t i = 0; i < level.vertices.size(); i++)
+  {
+    const Vertex& p = level.vertices[i];
+    const double dx = x - p.x;
+    const double dy = y - p.y;
+    const double dist = sqrt(dx*dx + dy*dy);
+    if (dist < ni.vertex_dist)
+    {
+      ni.vertex_dist = dist;
+      ni.vertex_idx = i;
+    }
+  }
+
+  for (size_t i = 0; i < level.fiducials.size(); i++)
+  {
+    const Fiducial& f = level.fiducials[i];
+    const double dx = x - f.x;
+    const double dy = y - f.y;
+    const double dist = sqrt(dx*dx + dy*dy);
+    if (dist < ni.fiducial_dist)
+    {
+      ni.fiducial_dist = dist;
+      ni.fiducial_idx = i;
+    }
+  }
+
+  for (size_t i = 0; i < level.models.size(); i++)
+  {
+    const Model& m = level.models[i];
+    const double dx = x - m.state.x;
+    const double dy = y - m.state.y;
+    const double dist = sqrt(dx*dx + dy*dy);  // no need for sqrt each time
+    if (dist < ni.model_dist)
+    {
+      ni.model_dist = dist;
+      ni.model_idx = i;
+    }
+  }
+
+  return ni;
+}
+
+int Building::nearest_item_index_if_within_distance(
+  const int level_index,
+  const double x,
+  const double y,
+  const double distance_threshold,
+  const ItemType item_type)
+{
+  if (level_index >= static_cast<int>(levels.size()))
+    return -1;
+
+  double min_dist = 1e100;
+  int min_index = -1;
+  if (item_type == VERTEX)
+  {
+    for (size_t i = 0; i < levels[level_index].vertices.size(); i++)
+    {
+      const Vertex& p = levels[level_index].vertices[i];
+      const double dx = x - p.x;
+      const double dy = y - p.y;
+      const double dist2 = dx*dx + dy*dy;  // no need for sqrt each time
+      if (dist2 < min_dist)
+      {
+        min_dist = dist2;
+        min_index = i;
+      }
+    }
+  }
+  else if (item_type == FIDUCIAL)
+  {
+    for (size_t i = 0; i < levels[level_index].fiducials.size(); i++)
+    {
+      const Fiducial& f = levels[level_index].fiducials[i];
+      const double dx = x - f.x;
+      const double dy = y - f.y;
+      const double dist2 = dx*dx + dy*dy;
+      if (dist2 < min_dist)
+      {
+        min_dist = dist2;
+        min_index = i;
+      }
+    }
+  }
+  else if (item_type == MODEL)
+  {
+    for (size_t i = 0; i < levels[level_index].models.size(); i++)
+    {
+      const Model& m = levels[level_index].models[i];
+      const double dx = x - m.state.x;
+      const double dy = y - m.state.y;
+      const double dist2 = dx*dx + dy*dy;  // no need for sqrt each time
+      if (dist2 < min_dist)
+      {
+        min_dist = dist2;
+        min_index = i;
+      }
+    }
+  }
+  if (sqrt(min_dist) < distance_threshold)
+    return min_index;
+  return -1;
+}
+
+void Building::add_edge(
+  const int level_index,
+  const int start_vertex_index,
+  const int end_vertex_index,
+  const Edge::Type edge_type)
+{
+  if (level_index >= static_cast<int>(levels.size()))
+    return;
+
+  printf("Building::add_edge(%d, %d, %d, %d)\n",
+    level_index,
+    start_vertex_index,
+    end_vertex_index,
+    static_cast<int>(edge_type));
+
+  levels[level_index].edges.push_back(
+    Edge(start_vertex_index, end_vertex_index, edge_type));
+}
+
+void Building::add_lane(
+  const int level_index,
+  const int start_vertex_index,
+  const int end_vertex_index,
+  const int graph_idx)
+{
+  if (level_index >= static_cast<int>(levels.size()))
+    return;
+
+  printf("Building::add_lane(%d, %d, %d, graph=%d)\n",
+    level_index,
+    start_vertex_index,
+    end_vertex_index,
+    graph_idx);
+  Edge e(start_vertex_index, end_vertex_index, Edge::LANE);
+  e.set_graph_idx(graph_idx);
+  levels[level_index].edges.push_back(e);
+}
+
+bool Building::delete_selected(const int level_index)
+{
+  if (level_index >= static_cast<int>(levels.size()))
+    return false;
+
+  printf("Building::delete_keypress()\n");
+  if (!levels[level_index].delete_selected())
+    return false;
+
+  return true;
+}
+
+QUuid Building::add_model(
+  const int level_idx,
+  const double x,
+  const double y,
+  const double z,
+  const double yaw,
+  const std::string& model_name)
+{
+  if (level_idx >= static_cast<int>(levels.size()))
+    return NULL;
+
+  printf("Building::add_model(%d, %.1f, %.1f, %.1f, %.2f, %s)\n",
+    level_idx, x, y, z, yaw, model_name.c_str());
+  Model m;
+  m.state.x = x;
+  m.state.y = y;
+  m.state.z = z;
+  m.state.yaw = yaw;
+  m.model_name = model_name;
+  m.instance_name = model_name;  // todo: add unique numeric suffix?
+  m.is_static = true;
+  levels[level_idx].models.push_back(m);
+  return levels[level_idx].models.rbegin()->uuid;
+}
+
+void Building::set_model_yaw(
+  const int level_idx,
+  const int model_idx,
+  const double yaw)
+{
+  if (level_idx >= static_cast<int>(levels.size()))
+    return;
+
+  levels[level_idx].models[model_idx].state.yaw = yaw;
+}
+
+void Building::clear()
+{
+  name.clear();
+  filename.clear();
+  reference_level_name.clear();
+  levels.clear();
+  lifts.clear();
+  clear_transform_cache();
+}
+
+void Building::add_level(const BuildingLevel& new_level)
+{
+  // make sure we don't have this level already
+  for (const auto& level : levels)
+  {
+    if (level.name == new_level.name)
+      return;
+  }
+  levels.push_back(new_level);
+}
+
+void Building::draw_lifts(QGraphicsScene* scene, const int level_idx)
+{
+  const BuildingLevel& level = levels[level_idx];
+  for (const auto& lift : lifts)
+  {
+    // find the level index referenced by the lift
+    int reference_floor_idx = -1;
+    for (size_t i = 0; i < levels.size(); i++)
+    {
+      if (levels[i].name == lift.reference_floor_name)
+      {
+        reference_floor_idx = static_cast<int>(i);
+        break;
+      }
+    }
+
+    Transform t;
+    if (reference_floor_idx >= 0)
+      t = get_transform(reference_floor_idx, level_idx);
+
+    lift.draw(
+      scene,
+      level.drawing_meters_per_pixel,
+      level.name,
+      level.elevation,
+      true,
+      t.scale,
+      t.dx,
+      t.dy);
+  }
+}
+
+bool Building::transform_between_levels(
+  const std::string& from_level_name,
+  const QPointF& from_point,
+  const std::string& to_level_name,
+  QPointF& to_point)
+{
+  int from_level_idx = -1;
+  int to_level_idx = -1;
+  for (size_t i = 0; i < levels.size(); i++)
+  {
+    if (levels[i].name == from_level_name)
+      from_level_idx = i;
+    if (levels[i].name == to_level_name)
+      to_level_idx = i;
+  }
+  if (from_level_idx < 0 || to_level_idx < 0)
+  {
+    to_point = from_point;
+    return false;
+  }
+  return transform_between_levels(
+    from_level_idx,
+    from_point,
+    to_level_idx,
+    to_point);
+}
+
+bool Building::transform_between_levels(
+  const int from_level_idx,
+  const QPointF& from_point,
+  const int to_level_idx,
+  QPointF& to_point)
+{
+
+  if (from_level_idx < 0 ||
+    from_level_idx >= static_cast<int>(levels.size()) ||
+    to_level_idx < 0 ||
+    to_level_idx >= static_cast<int>(levels.size()))
+  {
+    to_point = from_point;
+    return false;
+  }
+
+  const Transform t = get_transform(from_level_idx, to_level_idx);
+
+  to_point.rx() = t.scale * from_point.x() + t.dx;
+  to_point.ry() = t.scale * from_point.y() + t.dy;
+  return true;
+}
+
+void Building::clear_transform_cache()
+{
+  transforms.clear();
+}
+
+Building::Transform Building::compute_transform(
+  const int from_level_idx,
+  const int to_level_idx)
+{
+  // short-circuit if it's the same level
+  if (from_level_idx == to_level_idx)
+  {
+    Building::Transform t;
+    t.scale = 1.0;
+    t.dx = 0.0;
+    t.dy = 0.0;
+    return t;
+  }
+
+  // this internal function assumes that bounds checking has already happened
+  const BuildingLevel& from_level = levels[from_level_idx];
+  const BuildingLevel& to_level = levels[to_level_idx];
+
+  // assemble a vector of fudicials in common to these levels
+  vector<std::pair<Fiducial, Fiducial>> fiducials;
+  for (const Fiducial& f0 : from_level.fiducials)
+  {
+    for (const Fiducial& f1 : to_level.fiducials)
+    {
+      if (f0.name == f1.name)
+      {
+        fiducials.push_back(make_pair(f0, f1));
+        break;
+      }
+    }
+  }
+
+  // calculate the distances between each fiducial on their levels
+  vector<std::pair<double, double>> distances;
+  for (size_t f0_idx = 0; f0_idx < fiducials.size(); f0_idx++)
+  {
+    for (size_t f1_idx = f0_idx + 1; f1_idx < fiducials.size(); f1_idx++)
+    {
+      distances.push_back(
+        make_pair(
+          fiducials[f0_idx].first.distance(fiducials[f1_idx].first),
+          fiducials[f0_idx].second.distance(fiducials[f1_idx].second)));
+    }
+  }
+
+
+  // for now, we'll just compute the mean of the relative scale estimates.
+  // we can do fancier statistics later, if needed.
+  double relative_scale_sum = 0;
+  for (size_t i = 0; i < distances.size(); i++)
+    relative_scale_sum += distances[i].second / distances[i].first;
+  const double scale = relative_scale_sum / distances.size();
+
+  // scale the fiducials and estimate the "optimal" translation.
+  // for now, we'll just use the mean of the translation estimates.
+  double trans_x_sum = 0;
+  double trans_y_sum = 0;
+  for (const auto& fiducial : fiducials)
+  {
+    trans_x_sum += fiducial.second.x - fiducial.first.x * scale;
+    trans_y_sum += fiducial.second.y - fiducial.first.y * scale;
+  }
+  const double trans_x = trans_x_sum / fiducials.size();
+  const double trans_y = trans_y_sum / fiducials.size();
+
+  Building::Transform t;
+  t.scale = scale;
+  t.dx = trans_x;
+  t.dy = trans_y;
+
+  printf("transform %d->%d: scale = %.5f translation = (%.2f, %.2f)\n",
+    from_level_idx,
+    to_level_idx,
+    t.scale,
+    t.dx,
+    t.dy);
+
+  return t;
+}
+
+Building::Transform Building::get_transform(
+  const int from_level_idx,
+  const int to_level_idx)
+{
+  // this operation is a bit "heavy" so we'll cache the transformations
+  // as they are computed
+  LevelPair level_pair;
+  level_pair.from_idx = from_level_idx;
+  level_pair.to_idx = to_level_idx;
+
+  TransformMap::iterator transform_it = transforms.find(level_pair);
+  Transform t;
+
+  if (transform_it == transforms.end())
+  {
+    // the transform wasn't in the cache, so we need to compute it
+    t = compute_transform(from_level_idx, to_level_idx);
+    transforms[level_pair] = t;
+  }
+  else
+    t = transform_it->second;
+
+  return t;
+}
+
+void Building::calculate_all_transforms()
+{
+  if (levels.empty())
+    return;// let's not crash
+
+  clear_transform_cache();
+  for (size_t i = 0; i < levels.size(); i++)
+  {
+    for (size_t j = 0; j < levels.size(); j++)
+    {
+      get_transform(i, j);
+    }
+  }
+
+  // set drawing scale using this data
+  const int ref_idx = get_reference_level_idx();
+  const double ref_scale = levels[ref_idx].drawing_meters_per_pixel;
+  for (int i = 0; i < static_cast<int>(levels.size()); i++)
+  {
+    if (i != get_reference_level_idx())
+    {
+      Transform t = get_transform(ref_idx, i);
+      if (levels[i].fiducials.size() >= 2)
+        levels[i].drawing_meters_per_pixel = ref_scale / t.scale;
+    }
+  }
+}
+
+int Building::get_reference_level_idx()
+{
+  if (reference_level_name.empty())
+    return 0;
+  for (size_t i = 0; i < levels.size(); i++)
+  {
+    if (levels[i].name == reference_level_name)
+      return static_cast<int>(i);
+  }
+  return 0;
+}
+
+void Building::clear_scene()
+{
+  for (auto& level : levels)
+    level.clear_scene();
+}
+
+double Building::level_meters_per_pixel(const string& level_name) const
+{
+  for (const auto& level : levels)
+  {
+    if (level.name == level_name)
+      return level.drawing_meters_per_pixel;
+  }
+  return 0.05;  // just a somewhat sane default
+}
+
+void Building::rotate_all_models(const double rotation)
+{
+  for (auto& level : levels)
+  {
+    for (auto& model : level.models)
+    {
+      model.state.yaw += rotation;
+    }
+  }
+}
diff --git a/traffic_editor/gui/building_dialog.cpp b/traffic_editor/gui/building_dialog.cpp
new file mode 100644
index 0000000..74fad58
--- /dev/null
+++ b/traffic_editor/gui/building_dialog.cpp
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "building_dialog.h"
+#include <QtWidgets>
+
+
+BuildingDialog::BuildingDialog(Building& building)
+: QDialog(), _building(building)
+{
+  setWindowTitle("Building Properties");
+  _ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  _cancel_button = new QPushButton("Cancel", this);
+
+  QHBoxLayout* building_name_hbox = new QHBoxLayout;
+  building_name_hbox->addWidget(new QLabel("Building name:"));
+  _building_name_line_edit = new QLineEdit(
+    QString::fromStdString(building.name),
+    this);
+  building_name_hbox->addWidget(_building_name_line_edit);
+
+  QHBoxLayout* reference_level_hbox = new QHBoxLayout;
+  reference_level_hbox->addWidget(new QLabel("Reference level:"));
+  _reference_floor_combo_box = new QComboBox;
+  for (const auto& level : building.levels)
+    _reference_floor_combo_box->addItem(QString::fromStdString(level.name));
+  if (!building.levels.empty() && !building.reference_level_name.empty())
+    _reference_floor_combo_box->setCurrentText(
+      QString::fromStdString(building.reference_level_name));
+  reference_level_hbox->addWidget(_reference_floor_combo_box);
+
+  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
+  bottom_buttons_hbox->addWidget(_cancel_button);
+  bottom_buttons_hbox->addWidget(_ok_button);
+  connect(
+    _ok_button, &QAbstractButton::clicked,
+    this, &BuildingDialog::ok_button_clicked);
+  connect(
+    _cancel_button, &QAbstractButton::clicked,
+    this, &QDialog::reject);
+
+  QVBoxLayout* top_vbox = new QVBoxLayout;
+
+  top_vbox->addLayout(building_name_hbox);
+  top_vbox->addLayout(reference_level_hbox);
+  // todo: some sort of separator (?)
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  setLayout(top_vbox);
+}
+
+BuildingDialog::~BuildingDialog()
+{
+}
+
+void BuildingDialog::ok_button_clicked()
+{
+  _building.name = _building_name_line_edit->text().toStdString();
+  _building.reference_level_name =
+    _reference_floor_combo_box->currentText().toStdString();
+  accept();
+}
diff --git a/traffic_editor/gui/building_dialog.h b/traffic_editor/gui/building_dialog.h
new file mode 100644
index 0000000..a56b1a5
--- /dev/null
+++ b/traffic_editor/gui/building_dialog.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_DIALOG_H
+#define BUILDING_DIALOG_H
+
+#include <QDialog>
+#include "traffic_editor/building.h"
+class QLineEdit;
+class QComboBox;
+
+
+class BuildingDialog : public QDialog
+{
+public:
+  BuildingDialog(Building& building);
+  ~BuildingDialog();
+
+private:
+  Building& _building;
+
+  QLineEdit* _building_name_line_edit;
+  QComboBox* _reference_floor_combo_box;
+  QPushButton* _ok_button, * _cancel_button;
+
+private slots:
+  void ok_button_clicked();
+};
+
+#endif
diff --git a/traffic_editor/gui/building_level.cpp b/traffic_editor/gui/building_level.cpp
new file mode 100644
index 0000000..aefd181
--- /dev/null
+++ b/traffic_editor/gui/building_level.cpp
@@ -0,0 +1,993 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+#include <cmath>
+
+#include <QGraphicsOpacityEffect>
+#include <QGraphicsPixmapItem>
+#include <QGraphicsScene>
+#include <QImage>
+#include <QImageReader>
+
+#include "traffic_editor/building_level.h"
+using std::string;
+using std::vector;
+
+
+BuildingLevel::BuildingLevel()
+: Level()
+{
+}
+
+BuildingLevel::~BuildingLevel()
+{
+}
+
+bool BuildingLevel::from_yaml(
+  const std::string& _name,
+  const YAML::Node& _data)
+{
+  printf("parsing level [%s]\n", _name.c_str());
+  name = _name;
+
+  if (!_data.IsMap())
+    throw std::runtime_error("level " + name + " YAML invalid");
+
+  if (_data["drawing"] && _data["drawing"].IsMap())
+  {
+    const YAML::Node& drawing_data = _data["drawing"];
+    if (!drawing_data["filename"])
+      throw std::runtime_error("level " + name + " drawing invalid");
+    drawing_filename = drawing_data["filename"].as<string>();
+    /*
+    if (!load_drawing())
+      return false;
+    */
+  }
+  else if (_data["x_meters"] && _data["y_meters"])
+  {
+    x_meters = _data["x_meters"].as<double>();
+    y_meters = _data["y_meters"].as<double>();
+    drawing_meters_per_pixel = 0.05;  // something reasonable
+    drawing_width = x_meters / drawing_meters_per_pixel;
+    drawing_height = y_meters / drawing_meters_per_pixel;
+  }
+  else
+  {
+    x_meters = 100.0;
+    y_meters = 100.0;
+    drawing_meters_per_pixel = 0.05;
+    drawing_width = x_meters / drawing_meters_per_pixel;
+    drawing_height = y_meters / drawing_meters_per_pixel;
+  }
+
+  parse_vertices(_data);
+
+  if (_data["fiducials"] && _data["fiducials"].IsSequence())
+  {
+    const YAML::Node& fy = _data["fiducials"];
+    for (YAML::const_iterator it = fy.begin(); it != fy.end(); ++it)
+    {
+      Fiducial f;
+      f.from_yaml(*it);
+      fiducials.push_back(f);
+    }
+  }
+
+  if (_data["flattened_x_offset"])
+    flattened_x_offset = _data["flattened_x_offset"].as<double>();
+  if (_data["flattened_y_offset"])
+    flattened_y_offset = _data["flattened_y_offset"].as<double>();
+
+  load_yaml_edge_sequence(_data, "lanes", Edge::LANE);
+  load_yaml_edge_sequence(_data, "walls", Edge::WALL);
+  load_yaml_edge_sequence(_data, "measurements", Edge::MEAS);
+  load_yaml_edge_sequence(_data, "doors", Edge::DOOR);
+  load_yaml_edge_sequence(_data, "human_lanes", Edge::HUMAN_LANE);
+
+  if (_data["models"] && _data["models"].IsSequence())
+  {
+    const YAML::Node& ys = _data["models"];
+    for (YAML::const_iterator it = ys.begin(); it != ys.end(); ++it)
+    {
+      Model m;
+      m.from_yaml(*it, this->name);
+      models.push_back(m);
+    }
+  }
+
+  if (_data["floors"] && _data["floors"].IsSequence())
+  {
+    const YAML::Node& yf = _data["floors"];
+    for (YAML::const_iterator it = yf.begin(); it != yf.end(); ++it)
+    {
+      Polygon p;
+      p.from_yaml(*it, Polygon::FLOOR);
+      polygons.push_back(p);
+    }
+  }
+
+  if (_data["holes"] && _data["holes"].IsSequence())
+  {
+    const YAML::Node& yf = _data["holes"];
+    for (YAML::const_iterator it = yf.begin(); it != yf.end(); ++it)
+    {
+      Polygon p;
+      p.from_yaml(*it, Polygon::HOLE);
+      polygons.push_back(p);
+    }
+  }
+
+  if (_data["elevation"])
+    elevation = _data["elevation"].as<double>();
+
+  if (_data["layers"] && _data["layers"].IsMap())
+  {
+    const YAML::Node& yl = _data["layers"];
+    for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
+    {
+      Layer layer;
+      layer.from_yaml(it->first.as<string>(), it->second);
+      layers.push_back(layer);
+    }
+  }
+
+  return true;
+}
+
+bool BuildingLevel::load_drawing()
+{
+  if (drawing_filename.empty())
+    return true;// nothing to load
+
+  printf("  level %s drawing: %s\n",
+    name.c_str(),
+    drawing_filename.c_str());
+
+  QString qfilename = QString::fromStdString(drawing_filename);
+
+  QImageReader image_reader(qfilename);
+  image_reader.setAutoTransform(true);
+  QImage image = image_reader.read();
+  if (image.isNull())
+  {
+    qWarning("unable to read %s: %s",
+      qUtf8Printable(qfilename),
+      qUtf8Printable(image_reader.errorString()));
+    return false;
+  }
+  image = image.convertToFormat(QImage::Format_Grayscale8);
+  floorplan_pixmap = QPixmap::fromImage(image);
+  drawing_width = floorplan_pixmap.width();
+  drawing_height = floorplan_pixmap.height();
+  return true;
+}
+
+YAML::Node BuildingLevel::to_yaml() const
+{
+  YAML::Node y;
+  if (!drawing_filename.empty())
+  {
+    YAML::Node drawing_node;
+    drawing_node["filename"] = drawing_filename;
+    y["drawing"] = drawing_node;
+  }
+  else
+  {
+    y["x_meters"] = x_meters;
+    y["y_meters"] = y_meters;
+  }
+  y["elevation"] = elevation;
+  y["flattened_x_offset"] = flattened_x_offset;
+  y["flattened_y_offset"] = flattened_y_offset;
+
+  for (const auto& v : vertices)
+    y["vertices"].push_back(v.to_yaml());
+
+  for (const auto& f : fiducials)
+    y["fiducials"].push_back(f.to_yaml());
+
+  for (const auto& edge : edges)
+  {
+    YAML::Node n(edge.to_yaml());
+    std::string dict_name = "unknown";
+    switch (edge.type)
+    {
+      case Edge::LANE:
+        dict_name = "lanes";
+        break;
+      case Edge::WALL:
+        dict_name = "walls";
+        break;
+      case Edge::MEAS:
+        dict_name = "measurements";
+        break;
+      case Edge::DOOR:
+        dict_name = "doors";
+        break;
+      case Edge::HUMAN_LANE:
+        dict_name = "human_lanes";
+        break;
+      default:
+        printf("tried to save unknown edge type: %d\n",
+          static_cast<int>(edge.type));
+        break;
+    }
+    y[dict_name].push_back(n);
+  }
+
+  for (const auto& model : models)
+    y["models"].push_back(model.to_yaml());
+
+  for (const auto& polygon : polygons)
+  {
+    switch (polygon.type)
+    {
+      case Polygon::FLOOR:
+        y["floors"].push_back(polygon.to_yaml());
+        break;
+      case Polygon::HOLE:
+        y["holes"].push_back(polygon.to_yaml());
+        break;
+      default:
+        printf("tried to save an unknown polygon type: %d\n",
+          static_cast<int>(polygon.type));
+        break;
+    }
+  }
+
+  y["layers"] = YAML::Node(YAML::NodeType::Map);
+  for (const auto& layer : layers)
+    y["layers"][layer.name] = layer.to_yaml();
+
+  return y;
+}
+
+bool BuildingLevel::can_delete_current_selection()
+{
+  int selected_vertex_idx = -1;
+  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
+  {
+    if (vertices[i].selected)
+    {
+      selected_vertex_idx = i;
+      break;  // just grab the index of the first selected vertex
+    }
+  }
+
+  if (selected_vertex_idx < 0)
+    return true;
+
+  bool vertex_used = false;
+  for (const auto& edge : edges)
+  {
+    if (edge.start_idx == selected_vertex_idx ||
+      edge.end_idx == selected_vertex_idx)
+      vertex_used = true;
+  }
+  for (const auto& polygon : polygons)
+  {
+    for (const int& vertex_idx : polygon.vertices)
+    {
+      if (vertex_idx == selected_vertex_idx)
+        vertex_used = true;
+    }
+  }
+  if (vertex_used)
+    return false;// don't try to delete a vertex used in a shape
+  return true;
+}
+
+bool BuildingLevel::delete_selected()
+{
+  edges.erase(
+    std::remove_if(
+      edges.begin(),
+      edges.end(),
+      [](const Edge& edge) { return edge.selected; }),
+    edges.end());
+
+  models.erase(
+    std::remove_if(
+      models.begin(),
+      models.end(),
+      [](const auto& model) { return model.selected; }),
+    models.end());
+
+  fiducials.erase(
+    std::remove_if(
+      fiducials.begin(),
+      fiducials.end(),
+      [](const Fiducial& fiducial) { return fiducial.selected; }),
+    fiducials.end());
+
+  polygons.erase(
+    std::remove_if(
+      polygons.begin(),
+      polygons.end(),
+      [](const Polygon& polygon) { return polygon.selected; }),
+    polygons.end());
+
+  // Vertices take a lot more care, because we have to check if a vertex
+  // is used in an edge or a polygon before deleting it, and update all
+  // higher-index vertex indices in the edges and polygon vertex lists.
+  // Since this is a potentially expensive operation, first we'll spin
+  // through the vertex list and see if any vertices are selected, and
+  // only then make a copy of the vertex list.
+  int selected_vertex_idx = -1;
+  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
+  {
+    if (vertices[i].selected)
+    {
+      selected_vertex_idx = i;
+      break;  // just grab the index of the first selected vertex
+    }
+  }
+  if (selected_vertex_idx >= 0)
+  {
+    // See if this vertex is used in any edges/polygons.
+    bool vertex_used = false;
+    for (const auto& edge : edges)
+    {
+      if (edge.start_idx == selected_vertex_idx ||
+        edge.end_idx == selected_vertex_idx)
+        vertex_used = true;
+    }
+    for (const auto& polygon : polygons)
+    {
+      for (const int& vertex_idx : polygon.vertices)
+      {
+        if (vertex_idx == selected_vertex_idx)
+          vertex_used = true;
+      }
+    }
+    if (vertex_used)
+      return false;// don't try to delete a vertex used in a shape
+
+    // the vertex is not currently being used, so let's erase it
+    vertices.erase(vertices.begin() + selected_vertex_idx);
+
+    // now go through all edges and polygons to decrement any larger indices
+    for (Edge& edge : edges)
+    {
+      if (edge.start_idx > selected_vertex_idx)
+        edge.start_idx--;
+      if (edge.end_idx > selected_vertex_idx)
+        edge.end_idx--;
+    }
+
+    for (Polygon& polygon : polygons)
+    {
+      for (int i = 0; i < static_cast<int>(polygon.vertices.size()); i++)
+      {
+        if (polygon.vertices[i] > selected_vertex_idx)
+          polygon.vertices[i]--;
+      }
+    }
+  }
+  return true;
+}
+
+void BuildingLevel::get_selected_items(
+  std::vector<BuildingLevel::SelectedItem>& items)
+{
+  for (size_t i = 0; i < edges.size(); i++)
+  {
+    if (edges[i].selected)
+    {
+      BuildingLevel::SelectedItem item;
+      item.edge_idx = i;
+      items.push_back(item);
+    }
+  }
+
+  for (size_t i = 0; i < models.size(); i++)
+  {
+    if (models[i].selected)
+    {
+      BuildingLevel::SelectedItem item;
+      item.model_idx = i;
+      items.push_back(item);
+    }
+  }
+
+  for (size_t i = 0; i < vertices.size(); i++)
+  {
+    if (vertices[i].selected)
+    {
+      BuildingLevel::SelectedItem item;
+      item.vertex_idx = i;
+      items.push_back(item);
+    }
+  }
+
+  for (size_t i = 0; i < fiducials.size(); i++)
+  {
+    if (fiducials[i].selected)
+    {
+      BuildingLevel::SelectedItem item;
+      item.fiducial_idx = i;
+      items.push_back(item);
+    }
+  }
+
+  for (size_t i = 0; i < polygons.size(); i++)
+  {
+    if (polygons[i].selected)
+    {
+      BuildingLevel::SelectedItem item;
+      item.polygon_idx = i;
+      items.push_back(item);
+    }
+  }
+}
+
+void BuildingLevel::calculate_scale()
+{
+  // for now, just calculate the mean of the scale estimates
+  double scale_sum = 0.0;
+  int scale_count = 0;
+
+  for (auto& edge : edges)
+  {
+    if (edge.type == Edge::MEAS)
+    {
+      scale_count++;
+      const double dx = vertices[edge.start_idx].x - vertices[edge.end_idx].x;
+      const double dy = vertices[edge.start_idx].y - vertices[edge.end_idx].y;
+      const double distance_pixels = std::sqrt(dx*dx + dy*dy);
+      // todo: a clean, strongly-typed parameter API for edges
+      const double distance_meters =
+        edge.params[std::string("distance")].value_double;
+      scale_sum += distance_meters / distance_pixels;
+    }
+  }
+
+  if (scale_count > 0)
+  {
+    drawing_meters_per_pixel = scale_sum / static_cast<double>(scale_count);
+    printf("used %d measurements to estimate meters/pixel as %.5f\n",
+      scale_count, drawing_meters_per_pixel);
+  }
+  else
+    drawing_meters_per_pixel = 0.05;// default to something reasonable
+
+  if (drawing_width && drawing_height && drawing_meters_per_pixel > 0.0)
+  {
+    x_meters = drawing_width * drawing_meters_per_pixel;
+    y_meters = drawing_height * drawing_meters_per_pixel;
+  }
+}
+
+// todo: migrate this to the TrafficMap class eventually
+void BuildingLevel::draw_lane(
+  QGraphicsScene* scene,
+  const Edge& edge,
+  const RenderingOptions& opts) const
+{
+  const int graph_idx = edge.get_graph_idx();
+  if (graph_idx >= 0 &&
+    graph_idx < static_cast<int>(opts.show_building_lanes.size()) &&
+    !opts.show_building_lanes[graph_idx])
+    return;// don't render this lane
+
+  const auto& v_start = vertices[edge.start_idx];
+  const auto& v_end = vertices[edge.end_idx];
+  const double dx = v_end.x - v_start.x;
+  const double dy = v_end.y - v_start.y;
+  const double len = std::sqrt(dx*dx + dy*dy);
+
+  double pen_width_in_meters = edge.get_width() > 0 ? edge.get_width() : 1.0;
+  const double lane_pen_width = pen_width_in_meters / drawing_meters_per_pixel;
+
+  const QPen arrow_pen(
+    QBrush(QColor::fromRgbF(0.0, 0.0, 0.0, 0.5)),
+    lane_pen_width / 8);
+
+  // dimensions for the direction indicators along this path
+  const double arrow_w = lane_pen_width / 2.5;  // width of arrowheads
+  const double arrow_l = lane_pen_width / 2.5;  // length of arrowheads
+  const double arrow_spacing = lane_pen_width / 2.0;
+
+  const double norm_x = dx / len;
+  const double norm_y = dy / len;
+
+  // only draw arrows if it's a unidirectional lane. We used to draw
+  // arrows in both directions for bidirectional, but it was messy.
+
+  if (!edge.is_bidirectional())
+  {
+    for (double d = 0.0; d < len; d += arrow_spacing)
+    {
+      // first calculate the center vertex of this arrowhead
+      const double cx = v_start.x + d * norm_x;
+      const double cy = v_start.y + d * norm_y;
+      // one edge vertex of arrowhead
+      const double e1x = cx - arrow_w * norm_y;
+      const double e1y = cy + arrow_w * norm_x;
+      // another edge vertex of arrowhead
+      const double e2x = cx + arrow_w * norm_y;
+      const double e2y = cy - arrow_w * norm_x;
+      // tip of arrowhead
+      const double tx = cx + arrow_l * norm_x;
+      const double ty = cy + arrow_l * norm_y;
+      // now add arrowhead lines
+      scene->addLine(e1x, e1y, tx, ty, arrow_pen);
+      scene->addLine(e2x, e2y, tx, ty, arrow_pen);
+    }
+  }
+
+  QColor color;
+  switch (edge.get_graph_idx())
+  {
+    case 0: color.setRgbF(0.0, 0.5, 0.0); break;
+    case 1: color.setRgbF(0.0, 0.0, 0.5); break;
+    case 2: color.setRgbF(0.0, 0.5, 0.5); break;
+    case 3: color.setRgbF(0.5, 0.5, 0.0); break;
+    case 4: color.setRgbF(0.5, 0.0, 0.5); break;
+    case 5: color.setRgbF(0.8, 0.0, 0.0); break;
+    case 9: color.setRgbF(0.3, 0.3, 0.3); break;
+    default: break;  // will render as dark grey
+  }
+
+  // always draw lane as red if it's selected
+  if (edge.selected)
+    color.setRgbF(0.5, 0.0, 0.0);
+
+  // always draw lanes somewhat transparent
+  color.setAlphaF(0.5);
+
+  QGraphicsLineItem* lane_item = scene->addLine(
+    v_start.x, v_start.y,
+    v_end.x, v_end.y,
+    QPen(QBrush(color), lane_pen_width, Qt::SolidLine, Qt::RoundCap));
+  lane_item->setZValue(edge.get_graph_idx() + 1.0);
+
+  // draw the orientation icon, if specified
+  auto orientation_it = edge.params.find("orientation");
+  if (orientation_it != edge.params.end())
+  {
+    // draw robot-outline box midway down this lane
+    const double mx = (v_start.x + v_end.x) / 2.0;
+    const double my = (v_start.y + v_end.y) / 2.0;
+    const double yaw = std::atan2(norm_y, norm_x);
+
+    // robot-box half-dimensions in meters
+    const double rw = 0.4 / drawing_meters_per_pixel;
+    const double rl = 0.5 / drawing_meters_per_pixel;
+
+    // calculate the corners of the 'robot' box
+
+    // front-left
+    // |mx| + |cos -sin| | rl|
+    // |my|   |sin  cos| | rw|
+    const double flx = mx + rl * std::cos(yaw) - rw * std::sin(yaw);
+    const double fly = my + rl * std::sin(yaw) + rw * std::cos(yaw);
+
+    // front-right
+    // |mx| + |cos -sin| | rl|
+    // |my|   |sin  cos| |-rw|
+    const double frx = mx + rl * std::cos(yaw) + rw * std::sin(yaw);
+    const double fry = my + rl * std::sin(yaw) - rw * std::cos(yaw);
+
+    // back-left
+    // |mx| + |cos -sin| |-rl|
+    // |my|   |sin  cos| | rw|
+    const double blx = mx - rl * std::cos(yaw) - rw * std::sin(yaw);
+    const double bly = my - rl * std::sin(yaw) + rw * std::cos(yaw);
+
+    // back-right
+    // |mx| + |cos -sin| |-rl|
+    // |my|   |sin  cos| |-rw|
+    const double brx = mx - rl * std::cos(yaw) + rw * std::sin(yaw);
+    const double bry = my - rl * std::sin(yaw) - rw * std::cos(yaw);
+
+    QPainterPath pp;
+    pp.moveTo(QPointF(flx, fly));
+    pp.lineTo(QPointF(frx, fry));
+    pp.lineTo(QPointF(brx, bry));
+    pp.lineTo(QPointF(blx, bly));
+    pp.lineTo(QPointF(flx, fly));
+    pp.moveTo(QPointF(mx, my));
+
+    QPen orientation_pen(Qt::white, 5.0);
+    if (orientation_it->second.value_string == "forward")
+    {
+      const double hix = mx + 1.0 * cos(yaw) / drawing_meters_per_pixel;
+      const double hiy = my + 1.0 * sin(yaw) / drawing_meters_per_pixel;
+      pp.lineTo(QPointF(hix, hiy));
+      scene->addPath(pp, orientation_pen);
+    }
+    else if (orientation_it->second.value_string == "backward")
+    {
+      const double hix = mx - 1.0 * cos(yaw) / drawing_meters_per_pixel;
+      const double hiy = my - 1.0 * sin(yaw) / drawing_meters_per_pixel;
+      pp.lineTo(QPointF(hix, hiy));
+      scene->addPath(pp, orientation_pen);
+    }
+  }
+}
+
+void BuildingLevel::draw_wall(QGraphicsScene* scene, const Edge& edge) const
+{
+  const auto& v_start = vertices[edge.start_idx];
+  const auto& v_end = vertices[edge.end_idx];
+
+  const double r = edge.selected ? 0.5 : 0.0;
+  const double b = edge.selected ? 0.0 : 0.5;
+
+  scene->addLine(
+    v_start.x, v_start.y,
+    v_end.x, v_end.y,
+    QPen(
+      QBrush(QColor::fromRgbF(r, 0.0, b, 0.5)),
+      0.2 / drawing_meters_per_pixel,
+      Qt::SolidLine, Qt::RoundCap));
+}
+
+void BuildingLevel::draw_meas(QGraphicsScene* scene, const Edge& edge) const
+{
+  const auto& v_start = vertices[edge.start_idx];
+  const auto& v_end = vertices[edge.end_idx];
+  const double b = edge.selected ? 0.0 : 0.5;
+
+  scene->addLine(
+    v_start.x, v_start.y,
+    v_end.x, v_end.y,
+    QPen(
+      QBrush(QColor::fromRgbF(0.5, 0, b, 0.5)),
+      0.5 / drawing_meters_per_pixel,
+      Qt::SolidLine, Qt::RoundCap));
+}
+
+void BuildingLevel::draw_door(QGraphicsScene* scene, const Edge& edge) const
+{
+  const auto& v_start = vertices[edge.start_idx];
+  const auto& v_end = vertices[edge.end_idx];
+  const double g = edge.selected ? 1.0 : 0.0;
+  const double door_thickness = 0.2;  // meters
+  const double door_motion_thickness = 0.05;  // meters
+
+  auto door_axis_it = edge.params.find("motion_axis");
+  std::string door_axis("start");
+  if (door_axis_it != edge.params.end())
+    door_axis = door_axis_it->second.value_string;
+
+  double motion_degrees = 90;
+  auto motion_degrees_it = edge.params.find("motion_degrees");
+  if (motion_degrees_it != edge.params.end())
+    motion_degrees = std::abs(motion_degrees_it->second.value_double);
+
+  int motion_dir = 1;
+  auto motion_dir_it = edge.params.find("motion_direction");
+  if (motion_dir_it != edge.params.end())
+    motion_dir = motion_dir_it->second.value_int;
+
+  QPainterPath door_motion_path;
+
+  const double door_dx = v_end.x - v_start.x;
+  const double door_dy = v_end.y - v_start.y;
+  const double door_length = std::sqrt(door_dx * door_dx + door_dy * door_dy);
+  const double door_angle = std::atan2(door_dy, door_dx);
+
+  auto door_type_it = edge.params.find("type");
+  if (door_type_it != edge.params.end())
+  {
+    const double DEG2RAD = M_PI / 180.0;
+
+    const std::string& door_type = door_type_it->second.value_string;
+    if (door_type == "hinged")
+    {
+      const double hinge_x = door_axis == "start" ? v_start.x : v_end.x;
+      const double hinge_y = door_axis == "start" ? v_start.y : v_end.y;
+      const double angle_offset = door_axis == "start" ? 0.0 : M_PI;
+
+      add_door_swing_path(
+        door_motion_path,
+        hinge_x,
+        hinge_y,
+        door_length,
+        door_angle + angle_offset,
+        door_angle + angle_offset + DEG2RAD * motion_dir * motion_degrees);
+    }
+    else if (door_type == "double_hinged")
+    {
+      // each door section is half as long as door_length
+      add_door_swing_path(
+        door_motion_path,
+        v_start.x,
+        v_start.y,
+        door_length / 2,
+        door_angle,
+        door_angle + DEG2RAD * motion_dir * motion_degrees);
+
+      add_door_swing_path(
+        door_motion_path,
+        v_end.x,
+        v_end.y,
+        door_length / 2,
+        door_angle + M_PI,
+        door_angle + M_PI - DEG2RAD * motion_dir * motion_degrees);
+    }
+    else if (door_type == "sliding")
+    {
+      add_door_slide_path(
+        door_motion_path,
+        v_start.x,
+        v_start.y,
+        door_length,
+        door_angle);
+    }
+    else if (door_type == "double_sliding")
+    {
+      // each door section is half as long as door_length
+      add_door_slide_path(
+        door_motion_path,
+        v_start.x,
+        v_start.y,
+        door_length / 2,
+        door_angle);
+      add_door_slide_path(
+        door_motion_path,
+        v_end.x,
+        v_end.y,
+        door_length / 2,
+        door_angle + M_PI);
+    }
+    else
+    {
+      printf("tried to draw unknown door type: [%s]\n", door_type.c_str());
+    }
+  }
+  scene->addPath(
+    door_motion_path,
+    QPen(Qt::black, door_motion_thickness / drawing_meters_per_pixel));
+
+  // add the doorjamb last, so it sits on top of the Z stack of the travel arc
+  scene->addLine(
+    v_start.x, v_start.y,
+    v_end.x, v_end.y,
+    QPen(
+      QBrush(QColor::fromRgbF(1.0, g, 0.0, 0.5)),
+      door_thickness / drawing_meters_per_pixel,
+      Qt::SolidLine, Qt::RoundCap));
+}
+
+void BuildingLevel::add_door_slide_path(
+  QPainterPath& path,
+  double hinge_x,
+  double hinge_y,
+  double door_length,
+  double door_angle) const
+{
+  // first draw the door as a thin line
+  path.moveTo(hinge_x, hinge_y);
+  path.lineTo(
+    hinge_x + door_length * std::cos(door_angle),
+    hinge_y + door_length * std::sin(door_angle));
+
+  // now draw a box around where it slides (in the wall, usually)
+  const double th = door_angle;  // makes expressions below single-line...
+  const double pi_2 = M_PI / 2.0;
+  const double s = 0.15 / drawing_meters_per_pixel;  // sliding panel thickness
+
+  const QPointF p1(
+    hinge_x - s * std::cos(th + pi_2),
+    hinge_y - s * std::sin(th + pi_2));
+
+  const QPointF p2(
+    hinge_x - s * std::cos(th + pi_2) - door_length * std::cos(th),
+    hinge_y - s * std::sin(th + pi_2) - door_length * std::sin(th));
+
+  const QPointF p3(
+    hinge_x + s * std::cos(th + pi_2) - door_length * std::cos(th),
+    hinge_y + s * std::sin(th + pi_2) - door_length * std::sin(th));
+
+  const QPointF p4(
+    hinge_x + s * std::cos(th + pi_2),
+    hinge_y + s * std::sin(th + pi_2));
+
+
+  path.moveTo(p1);
+  path.lineTo(p2);
+  path.lineTo(p3);
+  path.lineTo(p4);
+  path.lineTo(p1);
+}
+
+void BuildingLevel::add_door_swing_path(
+  QPainterPath& path,
+  double hinge_x,
+  double hinge_y,
+  double door_length,
+  double start_angle,
+  double end_angle) const
+{
+  path.moveTo(hinge_x, hinge_y);
+  path.lineTo(
+    hinge_x + door_length * std::cos(start_angle),
+    hinge_y + door_length * std::sin(start_angle));
+
+  const int NUM_MOTION_STEPS = 10;
+  const double angle_inc = (end_angle - start_angle) / (NUM_MOTION_STEPS-1);
+  for (int i = 0; i < NUM_MOTION_STEPS; i++)
+  {
+    // compute door opening angle at this motion step
+    const double a = start_angle + i * angle_inc;
+
+    path.lineTo(
+      hinge_x + door_length * std::cos(a),
+      hinge_y + door_length * std::sin(a));
+  }
+
+  path.lineTo(hinge_x, hinge_y);
+}
+
+void BuildingLevel::draw_polygon(
+  QGraphicsScene* scene,
+  const QBrush& brush,
+  const Polygon& polygon) const
+{
+  QBrush selected_brush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5));
+
+  QVector<QPointF> polygon_vertices;
+  for (const auto& vertex_idx: polygon.vertices)
+  {
+    const Vertex& v = vertices[vertex_idx];
+    polygon_vertices.append(QPointF(v.x, v.y));
+  }
+
+  scene->addPolygon(
+    QPolygonF(polygon_vertices),
+    QPen(Qt::black),
+    polygon.selected ? selected_brush : brush);
+}
+
+void BuildingLevel::draw_polygons(QGraphicsScene* scene) const
+{
+  const QBrush floor_brush(QColor::fromRgbF(0.9, 0.9, 0.9, 0.8));
+  const QBrush hole_brush(QColor::fromRgbF(0.3, 0.3, 0.3, 0.5));
+
+  // first draw the floor polygons
+  for (const auto& polygon : polygons)
+  {
+    if (polygon.type == Polygon::FLOOR)
+      draw_polygon(scene, floor_brush, polygon);
+  }
+
+  // now draw the holes
+  for (const auto& polygon : polygons)
+  {
+    if (polygon.type == Polygon::HOLE)
+      draw_polygon(scene, hole_brush, polygon);
+  }
+
+#if 0
+  // ahhhhh only for debugging...
+  // plot the nearest projection point to a polygon, if it's set
+  // to something nonzero
+  if (level->polygon_edge_proj_x != 0)
+  {
+    const double r = 5.0;
+    addEllipse(
+      polygon_edge_proj_x - r,
+      polygon_edge_proj_y - r,
+      2 * r,
+      2 * r,
+      QPen(Qt::black),
+      QBrush(Qt::blue));
+  }
+#endif
+}
+
+void BuildingLevel::clear_selection()
+{
+  for (auto& vertex : vertices)
+    vertex.selected = false;
+
+  for (auto& edge : edges)
+    edge.selected = false;
+
+  for (auto& model : models)
+    model.selected = false;
+
+  for (auto& polygon : polygons)
+    polygon.selected = false;
+
+  for (auto& fiducial : fiducials)
+    fiducial.selected = false;
+}
+
+void BuildingLevel::draw(
+  QGraphicsScene* scene,
+  vector<EditorModel>& editor_models,
+  const RenderingOptions& rendering_options)
+{
+  if (drawing_filename.size())
+  {
+    scene->setSceneRect(
+      QRectF(0, 0, drawing_width, drawing_height));
+    scene->addPixmap(floorplan_pixmap);
+  }
+  else
+  {
+    const double w = x_meters / drawing_meters_per_pixel;
+    const double h = y_meters / drawing_meters_per_pixel;
+    scene->setSceneRect(QRectF(0, 0, w, h));
+    scene->addRect(0, 0, w, h, QPen(), Qt::white);
+  }
+
+  draw_polygons(scene);
+
+  for (const auto& layer : layers)
+  {
+    if (!layer.visible)
+      continue;
+
+    //printf("floorplan height: %d\n", level.floorplan_pixmap.height());
+    //printf("layer pixmap height: %d\n", layer.pixmap.height());
+    QGraphicsPixmapItem* item = scene->addPixmap(layer.pixmap);
+    // set the origin of the pixmap frame to the lower-left corner
+    item->setOffset(0, -layer.pixmap.height());
+    item->setPos(
+      -layer.translation_x / drawing_meters_per_pixel,
+      layer.translation_y / drawing_meters_per_pixel);
+    item->setScale(layer.meters_per_pixel / drawing_meters_per_pixel);
+    item->setRotation(-1.0 * layer.rotation * 180.0 / M_PI);
+    QGraphicsOpacityEffect* opacity_effect = new QGraphicsOpacityEffect;
+    opacity_effect->setOpacity(0.5);
+    item->setGraphicsEffect(opacity_effect);
+  }
+
+  if (rendering_options.show_models)
+  {
+    for (Model& model : models)
+      model.draw(scene, editor_models, drawing_meters_per_pixel);
+  }
+
+  for (const auto& edge : edges)
+  {
+    switch (edge.type)
+    {
+      case Edge::LANE: draw_lane(scene, edge, rendering_options); break;
+      case Edge::WALL: draw_wall(scene, edge); break;
+      case Edge::MEAS: draw_meas(scene, edge); break;
+      case Edge::DOOR: draw_door(scene, edge); break;
+      case Edge::HUMAN_LANE: draw_lane(scene, edge, rendering_options); break;
+      default:
+        printf("tried to draw unknown edge type: %d\n",
+          static_cast<int>(edge.type));
+        break;
+    }
+  }
+
+  for (const auto& v : vertices)
+    v.draw(
+      scene,
+      vertex_radius / drawing_meters_per_pixel,
+      QColor::fromRgbF(0.0, 0.5, 0.0));
+
+  for (const auto& f : fiducials)
+    f.draw(scene, drawing_meters_per_pixel);
+}
+
+void BuildingLevel::clear_scene()
+{
+  for (auto& model : models)
+    model.clear_scene();
+}
diff --git a/traffic_editor/gui/building_level_dialog.cpp b/traffic_editor/gui/building_level_dialog.cpp
new file mode 100644
index 0000000..6cda2c5
--- /dev/null
+++ b/traffic_editor/gui/building_level_dialog.cpp
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "building_level_dialog.h"
+#include <QtWidgets>
+
+
+BuildingLevelDialog::BuildingLevelDialog(BuildingLevel& _level,
+  Building& _building)
+: building_level(_level), building(_building)
+{
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  cancel_button = new QPushButton("Cancel", this);
+
+  name_line_edit = new QLineEdit(
+    QString::fromStdString(building_level.name), this);
+  QHBoxLayout* name_hbox = new QHBoxLayout;
+  name_hbox->addWidget(new QLabel("name:"));
+  name_hbox->addWidget(name_line_edit);
+
+  elevation_line_edit = new QLineEdit(
+    QString::number(building_level.elevation));
+  QHBoxLayout* elevation_hbox = new QHBoxLayout;
+  elevation_hbox->addWidget(new QLabel("elevation:"));
+  elevation_hbox->addWidget(elevation_line_edit);
+
+  drawing_filename_line_edit = new QLineEdit(
+    QString::fromStdString(building_level.drawing_filename),
+    this);
+  drawing_filename_button = new QPushButton("Find...", this);
+  QHBoxLayout* drawing_filename_hbox = new QHBoxLayout;
+  drawing_filename_hbox->addWidget(new QLabel("drawing:"));
+  drawing_filename_hbox->addWidget(drawing_filename_line_edit);
+  drawing_filename_hbox->addWidget(drawing_filename_button);
+  connect(
+    drawing_filename_button,
+    &QAbstractButton::clicked,
+    this,
+    &BuildingLevelDialog::drawing_filename_button_clicked);
+  connect(
+    drawing_filename_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &BuildingLevelDialog::drawing_filename_line_edited);
+
+  QHBoxLayout* instr_hbox = new QHBoxLayout;
+  instr_hbox->addWidget(
+    new QLabel(
+      "Explicit dimensions are only needed if drawing is not provided:"));
+
+  QHBoxLayout* x_hbox = new QHBoxLayout;
+  x_line_edit = new QLineEdit(QString::number(building_level.x_meters), this);
+  x_hbox->addWidget(new QLabel("x dimension (meters):"));
+  x_hbox->addWidget(x_line_edit);
+
+  QHBoxLayout* y_hbox = new QHBoxLayout;
+  y_line_edit = new QLineEdit(QString::number(building_level.y_meters), this);
+  y_hbox->addWidget(new QLabel("y dimension (meters):"));
+  y_hbox->addWidget(y_line_edit);
+
+  flattened_x_offset_line_edit =
+    new QLineEdit(QString::number(building_level.flattened_x_offset));
+  QHBoxLayout* flattened_x_offset_hbox = new QHBoxLayout;
+  flattened_x_offset_hbox->addWidget(
+    new QLabel("flattened x offset (meters)"));
+  flattened_x_offset_hbox->addWidget(flattened_x_offset_line_edit);
+
+  flattened_y_offset_line_edit =
+    new QLineEdit(QString::number(building_level.flattened_y_offset));
+  QHBoxLayout* flattened_y_offset_hbox = new QHBoxLayout;
+  flattened_y_offset_hbox->addWidget(
+    new QLabel("flattened y offset (meters)"));
+  flattened_y_offset_hbox->addWidget(flattened_y_offset_line_edit);
+
+  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
+  bottom_buttons_hbox->addWidget(cancel_button);
+  bottom_buttons_hbox->addWidget(ok_button);
+  connect(
+    ok_button,
+    &QAbstractButton::clicked,
+    this,
+    &BuildingLevelDialog::ok_button_clicked);
+  connect(
+    cancel_button,
+    &QAbstractButton::clicked,
+    this,
+    &QDialog::reject);
+
+  QVBoxLayout* top_vbox = new QVBoxLayout;
+  top_vbox->addLayout(name_hbox);
+  top_vbox->addLayout(elevation_hbox);
+  top_vbox->addLayout(drawing_filename_hbox);
+  top_vbox->addLayout(instr_hbox);
+  top_vbox->addLayout(x_hbox);
+  top_vbox->addLayout(y_hbox);
+  top_vbox->addLayout(flattened_x_offset_hbox);
+  top_vbox->addLayout(flattened_y_offset_hbox);
+  // todo: some sort of separator (?)
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  setLayout(top_vbox);
+
+  enable_dimensions(building_level.drawing_filename.empty());
+}
+
+BuildingLevelDialog::~BuildingLevelDialog()
+{
+}
+
+void BuildingLevelDialog::drawing_filename_button_clicked()
+{
+  QFileDialog file_dialog(this, "Find Drawing");
+  file_dialog.setFileMode(QFileDialog::ExistingFile);
+  file_dialog.setNameFilter("*.png");
+  if (file_dialog.exec() != QDialog::Accepted)
+  {
+    if (drawing_filename_line_edit->text().isEmpty())
+      enable_dimensions(true);
+    return;  // user clicked 'cancel'
+  }
+  const QString filename = file_dialog.selectedFiles().first();
+  if (!QFileInfo(filename).exists())
+  {
+    QMessageBox::critical(
+      this,
+      "Drawing file does not exist",
+      "File does not exist.");
+    if (drawing_filename_line_edit->text().isEmpty())
+      enable_dimensions(true);
+    return;
+  }
+  drawing_filename_line_edit->setText(
+    QDir::current().relativeFilePath(filename));
+  enable_dimensions(false);
+}
+
+void BuildingLevelDialog::ok_button_clicked()
+{
+  if (!drawing_filename_line_edit->text().isEmpty())
+  {
+    // make sure the drawing file exists
+    if (!QFileInfo(drawing_filename_line_edit->text()).exists())
+    {
+      QMessageBox::critical(
+        this,
+        "If supplied, drawing filename must exist",
+        "If supplied, drawing filename must exist");
+      return;
+    }
+  }
+  /*
+  // todo: figure out how to test for valid numeric values;
+  // this doesn't work but there must be a similar function somewhere
+  if (!x_line_edit->text().isNumber() || !y_line_edit->text().isNumber()) {
+    QMessageBox::critical(
+        this,
+        "X and Y dimensions must be numbers",
+        "X and Y dimensions must be numbers");
+    return;
+  }
+  */
+  if (name_line_edit->text().isEmpty())
+  {
+    QMessageBox::critical(
+      this,
+      "Name must not be empty",
+      "Name must not be empty");
+    return;
+  }
+  auto original_name = building_level.name;
+  building_level.name = name_line_edit->text().toStdString();
+  building_level.elevation = elevation_line_edit->text().toDouble();
+  for (size_t i = 0; i < building.lifts.size(); i ++)
+  {
+    if (original_name != building_level.name)
+    {
+      if (building.lifts[i].level_doors.find(original_name) !=
+        building.lifts[i].level_doors.end())
+      {
+        building.lifts[i].level_doors[building_level.name] =
+          building.lifts[i].level_doors[original_name];
+        building.lifts[i].level_doors.erase(original_name);
+      }
+    }
+    if (building.lifts[i].highest_floor == original_name)
+    {
+      building.lifts[i].highest_floor = building_level.name;
+      building.lifts[i].highest_elevation = building_level.elevation;
+    }
+    if (building.lifts[i].lowest_floor == original_name)
+    {
+      building.lifts[i].lowest_floor = building_level.name;
+      building.lifts[i].lowest_elevation = building_level.elevation;
+    }
+  }
+  building_level.drawing_filename =
+    drawing_filename_line_edit->text().toStdString();
+  if (building_level.drawing_filename.empty())
+  {
+    building_level.x_meters = x_line_edit->text().toDouble();
+    building_level.y_meters = y_line_edit->text().toDouble();
+  }
+  else
+  {
+    building_level.x_meters = 0.0;
+    building_level.y_meters = 0.0;
+  }
+
+  building_level.flattened_x_offset =
+    flattened_x_offset_line_edit->text().toDouble();
+  building_level.flattened_y_offset =
+    flattened_y_offset_line_edit->text().toDouble();
+
+  building_level.calculate_scale();
+  accept();
+}
+
+void BuildingLevelDialog::enable_dimensions(const bool enable)
+{
+  if (enable)
+  {
+    x_line_edit->setEnabled(true);
+    y_line_edit->setEnabled(true);
+  }
+  else
+  {
+    x_line_edit->setText("10");
+    y_line_edit->setText("10");
+    x_line_edit->setEnabled(false);
+    y_line_edit->setEnabled(false);
+  }
+}
+
+void BuildingLevelDialog::drawing_filename_line_edited(const QString& text)
+{
+  enable_dimensions(text.isEmpty());
+}
diff --git a/traffic_editor/gui/building_level_dialog.h b/traffic_editor/gui/building_level_dialog.h
new file mode 100644
index 0000000..3b46ef0
--- /dev/null
+++ b/traffic_editor/gui/building_level_dialog.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_LEVEL_DIALOG_H
+#define BUILDING_LEVEL_DIALOG_H
+
+#include <QDialog>
+#include "traffic_editor/building.h"
+#include "traffic_editor/building_level.h"
+class QLineEdit;
+
+
+class BuildingLevelDialog : public QDialog
+{
+public:
+  BuildingLevelDialog(BuildingLevel& level, Building& building);
+  ~BuildingLevelDialog();
+
+private:
+  BuildingLevel& building_level;
+  Building& building;
+
+  QLineEdit* name_line_edit, * drawing_filename_line_edit;
+  QLineEdit* x_line_edit, * y_line_edit;
+  QLineEdit* flattened_x_offset_line_edit;
+  QLineEdit* flattened_y_offset_line_edit;
+  QLineEdit* elevation_line_edit;
+  QPushButton* drawing_filename_button;
+  QPushButton* ok_button, * cancel_button;
+
+  void enable_dimensions(const bool enable);
+
+private slots:
+  void drawing_filename_button_clicked();
+  void ok_button_clicked();
+  void drawing_filename_line_edited(const QString& text);
+};
+
+#endif
diff --git a/traffic_editor/gui/building_level_table.cpp b/traffic_editor/gui/building_level_table.cpp
new file mode 100644
index 0000000..a7b4cc6
--- /dev/null
+++ b/traffic_editor/gui/building_level_table.cpp
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "building_level_table.h"
+#include "building_level_dialog.h"
+#include <QtWidgets>
+
+BuildingLevelTable::BuildingLevelTable()
+: TableList(6)
+{
+  const QStringList labels =
+  { "Name", "Scale", "X", "Y", "Z", "" };
+  setHorizontalHeaderLabels(labels);
+}
+
+BuildingLevelTable::~BuildingLevelTable()
+{
+}
+
+void BuildingLevelTable::update(Building& building)
+{
+  blockSignals(true);  // avoid tons of callbacks
+
+  setRowCount(1 + building.levels.size());
+  const int reference_level_idx = building.get_reference_level_idx();
+
+  for (size_t i = 0; i < building.levels.size(); i++)
+  {
+    QTableWidgetItem* name_item =
+      new QTableWidgetItem(QString::fromStdString(building.levels[i].name));
+    setItem(i, 0, name_item);
+
+    if (static_cast<int>(i) == reference_level_idx)
+      name_item->setBackground(QBrush(QColor("#e0ffe0")));
+
+    setItem(
+      i,
+      1,
+      new QTableWidgetItem(
+        QString::number(
+          building.levels[i].drawing_meters_per_pixel,
+          'f',
+          4)));
+
+    Building::Transform t = building.get_transform(reference_level_idx, i);
+
+    setItem(i, 2, new QTableWidgetItem(QString::number(t.dx, 'f', 1)));
+    setItem(i, 3, new QTableWidgetItem(QString::number(t.dy, 'f', 1)));
+
+    setItem(
+      i,
+      4,
+      new QTableWidgetItem(
+        QString::number(building.levels[i].elevation, 'f', 1)));
+
+    QPushButton* edit_button = new QPushButton("Edit...", this);
+    setCellWidget(i, 5, edit_button);
+    edit_button->setStyleSheet("QTableWidgetItem { background-color: red; }");
+
+    connect(
+      edit_button,
+      &QAbstractButton::clicked,
+      [this, &building, i]()
+      {
+        BuildingLevelDialog level_dialog(building.levels[i], building);
+        if (level_dialog.exec() == QDialog::Accepted)
+        {
+          building.levels[i].load_drawing();
+          setWindowModified(true);  // not sure why, but this doesn't work
+        }
+        update(building);
+      });
+  }
+
+  const int last_row_idx = static_cast<int>(building.levels.size());
+  // we'll use the last row for the "Add" button
+  for (int i = 0; i < 5; i++)
+    setItem(last_row_idx, i, new QTableWidgetItem(QString()));
+
+  QPushButton* add_button = new QPushButton("Add...", this);
+  setCellWidget(last_row_idx, 5, add_button);
+  connect(
+    add_button,
+    &QAbstractButton::clicked,
+    [this, &building]()
+    {
+      BuildingLevel level;
+      BuildingLevelDialog level_dialog(level, building);
+      if (level_dialog.exec() == QDialog::Accepted)
+      {
+        level.load_drawing();
+        building.add_level(level);
+        setWindowModified(true);
+        update(building);
+        emit redraw_scene();
+      }
+    });
+
+  blockSignals(false);
+}
diff --git a/traffic_editor/gui/building_level_table.h b/traffic_editor/gui/building_level_table.h
new file mode 100644
index 0000000..3ae76f9
--- /dev/null
+++ b/traffic_editor/gui/building_level_table.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_LEVEL_TABLE_H
+#define BUILDING_LEVEL_TABLE_H
+
+#include <QTableWidget>
+
+#include "table_list.h"
+#include "traffic_editor/building.h"
+
+class BuildingLevelTable : public TableList
+{
+  Q_OBJECT
+
+public:
+  BuildingLevelTable();
+  ~BuildingLevelTable();
+
+  void update(Building& building);
+
+signals:
+  void redraw_scene();
+};
+
+#endif
diff --git a/traffic_editor/gui/crowd_sim/agent_group.cpp b/traffic_editor/gui/crowd_sim/agent_group.cpp
new file mode 100644
index 0000000..cf45e91
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/agent_group.cpp
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/agent_group.h>
+
+using namespace crowd_sim;
+
+//==============================================
+YAML::Node AgentGroup::to_yaml() const
+{
+  YAML::Node group_node = YAML::Node(YAML::NodeType::Map);
+  group_node.SetStyle(YAML::EmitterStyle::Flow);
+  group_node["group_id"] = _group_id;
+  group_node["profile_selector"] = _agent_profile;
+  group_node["state_selector"] = _initial_state;
+  group_node["agents_number"] = _spawn_number;
+  group_node["agents_name"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto name : _external_agent_name)
+  {
+    group_node["agents_name"].push_back(name);
+  }
+  group_node["x"] = _spawn_point_x;
+  group_node["y"] = _spawn_point_y;
+  return group_node;
+}
+
+//==============================================
+void AgentGroup::from_yaml(const YAML::Node& input)
+{
+  _group_id = input["group_id"].as<size_t>();
+  _spawn_point_x = input["x"].as<double>();
+  _spawn_point_y = input["y"].as<double>();
+  _spawn_number = input["agents_number"].as<int>();
+  _agent_profile = input["profile_selector"].as<std::string>();
+  _initial_state = input["state_selector"].as<std::string>();
+  const YAML::Node& agent_name_node = input["agents_name"];
+  for (YAML::const_iterator it = agent_name_node.begin();
+    it != agent_name_node.end(); it++)
+  {
+    _external_agent_name.emplace_back( (*it).as<std::string>() );
+  }
+  if (_external_agent_name.size() > 0)
+  {
+    _is_external_group = true;
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/agent_group_table.cpp b/traffic_editor/gui/crowd_sim/agent_group_table.cpp
new file mode 100644
index 0000000..2eb80b1
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/agent_group_table.cpp
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#include "agent_group_table.h"
+
+
+using namespace crowd_sim;
+
+//=======================================
+std::shared_ptr<AgentGroupTab> AgentGroupTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl)
+{
+  const QStringList labels =
+  { "id", "profile", "initial state", "spawn number",
+    "external agent", "point_x", "point_y", ""};
+
+  auto agent_group_tab =
+    std::make_shared<AgentGroupTab>(crowd_sim_impl, labels);
+  if (!agent_group_tab)
+  {
+    printf("Failed to create agent_group table! Exiting");
+    return nullptr;
+  }
+  agent_group_tab->setMinimumSize(1200, 400);
+  return agent_group_tab;
+}
+
+//=======================================
+void AgentGroupTab::add_button_click()
+{
+  _cache.emplace_back(get_cache_size());
+}
+
+//=======================================
+void AgentGroupTab::delete_button_click(size_t row_number)
+{
+  if (row_number == 0)
+  {
+    std::cout <<
+      "Default agent_group for external agents is not allowed to be deleted. "
+              << std::endl;
+    return;
+  }
+  if (row_number > _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
+
+//=======================================
+void AgentGroupTab::list_item_in_cache()
+{
+  auto cache_count = get_cache_size();
+
+  for (auto i = 0; i < cache_count; i++)
+  {
+    auto current_group = _cache[i];
+
+    setItem(i, 0,
+      new QTableWidgetItem(QString::number(
+        static_cast<int>(current_group.get_group_id()))));
+
+    auto current_profile = current_group.get_agent_profile();
+    if (i == 0)
+    {
+      setItem(i, 1,
+        new QTableWidgetItem(QString::fromStdString(current_profile) ) );
+    }
+    else
+    {
+      QComboBox* profile_combo = new QComboBox;
+      _add_profiles_in_combobox(profile_combo, current_profile);
+      setCellWidget(i, 1, profile_combo);
+    }
+
+    auto current_state = current_group.get_initial_state();
+    if (i == 0)
+    {
+      setItem(i, 2,
+        new QTableWidgetItem(QString::fromStdString(current_state) ) );
+    }
+    else
+    {
+      QComboBox* state_combo = new QComboBox;
+      _add_states_in_combobox(state_combo, current_state);
+      setCellWidget(i, 2, state_combo);
+    }
+
+    setItem(i, 3,
+      new QTableWidgetItem(QString::number(current_group.get_spawn_number())));
+
+    std::string external_agent_name = "";
+    if (current_group.is_external_group())
+    {
+      for (auto name : current_group.get_external_agent_name())
+      {
+        external_agent_name += name + ";";
+      }
+    }
+    setItem(i, 4,
+      new QTableWidgetItem(QString::fromStdString(external_agent_name) ));
+
+    auto spawn_point = current_group.get_spawn_point();
+    setItem(i, 5,
+      new QTableWidgetItem(QString::number(spawn_point.first)));
+
+    setItem(i, 6,
+      new QTableWidgetItem(QString::number(spawn_point.second)));
+  }
+}
+
+//=======================================
+void AgentGroupTab::save()
+{
+  auto row_count = rowCount();
+  std::vector<AgentGroup> tmp_cache;
+  bool OK_status;
+  for (auto row = 0; row < row_count-1; row++)
+  {
+    if (row == 0)
+    {
+      tmp_cache.push_back(_cache[0]);
+      continue;
+    }
+
+    AgentGroup current_group(row);
+
+    auto profile_combo = static_cast<QComboBox*>(cellWidget(row, 1));
+    current_group.set_agent_profile(profile_combo->currentText().toStdString());
+
+    auto state_combo = static_cast<QComboBox*>(cellWidget(row, 2));
+    current_group.set_initial_state(state_combo->currentText().toStdString());
+
+    int spawn_number = item(row, 3)->text().toInt(&OK_status);
+    if (OK_status)
+    {
+      current_group.set_spawn_number(spawn_number);
+    }
+    else
+    {
+      std::cout << "Invalid input of spawn_number, use default 0." << std::endl;
+    }
+
+    double point_x = item(row, 5)->text().toDouble(&OK_status);
+    if (!OK_status)
+    {
+      std::cout <<
+        "Invalid input of x for spawn point coord, use default 0.0." <<
+        std::endl;
+      point_x = 0.0;
+    }
+    double point_y = item(row, 6)->text().toDouble(&OK_status);
+    if (!OK_status)
+    {
+      std::cout <<
+        "Invalid input of y for spawn point coord, use default 0.0." <<
+        std::endl;
+      point_y = 0.0;
+    }
+    current_group.set_spawn_point(point_x, point_y);
+    tmp_cache.push_back(current_group);
+  }
+  _cache = tmp_cache;
+}
+
+//=======================================
+void AgentGroupTab::save_to_impl()
+{
+  save();
+  get_impl()->save_agent_groups(_cache);
+}
+
+//=======================================
+void AgentGroupTab::_add_profiles_in_combobox(
+  QComboBox* profile_combo,
+  std::string current_profile)
+{
+  for (auto profile : get_impl()->get_agent_profiles())
+  {
+    profile_combo->addItem(QString::fromStdString(profile.profile_name));
+  }
+  int current_index =
+    profile_combo->findText(QString::fromStdString(current_profile));
+  profile_combo->setCurrentIndex(current_index >= 0 ? current_index : 0);
+}
+
+//=======================================
+void AgentGroupTab::_add_states_in_combobox(
+  QComboBox* state_combo,
+  std::string current_state)
+{
+  for (auto state : get_impl()->get_states())
+  {
+    state_combo->addItem(QString::fromStdString(state.get_name()));
+  }
+  int current_index = state_combo->findText(QString::fromStdString(
+        current_state));
+  state_combo->setCurrentIndex(current_index >= 0 ? current_index : 0);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/agent_group_table.h b/traffic_editor/gui/crowd_sim/agent_group_table.h
new file mode 100644
index 0000000..877cc6f
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/agent_group_table.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_AGENT_GROUP_TABLE__H
+#define CROWD_SIM_AGENT_GROUP_TABLE__H
+
+#include <QComboBox>
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class AgentGroupTab : public CrowdSimTableBase
+{
+public:
+
+  static std::shared_ptr<AgentGroupTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl);
+
+  AgentGroupTab(CrowdSimImplPtr crowd_sim_impl, const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels)
+  {
+    _cache = get_impl()->get_agent_groups();
+  }
+
+  ~AgentGroupTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  std::vector<AgentGroup> _cache;
+  void _add_profiles_in_combobox(QComboBox* profile_combo,
+    std::string current_profile);
+  void _add_states_in_combobox(QComboBox* states_combo,
+    std::string current_state);
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/agent_profile.cpp b/traffic_editor/gui/crowd_sim/agent_profile.cpp
new file mode 100644
index 0000000..45345e5
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/agent_profile.cpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/agent_profile.h>
+
+using namespace crowd_sim;
+
+//==============================================
+YAML::Node AgentProfile::to_yaml() const
+{
+  YAML::Node profile_node(YAML::NodeType::Map);
+  profile_node.SetStyle(YAML::EmitterStyle::Flow);
+  profile_node["name"] = profile_name;
+  profile_node["class"] = profile_class;
+  profile_node["max_accel"] = max_accel;
+  profile_node["max_angle_vel"] = max_angle_vel;
+  profile_node["max_neighbors"] = max_neighbors;
+  profile_node["max_speed"] = max_speed;
+  profile_node["neighbor_dist"] = neighbor_dist;
+  profile_node["obstacle_set"] = obstacle_set;
+  profile_node["pref_speed"] = pref_speed;
+  profile_node["r"] = r;
+  profile_node["ORCA_tau"] = ORCA_tau;
+  profile_node["ORCA_tauObst"] = ORCA_tauObst;
+  return profile_node;
+}
+
+//==============================================
+void AgentProfile::from_yaml(const YAML::Node& input)
+{
+  profile_name = input["name"].as<std::string>();
+  profile_class = input["class"].as<size_t>();
+  max_neighbors = input["max_neighbors"].as<size_t>();
+  obstacle_set = input["obstacle_set"].as<size_t>();
+  max_accel = input["max_accel"].as<double>();
+  max_angle_vel = input["max_angle_vel"].as<double>();
+  max_speed = input["max_speed"].as<double>();
+  neighbor_dist = input["neighbor_dist"].as<double>();
+  pref_speed = input["pref_speed"].as<double>();
+  r = input["r"].as<double>();
+  ORCA_tau = input["ORCA_tau"].as<double>();
+  ORCA_tauObst = input["ORCA_tauObst"].as<double>();
+}
diff --git a/traffic_editor/gui/crowd_sim/agent_profile_table.cpp b/traffic_editor/gui/crowd_sim/agent_profile_table.cpp
new file mode 100644
index 0000000..f43fd5a
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/agent_profile_table.cpp
@@ -0,0 +1,261 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <iostream>
+#include <vector>
+
+#include "agent_profile_table.h"
+
+using namespace crowd_sim;
+
+//===================================================
+std::shared_ptr<AgentProfileTab> AgentProfileTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl)
+{
+  const QStringList labels =
+  { "Name", "class", "max_accel", "max_angle_vel", "max_neighbors",
+    "max_speed", "neighbor_dist", "obstacle_set", "pref_speed", "r",
+    "ORCA_tau", "ORCA_tauObst", ""};
+
+  auto agent_profile_tab = std::make_shared<AgentProfileTab>(crowd_sim_impl,
+      labels);
+  if (!agent_profile_tab)
+  {
+    printf("Failed to create agent_profile table! Exiting");
+    return nullptr;
+  }
+  agent_profile_tab->setMinimumSize(1600, 400);
+  return agent_profile_tab;
+}
+
+//===================================================
+void AgentProfileTab::list_item_in_cache()
+{
+  auto cache_count = get_cache_size();
+  for (auto i = 0; i < cache_count; i++)
+  {
+    auto current_profile = _cache[i];
+    setItem(i, 0,
+      new QTableWidgetItem(QString::fromStdString(current_profile.profile_name)));
+    setItem(i, 1,
+      new QTableWidgetItem(QString::number(
+        static_cast<uint>(current_profile.profile_class))));
+    setItem(i, 2,
+      new QTableWidgetItem(QString::number(current_profile.max_accel)));
+    setItem(i, 3,
+      new QTableWidgetItem(QString::number(current_profile.max_angle_vel)));
+    setItem(i, 4,
+      new QTableWidgetItem(QString::number(
+        static_cast<uint>(current_profile.max_neighbors))));
+    setItem(i, 5,
+      new QTableWidgetItem(QString::number(current_profile.max_speed)));
+    setItem(i, 6,
+      new QTableWidgetItem(QString::number(current_profile.neighbor_dist)));
+    setItem(i, 7,
+      new QTableWidgetItem(QString::number(
+        static_cast<uint>(current_profile.obstacle_set))));
+    setItem(i, 8,
+      new QTableWidgetItem(QString::number(current_profile.pref_speed)));
+    setItem(i, 9,
+      new QTableWidgetItem(QString::number(current_profile.r)));
+    setItem(i, 10,
+      new QTableWidgetItem(QString::number(current_profile.ORCA_tau)));
+    setItem(i, 11,
+      new QTableWidgetItem(QString::number(current_profile.ORCA_tauObst)));
+  }
+}
+
+//===================================================
+void AgentProfileTab::add_button_click()
+{
+  _cache.emplace_back("new profile");
+}
+
+//===================================================
+void AgentProfileTab::delete_button_click(size_t row_number)
+{
+  if (row_number == 0)
+  {
+    std::cout <<
+      "Default external agnet profile is not allowed to be deleted." <<
+      std::endl;
+    return;
+  }
+  if (row_number > _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
+
+//===================================================
+void AgentProfileTab::save_to_impl()
+{
+  save();
+  get_impl()->save_agent_profiles(_cache);
+}
+
+//===================================================
+void AgentProfileTab::save()
+{
+  auto row_count = rowCount();
+  std::vector<AgentProfile> tmp_cache;
+
+  QTableWidgetItem* pItem;
+  bool OK_status;
+  for (auto i = 0; i < row_count - 1; i++)
+  {
+    AgentProfile current_profile("");
+
+    pItem = item(i, 0);
+    auto profile_name = pItem->text().toStdString();
+    current_profile.profile_name = profile_name;
+
+    pItem = item(i, 1);
+    auto profile_class = pItem->text().toInt(&OK_status);
+    if (OK_status)
+    {
+      current_profile.profile_class = static_cast<size_t>(profile_class);
+    }
+    else
+    {
+      std::cout << "Error in saving profile_class for Agent Profile: ["
+                << profile_name << "], value remains as default." << std::endl;
+    }
+
+    pItem = item(i, 2);
+    auto max_accel = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.max_accel = static_cast<double>(max_accel);
+    }
+    else
+    {
+      std::cout << "Error in saving max_accel for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 3);
+    auto max_angle_vel = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.max_angle_vel = static_cast<double>(max_angle_vel);
+    }
+    else
+    {
+      std::cout << "Error in saving max_angle_vel for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 4);
+    auto max_neighbors = pItem->text().toInt(&OK_status);
+    if (OK_status)
+    {
+      current_profile.max_neighbors = static_cast<size_t>(max_neighbors);
+    }
+    else
+    {
+      std::cout << "Error in saving max_neighbors for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 5);
+    auto max_speed = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.max_speed = static_cast<double>(max_speed);
+    }
+    else
+    {
+      std::cout << "Error in saving max_speed for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 6);
+    auto neighbor_dist = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.neighbor_dist = static_cast<double>(neighbor_dist);
+    }
+    else
+    {
+      std::cout << "Error in saving neighbor dist for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 7);
+    auto obstacle_set = pItem->text().toInt(&OK_status);
+    if (OK_status)
+    {
+      current_profile.obstacle_set = static_cast<double>(obstacle_set);
+    }
+    else
+    {
+      std::cout << "Error in saving obstacle_set for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 8);
+    auto pref_speed = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.pref_speed = static_cast<double>(pref_speed);
+    }
+    else
+    {
+      std::cout << "Error in saving pref_speed for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 9);
+    auto r = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.r = static_cast<double>(r);
+    }
+    else
+    {
+      std::cout << "Error in saving r for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 10);
+    auto ORCA_tau = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.ORCA_tau = static_cast<double>(ORCA_tau);
+    }
+    else
+    {
+      std::cout << "Error in saving ORCA_tau for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    pItem = item(i, 11);
+    auto ORCA_tauObst = pItem->text().toDouble(&OK_status);
+    if (OK_status)
+    {
+      current_profile.ORCA_tauObst = static_cast<double>(ORCA_tauObst);
+    }
+    else
+    {
+      std::cout << "Error in saving ORCA_tauObst for Agent Profile: ["
+                << profile_name << "]" << std::endl;
+    }
+
+    tmp_cache.push_back(current_profile);
+  }
+  _cache = tmp_cache;
+}
diff --git a/traffic_editor/gui/crowd_sim/agent_profile_table.h b/traffic_editor/gui/crowd_sim/agent_profile_table.h
new file mode 100644
index 0000000..b77f6b2
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/agent_profile_table.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_AGENT_PROFILE_TABLE__H
+#define CROWD_SIM_AGENT_PROFILE_TABLE__H
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class AgentProfileTab : public CrowdSimTableBase
+{
+public:
+
+  static std::shared_ptr<AgentProfileTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl);
+
+  AgentProfileTab(CrowdSimImplPtr crowd_sim_impl, const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels)
+  {
+    _cache = get_impl()->get_agent_profiles();
+  }
+  ~AgentProfileTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  std::vector<AgentProfile> _cache;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/condition.cpp b/traffic_editor/gui/crowd_sim/condition.cpp
new file mode 100644
index 0000000..4a68917
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/condition.cpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/condition.h>
+
+#include <iostream>
+
+using namespace crowd_sim;
+
+//===========================================================
+ConditionPtr Condition::init_from_yaml(const YAML::Node& input)
+{
+  if (input["type"] && input["type"].as<std::string>() == "goal_reached")
+  {
+    return std::make_shared<ConditionGOAL>();
+  }
+  if (input["type"] && input["type"].as<std::string>() == "timer")
+  {
+    return std::make_shared<ConditionTIMER>();
+  }
+  if (input["type"] && input["type"].as<std::string>() == "and")
+  {
+    return std::make_shared<ConditionAND>();
+  }
+  if (input["type"] && input["type"].as<std::string>() == "or")
+  {
+    return std::make_shared<ConditionOR>();
+  }
+  if (input["type"] && input["type"].as<std::string>() == "not")
+  {
+    return std::make_shared<ConditionNOT>();
+  }
+  //default
+  return std::make_shared<Condition>();
+}
+
+//===========================================================
+void BoolCondition::set_condition(ConditionPtr condition, int condition_index)
+{
+  if (!condition)
+    return;
+  if (condition_index == 1)
+    this->_condition1 = condition;
+  if (condition_index == 2)
+    this->_condition2 = condition;
+}
+
+//===========================================================
+void BoolCondition::set_condition(ConditionPtr condition)
+{
+  set_condition(condition, 1);
+}
+
+//===========================================================
+ConditionPtr BoolCondition::get_condition(int condition_index) const
+{
+  if (condition_index == 1)
+    return this->_condition1;
+  if (condition_index == 2)
+  {
+    if (this->get_type() == Condition::TYPE::NOT)
+    {
+      return this->_condition1;
+    }
+    return this->_condition2;
+  }
+  return this->_condition1;
+}
+
+//===========================================================
+ConditionPtr BoolCondition::get_condition() const
+{
+  return get_condition(1);
+}
+
+//===========================================================
+bool BoolCondition::is_valid() const
+{
+  if (this->get_type() == Condition::TYPE::NOT)
+  {
+    if (_condition1->is_valid())
+      return true;
+  }
+  else
+  {
+    if (_condition1->is_valid() && _condition2->is_valid())
+    {
+      return true;
+    }
+  }
+  std::cout << "Invalid <" << this->get_condition_name() << "> condition" <<
+    std::endl;
+  return false;
+}
+
+//===========================================================
+YAML::Node BoolCondition::to_yaml() const
+{
+  YAML::Node bool_node = YAML::Node(YAML::NodeType::Map);
+  bool_node.SetStyle(YAML::EmitterStyle::Block);
+  bool_node["type"] = get_condition_name();
+  bool_node["condition1"] = get_condition(1)->to_yaml();
+  if (get_condition(2))
+  {
+    bool_node["condition2"] = get_condition(2)->to_yaml();
+  }
+  return bool_node;
+}
+
+//===========================================================
+void BoolCondition::from_yaml(const YAML::Node& input)
+{
+  if (input["condition1"])
+  {
+    auto condition1_ptr = init_from_yaml(input["condition1"]);
+    condition1_ptr->from_yaml(input["condition1"]);
+    set_condition(condition1_ptr, 1);
+  }
+
+  if (input["condition2"])
+  {
+    auto condition2_ptr = init_from_yaml(input["condition2"]);
+    condition2_ptr->from_yaml(input["condition2"]);
+    set_condition(condition2_ptr, 2);
+  }
+}
+
+//===========================================================
+YAML::Node ConditionGOAL::to_yaml() const
+{
+  YAML::Node goal_node = YAML::Node(YAML::NodeType::Map);
+  goal_node.SetStyle(YAML::EmitterStyle::Flow);
+  goal_node["type"] = get_condition_name();
+  goal_node["distance"] = get_value();
+  return goal_node;
+}
+
+//===========================================================
+void ConditionGOAL::from_yaml(const YAML::Node& input)
+{
+  if (input["type"].as<std::string>() != "goal_reached")
+  {
+    throw std::runtime_error("Error in parsing goal_reached condition");
+  }
+  if (input["distance"] && input["distance"].as<double>() > 0)
+  {
+    set_value(input["distance"].as<double>() );
+  }
+}
+
+//===========================================================
+YAML::Node ConditionTIMER::to_yaml() const
+{
+  YAML::Node timer_node = YAML::Node(YAML::NodeType::Map);
+  timer_node.SetStyle(YAML::EmitterStyle::Flow);
+  timer_node["type"] = get_condition_name();
+  timer_node["dist"] = _distribution; //currently only support const distribution
+  timer_node["value"] = get_value();
+  timer_node["per_agent"] = "true";
+  return timer_node;
+}
+
+//===========================================================
+void ConditionTIMER::from_yaml(const YAML::Node& input)
+{
+  if (input["type"].as<std::string>() != "timer")
+  {
+    throw std::runtime_error("Error in parsing timer condition");
+  }
+  if (input["value"] && input["value"].as<double>() > 0)
+  {
+    set_value(input["value"].as<double>() );
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/condition_dialog.cpp b/traffic_editor/gui/crowd_sim/condition_dialog.cpp
new file mode 100644
index 0000000..84eedc8
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/condition_dialog.cpp
@@ -0,0 +1,339 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "condition_dialog.h"
+
+using namespace crowd_sim;
+
+//=========================================================
+ConditionDialog::ConditionDialog(
+  CrowdSimImplPtr crowd_sim_impl,
+  const std::string& dialog_title,
+  Transition& transition)
+: CrowdSimDialog(crowd_sim_impl, dialog_title),
+  _current_transition(transition)
+{
+  std::string title = "from_state:" + transition.get_from_state();
+  setWindowTitle(QString::fromStdString(title) );
+
+  _root_value = new QLineEdit(QString::number(_rootValueD));
+  _root_condition_value_container = new QWidget;
+  _condition1_container = new QWidget;
+  _condition2_container = new QWidget;
+  _condition1_value = new QLineEdit(QString::number(_condition1ValueD));
+  _condition2_value = new QLineEdit(QString::number(_condition2ValueD));
+
+  QHBoxLayout* root_condition_type = new QHBoxLayout;
+  _root_type = new QComboBox;
+  _construct_root_condition_type(
+    _root_type,
+    _current_transition.get_condition()->get_type() );
+  root_condition_type->addWidget(new QLabel("Condition type:"));
+  root_condition_type->addWidget(_root_type);
+
+  QHBoxLayout* root_condition_value = new QHBoxLayout(
+    _root_condition_value_container);
+  root_condition_value->addWidget(new QLabel(
+      "Value (duration(s) / goal distance(m))"));
+  root_condition_value->addWidget(_root_value);
+  connect(
+    _root_value,
+    &QLineEdit::editingFinished,
+    [&]()
+    {
+      bool OK_status;
+      double temp = _root_value->text().toDouble(&OK_status);
+      if (!OK_status)
+      {
+        std::cout << "Invalid condition value input!" << std::endl;
+        return;
+      }
+      auto root_condition = _current_transition.get_condition();
+      if (crowd_sim::Condition::GOAL == root_condition->get_type())
+      {
+        auto goal_condition = std::dynamic_pointer_cast<crowd_sim::ConditionGOAL>(
+          root_condition);
+        goal_condition->set_value(temp);
+      }
+      if (crowd_sim::Condition::TIMER == root_condition->get_type())
+      {
+        auto timer_condition = std::dynamic_pointer_cast<crowd_sim::ConditionTIMER>(
+          root_condition);
+        timer_condition->set_value(temp);
+      }
+    }
+  );
+
+  _condition1_type = new QComboBox;
+  _condition2_type = new QComboBox;
+  _construct_leaf_condition_widget(_condition1_container, _condition1_type,
+    _condition1_value, 1);
+  _construct_leaf_condition_widget(_condition2_container, _condition2_type,
+    _condition2_value, 2);
+
+  top_vbox->addLayout(root_condition_type);
+  top_vbox->addWidget(_root_condition_value_container);
+  top_vbox->addWidget(_condition1_container);
+  top_vbox->addWidget(_condition2_container);
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  update();
+}
+
+//=========================================================
+void ConditionDialog::save()
+{
+  if (_root_condition_value_container->isEnabled())
+  {
+    _root_value->editingFinished();
+  }
+  if (_condition1_container->isEnabled())
+  {
+    _condition1_value->editingFinished();
+  }
+  if (_condition2_container->isEnabled())
+  {
+    _condition2_value->editingFinished();
+  }
+}
+
+//========================================================
+void ConditionDialog::update()
+{
+  auto root_condition = _current_transition.get_condition();
+  _root_type->setCurrentIndex(root_condition->get_type());
+
+  if (Condition::BASE == root_condition->get_type())
+    return;
+
+  if (Condition::GOAL == root_condition->get_type() ||
+    Condition::TIMER == root_condition->get_type() )
+  {
+    auto root_condition_tmp =
+      std::dynamic_pointer_cast<crowd_sim::LeafCondition>(root_condition);
+    _rootValueD = root_condition_tmp->get_value();
+    _root_value->setText(QString::number(_rootValueD));
+    return;
+  }
+
+  auto root_condition_tmp = std::dynamic_pointer_cast<crowd_sim::BoolCondition>(
+    root_condition);
+  auto sub_condition_1 = root_condition_tmp->get_condition(1);
+  _condition1_type->setCurrentIndex(
+    sub_condition_1->get_type() - crowd_sim::Condition::GOAL);
+  _condition1ValueD = std::dynamic_pointer_cast<crowd_sim::LeafCondition>(
+    sub_condition_1)->get_value();
+  _condition1_value->setText(QString::number(_condition1ValueD));
+
+  if (Condition::NOT == root_condition->get_type())
+    return;
+  auto sub_condition_2 = root_condition_tmp->get_condition(2);
+  _condition2_type->setCurrentIndex(
+    sub_condition_2->get_type()- crowd_sim::Condition::GOAL);
+  _condition2ValueD = std::dynamic_pointer_cast<crowd_sim::LeafCondition>(
+    sub_condition_2)->get_value();
+  _condition2_value->setText(QString::number(_condition2ValueD));
+}
+
+//=========================================================
+void ConditionDialog::_construct_root_condition_type(
+  QComboBox* root_type,
+  Condition::TYPE current_type)
+{
+  _root_is_invalid();
+  if (Condition::GOAL == current_type ||
+    Condition::TIMER == current_type)
+    _root_is_leaf_condition();
+  if (Condition::AND == current_type ||
+    Condition::OR == current_type)
+    _root_is_bool2_condition();
+  if (Condition::NOT == current_type)
+    _root_is_not_condition();
+
+  root_type->addItem("base_condition(invalid)");
+  root_type->addItem("goal_reached");
+  root_type->addItem("timer");
+  root_type->addItem("and");
+  root_type->addItem("or");
+  root_type->addItem("not");
+
+  connect(
+    root_type,
+    QOverload<int>::of(&QComboBox::activated),
+    [this](int index)
+    {
+      switch (index)
+      {
+        case 1:
+          _root_is_leaf_condition();
+          if (_current_transition.get_condition()->get_type() !=
+          crowd_sim::Condition::GOAL)
+            _current_transition.set_condition(
+              std::make_shared<crowd_sim::ConditionGOAL>() );
+          break;
+        case 2:
+          _root_is_leaf_condition();
+          if (_current_transition.get_condition()->get_type() !=
+          crowd_sim::Condition::TIMER)
+            _current_transition.set_condition(
+              std::make_shared<crowd_sim::ConditionTIMER>() );
+          break;
+        case 3:
+          _root_is_bool2_condition();
+          if (_current_transition.get_condition()->get_type() !=
+          crowd_sim::Condition::AND)
+            _current_transition.set_condition(
+              std::make_shared<crowd_sim::ConditionAND>() );
+          break;
+        case 4:
+          _root_is_bool2_condition();
+          if (_current_transition.get_condition()->get_type() !=
+          crowd_sim::Condition::OR)
+            _current_transition.set_condition(
+              std::make_shared<crowd_sim::ConditionOR>() );
+          break;
+        case 5:
+          _root_is_not_condition();
+          if (_current_transition.get_condition()->get_type() !=
+          crowd_sim::Condition::NOT)
+            _current_transition.set_condition(
+              std::make_shared<crowd_sim::ConditionNOT>() );
+          break;
+        default:
+          _root_is_invalid();
+      }
+    }
+  );
+}
+
+//=======================================
+void ConditionDialog::_root_is_invalid()
+{
+  _root_condition_value_container->setEnabled(false);
+  _condition1_container->setEnabled(false);
+  _condition2_container->setEnabled(false);
+}
+//=======================================
+void ConditionDialog::_root_is_leaf_condition()
+{
+  _root_condition_value_container->setEnabled(true);
+  _condition1_container->setEnabled(false);
+  _condition2_container->setEnabled(false);
+}
+
+//=======================================
+void ConditionDialog::_root_is_bool2_condition()
+{
+  _root_condition_value_container->setEnabled(false);
+  _condition1_container->setEnabled(true);
+  _condition2_container->setEnabled(true);
+}
+
+//=======================================
+void ConditionDialog::_root_is_not_condition()
+{
+  _root_condition_value_container->setEnabled(false);
+  _condition1_container->setEnabled(true);
+  _condition2_container->setEnabled(false);
+}
+
+//=========================================
+void ConditionDialog::_construct_leaf_condition_widget(
+  QWidget* condition_container,
+  QComboBox* condition_type,
+  QLineEdit* condition_value,
+  int condition_index)
+{
+  QHBoxLayout* condition_hbox = new QHBoxLayout(condition_container);
+  condition_type->addItem("goal_reached");
+  condition_type->addItem("timer");
+
+  if (condition_index == 1)
+    condition_value->setText(QString::number(_condition1ValueD));
+  else
+    condition_value->setText(QString::number(_condition2ValueD));
+  std::string condition_label = "condition" + std::to_string(condition_index) +
+    ":";
+  condition_hbox->addWidget(new QLabel(QString::fromStdString(condition_label) ));
+  condition_hbox->addWidget(condition_type);
+  condition_hbox->addWidget(condition_value);
+  connect(
+    condition_value,
+    &QLineEdit::editingFinished,
+    [this, condition_type, condition_value, condition_index]()
+    {
+      bool OK_status;
+      double temp_value = condition_value->text().toDouble(&OK_status);
+      if (!OK_status)
+      {
+        std::cout << "Invalid condition value input!" << std::endl;
+        return;
+      }
+      if (condition_type->currentIndex() == 0)
+      {
+        _set_sub_condition_in_root_condition(
+          crowd_sim::Condition::GOAL,
+          temp_value,
+          condition_index);
+      }
+      if (condition_type->currentIndex() == 1)
+      {
+        _set_sub_condition_in_root_condition(
+          crowd_sim::Condition::TIMER,
+          temp_value,
+          condition_index);
+      }
+    }
+  );
+}
+
+//======================================================
+void ConditionDialog::_set_sub_condition_in_root_condition(
+  crowd_sim::Condition::TYPE type,
+  double value,
+  int condition_index)
+{
+  auto root_condition = _current_transition.get_condition();
+  if (root_condition->get_type() == Condition::GOAL ||
+    root_condition->get_type() == Condition::TIMER)
+    return;
+  if (root_condition->get_type() == Condition::NOT)
+    condition_index = 1;
+  auto bool_root_condition =
+    std::dynamic_pointer_cast<crowd_sim::BoolCondition>(root_condition);
+
+  if (type == Condition::GOAL)
+  {
+    auto sub_condition = std::make_shared<crowd_sim::ConditionGOAL>();
+    sub_condition->set_value(value);
+    bool_root_condition->set_condition(sub_condition, condition_index);
+  }
+  if (type == crowd_sim::Condition::TIMER)
+  {
+    auto sub_condition = std::make_shared<crowd_sim::ConditionTIMER>();
+    sub_condition->set_value(value);
+    bool_root_condition->set_condition(sub_condition, condition_index);
+  }
+}
+
+//===================================================
+void ConditionDialog::ok_button_click()
+{
+  save();
+  accept();
+}
+
diff --git a/traffic_editor/gui/crowd_sim/condition_dialog.h b/traffic_editor/gui/crowd_sim/condition_dialog.h
new file mode 100644
index 0000000..eb00c68
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/condition_dialog.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_CONDITION_DIALOG__H
+#define CROWD_SIM_CONDITION_DIALOG__H
+
+#include <QComboBox>
+#include <QWidget>
+#include <QLineEdit>
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+#include <traffic_editor/crowd_sim/condition.h>
+
+#include "crowd_sim_dialog.h"
+
+using namespace crowd_sim;
+
+class ConditionDialog : public CrowdSimDialog
+{
+public:
+  ConditionDialog(
+    CrowdSimImplPtr crowd_sim_impl,
+    const std::string& dialog_title,
+    Transition& transition);
+  ~ConditionDialog() {}
+
+  void save();
+  void update();
+  void ok_button_click() override;
+
+private:
+  crowd_sim::Transition& _current_transition;
+
+  QComboBox* _root_type;
+  QLineEdit* _root_value;
+  double _rootValueD = 0;
+
+  QComboBox* _condition1_type, * _condition2_type;
+  QLineEdit* _condition1_value, * _condition2_value;
+  double _condition1ValueD = 0, _condition2ValueD = 0;
+
+  QWidget* _root_condition_value_container, * _condition1_container,
+    * _condition2_container;
+
+  void _construct_root_condition_type(
+    QComboBox* root_type,
+    crowd_sim::Condition::TYPE current_type);
+
+  void _construct_leaf_condition_widget(
+    QWidget* condition_container,
+    QComboBox* condition_type,
+    QLineEdit* condition_value,
+    int condition_index);
+
+  void _set_sub_condition_in_root_condition(
+    crowd_sim::Condition::TYPE type,
+    double value,
+    int condition_index);
+
+  void _root_is_leaf_condition();
+  void _root_is_bool2_condition();
+  void _root_is_not_condition();
+  void _root_is_invalid();
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_dialog.cpp b/traffic_editor/gui/crowd_sim/crowd_sim_dialog.cpp
new file mode 100644
index 0000000..56ec4b8
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_dialog.cpp
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "crowd_sim_dialog.h"
+#include "state_table.h"
+#include "goal_set_table.h"
+#include "transition_table.h"
+#include "to_state_table.h"
+#include "agent_profile_table.h"
+#include "agent_group_table.h"
+#include "model_type_table.h"
+
+using namespace crowd_sim;
+
+//===========================================================
+CrowdSimDialog::CrowdSimDialog(
+  CrowdSimImplPtr crowd_sim_impl,
+  const std::string& dialog_title)
+{
+  ok_button = new QPushButton("OK", this);
+  cancel_button = new QPushButton("Cancel", this);
+  bottom_buttons_hbox = new QHBoxLayout;
+  bottom_buttons_hbox->addWidget(cancel_button);
+  bottom_buttons_hbox->addWidget(ok_button);
+  connect(
+    ok_button,
+    &QAbstractButton::clicked,
+    [this]()
+    {
+      ok_button_click();
+    }
+  );
+  connect(
+    cancel_button,
+    &QAbstractButton::clicked,
+    [this]()
+    {
+      cancel_button_click();
+    }
+  );
+  top_vbox = new QVBoxLayout(this);
+
+  if ("States" == dialog_title)
+  {
+    _table_ptr = StatesTab::init_and_make(crowd_sim_impl);
+  }
+  else if ("GoalSets" == dialog_title)
+  {
+    _table_ptr = GoalSetTab::init_and_make(crowd_sim_impl);
+  }
+  else if ("AgentProfiles" == dialog_title)
+  {
+    _table_ptr = AgentProfileTab::init_and_make(crowd_sim_impl);
+  }
+  else if ("Transitions" == dialog_title)
+  {
+    _table_ptr = TransitionTab::init_and_make(crowd_sim_impl);
+  }
+  else if ("AgentGroups" == dialog_title)
+  {
+    _table_ptr = AgentGroupTab::init_and_make(crowd_sim_impl);
+  }
+  else if ("ModelTypes" == dialog_title)
+  {
+    _table_ptr = ModelTypeTab::init_and_make(crowd_sim_impl);
+  }
+  else
+  {
+    // stop constructing table with other type of dialog
+    _table_ptr = nullptr;
+    return;
+  }
+
+  if (!_table_ptr)
+  {
+    throw std::runtime_error(
+            "Failed to initialize table in Dialog " + dialog_title);
+  }
+  _table_ptr->update();
+  QHBoxLayout* table_box = new QHBoxLayout;
+  table_box->addWidget(_table_ptr.get());
+  top_vbox->addLayout(table_box);
+  top_vbox->addLayout(bottom_buttons_hbox);
+  setWindowTitle(QString::fromStdString(dialog_title));
+}
+
+//==============================================
+void CrowdSimDialog::ok_button_click()
+{
+  if (_table_ptr)
+    _table_ptr->save_to_impl();
+  accept();
+}
+
+//==============================================
+void CrowdSimDialog::cancel_button_click()
+{
+  reject();
+}
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_dialog.h b/traffic_editor/gui/crowd_sim/crowd_sim_dialog.h
new file mode 100644
index 0000000..71839e3
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_dialog.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_DIALOG__H
+#define CROWD_SIM_DIALOG__H
+
+#include <memory>
+
+#include <QDialog>
+#include <QComboBox>
+#include <QtWidgets>
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class CrowdSimDialog : public QDialog
+{
+public:
+  CrowdSimDialog(
+    CrowdSimImplPtr crowd_sim_impl,
+    const std::string& dialog_title);
+  virtual ~CrowdSimDialog() {}
+
+  QPushButton* ok_button, * cancel_button;
+  QHBoxLayout* bottom_buttons_hbox;
+  QVBoxLayout* top_vbox;
+
+  virtual void ok_button_click();
+  void cancel_button_click();
+
+private:
+  CrowdSimTablePtr _table_ptr;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_editor_table.cpp b/traffic_editor/gui/crowd_sim/crowd_sim_editor_table.cpp
new file mode 100644
index 0000000..6d7c121
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_editor_table.cpp
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <iostream>
+
+#include <QString>
+
+#include "crowd_sim_editor_table.h"
+#include "crowd_sim_dialog.h"
+
+using namespace crowd_sim;
+
+//=====================================================================
+CrowdSimEditorTable::CrowdSimEditorTable(const Project& input_project)
+: TableList(3),
+  _project(input_project)
+{
+  if (_project.building.crowd_sim_impl == nullptr)
+  {
+    printf("Initialize crowd_sim_implementation for project.building\n");
+    _impl = std::make_shared<crowd_sim::CrowdSimImplementation>();
+    _project.building.crowd_sim_impl = _impl;
+  }
+  else
+  {
+    _impl = _project.building.crowd_sim_impl;
+  }
+
+  const QStringList labels =
+  { "Name", "Status", "" };
+  setHorizontalHeaderLabels(labels);
+  setRowCount(
+    _reserved_rows +  // checkbox for enable_crowd_sim, LineEdit for updtae_time_step
+    _required_components.size());
+
+  _enable_crowd_sim_name_item =
+    new QTableWidgetItem(QString::fromStdString("enable_crowd_sim"));
+  setItem(0, 0, _enable_crowd_sim_name_item);
+  _enable_crowd_sim_checkbox = new QCheckBox(this);
+  _enable_crowd_sim_checkbox->setChecked(_impl->get_enable_crowd_sim());
+  setCellWidget(0, 1, _enable_crowd_sim_checkbox);
+  connect(
+    _enable_crowd_sim_checkbox,
+    &QAbstractButton::clicked,
+    [this](bool box_checked)
+    {
+      _impl->set_enable_crowd_sim(box_checked);
+    }
+  );
+
+  _update_time_step_name_item =
+    new QTableWidgetItem(QString::fromStdString("update_time_step"));
+  setItem(1, 0, _update_time_step_name_item);
+  _update_time_step_value_item =
+    new QLineEdit(QString::number(_impl->get_update_time_step()), this);
+  setCellWidget(1, 1, _update_time_step_value_item);
+  connect(
+    _update_time_step_value_item,
+    &QLineEdit::editingFinished,
+    [this]()
+    {
+      bool OK_status;
+      double update_time_step =
+      _update_time_step_value_item->text().toDouble(&OK_status);
+      _impl->set_update_time_step(
+        OK_status ? update_time_step : 0.1);
+    }
+  );
+
+  update();
+
+  for (size_t i = 0; i < _required_components.size(); ++i)
+  {
+    int row_id = _reserved_rows + i;
+
+    QTableWidgetItem* name_item =
+      new QTableWidgetItem(QString::fromStdString(_required_components[i]) );
+    setItem(row_id, 0, name_item);
+    QPushButton* edit_button = new QPushButton("Edit", this);
+    setCellWidget(row_id, 2, edit_button);
+    edit_button->setStyleSheet("QTableWidgetItem { background-color: red; }");
+
+    connect(
+      edit_button,
+      &QAbstractButton::clicked,
+      [this, i]()
+      {
+        update();
+        CrowdSimDialog dialog(_impl, _required_components[i]);
+        dialog.exec();
+        update();
+      }
+    );
+  }
+
+}
+
+//=================================================
+void CrowdSimEditorTable::update()
+{
+  update_goal_area();
+  update_navmesh_level();
+  update_external_agent_from_spawn_point();
+  update_external_agent_state();
+
+  blockSignals(true);
+
+  _enable_crowd_sim_checkbox->setChecked(_impl->get_enable_crowd_sim() );
+  _update_time_step_value_item->setText(QString::number(_impl->
+    get_update_time_step() ));
+
+  size_t status_number = 0;
+  for (size_t i = 0; i < _required_components.size(); ++i)
+  {
+    status_number = 0;
+    if ("States" == _required_components[i])
+    {
+      status_number = _impl->get_states().size();
+    }
+    if ("GoalSets" == this->_required_components[i])
+    {
+      status_number = _impl->get_goal_sets().size();
+    }
+    if ("AgentProfiles" == this->_required_components[i])
+    {
+      status_number = _impl->get_agent_profiles().size();
+    }
+    if ("Transitions" == this->_required_components[i])
+    {
+      status_number = _impl->get_transitions().size();
+    }
+    if ("AgentGroups" == this->_required_components[i])
+    {
+      status_number = _impl->get_agent_groups().size();
+    }
+    if ("ModelTypes" == this->_required_components[i])
+    {
+      status_number = _impl->get_model_types().size();
+    }
+
+    setItem(
+      _reserved_rows + i,
+      1,
+      new QTableWidgetItem(QString::number(status_number)));
+  }
+
+  blockSignals(false);
+}
+
+//===================================================
+void CrowdSimEditorTable::update_goal_area()
+{
+  _goal_areas_cache.clear();
+  for (auto level : _project.building.levels)
+  {
+    auto vertex_list = level.vertices;
+    for (auto vertex : vertex_list)
+    {
+      if (vertex.params.find("human_goal_set_name") == vertex.params.end() )
+        continue;
+      auto param = vertex.params["human_goal_set_name"];
+      if (param.type != param.STRING)
+      {
+        std::cout << "Error param type for human_goal_set_name." << std::endl;
+        return;
+      }
+      _goal_areas_cache.insert(param.value_string);
+    }
+  }
+  _impl->set_goal_areas(_goal_areas_cache);
+}
+
+//====================================================
+void CrowdSimEditorTable::update_navmesh_level()
+{
+  _navmesh_filename_cache.clear();
+  for (auto level : _project.building.levels)
+  {
+    _navmesh_filename_cache.emplace_back(level.name + "_navmesh.nav");
+  }
+  _impl->set_navmesh_file_name(_navmesh_filename_cache);
+}
+
+//====================================================
+void CrowdSimEditorTable::update_external_agent_from_spawn_point()
+{
+  std::vector<std::string> spawn_point_name;
+
+  for (auto level : _project.building.levels)
+  {
+    for (auto vertex : level.vertices)
+    {
+      if (vertex.params.find("spawn_robot_name") != vertex.params.end())
+      {
+        spawn_point_name.emplace_back(
+          vertex.params["spawn_robot_name"].value_string);
+      }
+    }
+  }
+
+  auto agent_groups = _impl->get_agent_groups();
+  if (agent_groups.size() == 0)
+  {
+    agent_groups.emplace_back(0, true);
+  }
+  auto& external_group = agent_groups.at(0);
+  external_group.set_external_agent_name(spawn_point_name);
+  _impl->save_agent_groups(agent_groups);
+}
+
+//========================================================
+void CrowdSimEditorTable::update_external_agent_state()
+{
+  auto states = _impl->get_states();
+  if (states.size() == 0)
+  {
+    states.emplace_back("external_static");
+  }
+  auto& external_state = states.at(0);
+  external_state.set_name("external_static");
+  external_state.set_final_state(true);
+  _impl->save_states(states);
+}
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_editor_table.h b/traffic_editor/gui/crowd_sim/crowd_sim_editor_table.h
new file mode 100644
index 0000000..ca9e5da
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_editor_table.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_EDITOR_TABLE__H
+#define CROWD_SIM_EDITOR_TABLE__H
+
+#include <vector>
+#include <string>
+#include <set>
+
+#include <QTableWidget>
+#include <QtWidgets>
+
+#include "table_list.h"
+#include "project.h"
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+using namespace crowd_sim;
+
+class CrowdSimEditorTable : public TableList
+{
+  Q_OBJECT;
+
+public:
+  CrowdSimEditorTable(const Project& input_project);
+  ~CrowdSimEditorTable() {}
+
+  void update();
+  void update_goal_area();
+  void update_navmesh_level();
+  void update_external_agent_from_spawn_point();
+  void update_external_agent_state();
+
+private:
+  const Project& _project;
+  CrowdSimImplPtr _impl;
+
+  // reserved rows for checkbox for enable_crowd_sim, LineEdit for updtae_time_step
+  int _reserved_rows = 2;
+  std::vector<std::string> _required_components {
+    "GoalSets",
+    "States",
+    "Transitions",
+    "AgentProfiles",
+    "AgentGroups",
+    "ModelTypes"};
+  std::set<std::string> _goal_areas_cache;
+  std::vector<std::string> _navmesh_filename_cache;
+
+  QTableWidgetItem* _enable_crowd_sim_name_item;
+  QCheckBox* _enable_crowd_sim_checkbox;
+  QTableWidgetItem* _update_time_step_name_item;
+  QLineEdit* _update_time_step_value_item;
+};
+
+#endif
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_impl.cpp b/traffic_editor/gui/crowd_sim/crowd_sim_impl.cpp
new file mode 100644
index 0000000..76c88ff
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_impl.cpp
@@ -0,0 +1,308 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+using namespace crowd_sim;
+
+//=================================================
+void CrowdSimImplementation::_initialize_state()
+{
+  if (_states.size() == 0)
+    _states.emplace_back("external_static");
+  else
+    _states[0] = State("external_static");
+}
+
+//=================================================
+void CrowdSimImplementation::_initialize_agent_profile()
+{
+  if (_agent_profiles.size() == 0)
+    _agent_profiles.emplace_back("external_agent");
+  else
+    _agent_profiles[0] = AgentProfile("external_agent");
+}
+
+//=================================================
+void CrowdSimImplementation::_initialize_agent_group()
+{
+  if (_agent_groups.size() == 0)
+    _agent_groups.emplace_back(0, true);
+  else
+    _agent_groups[0] = AgentGroup(0, true);
+  _agent_groups[0].set_agent_profile("external_agent");
+  _agent_groups[0].set_initial_state("external_static");
+}
+
+//=================================================
+void CrowdSimImplementation::_initialize_model_type()
+{
+  if (_model_types.size() == 0)
+    _model_types.emplace_back("human", "walk");
+  else
+    _model_types[0] = ModelType("human", "walk");
+  auto& default_type = _model_types.at(0);
+  default_type.set_animation_speed(1.0);
+  default_type.set_model_uri("model://MaleVisitorPhone");
+  default_type.set_init_pose(
+    {0, 0, 0, 0, 0, 0}
+  );
+}
+
+//=================================================
+YAML::Node CrowdSimImplementation::_output_obstacle_node() const
+{
+  // Currently only have one level navmesh
+  YAML::Node obstacle_node = YAML::Node(YAML::NodeType::Map);
+  obstacle_node.SetStyle(YAML::EmitterStyle::Flow);
+  obstacle_node["class"] = 1;
+  obstacle_node["type"] = "nav_mesh";
+  obstacle_node["file_name"] = this->_navmesh_filename_list[0];
+  return obstacle_node;
+}
+
+//=================================================
+YAML::Node CrowdSimImplementation::to_yaml()
+{
+  YAML::Node top_node = YAML::Node(YAML::NodeType::Map);
+  top_node["enable"] = _enable_crowd_sim ? 1 : 0;
+  top_node["update_time_step"] = _update_time_step;
+
+  top_node["states"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto state : _states)
+  {
+    if (!state.is_valid())
+      continue;
+    top_node["states"].push_back(state.to_yaml());
+  }
+
+  top_node["goal_sets"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto goal_set : _goal_sets)
+  {
+    top_node["goal_sets"].push_back(goal_set.to_yaml());
+  }
+
+  top_node["agent_profiles"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto profile : _agent_profiles)
+  {
+    top_node["agent_profiles"].push_back(profile.to_yaml());
+  }
+
+  top_node["transitions"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto transition : _transitions)
+  {
+    top_node["transitions"].push_back(transition.to_yaml());
+  }
+
+  top_node["obstacle_set"] = _output_obstacle_node();
+
+  top_node["agent_groups"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto group : _agent_groups)
+  {
+    top_node["agent_groups"].push_back(group.to_yaml());
+  }
+
+  top_node["model_types"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto model_type : _model_types)
+  {
+    top_node["model_types"].push_back(model_type.to_yaml());
+  }
+
+  return top_node;
+}
+
+//=================================================
+bool CrowdSimImplementation::from_yaml(const YAML::Node& input)
+{
+  if (!input["goal_sets"] || !input["goal_sets"].IsSequence())
+  {
+    printf("Error in load goal_sets\n");
+    return false;
+  }
+  if (!input["states"] || !input["states"].IsSequence())
+  {
+    printf("Error in load states\n");
+    return false;
+  }
+  if (!input["transitions"] || !input["transitions"].IsSequence())
+  {
+    printf("Error in load transitions\n");
+    return false;
+  }
+  if (!input["agent_profiles"] || !input["agent_profiles"].IsSequence())
+  {
+    printf("Error in load agent_profiles\n");
+    return false;
+  }
+  if (!input["agent_groups"] || !input["agent_groups"].IsSequence())
+  {
+    printf("Error in load agent_groups\n");
+    return false;
+  }
+  if (!input["model_types"] || !input["model_types"].IsSequence())
+  {
+    printf("Error in load model_types\n");
+    return false;
+  }
+
+  clear();
+
+  if (input["update_time_step"] && input["update_time_step"].as<double>() > 0)
+  {
+    this->_update_time_step = input["update_time_step"].as<double>();
+  }
+  if (input["enable"] && input["enable"].as<int>() == 1)
+  {
+    this->_enable_crowd_sim = true;
+  }
+  else
+  {
+    // default disable crowd_simulation
+    this->_enable_crowd_sim = false;
+  }
+
+  const YAML::Node& goal_set_node = input["goal_sets"];
+  for (YAML::const_iterator it = goal_set_node.begin();
+    it != goal_set_node.end(); it++)
+  {
+    GoalSet goalset_temp(*it);
+    this->_goal_sets.emplace_back(goalset_temp);
+  }
+  printf("crowd_sim loaded %lu goal_sets\n", this->_goal_sets.size());
+
+  const YAML::Node& state_node = input["states"];
+  for (YAML::const_iterator it = state_node.begin();
+    it != state_node.end();
+    it++)
+  {
+    State state_temp(*it);
+    this->_states.emplace_back(state_temp);
+  }
+  printf("crowd_sim loaded %lu states\n", this->_states.size());
+
+  const YAML::Node& transition_node = input["transitions"];
+  for (YAML::const_iterator it = transition_node.begin();
+    it != transition_node.end(); it++)
+  {
+    Transition transition_temp(*it);
+    this->_transitions.emplace_back(transition_temp);
+  }
+  printf("crowd_sim loaded %lu transitions\n", this->_transitions.size());
+
+  const YAML::Node& agent_profile_node = input["agent_profiles"];
+  for (YAML::const_iterator it = agent_profile_node.begin();
+    it != agent_profile_node.end(); it++)
+  {
+    AgentProfile agent_profile_temp(*it);
+    this->_agent_profiles.emplace_back(agent_profile_temp);
+  }
+  printf("crowd_sim loaded %lu agent_profiles\n", this->_agent_profiles.size());
+
+  const YAML::Node& agent_group_node = input["agent_groups"];
+  for (YAML::const_iterator it = agent_group_node.begin();
+    it != agent_group_node.end(); it++)
+  {
+    AgentGroup agent_group_temp(*it);
+    this->_agent_groups.emplace_back(agent_group_temp);
+  }
+  printf("crowd_sim loaded %lu agent_groups\n", this->_agent_profiles.size());
+
+  const YAML::Node& model_type_node = input["model_types"];
+  for (YAML::const_iterator it = model_type_node.begin();
+    it != model_type_node.end(); it++)
+  {
+    ModelType model_type_temp(*it);
+    this->_model_types.emplace_back(model_type_temp);
+  }
+  printf("crowd_sim loaded %lu model_types\n", this->_agent_profiles.size());
+
+  init_default_configure();
+  return true;
+}
+
+//=================================================
+void CrowdSimImplementation::clear()
+{
+  _goal_areas.clear();
+  _navmesh_filename_list.clear();
+
+  _enable_crowd_sim = false;
+  _update_time_step = 0.1;
+  _states.clear();
+  _goal_sets.clear();
+  _transitions.clear();
+  _agent_profiles.clear();
+  _agent_groups.clear();
+  _model_types.clear();
+}
+
+//=================================================
+void CrowdSimImplementation::init_default_configure()
+{
+  _initialize_state();
+  _initialize_agent_profile();
+  _initialize_agent_group();
+}
+
+//=================================================
+void CrowdSimImplementation::save_goal_sets(
+  const std::vector<GoalSet>& goal_sets)
+{
+  _goal_sets.clear();
+  _goal_sets = goal_sets;
+}
+
+//===================================================
+void CrowdSimImplementation::save_states(const std::vector<State>& states)
+{
+  _states.clear();
+  _states = states;
+  _initialize_state();
+}
+
+//===================================================
+void CrowdSimImplementation::save_transitions(
+  const std::vector<Transition>& transitions)
+{
+  _transitions.clear();
+  _transitions = transitions;
+}
+
+//=================================================
+void CrowdSimImplementation::save_agent_profiles(
+  const std::vector<AgentProfile>& agent_profiles)
+{
+  _agent_profiles.clear();
+  _agent_profiles = agent_profiles;
+  _initialize_agent_profile();
+}
+
+//=================================================
+void CrowdSimImplementation::save_agent_groups(
+  const std::vector<AgentGroup>& agent_groups)
+{
+  _agent_groups.clear();
+  _agent_groups = agent_groups;
+}
+
+//=================================================
+void CrowdSimImplementation::save_model_types(
+  const std::vector<ModelType>& model_types)
+{
+  _model_types.clear();
+  _model_types = model_types;
+}
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_table_base.cpp b/traffic_editor/gui/crowd_sim/crowd_sim_table_base.cpp
new file mode 100644
index 0000000..594de01
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_table_base.cpp
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <QHeaderView>
+#include <QWidget>
+#include <QPushButton>
+
+#include "crowd_sim_table_base.h"
+
+//========================================
+CrowdSimTableBase::CrowdSimTableBase(CrowdSimImplPtr impl,
+  const QStringList& labels)
+: TableList(labels.size()),
+  _crowd_sim_impl(impl),
+  _label_size(labels.size())
+{
+  setHorizontalHeaderLabels(labels);
+  horizontalHeader()->setSectionResizeMode(1, QHeaderView::Stretch);
+  setMinimumSize(800, 400);
+  setSizePolicy(
+    QSizePolicy::Expanding,
+    QSizePolicy::MinimumExpanding);
+}
+
+//======================================
+void CrowdSimTableBase::update()
+{
+  blockSignals(true);
+  clearContents();
+
+  int cache_item_size = get_cache_size();
+
+  setRowCount(
+    cache_item_size +
+    1   // put add button in this row
+  );
+  list_item_in_cache();
+
+  for (auto i = 0; i < cache_item_size; i++)
+  {
+    QPushButton* delete_button = new QPushButton("Del");
+    setCellWidget(i, get_label_size() - 1, delete_button);
+    connect(
+      delete_button,
+      &QAbstractButton::clicked,
+      [i, this]()
+      {
+        save();
+        delete_button_click(i);
+        update();
+      }
+    );
+  }
+
+  QPushButton* add_button = new QPushButton("Add");
+  setCellWidget(cache_item_size, get_label_size() - 1, add_button);
+  connect(
+    add_button,
+    &QAbstractButton::clicked,
+    [this]()
+    {
+      save();
+      add_button_click();
+      update();
+    }
+  );
+
+  blockSignals(false);
+}
diff --git a/traffic_editor/gui/crowd_sim/crowd_sim_table_base.h b/traffic_editor/gui/crowd_sim/crowd_sim_table_base.h
new file mode 100644
index 0000000..87ab058
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/crowd_sim_table_base.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_CROWDSIM_TABLE_BASE__H
+#define CROWD_SIM_CROWDSIM_TABLE_BASE__H
+
+#include <memory>
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+#include "table_list.h"
+
+using namespace crowd_sim;
+
+class CrowdSimTableBase : public TableList
+{
+public:
+  CrowdSimTableBase(CrowdSimImplPtr impl, const QStringList& labels);
+  virtual ~CrowdSimTableBase() {}
+
+  CrowdSimImplPtr get_impl() const { return _crowd_sim_impl; }
+  size_t get_label_size() const { return _label_size; }
+  void set_label_size(size_t label_size) { _label_size = label_size; }
+
+  virtual int get_cache_size() const = 0;
+  virtual void list_item_in_cache() = 0;
+  virtual void save() = 0;
+  virtual void save_to_impl() = 0;
+  virtual void add_button_click() = 0;
+  virtual void delete_button_click(size_t row_num) = 0;
+
+  virtual void update();
+
+private:
+  CrowdSimImplPtr _crowd_sim_impl;
+  size_t _label_size;
+};
+
+using CrowdSimTablePtr = std::shared_ptr<CrowdSimTableBase>;
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/goal_set.cpp b/traffic_editor/gui/crowd_sim/goal_set.cpp
new file mode 100644
index 0000000..0b41920
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/goal_set.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/goal_set.h>
+
+#include <iostream>
+
+using namespace crowd_sim;
+
+//==============================================
+void GoalSet::add_goal_area(std::string area_name)
+{
+  if (area_name.empty())
+  {
+    std::cout << "Invalid area_name provided." << std::endl;
+  }
+  this->_goal_area_contained.insert(area_name);
+}
+
+//==============================================
+YAML::Node GoalSet::get_goal_areas_to_yaml() const
+{
+  YAML::Node goal_area = YAML::Node(YAML::NodeType::Sequence);
+  goal_area.SetStyle(YAML::EmitterStyle::Flow);
+  for (auto area : get_goal_areas())
+  {
+    goal_area.push_back(area);
+  }
+  return goal_area;
+}
+
+//==============================================
+YAML::Node GoalSet::to_yaml() const
+{
+  YAML::Node goalset_node(YAML::NodeType::Map);
+  goalset_node.SetStyle(YAML::EmitterStyle::Flow);
+  goalset_node["set_id"] = get_goal_set_id();
+  goalset_node["capacity"] = get_capacity();
+  goalset_node["set_area"] = get_goal_areas_to_yaml();
+  return goalset_node;
+}
+
+//==============================================
+void GoalSet::from_yaml(const YAML::Node& input)
+{
+  _set_goal_set_id(input["set_id"].as<size_t>());
+  set_capacity(input["capacity"].as<size_t>());
+  _goal_area_contained.clear();
+  for (auto area : input["set_area"])
+  {
+    add_goal_area(area.as<std::string>());
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/goal_set_table.cpp b/traffic_editor/gui/crowd_sim/goal_set_table.cpp
new file mode 100644
index 0000000..e041f95
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/goal_set_table.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <iostream>
+
+#include "goal_set_table.h"
+#include "multi_select_combo_box.h"
+
+using namespace crowd_sim;
+
+//======================================================
+std::shared_ptr<GoalSetTab> GoalSetTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl)
+{
+
+  const QStringList labels =
+  { "Id", "Goal Area", "Capacity", ""};
+
+  auto goal_set_tab_ptr = std::make_shared<GoalSetTab>(crowd_sim_impl, labels);
+  if (!goal_set_tab_ptr)
+  {
+    printf("Failed to create goal set table! Exiting");
+    return nullptr;
+  }
+  return goal_set_tab_ptr;
+}
+
+//======================================================
+void GoalSetTab::list_item_in_cache()
+{
+  auto cache_count = _cache.size();
+  for (size_t i = 0; i < cache_count; i++)
+  {
+    auto& goal_set = _cache[i];
+    QTableWidget::setItem(
+      i,
+      0,
+      new QTableWidgetItem(
+        QString::number(static_cast<int>(goal_set.get_goal_set_id() ))));
+
+    MultiSelectComboBox* multi_combo_box =
+      new MultiSelectComboBox(get_impl()->get_goal_areas());
+    multi_combo_box->showCheckedItem(goal_set.get_goal_areas());
+    QTableWidget::setCellWidget(
+      i,
+      1,
+      multi_combo_box);
+
+    QTableWidget::setItem(
+      i,
+      2,
+      new QTableWidgetItem(
+        QString::number(static_cast<int>(goal_set.get_capacity() ))));
+  }
+}
+
+//======================================================
+// this function will save all the goal_set listed in the table widget into _cache,
+// and reassign goal_set_id as the row_number
+void GoalSetTab::save()
+{
+  auto row_count = rowCount();
+  std::vector<GoalSet> tmp_cache;
+
+  for (auto i = 0; i < row_count - 1; i++)
+  {
+    auto pItem_setid = item(i, 0);
+    bool OK_status;
+    auto set_id = pItem_setid->text().toInt(&OK_status);
+    if (!OK_status)
+    {
+      std::cout << "Invalid goal set id in row " << i << " with [" <<
+        pItem_setid->text().toStdString() << "]" << std::endl;
+      return;
+    }
+    if (set_id != i)
+    {
+      std::cout << "Reassign goal set id for row" << i << std::endl;
+    }
+
+    auto pItem_areas = static_cast<MultiSelectComboBox*>(cellWidget(i, 1));
+    //if no goal area selected, don't save the goal set
+    if (pItem_areas->getCheckResult().empty())
+      continue;
+
+    auto pItem_capacity = item(i, 2);
+    auto capacity = pItem_capacity->text().toInt(&OK_status);
+    if (!OK_status)
+    {
+      std::cout << "Invalid capacity for goal set" << std::endl;
+      return;
+    }
+
+    auto cur_it =
+      tmp_cache.emplace(tmp_cache.end(), static_cast<size_t>(set_id));
+    for (auto item : pItem_areas->getCheckResult() )
+    {
+      cur_it->add_goal_area(item);
+    }
+    cur_it->set_capacity(static_cast<size_t>(capacity));
+  }
+  _cache = tmp_cache;
+}
+
+//======================================================
+void GoalSetTab::save_to_impl()
+{
+  save();
+  get_impl()->save_goal_sets(_cache);
+}
+
+//======================================================
+void GoalSetTab::add_button_click()
+{
+  _cache.emplace_back(_cache.size());
+}
+
+//======================================================
+void GoalSetTab::delete_button_click(size_t row_number)
+{
+  if (row_number >= _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
diff --git a/traffic_editor/gui/crowd_sim/goal_set_table.h b/traffic_editor/gui/crowd_sim/goal_set_table.h
new file mode 100644
index 0000000..aed35aa
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/goal_set_table.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_GOAL_SET_TABLE__H
+#define CROWD_SIM_GOAL_SET_TABLE__H
+
+#include <memory>
+#include <vector>
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+#include <traffic_editor/crowd_sim/goal_set.h>
+
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class GoalSetTab : public CrowdSimTableBase
+{
+public:
+  static std::shared_ptr<GoalSetTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl);
+
+  GoalSetTab(CrowdSimImplPtr crowd_sim_impl, const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels)
+  {
+    _cache = get_impl()->get_goal_sets();
+  }
+  ~GoalSetTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  std::vector<crowd_sim::GoalSet> _cache;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/model_type.cpp b/traffic_editor/gui/crowd_sim/model_type.cpp
new file mode 100644
index 0000000..2e1396f
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/model_type.cpp
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/model_type.h>
+
+using namespace crowd_sim;
+
+//==============================================
+YAML::Node ModelType::to_yaml() const
+{
+  YAML::Node model_node = YAML::Node(YAML::NodeType::Map);
+  model_node.SetStyle(YAML::EmitterStyle::Flow);
+  model_node["typename"] = get_name();
+  model_node["animation"] = get_animation();
+  model_node["animation_speed"] = get_animation_speed();
+  model_node["model_uri"] = get_model_uri();
+  model_node["init_pose"] = get_init_pose();
+  return model_node;
+}
+
+//==============================================
+void ModelType::from_yaml(const YAML::Node& input)
+{
+  _name = input["typename"].as<std::string>();
+  _animation = input["animation"].as<std::string>();
+  _animation_speed = input["animation_speed"].as<double>();
+  _model_uri = input["model_uri"].as<std::string>();
+  const YAML::Node& pose_node = input["init_pose"];
+  size_t i = 0;
+  for (YAML::const_iterator it = pose_node.begin();
+    it != pose_node.end() && i < _init_pose.size();
+    it++)
+  {
+    _init_pose[i++] = (*it).as<double>();
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/model_type_table.cpp b/traffic_editor/gui/crowd_sim/model_type_table.cpp
new file mode 100644
index 0000000..2be5360
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/model_type_table.cpp
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "model_type_table.h"
+
+using namespace crowd_sim;
+
+//===================================================
+std::shared_ptr<ModelTypeTab> ModelTypeTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl)
+{
+  const QStringList labels =
+  {"name", "animation", "anim_speed",
+    "model_uri", "x", "y", "z", "pitch", "roll", "yaw",
+    ""};
+
+  auto model_type_tab = std::make_shared<ModelTypeTab>(crowd_sim_impl, labels);
+  if (!model_type_tab)
+  {
+    printf("Failed to create model_type table! Exiting");
+    return nullptr;
+  }
+  model_type_tab->setMinimumSize(1200, 400);
+  return model_type_tab;
+}
+
+//===================================================
+void ModelTypeTab::list_item_in_cache()
+{
+  auto cache_count = get_cache_size();
+  for (auto i = 0; i < cache_count; i++)
+  {
+    auto current_model_type = _cache[i];
+    setItem(i, 0,
+      new QTableWidgetItem(QString::fromStdString(
+        current_model_type.get_name() )));
+    setItem(i, 1,
+      new QTableWidgetItem(QString::fromStdString(
+        current_model_type.get_animation() )));
+    setItem(i, 2,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_animation_speed() )));
+    setItem(i, 3,
+      new QTableWidgetItem(QString::fromStdString(
+        current_model_type.get_model_uri() )));
+    setItem(i, 4,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_init_pose()[0])));
+    setItem(i, 5,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_init_pose()[1])));
+    setItem(i, 6,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_init_pose()[2])));
+    setItem(i, 7,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_init_pose()[3])));
+    setItem(i, 8,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_init_pose()[4])));
+    setItem(i, 9,
+      new QTableWidgetItem(QString::number(
+        current_model_type.get_init_pose()[5])));
+  }
+}
+
+//===================================================
+void ModelTypeTab::add_button_click()
+{
+  _cache.emplace_back("new_type", "new_animation");
+}
+
+//===================================================
+void ModelTypeTab::delete_button_click(size_t row_number)
+{
+  if (row_number > _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
+
+//===================================================
+void ModelTypeTab::save()
+{
+  auto row_count = rowCount();
+  std::vector<ModelType> tmp_cache;
+  bool OK_status;
+  for (auto i = 0; i < row_count - 1; i++)
+  {
+    ModelType current_model_type("", "");
+    current_model_type.set_name(
+      item(i, 0)->text().toStdString() );
+    current_model_type.set_animation(
+      item(i, 1)->text().toStdString() );
+    current_model_type.set_animation_speed(
+      item(i, 2)->text().toDouble(&OK_status) );
+    current_model_type.set_model_uri(
+      item(i, 3)->text().toStdString() );
+
+    std::vector<double> init_pose = {
+      item(i, 4)->text().toDouble(&OK_status),
+      item(i, 5)->text().toDouble(&OK_status),
+      item(i, 6)->text().toDouble(&OK_status),
+      item(i, 7)->text().toDouble(&OK_status),
+      item(i, 8)->text().toDouble(&OK_status),
+      item(i, 9)->text().toDouble(&OK_status)
+    };
+    current_model_type.set_init_pose(
+      init_pose);
+
+    if (!current_model_type.is_valid())
+      continue;
+    tmp_cache.push_back(current_model_type);
+  }
+  _cache = tmp_cache;
+}
+
+//===================================================
+void ModelTypeTab::save_to_impl()
+{
+  save();
+  get_impl()->save_model_types(_cache);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/model_type_table.h b/traffic_editor/gui/crowd_sim/model_type_table.h
new file mode 100644
index 0000000..a46073d
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/model_type_table.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_MODEL_TYPE_TABLE__H
+#define CROWD_SIM_MODEL_TYPE_TABLE__H
+
+#include <QComboBox>
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class ModelTypeTab : public CrowdSimTableBase
+{
+public:
+
+  static std::shared_ptr<ModelTypeTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl);
+  ModelTypeTab(CrowdSimImplPtr crowd_sim_impl, const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels)
+  {
+    _cache = get_impl()->get_model_types();
+  }
+  ~ModelTypeTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  std::vector<ModelType> _cache;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/state.cpp b/traffic_editor/gui/crowd_sim/state.cpp
new file mode 100644
index 0000000..82c5542
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/state.cpp
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+#include <traffic_editor/crowd_sim/state.h>
+
+using namespace crowd_sim;
+
+//==============================================
+bool State::is_valid() const
+{
+  if (_is_final_state && _name.size() > 0)
+    return true;
+  if (_name.size() > 0 && _navmesh_file_name.size() > 0 && _goal_set_id >= 0)
+    return true;
+  return false;
+}
+
+//==============================================
+YAML::Node State::to_yaml() const
+{
+  YAML::Node state_node(YAML::NodeType::Map);
+  state_node.SetStyle(YAML::EmitterStyle::Flow);
+  state_node["name"] = get_name();
+  state_node["goal_set"] = get_goal_set_id();
+  state_node["navmesh_file_name"] = get_navmesh_file_name();
+  state_node["final"] = get_final_state() ? 1 : 0;
+  return state_node;
+}
+
+//==============================================
+void State::from_yaml(const YAML::Node& input)
+{
+  set_name(input["name"].as<std::string>());
+  set_navmesh_file_name(input["navmesh_file_name"].as<std::string>());
+  set_final_state(input["final"].as<int>() == 0 ? false : true);
+  set_goal_set_id(input["goal_set"].as<int>());
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/state_table.cpp b/traffic_editor/gui/crowd_sim/state_table.cpp
new file mode 100644
index 0000000..1d005b5
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/state_table.cpp
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <QWidget>
+#include <QComboBox>
+
+#include "state_table.h"
+
+using namespace crowd_sim;
+
+//========================================
+std::shared_ptr<StatesTab> StatesTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl)
+{
+  const QStringList labels =
+  { "Name", "Is Final", "Navmesh File Name", "Goal Set Id", ""};
+
+  auto state_tab_ptr = std::make_shared<StatesTab>(crowd_sim_impl, labels);
+  if (!state_tab_ptr)
+  {
+    printf("Failed to create state table! Exiting");
+    return nullptr;
+  }
+  return state_tab_ptr;
+}
+
+//========================================
+void StatesTab::list_item_in_cache()
+{
+  auto cache_count = _cache.size();
+
+  //row 0 for external_state
+  auto external_state = _cache[0];
+  setItem(0, 0,
+    new QTableWidgetItem(QString::fromStdString(external_state.get_name() )));
+  setItem(0, 1,
+    new QTableWidgetItem(QString::number(
+      external_state.get_final_state() ? 1 : 0)));
+
+  for (size_t i = 1; i < cache_count; i++)
+  {
+    auto& current_state = _cache.at(i);
+    setItem(i, 0,
+      new QTableWidgetItem(QString::fromStdString(current_state.get_name()) ) );
+
+    QComboBox* final_state_combo = new QComboBox;
+    _list_final_states_in_combo(final_state_combo,
+      current_state.get_final_state());
+    setCellWidget(i, 1, final_state_combo);
+
+    QComboBox* navmesh_list_combo = new QComboBox;
+    _list_navmesh_file_in_combo(navmesh_list_combo,
+      current_state.get_navmesh_file_name() );
+    setCellWidget(i, 2, navmesh_list_combo);
+
+    QComboBox* goal_set_combo = new QComboBox;
+    _list_goal_sets_in_combo(goal_set_combo, current_state.get_goal_set_id());
+    setCellWidget(i, 3, goal_set_combo);
+  }
+}
+
+//========================================
+void StatesTab::add_button_click()
+{
+  _cache.emplace_back("new_state");
+}
+
+//========================================
+void StatesTab::delete_button_click(size_t row_number)
+{
+  if (row_number == 0)
+  {
+    std::cout <<
+      "Default state for external agent is not allowed to be deleted." <<
+      std::endl;
+    return;
+  }
+  if (row_number > _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
+
+//========================================
+void StatesTab::save()
+{
+  auto rows_count = rowCount();
+  std::vector<crowd_sim::State> tmp_cache;
+  //row 0 is not allowed to be changed
+  tmp_cache.emplace_back("external_static");
+
+  //check duplicate names
+  std::set<std::string> saved_names;
+
+  for (auto i = 1; i < rows_count - 1; i++)
+  {
+    auto name_item = item(i, 0)->text().toStdString();
+
+    auto final_item =
+      static_cast<QComboBox*>(cellWidget(i, 1))->currentText().toStdString();
+
+    auto navmesh_file_name =
+      static_cast<QComboBox*>(cellWidget(i, 2))->currentText().toStdString();
+
+    bool OK_status;
+    auto goal_set_id =
+      static_cast<QComboBox*>(cellWidget(i,
+      3))->currentText().toInt(&OK_status);
+
+    if (saved_names.find(name_item) != saved_names.end())
+    {
+      std::cout << "Defined duplicate state name for [" <<
+        name_item << "]. Skip saving this state." <<
+        std::endl;
+      continue;
+    }
+
+    tmp_cache.emplace_back(name_item);
+    auto& cur_it = tmp_cache.back();
+    cur_it.set_final_state(final_item == "1");
+    cur_it.set_navmesh_file_name(navmesh_file_name);
+    cur_it.set_goal_set_id(static_cast<size_t>(goal_set_id));
+    saved_names.insert(name_item);
+  }
+
+  _cache = tmp_cache;
+}
+
+//========================================
+void StatesTab::save_to_impl()
+{
+  save();
+  get_impl()->save_states(_cache);
+}
+
+//========================================
+void StatesTab::_list_goal_sets_in_combo(
+  QComboBox* comboBox,
+  size_t current_goal_set_id)
+{
+  for (auto goal_set : get_impl()->get_goal_sets())
+  {
+    comboBox->addItem(QString::number(
+        static_cast<int>(goal_set.get_goal_set_id())));
+  }
+  auto index =
+    comboBox->findText(QString::number(static_cast<int>(current_goal_set_id) ));
+  if (index >= 0)
+  {
+    comboBox->setCurrentIndex(index);
+  }
+}
+
+//========================================
+void StatesTab::_list_final_states_in_combo(
+  QComboBox* comboBox,
+  bool current_state)
+{
+  comboBox->addItem("1");
+  comboBox->addItem("0");
+  if (!current_state)
+  {
+    comboBox->setCurrentIndex(1);
+  }
+  else
+  {
+    comboBox->setCurrentIndex(0);
+  }
+}
+
+//========================================
+void StatesTab::_list_navmesh_file_in_combo(
+  QComboBox* comboBox,
+  std::string navmesh_filename)
+{
+  auto navmesh_list = get_impl()->get_navmesh_file_name();
+  for (size_t i = 0; i < navmesh_list.size(); i++)
+  {
+    comboBox->addItem(QString::fromStdString(navmesh_list[i]));
+    if (navmesh_list[i] == navmesh_filename)
+    {
+      comboBox->setCurrentIndex(i);
+    }
+  }
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/state_table.h b/traffic_editor/gui/crowd_sim/state_table.h
new file mode 100644
index 0000000..817ee22
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/state_table.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_STATE_TABLE__H
+#define CROWD_SIM_STATE_TABLE__H
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class StatesTab : public CrowdSimTableBase
+{
+public:
+  static std::shared_ptr<StatesTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl);
+
+  StatesTab(CrowdSimImplPtr crowd_sim_impl, const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels)
+  {
+    _cache = get_impl()->get_states();
+  }
+  ~StatesTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  std::vector<crowd_sim::State> _cache;
+
+  void _list_goal_sets_in_combo(QComboBox* comboBox,
+    size_t current_goal_set_id);
+  void _list_final_states_in_combo(QComboBox* comboBox, bool current_state);
+  void _list_navmesh_file_in_combo(QComboBox* comboBox,
+    std::string navmesh_filename);
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/to_state_dialog.cpp b/traffic_editor/gui/crowd_sim/to_state_dialog.cpp
new file mode 100644
index 0000000..580b38a
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/to_state_dialog.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "to_state_dialog.h"
+
+using namespace crowd_sim;
+
+ToStateDialog::ToStateDialog(
+  CrowdSimImplPtr crowd_sim_impl,
+  const std::string& dialog_title,
+  crowd_sim::Transition& transition)
+: CrowdSimDialog(crowd_sim_impl, dialog_title)
+{
+  _to_state_tab = ToStateTab::init_and_make(crowd_sim_impl, transition);
+  if (!_to_state_tab)
+  {
+    throw std::runtime_error("Failed to initialize ToStateTab in ToStateDialog");
+  }
+  _to_state_tab->update();
+  std::string title = "from_state: " + transition.get_from_state();
+  setWindowTitle(QString::fromStdString(title) );
+  QHBoxLayout* table_box = new QHBoxLayout;
+  table_box->addWidget(_to_state_tab.get());
+  top_vbox->addLayout(table_box);
+  top_vbox->addLayout(bottom_buttons_hbox);
+}
+
+//=============================================
+void ToStateDialog::ok_button_click()
+{
+  _to_state_tab->save_to_impl(); //save to current transition
+  accept();
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/to_state_dialog.h b/traffic_editor/gui/crowd_sim/to_state_dialog.h
new file mode 100644
index 0000000..fcdbbfc
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/to_state_dialog.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef TO_STATE_DIALOG__H
+#define TO_STATE_DIALOG__H
+
+#include "crowd_sim_dialog.h"
+#include "to_state_table.h"
+
+using namespace crowd_sim;
+
+class ToStateDialog final : public CrowdSimDialog
+{
+public:
+  ToStateDialog(
+    CrowdSimImplPtr crowd_sim_impl,
+    const std::string& dialog_title,
+    crowd_sim::Transition& transition);
+  void ok_button_click() override;
+
+private:
+  std::shared_ptr<ToStateTab> _to_state_tab;
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/to_state_table.cpp b/traffic_editor/gui/crowd_sim/to_state_table.cpp
new file mode 100644
index 0000000..fe891d1
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/to_state_table.cpp
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <map>
+
+#include <QWidget>
+#include <QComboBox>
+
+#include "to_state_table.h"
+
+//=====================================================
+std::shared_ptr<ToStateTab> ToStateTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl,
+  crowd_sim::Transition& transition)
+{
+  const QStringList labels = {"To State Name", "Weight", ""};
+
+  auto to_state_tab_ptr = std::make_shared<ToStateTab>(crowd_sim_impl,
+      transition, labels);
+  if (!to_state_tab_ptr)
+  {
+    printf("Failed to create goal set table! Exiting");
+    return nullptr;
+  }
+  return to_state_tab_ptr;
+}
+
+//=====================================================
+void ToStateTab::list_item_in_cache()
+{
+  auto cache_count = get_cache_size();
+  for (auto i = 0; i < cache_count; i++)
+  {
+    auto to_state = _cache.at(i);
+    auto to_state_name = to_state.first;
+    auto to_state_weight = to_state.second;
+
+    QComboBox* state_comboBox = new QComboBox;
+    for (auto state : get_impl()->get_states())
+    {
+      state_comboBox->addItem(QString::fromStdString(state.get_name() ));
+    }
+    auto index =
+      state_comboBox->findText(QString::fromStdString(to_state_name) );
+    state_comboBox->setCurrentIndex(index >= 0 ? index : 0);
+    setCellWidget(i, 0, state_comboBox);
+
+    setItem(
+      i, 1, new QTableWidgetItem(QString::number(to_state_weight)));
+  }
+}
+
+//=====================================================
+void ToStateTab::add_button_click()
+{
+  _cache.emplace_back(std::make_pair("", 1));
+}
+
+//=====================================================
+void ToStateTab::delete_button_click(size_t row_number)
+{
+  if (row_number > _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
+
+//=====================================================
+void ToStateTab::save()
+{
+  auto tmp_cache = _cache;
+  tmp_cache.clear();
+  for (auto i = 0; i < rowCount() - 1; i++)
+  {
+    QComboBox* current_to_state_combo =
+      static_cast<QComboBox*>(cellWidget(i, 0));
+    std::string to_state_name =
+      current_to_state_combo->currentText().toStdString();
+
+    QTableWidgetItem* weight_item = item(i, 1);
+    bool OK_status;
+    double to_state_weight = weight_item->text().toDouble(&OK_status);
+    if (!OK_status)
+    {
+      std::cout << "Error in saving ToStateTab, invalid weight provided!" <<
+        std::endl;
+      continue;
+    }
+    tmp_cache.emplace_back(std::make_pair(to_state_name, to_state_weight));
+  }
+  _cache = tmp_cache;
+}
+
+//=====================================================
+void ToStateTab::save_to_impl()
+{
+  save();
+  _current_transition.clear_to_state();
+  for (auto to_state : _cache)
+  {
+    _current_transition.add_to_state(to_state.first, to_state.second);
+  }
+}
diff --git a/traffic_editor/gui/crowd_sim/to_state_table.h b/traffic_editor/gui/crowd_sim/to_state_table.h
new file mode 100644
index 0000000..5643d0c
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/to_state_table.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_TO_STATE_TABLE__H
+#define CROWD_SIM_TO_STATE_TABLE__H
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class ToStateTab : public CrowdSimTableBase
+{
+public:
+  static std::shared_ptr<ToStateTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl,
+    crowd_sim::Transition& transition);
+
+  ToStateTab(
+    CrowdSimImplPtr crowd_sim_impl,
+    crowd_sim::Transition& transition,
+    const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels),
+    _current_transition(transition)
+  {
+    _cache.clear();
+    for (auto to_state : transition.get_to_state())
+      _cache.emplace_back(to_state);
+  }
+  ~ToStateTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  //to_state_cache<to_state_name, weight>
+  std::vector<std::pair<std::string, double>> _cache;
+  Transition& _current_transition;
+
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/transition.cpp b/traffic_editor/gui/crowd_sim/transition.cpp
new file mode 100644
index 0000000..88c34c8
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/transition.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <traffic_editor/crowd_sim/transition.h>
+
+using namespace crowd_sim;
+
+//==============================================
+YAML::Node Transition::to_yaml() const
+{
+  YAML::Node transition_node(YAML::NodeType::Map);
+  transition_node.SetStyle(YAML::EmitterStyle::Flow);
+  transition_node["from"] = _from_state_name;
+  transition_node["to"] =
+    _to_state_name.size() == 1 ? _to_state_name.begin()->first : "";
+  transition_node["Condition"] = _condition->to_yaml();
+  transition_node["Target"] = YAML::Node(YAML::NodeType::Sequence);
+  for (auto to_state : _to_state_name)
+  {
+    YAML::Node target_node = YAML::Node(YAML::NodeType::Map);
+    target_node["name"] = to_state.first;
+    target_node["weight"] = to_state.second;
+    transition_node["Target"].push_back(target_node);
+  }
+  return transition_node;
+}
+
+//==============================================
+void Transition::from_yaml(const YAML::Node& input)
+{
+  set_from_state(input["from"].as<std::string>());
+  if (input["to"] && input["to"].as<std::string>() != "")
+  {
+    add_to_state(input["to"].as<std::string>());
+  }
+  const YAML::Node& targets = input["Target"];
+  for (YAML::const_iterator it = targets.begin(); it != targets.end(); it++)
+  {
+    if (!it->IsMap())
+    {
+      throw std::runtime_error("Single Target expects a map");
+    }
+    add_to_state((*it)["name"].as<std::string>(),
+      (*it)["weight"].as<double>() );
+  }
+
+  //set condition from yaml
+  ConditionPtr condition_ptr = std::make_shared<Condition>()->init_from_yaml(
+    input["Condition"]);
+  condition_ptr->from_yaml(input["Condition"]);
+  set_condition(condition_ptr);
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/crowd_sim/transition_table.cpp b/traffic_editor/gui/crowd_sim/transition_table.cpp
new file mode 100644
index 0000000..c7b7fda
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/transition_table.cpp
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <QWidget>
+#include <QComboBox>
+#include <QPushButton>
+
+#include "transition_table.h"
+#include "to_state_dialog.h"
+#include "condition_dialog.h"
+
+//==================================================
+std::shared_ptr<TransitionTab> TransitionTab::init_and_make(
+  CrowdSimImplPtr crowd_sim_impl)
+{
+  const QStringList labels =
+  { "From State", "To State", "To-State edit", "Condition", "Condition edit",
+    ""};
+
+  auto transition_tab_ptr = std::make_shared<TransitionTab>(crowd_sim_impl,
+      labels);
+  if (!transition_tab_ptr)
+  {
+    printf("Failed to create goal set table! Exiting");
+    return nullptr;
+  }
+  return transition_tab_ptr;
+}
+
+//==================================================
+void TransitionTab::list_item_in_cache()
+{
+  auto cache_count = _cache.size();
+  for (size_t i = 0; i < cache_count; i++)
+  {
+    auto& transition = _cache.at(i);
+
+    QComboBox* from_state_comboBox = new QComboBox;
+    _list_from_states_in_combo(from_state_comboBox, transition);
+    setCellWidget(i, 0, from_state_comboBox);
+
+    auto to_state = transition.get_to_state();
+    std::string to_state_name = "";
+    for (auto state : to_state)
+    {
+      to_state_name += state.first + ";";
+    }
+    setItem(i, 1, new QTableWidgetItem(QString::fromStdString(to_state_name)));
+
+    QPushButton* to_state_edit = new QPushButton("Edit", this);
+    setCellWidget(i, 2, to_state_edit);
+    connect(
+      to_state_edit,
+      &QAbstractButton::clicked,
+      [this, &transition]()
+      {
+        ToStateDialog to_state_dialog(get_impl(), "To_State", transition);
+        to_state_dialog.exec();
+        update();
+      }
+    );
+
+    auto condition_name = transition.get_condition()->get_condition_name();
+    setItem(i, 3, new QTableWidgetItem(QString::fromStdString(condition_name)));
+
+    QPushButton* condition_edit = new QPushButton("Edit", this);
+    setCellWidget(i, 4, condition_edit);
+    connect(
+      condition_edit,
+      &QAbstractButton::clicked,
+      [this, &transition]()
+      {
+        ConditionDialog condition_dialog(get_impl(), "Condition", transition);
+        condition_dialog.exec();
+        update();
+      }
+    );
+  }
+}
+
+//==================================================
+void TransitionTab::_list_from_states_in_combo(
+  QComboBox* comboBox,
+  crowd_sim::Transition& transition)
+{
+  for (auto state : get_impl()->get_states())
+  {
+    if (state.get_final_state())
+    {
+      continue;
+    }
+    comboBox->addItem(QString::fromStdString(state.get_name() ) );
+  }
+  auto index =
+    comboBox->findText(QString::fromStdString(transition.get_from_state()) );
+  comboBox->setCurrentIndex(index >= 0 ? index : 0);
+  connect(
+    comboBox,
+    &QComboBox::currentTextChanged,
+    [this](const QString& text)
+    {
+      save();
+    }
+  );
+}
+
+//==================================================
+void TransitionTab::save()
+{
+  auto tmp_cache = _cache;
+  auto row_count = rowCount();
+  for (auto i = 0; i < row_count-1; i++)
+  {
+    auto& current_transition = tmp_cache.at(i);
+
+    auto pItem_from_state = static_cast<QComboBox*>(cellWidget(i, 0));
+    current_transition.set_from_state(
+      pItem_from_state->currentText().toStdString());
+  }
+  _cache = tmp_cache;
+  update();
+}
+
+//==================================================
+void TransitionTab::save_to_impl()
+{
+  save();
+  std::vector<size_t> invalid_trasition;
+  for (size_t i = 0; i < _cache.size(); i++)
+  {
+    if (!_cache[i].is_valid())
+    {
+      std::cout << _cache[i].get_from_state() <<
+        _cache[i].get_to_state().size() <<
+        _cache[i].get_condition()->get_condition_name() << std::endl;
+      invalid_trasition.push_back(i);
+    }
+  }
+  while (!invalid_trasition.empty())
+  {
+    size_t index = invalid_trasition.back();
+    _cache.erase(_cache.begin() + index);
+    invalid_trasition.pop_back();
+  }
+  get_impl()->save_transitions(_cache);
+}
+
+//==================================================
+void TransitionTab::add_button_click()
+{
+  _cache.emplace_back("");
+}
+
+//==================================================
+void TransitionTab::delete_button_click(size_t row_number)
+{
+  if (row_number > _cache.size())
+    return;
+  _cache.erase(_cache.begin() + row_number);
+}
diff --git a/traffic_editor/gui/crowd_sim/transition_table.h b/traffic_editor/gui/crowd_sim/transition_table.h
new file mode 100644
index 0000000..1a54b86
--- /dev/null
+++ b/traffic_editor/gui/crowd_sim/transition_table.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_TRANSITION_TABLE__H
+#define CROWD_SIM_TRANSITION_TABLE__H
+
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+#include "crowd_sim_table_base.h"
+
+using namespace crowd_sim;
+
+class TransitionTab : public CrowdSimTableBase
+{
+public:
+  static std::shared_ptr<TransitionTab> init_and_make(
+    CrowdSimImplPtr crowd_sim_impl);
+
+  TransitionTab(CrowdSimImplPtr crowd_sim_impl, const QStringList& labels)
+  : CrowdSimTableBase(crowd_sim_impl, labels)
+  {
+    _cache = get_impl()->get_transitions();
+  }
+  ~TransitionTab() {}
+
+  int get_cache_size() const override
+  {
+    return static_cast<int>(_cache.size());
+  }
+  void list_item_in_cache() override;
+  void save() override;
+  void save_to_impl() override;
+  void add_button_click() override;
+  void delete_button_click(size_t row_number) override;
+
+private:
+  std::vector<crowd_sim::Transition> _cache;
+
+  void _list_from_states_in_combo(
+    QComboBox* comboBox,
+    crowd_sim::Transition& transition);
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/edge.cpp b/traffic_editor/gui/edge.cpp
new file mode 100644
index 0000000..18c21e0
--- /dev/null
+++ b/traffic_editor/gui/edge.cpp
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "traffic_editor/edge.h"
+using std::string;
+
+
+Edge::Edge()
+: start_idx(0),
+  end_idx(0),
+  type(UNDEFINED),
+  selected(false)
+{
+}
+
+Edge::Edge(const int _start_idx, const int _end_idx, const Type _type)
+: start_idx(_start_idx),
+  end_idx(_end_idx),
+  type(_type),
+  selected(false)
+{
+  create_required_parameters();
+}
+
+Edge::~Edge()
+{
+}
+
+void Edge::from_yaml(const YAML::Node& data, const Type edge_type)
+{
+  if (!data.IsSequence())
+    throw std::runtime_error("Edge::from_yaml expected a sequence");
+  start_idx = data[0].as<double>();
+  end_idx = data[1].as<double>();
+  type = edge_type;
+  // load the parameters
+  if (data.size() >= 2)
+  {
+    for (YAML::const_iterator it = data[2].begin(); it != data[2].end(); ++it)
+    {
+      Param p;
+      p.from_yaml(it->second);
+      params[it->first.as<string>()] = p;
+    }
+  }
+
+  create_required_parameters();
+}
+
+YAML::Node Edge::to_yaml() const
+{
+  YAML::Node y;
+  y.push_back(start_idx);
+  y.push_back(end_idx);
+
+  YAML::Node params_node(YAML::NodeType::Map);
+  for (const auto& param : params)
+    params_node[param.first] = param.second.to_yaml();
+  y.push_back(params_node);
+  y.SetStyle(YAML::EmitterStyle::Flow);
+  return y;
+}
+
+bool Edge::is_bidirectional() const
+{
+  auto it = params.find("bidirectional");
+  if (it == params.end() || it->second.type != Param::BOOL)
+    return false;
+  return it->second.value_bool;
+}
+
+void Edge::set_param(const std::string& name, const std::string& value)
+{
+  auto it = params.find(name);
+  if (it == params.end())
+  {
+    printf("tried to set unknown parameter [%s]\n", name.c_str());
+    return;  // unknown parameter
+  }
+  it->second.set(value);
+}
+
+template<typename T>
+void Edge::create_param_if_needed(
+  const std::string& name,
+  const Param::Type& param_type,
+  const T& param_value)
+{
+  auto it = params.find(name);
+  if (it == params.end() || it->second.type != param_type)
+    params[name] = param_value;
+}
+
+void Edge::create_required_parameters()
+{
+  // create required parameters if they don't exist yet on this edge
+  if (type == MEAS)
+  {
+    auto it = params.find("distance");
+    if (it == params.end() || it->second.type != Param::DOUBLE)
+      params["distance"] = Param(1.0);
+  }
+  else if (type == WALL)
+  {
+    create_param_if_needed("texture_name", Param::STRING,
+      std::string("default"));
+    create_param_if_needed("alpha", Param::DOUBLE, 1.0);
+  }
+  else if (type == LANE)
+  {
+    create_param_if_needed("bidirectional", Param::BOOL, false);
+    create_param_if_needed("orientation", Param::STRING, std::string());
+    create_param_if_needed("graph_idx", Param::INT, 0);
+    create_param_if_needed("demo_mock_floor_name", Param::STRING,
+      std::string());
+    create_param_if_needed("demo_mock_lift_name", Param::STRING, std::string());
+  }
+  else if (type == DOOR)
+  {
+    create_param_if_needed("name", Param::STRING, std::string());
+    create_param_if_needed("type", Param::STRING, std::string("hinged"));
+    create_param_if_needed("motion_axis", Param::STRING, std::string("start"));
+    create_param_if_needed("motion_direction", Param::INT, 1);
+    create_param_if_needed("motion_degrees", Param::DOUBLE, 90.0);  // hinged
+    create_param_if_needed("plugin", Param::STRING, std::string("normal"));
+  }
+  else if (type == HUMAN_LANE)
+  {
+    create_param_if_needed("width", Param::DOUBLE, 1.0);
+    create_param_if_needed("bidirectional", Param::BOOL, true);
+    create_param_if_needed("orientation", Param::STRING, std::string());
+    create_param_if_needed("graph_idx", Param::INT, 9);
+    create_param_if_needed("demo_mock_floor_name", Param::STRING,
+      std::string());
+    create_param_if_needed("demo_mock_lift_name", Param::STRING, std::string());
+  }
+}
+
+std::string Edge::type_to_string() const
+{
+  if (type == LANE)
+    return string("lane");
+  else if (type == WALL)
+    return string("wall");
+  else if (type == MEAS)
+    return string("measurement");
+  else if (type == DOOR)
+    return string("door");
+  else if (type == HUMAN_LANE)
+    return string("human_lane");
+  return string("undefined");
+}
+
+QString Edge::type_to_qstring() const
+{
+  return QString::fromStdString(type_to_string());
+}
+
+void Edge::set_graph_idx(const int idx)
+{
+  if (type != LANE && type != HUMAN_LANE)
+    return;// for now at least, only lanes have graph indices
+  params["graph_idx"] = Param(idx);
+}
+
+int Edge::get_graph_idx() const
+{
+  if (type != LANE && type != HUMAN_LANE)
+    return 0;// for now, only lanes have indices defined
+  auto it = params.find("graph_idx");
+  if (it == params.end() || it->second.type != Param::INT)
+    return 0;// shouldn't get here
+  return it->second.value_int;
+}
+
+double Edge::get_width() const
+{
+  if (type != HUMAN_LANE)
+    return -1.0;
+  auto it = params.find("width");
+  if (it == params.end() || it->second.type != Param::DOUBLE)
+    return -1.0;// shouldn't get here
+  return it->second.value_double;
+}
diff --git a/traffic_editor/gui/editor.cpp b/traffic_editor/gui/editor.cpp
new file mode 100644
index 0000000..16f86d1
--- /dev/null
+++ b/traffic_editor/gui/editor.cpp
@@ -0,0 +1,2591 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+#include <cmath>
+#include <string>
+#include <unistd.h>
+#include <sys/types.h>
+#include <pwd.h>
+
+#include <QtWidgets>
+
+#include <QInputDialog>
+#include <QLabel>
+#include <QListWidget>
+#include <QToolBar>
+
+#ifdef HAS_OPENCV
+#include <opencv2/core/core.hpp>
+#include <opencv2/videoio.hpp>
+#include <opencv2/imgproc.hpp>
+#endif
+
+#include <yaml-cpp/yaml.h>
+
+#include "ament_index_cpp/get_package_share_directory.hpp"
+#include "ament_index_cpp/get_package_prefix.hpp"
+#include "ament_index_cpp/get_resource.hpp"
+
+#include "actions/add_fiducial.h"
+#include "actions/add_model.h"
+#include "actions/add_property.h"
+#include "actions/add_polygon.h"
+#include "actions/add_vertex.h"
+#include "actions/delete.h"
+#include "actions/polygon_add_vertex.h"
+#include "actions/polygon_remove_vertices.h"
+
+#include "add_param_dialog.h"
+#include "building_dialog.h"
+#include "building_level_dialog.h"
+#include "building_level_table.h"
+#include "editor.h"
+#include "layer_dialog.h"
+#include "lift_table.h"
+#include "map_view.h"
+#include "model_dialog.h"
+#include "preferences_dialog.h"
+#include "preferences_keys.h"
+#include "project_dialog.h"
+#include "scenario_table.h"
+#include "traffic_table.h"
+#include "ui_transform_dialog.h"
+
+
+using std::string;
+using std::isnan;
+
+
+Editor* Editor::instance = nullptr;
+
+Editor::Editor()
+: QMainWindow()
+{
+  instance = this;
+
+  setWindowTitle("Traffic Editor[*]");
+
+  QSettings settings;
+  qDebug("settings filename: [%s]", qUtf8Printable(settings.fileName()));
+
+  scene = new QGraphicsScene(this);
+
+  map_view = new MapView(this);
+  map_view->setScene(scene);
+
+  QVBoxLayout* left_layout = new QVBoxLayout;
+  left_layout->addWidget(map_view);
+
+  layers_table = new TableList;  // todo: replace with specific subclass?
+
+  level_table = new BuildingLevelTable;
+  connect(
+    level_table, &QTableWidget::cellClicked,
+    [=](int row, int /*col*/)
+    {
+      if (row < static_cast<int>(project.building.levels.size()))
+      {
+        // save the center point of the current level's image coordinates
+        const QPoint p_center_window(
+          map_view->viewport()->width() / 2,
+          map_view->viewport()->height() / 2);
+        QPointF p_center_scene = map_view->mapToScene(p_center_window);
+        // printf("p_center_scene: (%.1f, %.1f)\n",
+        //   p_center_scene.x(), p_center_scene.y());
+
+        QPointF p_transformed;
+        project.building.transform_between_levels(
+          level_idx,
+          p_center_scene,
+          row,
+          p_transformed);
+
+        // maintain the view scale
+        const double prev_scale = map_view->transform().m11();
+
+        double scale = prev_scale *
+        project.building.levels[row].drawing_meters_per_pixel /
+        project.building.levels[level_idx].drawing_meters_per_pixel;
+        if (isnan(scale))
+        {
+          scale = 1.0;
+          p_transformed = QPointF(0.0, 0.0);
+        }
+
+        level_idx = row;
+        create_scene();
+
+        QTransform t;
+        t.scale(scale, scale);
+        map_view->setTransform(t);
+        map_view->centerOn(p_transformed);
+      }
+    });
+
+  connect(
+    level_table,
+    &BuildingLevelTable::redraw_scene,
+    this,
+    &Editor::create_scene);
+
+  lift_table = new LiftTable;
+  connect(
+    lift_table,
+    &TableList::redraw,
+    [this]() { this->create_scene(); });
+
+  traffic_table = new TrafficTable;
+  connect(
+    traffic_table,
+    &TableList::redraw,
+    [this]() { this->create_scene(); });
+
+  connect(
+    traffic_table,
+    &QTableWidget::cellClicked,
+    [=](int row, int /*col*/)
+    {
+      project.traffic_map_idx = row;
+      traffic_table->update(project);
+    });
+
+  scenario_table = new ScenarioTable;
+  connect(
+    scenario_table,
+    &QTableWidget::cellClicked,
+    [=](int row, int /*col*/)
+    {
+      project.scenario_row_clicked(row);
+      create_scene();
+    });
+
+  crowd_sim_table = new CrowdSimEditorTable(project);
+  connect(
+    crowd_sim_table,
+    &QTableWidget::cellClicked,
+    [&]()
+    {
+      crowd_sim_table->update();
+      create_scene();
+    }
+  );
+
+
+  right_tab_widget = new QTabWidget;
+  right_tab_widget->setStyleSheet("QTabBar::tab { color: black; }");
+  right_tab_widget->addTab(level_table, "levels");
+  right_tab_widget->addTab(layers_table, "layers");
+  right_tab_widget->addTab(lift_table, "lifts");
+  right_tab_widget->addTab(traffic_table, "traffic");
+  right_tab_widget->addTab(scenario_table, "scenarios");
+  right_tab_widget->addTab(crowd_sim_table, "crowd_sim");
+
+  property_editor = new QTableWidget;
+  property_editor->setStyleSheet(
+    "QTableWidget { background-color: #e0e0e0; color: black; gridline-color: #606060; } QLineEdit { background:white; }");
+  property_editor->setMinimumSize(600, 200);
+  property_editor->setSizePolicy(
+    QSizePolicy::Fixed,
+    QSizePolicy::MinimumExpanding);
+  property_editor->setColumnCount(2);
+  property_editor->horizontalHeader()->setVisible(false);
+  property_editor->verticalHeader()->setVisible(false);
+  property_editor->horizontalHeader()->setSectionResizeMode(
+    0,
+    QHeaderView::ResizeToContents);
+  property_editor->horizontalHeader()->setSectionResizeMode(
+    1,
+    QHeaderView::Stretch);
+  property_editor->verticalHeader()->setSectionResizeMode(
+    QHeaderView::ResizeToContents);
+  property_editor->setAutoFillBackground(true);
+  connect(
+    property_editor, &QTableWidget::cellChanged,
+    this, &Editor::property_editor_cell_changed);
+
+  QHBoxLayout* param_button_layout = new QHBoxLayout;
+
+  add_param_button = new QPushButton("Add...");
+  add_param_button->setEnabled(false);
+  connect(
+    add_param_button, &QAbstractButton::clicked,
+    this, &Editor::add_param_button_clicked);
+
+  delete_param_button = new QPushButton("Delete");
+  delete_param_button->setEnabled(false);
+  connect(
+    delete_param_button, &QAbstractButton::clicked,
+    this, &Editor::delete_param_button_clicked);
+
+  param_button_layout->addWidget(add_param_button);
+  param_button_layout->addWidget(delete_param_button);
+
+  QVBoxLayout* right_column_layout = new QVBoxLayout;
+  right_column_layout->addWidget(right_tab_widget);
+
+  QLabel* properties_label = new QLabel("Properties");
+  properties_label->setStyleSheet("QLabel { color: white; }");
+  right_column_layout->addWidget(properties_label);
+  right_column_layout->addWidget(property_editor);
+  right_column_layout->addLayout(param_button_layout);
+
+  QHBoxLayout* hbox_layout = new QHBoxLayout;
+  hbox_layout->addLayout(left_layout, 1);
+  hbox_layout->addLayout(right_column_layout);
+
+  QWidget* w = new QWidget();
+  w->setMouseTracking(true);
+  setMouseTracking(true);
+  w->setLayout(hbox_layout);
+  w->setStyleSheet("background-color: #404040");
+  setCentralWidget(w);
+
+  // PROJECT MENU
+  QMenu* project_menu = menuBar()->addMenu("&Project");
+
+  project_menu->addAction(
+    "&New...",
+    this,
+    &Editor::project_new,
+    QKeySequence(Qt::CTRL + Qt::Key_N));
+
+  project_menu->addAction(
+    "&Open...",
+    this,
+    &Editor::project_open,
+    QKeySequence(Qt::CTRL + Qt::Key_O));
+
+  project_menu->addAction(
+    "&Save",
+    this,
+    &Editor::project_save,
+    QKeySequence(Qt::CTRL + Qt::Key_S));
+
+  project_menu->addSeparator();
+
+  project_menu->addAction(
+    "E&xit",
+    this,
+    &QWidget::close,
+    QKeySequence(Qt::CTRL + Qt::Key_Q));
+
+  // EDIT MENU
+  QMenu* edit_menu = menuBar()->addMenu("&Edit");
+  edit_menu->addAction(
+    "&Undo",
+    this,
+    &Editor::edit_undo,
+    QKeySequence::Undo);
+  edit_menu->addAction(
+    "&Redo",
+    this,
+    &Editor::edit_redo,
+    QKeySequence::Redo);
+  edit_menu->addSeparator();
+  edit_menu->addAction(
+    "&Building properties...",
+    this,
+    &Editor::edit_building_properties);
+  edit_menu->addAction(
+    "&Project properties...",
+    this,
+    &Editor::edit_project_properties);
+  edit_menu->addSeparator();
+  edit_menu->addAction(
+    "&Transform...",
+    this,
+    &Editor::edit_transform);
+  edit_menu->addSeparator();
+  edit_menu->addAction("&Preferences...", this, &Editor::edit_preferences);
+
+  // MODE MENU
+  QMenu* mode_menu = menuBar()->addMenu("&Mode");
+  mode_menu->addAction(
+    "&Building",
+    this,
+    [this]() { this->set_mode(MODE_BUILDING, "Building"); },
+    QKeySequence(Qt::CTRL + Qt::Key_B));
+
+  mode_menu->addAction(
+    "&Traffic lanes",
+    this,
+    [this]() { this->set_mode(MODE_TRAFFIC, "Traffic"); },
+    QKeySequence(Qt::CTRL + Qt::Key_T));
+
+  mode_menu->addAction(
+    "&Scenario",
+    this,
+    [this]() { this->set_mode(MODE_SCENARIO, "Scenario"); },
+    QKeySequence(Qt::CTRL + Qt::Key_E));
+
+  mode_menu->addAction(
+    "&Crowd Simulation",
+    this,
+    [this]() { this->set_mode(MODE_CROWD_SIM, "CrowdSim"); },
+    QKeySequence(Qt::CTRL + Qt::Key_C));
+
+  // VIEW MENU
+  QMenu* view_menu = menuBar()->addMenu("&View");
+  view_models_action =
+    view_menu->addAction("&Models", this, &Editor::view_models);
+  view_models_action->setCheckable(true);
+  view_models_action->setChecked(true);
+  view_menu->addSeparator();
+
+  zoom_fit_action =
+    view_menu->addAction("&Fit to Window", this, &Editor::zoom_fit);
+  zoom_fit_action->setEnabled(false);
+
+  // HELP MENU
+  QMenu* help_menu = menuBar()->addMenu("&Help");
+
+  help_menu->addAction("&About", this, &Editor::help_about);
+  help_menu->addAction("About &Qt", &QApplication::aboutQt);
+
+  // TOOLBAR
+  toolbar = new QToolBar();
+
+  mode_combo_box = new QComboBox;
+  mode_combo_box->addItem("Building");
+  mode_combo_box->addItem("Traffic");
+  mode_combo_box->addItem("Scenario");
+  mode_combo_box->addItem("Crowd_Sim");
+  connect(
+    mode_combo_box,
+    &QComboBox::currentTextChanged,
+    [this](const QString& text)
+    {
+      if (text == "Building")
+        set_mode(MODE_BUILDING, "Building");
+      else if (text == "Traffic")
+        set_mode(MODE_TRAFFIC, "Traffic");
+      else if (text == "Scenario")
+        set_mode(MODE_SCENARIO, "Scenario");
+      else if (text == "Crowd_Sim")
+        set_mode(MODE_CROWD_SIM, "CrowdSim");
+    });
+
+  QLabel* mode_label = new QLabel("Edit mode:");
+  mode_label->setStyleSheet("QLabel { color: white; }");
+  toolbar->addWidget(mode_label);
+  toolbar->addWidget(mode_combo_box);
+
+  tool_button_group = new QButtonGroup(this);
+  tool_button_group->setExclusive(true);
+
+  create_tool_button(TOOL_SELECT, ":icons/select.svg", "Select (Esc)");
+  create_tool_button(TOOL_MOVE, ":icons/move.svg", "Move (M)");
+  create_tool_button(TOOL_ROTATE, ":icons/rotate.svg", "Rotate (R)");
+  create_tool_button(TOOL_ADD_VERTEX, ":icons/vertex.svg", "Add Vertex (V)");
+  create_tool_button(TOOL_ADD_FIDUCIAL, ":icons/fiducial.svg", "Add Fiducial");
+  create_tool_button(TOOL_ADD_LANE, "", "Add Lane (L)");
+  create_tool_button(TOOL_ADD_WALL, ":icons/wall.svg", "Add Wall (W)");
+  create_tool_button(
+    TOOL_ADD_MEAS,
+    ":icons/measurement.svg",
+    "Add Measurement");
+  create_tool_button(TOOL_ADD_DOOR, ":icons/door.svg", "Add Door");
+  create_tool_button(TOOL_ADD_MODEL, "", "Add Model");
+  create_tool_button(TOOL_ADD_FLOOR, ":icons/floor.svg", "Add floor polygon");
+  create_tool_button(TOOL_ADD_HOLE, ":icons/hole.svg", "Add hole polygon");
+  create_tool_button(TOOL_ADD_ROI, ":icons/roi.svg", "Add region of interest");
+  create_tool_button(TOOL_EDIT_POLYGON, "", "Edit Polygon");
+  create_tool_button(TOOL_ADD_HUMAN_LANE, "", "Add Human Lane with width");
+
+  connect(
+    tool_button_group,
+    QOverload<int, bool>::of(&QButtonGroup::buttonToggled),
+    this, &Editor::tool_toggled);
+
+  toolbar->addSeparator();
+
+#ifdef HAS_IGNITION_PLUGIN
+  sim_reset_action = toolbar->addAction(
+    "Reset",
+    this,
+    &Editor::sim_reset);
+  sim_reset_action->setVisible(false);
+
+  sim_play_pause_action = toolbar->addAction(
+    "Play",
+    this,
+    &Editor::sim_play_pause);
+  sim_play_pause_action->setVisible(false);
+
+#ifdef HAS_OPENCV
+  record_start_stop_action = toolbar->addAction(
+    "Record",
+    this,
+    &Editor::record_start_stop);
+  record_start_stop_action->setVisible(false);
+#endif  // HAS_OPENCV
+
+#endif  // HAS_IGNITION_PLUGIN
+
+  toolbar->setStyleSheet(
+    "QToolBar {background-color: #404040; border: none; spacing: 5px} QToolButton {background-color: #c0c0c0; color: blue; border: 1px solid black;} QToolButton:checked {background-color: #808080; color: red; border: 1px solid black;}");
+  addToolBar(Qt::TopToolBarArea, toolbar);
+
+  ///////////////////////////////////////////////////////////
+  // SET SIZE
+  const int width =
+    settings.contains(preferences_keys::window_width) ?
+    settings.value(preferences_keys::window_width).toInt() :
+    QGuiApplication::primaryScreen()->availableSize().width();
+
+  const int height =
+    settings.contains(preferences_keys::window_height) ?
+    settings.value(preferences_keys::window_height).toInt() :
+    QGuiApplication::primaryScreen()->availableSize().height();
+
+  const int left =
+    settings.contains(preferences_keys::window_left) ?
+    settings.value(preferences_keys::window_left).toInt() :
+    0;
+
+  const int top =
+    settings.contains(preferences_keys::window_top) ?
+    settings.value(preferences_keys::window_top).toInt() :
+    0;
+
+  setGeometry(left, top, width, height);
+  map_view->adjustSize();
+
+  // default tool is the "select" tool
+  tool_button_group->button(TOOL_SELECT)->click();
+  set_mode(MODE_BUILDING, "Building");
+
+  load_model_names();
+  level_table->setCurrentCell(level_idx, 0);
+
+#ifdef HAS_IGNITION_PLUGIN
+  scene_update_timer = new QTimer;
+  connect(
+    scene_update_timer,
+    &QTimer::timeout,
+    this,
+    &Editor::scene_update_timer_timeout);
+  scene_update_timer->start(1000 / 30);
+#endif
+}
+
+Editor::~Editor()
+{
+#if defined(HAS_OPENCV) && defined(HAS_IGNITION_PLUGIN)
+  if (video_writer)
+  {
+    delete video_writer;
+    video_writer = nullptr;
+  }
+#endif
+}
+
+#ifdef HAS_IGNITION_PLUGIN
+void Editor::scene_update_timer_timeout()
+{
+  if (project.building.levels.empty())
+    return;// let's not crash...
+
+  project.scenario_scene_update(scene, level_idx);
+
+  {
+    std::lock_guard<std::mutex> building_guard(
+      project.building.building_mutex);
+
+    // project->draw_scenario(scene, level_idx);
+    //project.building.levels[level_idx]->name,
+    //    building.levels[level_idx]->drawing_meters_per_pixel,
+
+    const BuildingLevel& level = project.building.levels[level_idx];
+
+    const std::string& level_name = level.name;
+    const double level_scale = level.drawing_meters_per_pixel;
+
+    // for now, we're not dealing with models changing levels from their
+    // starting level. we'll need to do that in the future at some point.
+    for (auto& model : project.building.levels[level_idx].models)
+    {
+      if (!model.is_active)
+        continue;
+
+      if (model.state.level_name != level_name)
+        continue;
+
+      model.draw(scene, editor_models, level_scale);
+    }
+
+    //scenario->draw(scene, level_idx);
+  }
+
+#ifdef HAS_OPENCV
+  record_frame_to_video();
+#endif  // HAS_OPENCV
+}
+#endif  // HAS_IGNITION_PLUGIN
+
+void Editor::load_model_names()
+{
+  QSettings settings;
+  QString thumbnail_path(
+    settings.value(preferences_keys::thumbnail_path).toString());
+  if (thumbnail_path.isEmpty())
+  {
+    std::string assets_dir;
+    std::string share_dir;
+
+    try
+    {
+      share_dir =
+        ament_index_cpp::get_package_share_directory("traffic_editor_assets");
+
+      ament_index_cpp::get_resource("traffic_editor_assets",
+        "assets",
+        assets_dir);
+    }
+    catch (const ament_index_cpp::PackageNotFoundError& e)
+    {
+      qWarning("Could not load default thumbnail directory! "
+        "traffic_editor_assets package not found in workspace!");
+      return;
+    }
+
+    // Strip newlines from assets_dir
+    assets_dir.erase(std::remove(assets_dir.begin(), assets_dir.end(), '\n'),
+      assets_dir.end());
+
+    // Obtain thumbnail path from traffic_editor_assets ament package
+    thumbnail_path =
+      QDir::cleanPath(
+      QDir(QApplication::applicationDirPath()).filePath(
+        (share_dir + "/" + assets_dir + "/thumbnails").c_str()
+      )
+      );
+    settings.setValue(preferences_keys::thumbnail_path, thumbnail_path);
+  }
+
+  QString model_list_path = QDir(thumbnail_path).filePath("model_list.yaml");
+
+  YAML::Node y;
+  std::string filename(model_list_path.toStdString());
+  try
+  {
+    y = YAML::LoadFile(filename);
+  }
+  catch (const std::exception& e)
+  {
+    qWarning("couldn't parse %s: %s", filename.c_str(), e.what());
+    return;
+  }
+  qInfo("parsed %s successfully", filename.c_str());
+
+  const double model_meters_per_pixel = y["meters_per_pixel"].as<double>();
+  const YAML::Node ym = y["models"];
+  for (YAML::const_iterator it = ym.begin(); it != ym.end(); ++it)
+    editor_models.push_back(
+      EditorModel(it->as<std::string>(), model_meters_per_pixel));
+}
+
+QToolButton* Editor::create_tool_button(
+  const ToolId id,
+  const QString& icon_filename,
+  const QString& tooltip)
+{
+  QToolButton* b = new QToolButton(toolbar);
+  b->setCheckable(true);
+
+  if (!icon_filename.isEmpty())
+  {
+    QIcon icon(icon_filename);
+    b->setIcon(icon);
+    b->setToolTip(tooltip);
+  }
+  else
+  {
+    b->setText(tool_id_to_string(id));
+    //b->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Maximum);
+  }
+  tools[id] = toolbar->addWidget(b);
+  tool_button_group->addButton(b, id);
+  return b;
+}
+
+Editor* Editor::get_instance()
+{
+  return instance;
+}
+
+bool Editor::load_project(const QString& filename)
+{
+  const std::string filename_std_string = filename.toStdString();
+
+  if (!project.load(filename.toStdString()))
+    return false;
+
+  level_idx = 0;
+
+  if (!project.building.levels.empty())
+  {
+    const BuildingLevel& level = project.building.levels[level_idx];
+    scene->setSceneRect(
+      QRectF(0, 0, level.drawing_width, level.drawing_height));
+    previous_mouse_point = QPointF(level.drawing_width, level.drawing_height);
+  }
+
+  create_scene();
+
+  update_tables();
+
+#ifdef HAS_IGNITION_PLUGIN
+  if (project.has_sim_plugin())
+  {
+    printf("project has a sim plugin\n");
+    sim_reset_action->setVisible(true);
+    sim_play_pause_action->setVisible(true);
+#ifdef HAS_OPENCV
+    record_start_stop_action->setVisible(true);
+#endif
+  }
+  else
+    printf("project does not have a sim plugin\n");
+#endif
+
+  QSettings settings;
+  settings.setValue(preferences_keys::previous_project_path, filename);
+
+  setWindowModified(false);
+
+  return true;
+}
+
+void Editor::restore_previous_viewport()
+{
+  QSettings settings;
+
+  if (settings.contains(preferences_keys::level_name))
+  {
+    const std::string level_name =
+      settings.value(preferences_keys::level_name).toString().toStdString();
+    for (size_t i = 0; i < project.building.levels.size(); i++)
+    {
+      if (project.building.levels[i].name == level_name)
+      {
+        level_idx = i;
+        create_scene();
+        level_table->setCurrentCell(i, 0);
+        break;
+      }
+    }
+  }
+
+  double viewport_center_x =
+    settings.contains(preferences_keys::viewport_center_x) ?
+    settings.value(preferences_keys::viewport_center_x).toDouble() :
+    0.0;
+
+  double viewport_center_y =
+    settings.contains(preferences_keys::viewport_center_y) ?
+    settings.value(preferences_keys::viewport_center_y).toDouble() :
+    0.0;
+
+  double viewport_scale =
+    settings.contains(preferences_keys::viewport_scale) ?
+    settings.value(preferences_keys::viewport_scale).toDouble() :
+    1.0;
+
+  // sanity-check the viewport center and scale, since they can be garbage
+  // if the last loaded level doesn't have its scale set up.
+  if (isnan(viewport_center_x))
+    viewport_center_x = 0.0;
+  if (isnan(viewport_center_y))
+    viewport_center_y = 0.0;
+  if (isnan(viewport_scale))
+    viewport_scale = 1.0;
+
+  printf("restoring viewport: (%.1f, %.1f, %3f)\n",
+    viewport_center_x,
+    viewport_center_y,
+    viewport_scale);
+
+  QTransform t;
+  t.scale(viewport_scale, viewport_scale);
+  map_view->setTransform(t);
+  map_view->centerOn(QPointF(viewport_center_x, viewport_center_y));
+}
+
+bool Editor::load_previous_project()
+{
+  QSettings settings;
+  const QString filename(
+    settings.value(preferences_keys::previous_project_path).toString());
+  if (!filename.isEmpty())
+    return load_project(filename);
+  return true;
+}
+
+void Editor::project_new()
+{
+  QFileDialog dialog(this, "New Project");
+  dialog.setNameFilter("*.project.yaml");
+  dialog.setDefaultSuffix(".project.yaml");
+  dialog.setAcceptMode(QFileDialog::AcceptMode::AcceptSave);
+  dialog.setConfirmOverwrite(true);
+
+  if (dialog.exec() != QDialog::Accepted)
+    return;
+
+  QFileInfo file_info(dialog.selectedFiles().first());
+  std::string fn = file_info.fileName().toStdString();
+
+  project.clear();
+  project.set_filename(file_info.absoluteFilePath().toStdString());
+  QString dir_path = file_info.dir().path();
+  QDir::setCurrent(dir_path);
+
+  create_scene();
+  project_save();
+  update_tables();
+
+  QSettings settings;
+  settings.setValue(
+    preferences_keys::previous_project_path,
+    QString::fromStdString(project.get_filename()));
+}
+
+void Editor::project_open()
+{
+  QFileDialog file_dialog(this, "Open Project");
+  file_dialog.setFileMode(QFileDialog::ExistingFile);
+  file_dialog.setNameFilter("*.project.yaml");
+
+  if (file_dialog.exec() != QDialog::Accepted)
+    return;
+
+  QFileInfo file_info(file_dialog.selectedFiles().first());
+  if (!file_info.exists())
+  {
+    QMessageBox::critical(
+      this,
+      "File does not exist",
+      "File does not exist. Cannot open file.");
+    return;
+  }
+  load_project(file_info.filePath());
+}
+
+bool Editor::project_save()
+{
+  project.save();
+  setWindowModified(false);
+  return true;
+}
+
+void Editor::help_about()
+{
+  QMessageBox::about(this, "About", "Welcome to the Traffic Editor");
+}
+
+void Editor::edit_undo()
+{
+  undo_stack.undo();
+  if (
+    tool_id == TOOL_ADD_LANE
+    || tool_id == TOOL_ADD_WALL)
+  {
+    clicked_idx = -1;
+    prev_clicked_idx = -1;
+  }
+  create_scene();
+  update_property_editor();
+  setWindowModified(true);
+}
+
+void Editor::edit_redo()
+{
+  undo_stack.redo();
+  create_scene();
+  setWindowModified(true);
+}
+
+void Editor::edit_preferences()
+{
+  PreferencesDialog preferences_dialog(this);
+
+  if (preferences_dialog.exec() == QDialog::Accepted)
+    load_model_names();
+}
+
+void Editor::edit_building_properties()
+{
+  BuildingDialog building_dialog(project.building);
+  if (building_dialog.exec() == QDialog::Accepted)
+    setWindowModified(true);
+}
+
+void Editor::edit_project_properties()
+{
+  ProjectDialog project_dialog(project);
+  if (project_dialog.exec() == QDialog::Accepted)
+    setWindowModified(true);
+}
+
+void Editor::edit_transform()
+{
+  QDialog dialog;
+  Ui::TransformDialog dialog_ui;
+  dialog_ui.setupUi(&dialog);
+  if (dialog.exec() != QDialog::Accepted)
+    return;
+
+  const double rotation =
+    dialog_ui.rotate_all_models_line_edit->text().toDouble();
+  project.building.rotate_all_models(rotation);
+  create_scene();
+  setWindowModified(true);
+}
+
+void Editor::view_models()
+{
+  project.rendering_options.show_models = view_models_action->isChecked();
+  create_scene();
+}
+
+void Editor::zoom_fit()
+{
+  // todo: implement this for real
+  //map_view->set_absolute_scale(1.0);
+  map_view->resetMatrix();
+}
+
+void Editor::mouse_event(const MouseType t, QMouseEvent* e)
+{
+  QPointF p;
+  if (!is_mouse_event_in_map(e, p))
+  {
+    e->ignore();
+    return;
+  }
+  if (level_idx >= static_cast<int>(project.building.levels.size()))
+  {
+    if (t == MOUSE_RELEASE)
+    {
+      if (project.get_filename().empty())
+      {
+        QMessageBox::critical(
+          this,
+          "No project",
+          "Please try File->New Project... or File->Open Project...");
+      }
+      else if (project.building.levels.empty())
+      {
+        QMessageBox::critical(
+          this,
+          "No levels defined",
+          "No levels defined. Use Level->Add...");
+      }
+    }
+    return;
+  }
+  // dispatch to individual mouse handler functions to save indenting...
+  switch (tool_id)
+  {
+    case TOOL_SELECT:       mouse_select(t, e, p); break;
+    case TOOL_ADD_VERTEX:   mouse_add_vertex(t, e, p); break;
+    case TOOL_MOVE:         mouse_move(t, e, p); break;
+    case TOOL_ADD_LANE:     mouse_add_lane(t, e, p); break;
+    case TOOL_ADD_WALL:     mouse_add_wall(t, e, p); break;
+    case TOOL_ADD_MEAS:     mouse_add_meas(t, e, p); break;
+    case TOOL_ADD_DOOR:     mouse_add_door(t, e, p); break;
+    case TOOL_ADD_MODEL:    mouse_add_model(t, e, p); break;
+    case TOOL_ROTATE:       mouse_rotate(t, e, p); break;
+    case TOOL_ADD_FLOOR:    mouse_add_floor(t, e, p); break;
+    case TOOL_ADD_HOLE:     mouse_add_hole(t, e, p); break;
+    case TOOL_EDIT_POLYGON: mouse_edit_polygon(t, e, p); break;
+    case TOOL_ADD_FIDUCIAL: mouse_add_fiducial(t, e, p); break;
+    case TOOL_ADD_ROI:      mouse_add_roi(t, e, p); break;
+    case TOOL_ADD_HUMAN_LANE: mouse_add_human_lane(t, e, p); break;
+
+    default: break;
+  }
+  previous_mouse_point = p;
+}
+
+void Editor::mousePressEvent(QMouseEvent* e)
+{
+  mouse_event(MOUSE_PRESS, e);
+}
+
+void Editor::mouseReleaseEvent(QMouseEvent* e)
+{
+  mouse_event(MOUSE_RELEASE, e);
+}
+
+void Editor::mouseMoveEvent(QMouseEvent* e)
+{
+  mouse_event(MOUSE_MOVE, e);
+}
+
+bool Editor::is_mouse_event_in_map(QMouseEvent* e, QPointF& p_scene)
+{
+  const QPoint p_global = mapToGlobal(e->pos());
+  const QPoint p_map = map_view->mapFromGlobal(p_global);
+  if (p_map.x() < 0 || p_map.y() < 0 ||
+    p_map.x() >= map_view->width() || p_map.y() >= map_view->height())
+    return false;
+  // This event point is valid. Now we can set p_scene.
+  p_scene = map_view->mapToScene(p_map);
+  return true;
+}
+
+void Editor::keyPressEvent(QKeyEvent* e)
+{
+  switch (e->key())
+  {
+    case Qt::Key_Delete:
+      if (project.can_delete_current_selection(level_idx))
+      {
+        undo_stack.push(new DeleteCommand(&project, level_idx));
+        create_scene();
+      }
+      else
+      {
+        QMessageBox::critical(
+          this,
+          "Could not delete item",
+          "If deleting a vertex, it must not be in any edges or polygons.");
+
+        project.clear_selection(level_idx);
+      }
+      break;
+    case Qt::Key_S:
+    case Qt::Key_Escape:
+      tool_button_group->button(TOOL_SELECT)->click();
+      project.clear_selection(level_idx);
+      clear_current_tool_buffer();
+      update_property_editor();
+      create_scene();
+      break;
+    case Qt::Key_V:
+      clear_current_tool_buffer();
+      tool_button_group->button(TOOL_ADD_VERTEX)->click();
+      break;
+    case Qt::Key_M:
+      clear_current_tool_buffer();
+      tool_button_group->button(TOOL_MOVE)->click();
+      break;
+    case Qt::Key_L:
+      clear_current_tool_buffer();
+      tool_button_group->button(TOOL_ADD_LANE)->click();
+      break;
+    case Qt::Key_W:
+      tool_button_group->button(TOOL_ADD_WALL)->click();
+      break;
+    case Qt::Key_T:
+      tool_button_group->button(TOOL_ADD_MEAS)->click();
+      break;
+    case Qt::Key_O:
+      tool_button_group->button(TOOL_ADD_MODEL)->click();
+      break;
+    case Qt::Key_R:
+      tool_button_group->button(TOOL_ROTATE)->click();
+      break;
+    case Qt::Key_F:
+      tool_button_group->button(TOOL_ADD_FLOOR)->click();
+      break;
+    case Qt::Key_E:
+      tool_button_group->button(TOOL_EDIT_POLYGON)->click();
+      break;
+    case Qt::Key_B:
+      for (auto& edge : project.building.levels[level_idx].edges)
+      {
+        if (edge.type == Edge::LANE && edge.selected)
+        {
+          // toggle bidirectional flag
+          edge.set_param("bidirectional",
+            edge.is_bidirectional() ? "false" : "true");
+          create_scene();
+        }
+      }
+      break;
+    case Qt::Key_0: number_key_pressed(0); break;
+    case Qt::Key_1: number_key_pressed(1); break;
+    case Qt::Key_2: number_key_pressed(2); break;
+    case Qt::Key_3: number_key_pressed(3); break;
+    case Qt::Key_4: number_key_pressed(4); break;
+    case Qt::Key_5: number_key_pressed(5); break;
+    case Qt::Key_6: number_key_pressed(6); break;
+    case Qt::Key_7: number_key_pressed(7); break;
+    case Qt::Key_8: number_key_pressed(8); break;
+    case Qt::Key_9: number_key_pressed(9); break;
+    default:
+      break;
+  }
+}
+
+const QString Editor::tool_id_to_string(const int id)
+{
+  switch (id)
+  {
+    case TOOL_SELECT: return "&select";
+    case TOOL_MOVE: return "&move";
+    case TOOL_ROTATE: return "&rotate";
+    case TOOL_ADD_VERTEX: return "add &vertex";
+    case TOOL_ADD_LANE: return "add &lane";
+    case TOOL_ADD_WALL: return "add &wall";
+    case TOOL_ADD_MEAS: return "add measuremen&t";
+    case TOOL_ADD_DOOR: return "add door";
+    case TOOL_ADD_MODEL: return "add m&odel";
+    case TOOL_ADD_FLOOR: return "add &floor";
+    case TOOL_ADD_HOLE: return "add hole";
+    case TOOL_EDIT_POLYGON: return "&edit polygon";
+    case TOOL_ADD_HUMAN_LANE: return "add human lane";
+    default: return "unknown tool ID";
+  }
+}
+
+void Editor::tool_toggled(int id, bool checked)
+{
+  if (!checked)
+    return;
+
+  clicked_idx = -1;
+  remove_mouse_motion_item();
+
+  tool_id = static_cast<ToolId>(id);
+
+#if 0
+  // TODO: need to improve logic to set back to "normal" cursor...
+  // set the cursor
+  Qt::CursorShape cursor = Qt::ArrowCursor;
+  if (tool_id == TOOL_ADD_VERTEX)
+    cursor = Qt::CrossCursor;
+  map_view->setCursor(cursor);
+#endif
+
+  // set the status bar
+  switch (tool_id)
+  {
+    case TOOL_SELECT:
+      statusBar()->showMessage("Click an item to select it.");
+      break;
+    case TOOL_ADD_LANE:
+    case TOOL_ADD_WALL:
+    case TOOL_ADD_MEAS:
+      statusBar()->showMessage(
+        "Click one vertex and then another vertex to add an edge.");
+      break;
+    case TOOL_ADD_FLOOR:
+      statusBar()->showMessage(
+        "Left-click to add polygon vertices. "
+        "Right-click to close polygon.");
+      break;
+    case TOOL_EDIT_POLYGON:
+      statusBar()->showMessage(
+        "Left-click drag an edge to introduce a new vertex. "
+        "Right-click a polygon vertex to remove it from the polygon.");
+      break;
+    default:
+      statusBar()->clearMessage();
+      break;
+  }
+
+  // execute dialogs as needed
+  if (tool_id == TOOL_ADD_MODEL)
+  {
+    Model model;
+    ModelDialog dialog(this, model, editor_models);
+    if (dialog.exec() == QDialog::Accepted)
+    {
+      // find the EditorModel with the requested name
+      for (auto& em : editor_models)
+      {
+        if (em.name == model.model_name)
+        {
+          mouse_motion_editor_model = &em;
+          const QPixmap pixmap(mouse_motion_editor_model->get_pixmap());
+          mouse_motion_model = scene->addPixmap(pixmap);
+          mouse_motion_model->setOffset(-pixmap.width()/2, -pixmap.height()/2);
+          mouse_motion_model->setScale(
+            mouse_motion_editor_model->meters_per_pixel /
+            project.building.levels[level_idx].drawing_meters_per_pixel);
+          mouse_motion_model->setPos(
+            previous_mouse_point.x(),
+            previous_mouse_point.y());
+          statusBar()->showMessage("Left-click to instantiate this model.");
+          break;
+        }
+      }
+    }
+    else
+      tool_button_group->button(TOOL_SELECT)->click();// back to select mode
+  }
+}
+
+void Editor::update_property_editor()
+{
+  add_param_button->setEnabled(false);
+  delete_param_button->setEnabled(false);
+
+  if (project.building.levels.empty())
+    return;
+
+  for (const auto& p : project.building.levels[level_idx].polygons)
+  {
+    if (p.selected)
+    {
+      populate_property_editor(p);
+      return;
+    }
+  }
+
+  for (const auto& e : project.building.levels[level_idx].edges)
+  {
+    if (e.selected)
+    {
+      populate_property_editor(e);
+      return;  // stop after finding the first one
+    }
+  }
+
+  for (const auto& m : project.building.levels[level_idx].models)
+  {
+    if (m.selected)
+    {
+      populate_property_editor(m);
+      return;  // stop after finding the first one
+    }
+  }
+
+  for (const auto& v : project.building.levels[level_idx].vertices)
+  {
+    if (v.selected)
+    {
+      populate_property_editor(v);
+      return;  // stop after finding the first one
+    }
+  }
+
+  for (const auto& f : project.building.levels[level_idx].fiducials)
+  {
+    if (f.selected)
+    {
+      populate_property_editor(f);
+      return;  // stop after finding the first one
+    }
+  }
+
+  // if we get here, we never found anything :(
+  clear_property_editor();
+}
+
+QTableWidgetItem* Editor::create_table_item(
+  const QString& str,
+  bool editable)
+{
+  QTableWidgetItem* item = new QTableWidgetItem(str);
+  if (!editable)
+    item->setFlags(Qt::NoItemFlags);
+  else
+    item->setBackground(QBrush(Qt::white));
+  return item;
+}
+
+void Editor::property_editor_set_row(
+  const int row_idx,
+  const QString& label,
+  const QString& value,
+  const bool editable)
+{
+  QTableWidgetItem* label_item = new QTableWidgetItem(label);
+  label_item->setFlags(Qt::NoItemFlags);
+
+  QTableWidgetItem* value_item = new QTableWidgetItem(value);
+  if (!editable)
+    value_item->setFlags(Qt::NoItemFlags);
+  else
+    value_item->setBackground(QBrush(Qt::white));
+
+  property_editor->setItem(row_idx, 0, label_item);
+  property_editor->setItem(row_idx, 1, value_item);
+}
+
+void Editor::property_editor_set_row(
+  const int row_idx,
+  const QString& label,
+  const int& value,
+  const bool editable)
+{
+  property_editor_set_row(row_idx, label, QString::number(value), editable);
+}
+
+void Editor::property_editor_set_row(
+  const int row_idx,
+  const QString& label,
+  const double& value,
+  const int num_decimal_places,
+  const bool editable)
+{
+  property_editor_set_row(
+    row_idx,
+    label,
+    QString::number(value, 'g', num_decimal_places + 1),
+    editable);
+}
+
+void Editor::add_param_button_clicked()
+{
+  const string object_type =
+    add_param_button->property("object_type").toString().toStdString();
+  printf("add param object type: %s\n", object_type.c_str());
+
+  if (object_type == "vertex")
+  {
+    AddParamDialog dialog(this, Vertex::allowed_params);
+    if (dialog.exec() != QDialog::Accepted)
+      return;
+
+    AddPropertyCommand* cmd = new AddPropertyCommand(
+      &project,
+      dialog.get_param_name(),
+      Param(dialog.get_param_type()),
+      level_idx
+    );
+
+    undo_stack.push(cmd);
+    auto updated_id = cmd->get_vertex_updated();
+    populate_property_editor(
+      project.building.levels[level_idx].vertices[updated_id]);
+    setWindowModified(true);
+  }
+}
+
+void Editor::delete_param_button_clicked()
+{
+  QMessageBox::about(
+    this,
+    "work in progress",
+    "TODO: something...sorry. For now, hand-edit the YAML.");
+}
+
+void Editor::populate_layers_table()
+{
+  if (project.building.levels.empty())
+    return;// let's not crash...
+  const Level& level = project.building.levels[level_idx];
+  layers_table->blockSignals(true);  // otherwise we get tons of callbacks
+  layers_table->setRowCount(2 + level.layers.size());
+
+  layers_table->blockSignals(true);  // otherwise we get tons of callbacks
+  layers_table_set_row(0, "floorplan", true);
+
+  for (size_t i = 0; i < level.layers.size(); i++)
+  {
+    layers_table_set_row(
+      i + 1,
+      QString::fromStdString(level.layers[i].name),
+      level.layers[i].visible);
+  }
+
+  const int last_row_idx = static_cast<int>(level.layers.size()) + 1;
+  // we'll use the last row for the "Add" button
+  layers_table->setCellWidget(last_row_idx, 0, nullptr);
+  QPushButton* add_button = new QPushButton("Add...", this);
+  layers_table->setCellWidget(last_row_idx, 1, add_button);
+  connect(
+    add_button, &QAbstractButton::clicked,
+    [=]() { this->layer_add_button_clicked(); });
+
+  layers_table->blockSignals(false);  // re-enable callbacks
+}
+
+void Editor::layers_table_set_row(
+  const int row_idx,
+  const QString& label,
+  const bool checked)
+{
+  QCheckBox* checkbox = new QCheckBox(label);
+  checkbox->setChecked(checked);
+  layers_table->setCellWidget(row_idx, 0, checkbox);
+
+  QPushButton* button = new QPushButton("Edit...", this);
+  layers_table->setCellWidget(row_idx, 1, button);
+
+  connect(
+    button, &QAbstractButton::clicked,
+    [=]() { this->layer_edit_button_clicked(label.toStdString()); });
+  connect(
+    checkbox, &QAbstractButton::clicked,
+    [=](bool box_checked)
+    {
+      if (row_idx > 0)
+        project.building.levels[level_idx].layers[row_idx-1].visible =
+        box_checked;
+      create_scene();
+    });
+}
+
+void Editor::layer_edit_button_clicked(const std::string& label)
+{
+  printf("clicked: [%s]\n", label.c_str());
+  if (project.building.levels.empty())
+    return;
+  // find the index of this layer in the current level
+  Level& level = project.building.levels[level_idx];
+  for (size_t i = 0; i < level.layers.size(); i++)
+  {
+    Layer& layer = level.layers[i];
+    if (label != layer.name)
+      continue;
+    LayerDialog* dialog = new LayerDialog(this, layer, true);
+    dialog->show();
+    dialog->raise();
+    dialog->activateWindow();
+    connect(
+      dialog,
+      &LayerDialog::redraw,
+      this,
+      &Editor::create_scene);
+    return;  // only create a dialog for the first name match
+  }
+}
+
+void Editor::layer_add_button_clicked()
+{
+  if (level_idx >= static_cast<int>(project.building.levels.size()))
+    return;// let's not crash (yet)
+  Level& level = project.building.levels[level_idx];
+  Layer layer;
+  LayerDialog layer_dialog(this, layer);
+  if (layer_dialog.exec() != QDialog::Accepted)
+    return;
+  printf("added a layer: [%s]\n", layer.name.c_str());
+  level.layers.push_back(layer);
+  populate_layers_table();
+  setWindowModified(true);
+}
+
+void Editor::populate_property_editor(const Edge& edge)
+{
+  const BuildingLevel& level = project.building.levels[level_idx];
+  const double scale = level.drawing_meters_per_pixel;
+  const Vertex& sv = level.vertices[edge.start_idx];
+  const Vertex& ev = level.vertices[edge.end_idx];
+
+  const double sx = sv.x * scale;
+  const double sy = sv.y * scale;
+  const double ex = ev.x * scale;
+  const double ey = ev.y * scale;
+
+  const double dx = ex - sx;
+  const double dy = ey - sy;
+  const double len = sqrt(dx*dx + dy*dy);
+
+  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
+  property_editor->setRowCount(8 + edge.params.size());
+
+  property_editor_set_row(0, "edge_type", edge.type_to_qstring());
+  property_editor_set_row(1, "start_idx", edge.start_idx);
+  property_editor_set_row(2, "end_idx", edge.end_idx);
+  property_editor_set_row(3, "start x (m)", sx);
+  property_editor_set_row(4, "start y (m)", sy);
+  property_editor_set_row(5, "end x (m)", ex);
+  property_editor_set_row(6, "end y (m)", ey);
+  property_editor_set_row(7, "length (m)", len);
+
+  int row = 8;
+  for (const auto& param : edge.params)
+  {
+    property_editor_set_row(
+      row,
+      QString::fromStdString(param.first),
+      param.second.to_qstring(),
+      true);
+    row++;
+  }
+
+  property_editor->blockSignals(false);  // re-enable callbacks
+}
+
+void Editor::populate_property_editor(const Vertex& vertex)
+{
+  const BuildingLevel& level = project.building.levels[level_idx];
+  const double scale = level.drawing_meters_per_pixel;
+
+  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
+  property_editor->setRowCount(5 + vertex.params.size());
+
+  property_editor_set_row(0, "x (pixels)", vertex.x, 3, true);
+  property_editor_set_row(1, "y (pixels)", vertex.y, 3, true);
+  property_editor_set_row(2, "x (m)", vertex.x * scale);
+  property_editor_set_row(3, "y (m)", -1.0 * vertex.y * scale);
+  property_editor_set_row(
+    4,
+    "name",
+    QString::fromStdString(vertex.name),
+    true);
+
+  int row = 5;
+  for (const auto& param : vertex.params)
+  {
+    property_editor_set_row(
+      row,
+      QString::fromStdString(param.first),
+      param.second.to_qstring(),
+      true);
+    row++;
+  }
+
+  add_param_button->setEnabled(true);
+  add_param_button->setProperty("object_type", QVariant("vertex"));
+
+  property_editor->blockSignals(false);  // re-enable callbacks
+}
+
+void Editor::populate_property_editor(const Fiducial& fiducial)
+{
+  property_editor->blockSignals(true);
+
+  property_editor->setRowCount(1);
+  property_editor_set_row(
+    0,
+    "name",
+    QString::fromStdString(fiducial.name),
+    true);  // true means that this cell value is editable
+
+  property_editor->blockSignals(false);
+}
+
+void Editor::populate_property_editor(const Model& model)
+{
+  printf("populate_property_editor(model)\n");
+  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
+
+  property_editor->setRowCount(4);
+
+  property_editor_set_row(
+    0,
+    "name",
+    QString::fromStdString(model.instance_name),
+    true);
+
+  property_editor_set_row(
+    1,
+    "model_name",
+    QString::fromStdString(model.model_name));
+
+  property_editor_set_row(
+    2,
+    "elevation",
+    model.state.z,
+    3,
+    true);
+
+  property_editor_set_row(
+    3,
+    "static",
+    model.is_static ? QString("true") : QString("false"),
+    true);
+
+  property_editor->blockSignals(false);  // re-enable callbacks
+}
+
+void Editor::populate_property_editor(const Polygon& polygon)
+{
+  printf("populate_property_editor(polygon)\n");
+  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
+
+  property_editor->setRowCount(polygon.params.size());
+
+  int row = 0;
+  for (const auto& param : polygon.params)
+  {
+    property_editor_set_row(
+      row,
+      QString::fromStdString(param.first),
+      param.second.to_qstring(),
+      true);
+    row++;
+  }
+
+  property_editor->blockSignals(false);  // re-enable callbacks
+}
+
+void Editor::clear_property_editor()
+{
+  property_editor->setRowCount(0);
+  add_param_button->setEnabled(false);
+  delete_param_button->setEnabled(false);
+}
+
+void Editor::property_editor_cell_changed(int row, int column)
+{
+  std::string name = property_editor->item(row, 0)->text().toStdString();
+  std::string value = property_editor->item(row, 1)->text().toStdString();
+  printf("property_editor_cell_changed(%d, %d) = param %s\n",
+    row, column, name.c_str());
+
+  for (auto& v : project.building.levels[level_idx].vertices)
+  {
+    if (!v.selected)
+      continue;
+    if (name == "name")
+      v.name = value;
+    else if (name == "x (pixels)")
+      v.x = stof(value);
+    else if (name == "y (pixels)")
+      v.y = stof(value);
+    else
+      v.set_param(name, value);
+    create_scene();
+    setWindowModified(true);
+    return;  // stop after finding the first one
+  }
+
+  for (auto& e : project.building.levels[level_idx].edges)
+  {
+    if (!e.selected)
+      continue;
+    e.set_param(name, value);
+    create_scene();
+    setWindowModified(true);
+    return;  // stop after finding the first one
+  }
+
+  for (auto& f : project.building.levels[level_idx].fiducials)
+  {
+    if (!f.selected)
+      continue;
+    if (name == "name")
+      f.name = value;
+    create_scene();
+    setWindowModified(true);
+    return;  // stop after finding the first one
+  }
+
+  for (auto& p : project.building.levels[level_idx].polygons)
+  {
+    if (!p.selected)
+      continue;
+    p.set_param(name, value);
+    setWindowModified(true);
+    return;  // stop after finding the first one
+  }
+
+  for (auto& m : project.building.levels[level_idx].models)
+  {
+    if (!m.selected)
+      continue;
+    m.set_param(name, value);
+    setWindowModified(true);
+    return; // stop after finding the first one
+  }
+}
+
+bool Editor::create_scene()
+{
+  scene->clear();  // destroys the mouse_motion_* items if they are there
+#ifdef HAS_IGNITION_PLUGIN
+  project.clear_scene();  // forget all pointers to the graphics items
+#endif
+  mouse_motion_line = nullptr;
+  mouse_motion_model = nullptr;
+  mouse_motion_ellipse = nullptr;
+  mouse_motion_polygon = nullptr;
+
+  project.draw(scene, level_idx, editor_models);
+
+  return true;
+}
+
+void Editor::draw_mouse_motion_line_item(
+  const double mouse_x,
+  const double mouse_y)
+{
+  double pen_width = 1;
+  QColor color;
+  switch (tool_id)
+  {
+    case TOOL_ADD_LANE:
+      pen_width = 20;
+      color = QColor::fromRgbF(0, 0, 1, 0.5);
+      break;
+    case TOOL_ADD_WALL:
+      pen_width = 5;
+      color = QColor::fromRgbF(0, 0, 1, 0.5);
+      break;
+    case TOOL_ADD_MEAS:
+      pen_width = 5;
+      color = QColor::fromRgbF(1, 0, 1, 0.5);
+      break;
+    default:
+      break;
+  }
+
+  QPen pen(QBrush(color), pen_width, Qt::SolidLine, Qt::RoundCap);
+  const auto& start =
+    project.building.levels[level_idx].vertices[clicked_idx];
+  if (!mouse_motion_line)
+    mouse_motion_line = scene->addLine(start.x, start.y, mouse_x, mouse_y, pen);
+  else
+    mouse_motion_line->setLine(start.x, start.y, mouse_x, mouse_y);
+}
+
+void Editor::remove_mouse_motion_item()
+{
+  if (mouse_motion_line)
+  {
+    scene->removeItem(mouse_motion_line);
+    delete mouse_motion_line;
+    mouse_motion_line = nullptr;
+  }
+  if (mouse_motion_model)
+  {
+    scene->removeItem(mouse_motion_model);
+    delete mouse_motion_model;
+    mouse_motion_model = nullptr;
+  }
+  if (mouse_motion_ellipse)
+  {
+    scene->removeItem(mouse_motion_ellipse);
+    delete mouse_motion_ellipse;
+    mouse_motion_ellipse = nullptr;
+  }
+  if (mouse_motion_polygon)
+  {
+    scene->removeItem(mouse_motion_polygon);
+    delete mouse_motion_polygon;
+    mouse_motion_polygon = nullptr;
+  }
+  mouse_motion_editor_model = nullptr;
+
+  mouse_vertex_idx = -1;
+  mouse_fiducial_idx = -1;
+}
+
+///////////////////////////////////////////////////////////////////////
+// MOUSE HANDLERS
+///////////////////////////////////////////////////////////////////////
+
+void Editor::mouse_select(
+  const MouseType type, QMouseEvent* e, const QPointF& p)
+{
+  if (type != MOUSE_PRESS)
+    return;
+  const QPoint p_global = mapToGlobal(e->pos());
+  const QPoint p_map = map_view->mapFromGlobal(p_global);
+  QGraphicsItem* item = map_view->itemAt(p_map);
+
+  project.mouse_select_press(mode, level_idx, p.x(), p.y(), item);
+
+  // todo: figure out something smarter than this abomination
+  selected_polygon = project.get_selected_polygon(mode, level_idx);
+
+  // todo: be smarter and go find the actual GraphicsItem to avoid
+  // a full repaint here?
+  create_scene();
+  update_property_editor();
+}
+
+void Editor::mouse_add_vertex(
+  const MouseType t, QMouseEvent*, const QPointF& p)
+{
+  if (t == MOUSE_PRESS)
+  {
+    if (mode == MODE_SCENARIO)
+    {
+      if (project.scenario_idx < 0)
+      {
+        QMessageBox::warning(
+          this,
+          "Add Vertex",
+          "No scenario currently defined.");
+        return;
+      }
+    }
+
+    AddVertexCommand* command = new AddVertexCommand(&project, mode, level_idx,
+        p.x(), p.y());
+
+    undo_stack.push(command);
+
+    setWindowModified(true);
+    create_scene();
+  }
+}
+
+void Editor::mouse_add_fiducial(
+  const MouseType t, QMouseEvent*, const QPointF& p)
+{
+  if (t == MOUSE_PRESS)
+  {
+    AddFiducialCommand* command = new AddFiducialCommand(
+      &project,
+      level_idx,
+      p.x(),
+      p.y());
+    undo_stack.push(command);
+    setWindowModified(true);
+    create_scene();
+  }
+}
+
+void Editor::mouse_move(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  if (t == MOUSE_PRESS)
+  {
+    Building::NearestItem ni =
+      project.building.nearest_items(level_idx, p.x(), p.y());
+
+    // todo: use QGraphics stuff to see if we clicked a model pixmap...
+    const double model_dist_thresh = 0.5 /
+      project.building.levels[level_idx].drawing_meters_per_pixel;
+
+    if (ni.model_idx >= 0 && ni.model_dist < model_dist_thresh)
+    {
+      // Now we need to find the pixmap item for this model.
+      const Model& model =
+        project.building.levels[level_idx].models[ni.model_idx];
+      mouse_motion_model = get_closest_pixmap_item(
+        QPointF(model.state.x, model.state.y));
+      mouse_model_idx = ni.model_idx;
+      latest_move_model = new MoveModelCommand(&project, level_idx,
+          mouse_model_idx);
+    }
+    else if (ni.vertex_idx >= 0 && ni.vertex_dist < 10.0)
+    {
+      mouse_vertex_idx = ni.vertex_idx;
+
+      latest_move_vertex = new MoveVertexCommand(&project, level_idx,
+          mouse_vertex_idx);
+      // todo: save the QGrahpicsEllipse or group, to avoid full repaints?
+    }
+    else if (ni.fiducial_idx >= 0 && ni.fiducial_dist < 10.0)
+    {
+      mouse_fiducial_idx = ni.fiducial_idx;
+      latest_move_fiducial = new MoveFiducialCommand(&project, level_idx,
+          mouse_fiducial_idx);
+      // todo: save the QGrahpicsEllipse or group, to avoid full repaints?
+    }
+  }
+  else if (t == MOUSE_RELEASE)
+  {
+    if (mouse_vertex_idx >= 0) //Add mouse move vertex.
+    {
+      if (latest_move_vertex->has_moved)
+      {
+        undo_stack.push(latest_move_vertex);
+      }
+      else
+      {
+        delete latest_move_vertex;
+        latest_move_vertex = NULL;
+      }
+    }
+
+    if (mouse_model_idx >= 0) //Add mouse move model
+    {
+      if (latest_move_model->has_moved)
+      {
+        undo_stack.push(latest_move_model);
+      }
+      else
+      {
+        delete latest_move_model;
+        latest_move_model = NULL;
+      }
+    }
+
+    if (mouse_fiducial_idx >= 0) //Add mouse move fiducial
+    {
+      if (latest_move_fiducial->has_moved)
+      {
+        undo_stack.push(latest_move_fiducial);
+      }
+      else
+      {
+        delete latest_move_fiducial;
+        latest_move_fiducial = NULL;
+      }
+    }
+    mouse_vertex_idx = -1;
+    mouse_fiducial_idx = -1;
+    create_scene();  // this will free mouse_motion_model
+    setWindowModified(true);
+  }
+  else if (t == MOUSE_MOVE)
+  {
+    if (!(e->buttons() & Qt::LeftButton))
+      return;// we only care about mouse-dragging, not just motion
+    printf("mouse move, vertex_idx = %d, fiducial_idx = %d\n",
+      mouse_vertex_idx,
+      mouse_fiducial_idx);
+    if (mouse_motion_model != nullptr)
+    {
+      // we're dragging a model
+      // update both the nav_model data and the pixmap in the scene
+      Model& model =
+        project.building.levels[level_idx].models[mouse_model_idx];
+      model.state.x = p.x();
+      model.state.y = p.y();
+      mouse_motion_model->setPos(p);
+      latest_move_model->set_final_destination(p.x(), p.y());
+    }
+    else if (mouse_vertex_idx >= 0)
+    {
+      // we're dragging a vertex
+      Vertex& pt =
+        project.building.levels[level_idx].vertices[mouse_vertex_idx];
+      pt.x = p.x();
+      pt.y = p.y();
+      latest_move_vertex->set_final_destination(p.x(), p.y());
+      create_scene();
+    }
+    else if (mouse_fiducial_idx >= 0)
+    {
+      Fiducial& f =
+        project.building.levels[level_idx].fiducials[mouse_fiducial_idx];
+      f.x = p.x();
+      f.y = p.y();
+      latest_move_fiducial->set_final_destination(p.x(), p.y());
+      printf("moved fiducial %d to (%.1f, %.1f)\n",
+        mouse_fiducial_idx,
+        f.x,
+        f.y);
+      create_scene();
+    }
+  }
+}
+
+void Editor::mouse_add_edge(
+  const MouseType t,
+  QMouseEvent* e,
+  const QPointF& p,
+  const Edge::Type& edge_type)
+{
+  QPointF p_aligned(p);
+  if (clicked_idx >= 0 && e->modifiers() & Qt::ShiftModifier)
+  {
+    const auto& start =
+      project.building.levels[level_idx].vertices[clicked_idx];
+    align_point(QPointF(start.x, start.y), p_aligned);
+  }
+
+  if (t == MOUSE_PRESS)
+  {
+    if (e->buttons() & Qt::RightButton)
+    {
+      // right button means "exit edge drawing mode please"
+      clicked_idx = -1;
+      prev_clicked_idx = -1;
+      if (latest_add_edge != NULL)
+      {
+        //Need to check if new vertex was added.
+        delete latest_add_edge;
+        latest_add_edge = NULL;
+      }
+      remove_mouse_motion_item();
+      return;
+    }
+
+    if (prev_clicked_idx < 0)
+    {
+      latest_add_edge = new AddEdgeCommand(&project, level_idx);
+      clicked_idx = latest_add_edge->set_first_point(p_aligned.x(),
+          p_aligned.y());
+      latest_add_edge->set_edge_type(edge_type);
+      prev_clicked_idx = clicked_idx;
+      create_scene();
+      setWindowModified(true);
+      return; // no previous vertex click happened; nothing else to do
+    }
+
+    clicked_idx =
+      latest_add_edge->set_second_point(p_aligned.x(), p_aligned.y());
+
+    if (clicked_idx == prev_clicked_idx)  // don't create self edge loops
+    {
+      remove_mouse_motion_item();
+      return;
+    }
+    undo_stack.push(latest_add_edge);
+
+    if (edge_type == Edge::DOOR || edge_type == Edge::MEAS)
+    {
+      clicked_idx = -1;  // doors and measurements don't usually chain
+      latest_add_edge = NULL;
+      remove_mouse_motion_item();
+    }
+    else
+    {
+      latest_add_edge = new AddEdgeCommand(&project, level_idx);
+      latest_add_edge->set_first_point(p_aligned.x(), p_aligned.y());
+      latest_add_edge->set_edge_type(edge_type);
+    }
+    prev_clicked_idx = clicked_idx;
+    create_scene();
+    setWindowModified(true);
+  }
+  else if (t == MOUSE_MOVE)
+  {
+    if (clicked_idx < 0)
+      return;
+
+    draw_mouse_motion_line_item(p_aligned.x(), p_aligned.y());
+  }
+}
+
+void Editor::mouse_add_lane(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_edge(t, e, p, Edge::LANE);
+}
+
+void Editor::mouse_add_wall(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_edge(t, e, p, Edge::WALL);
+}
+
+void Editor::mouse_add_meas(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_edge(t, e, p, Edge::MEAS);
+}
+
+void Editor::mouse_add_door(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_edge(t, e, p, Edge::DOOR);
+}
+
+void Editor::mouse_add_human_lane(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_edge(t, e, p, Edge::HUMAN_LANE);
+}
+
+void Editor::mouse_add_model(
+  const MouseType t, QMouseEvent*, const QPointF& p)
+{
+  if (t == MOUSE_PRESS)
+  {
+    if (mouse_motion_editor_model == nullptr)
+      return;
+
+    AddModelCommand* cmd = new AddModelCommand(
+      &project,
+      level_idx,
+      p.x(),
+      p.y(),
+      mouse_motion_editor_model->name
+    );
+    undo_stack.push(cmd);
+    setWindowModified(true);
+    create_scene();
+  }
+  else if (t == MOUSE_MOVE)
+  {
+    if (mouse_motion_editor_model == nullptr)
+      return;// nothing currently selected. nothing to do.
+    if (mouse_motion_model == nullptr)
+    {
+      const QPixmap pixmap(mouse_motion_editor_model->get_pixmap());
+      mouse_motion_model = scene->addPixmap(pixmap);
+      mouse_motion_model->setOffset(-pixmap.width()/2, -pixmap.height()/2);
+      mouse_motion_model->setScale(
+        mouse_motion_editor_model->meters_per_pixel /
+        project.building.levels[level_idx].drawing_meters_per_pixel);
+    }
+    mouse_motion_model->setPos(p.x(), p.y());
+  }
+}
+
+double Editor::discretize_angle(const double& angle)
+{
+  const double discretization = 45.0 * M_PI / 180.0;
+  return discretization * round(angle / discretization);
+}
+
+void Editor::align_point(const QPointF& start, QPointF& end)
+{
+  if (qAbs(start.x() - end.x()) < qAbs(start.y() - end.y()))
+    end.setX(start.x());
+  else
+    end.setY(start.y());
+}
+
+void Editor::mouse_rotate(
+  const MouseType t, QMouseEvent* mouse_event, const QPointF& p)
+{
+  if (t == MOUSE_PRESS)
+  {
+    clicked_idx = project.building.nearest_item_index_if_within_distance(
+      level_idx,
+      p.x(),
+      p.y(),
+      50.0,
+      Building::MODEL);
+    if (clicked_idx < 0)
+      return;// nothing to do. click wasn't on a model.
+
+    latest_rotate_model = new RotateModelCommand(&project, level_idx,
+        clicked_idx);
+    const Model& model =
+      project.building.levels[level_idx].models[clicked_idx];
+    mouse_motion_model = get_closest_pixmap_item(
+      QPointF(model.state.x, model.state.y));
+    QPen pen(Qt::red);
+    pen.setWidth(4);
+    const double r = static_cast<double>(ROTATION_INDICATOR_RADIUS);
+    mouse_motion_ellipse = scene->addEllipse(
+      model.state.x - r,  // ellipse upper-left column
+      model.state.y - r,  // ellipse upper-left row
+      2 * r,  // ellipse width
+      2 * r,  // ellipse height
+      pen);
+    mouse_motion_line = scene->addLine(
+      model.state.x,
+      model.state.y,
+      model.state.x + r * cos(model.state.yaw),
+      model.state.y - r * sin(model.state.yaw),
+      pen);
+  }
+  else if (t == MOUSE_RELEASE)
+  {
+    //remove_mouse_motion_item();
+    if (clicked_idx < 0)
+      return;
+    const Model& model =
+      project.building.levels[level_idx].models[clicked_idx];
+    const double dx = p.x() - model.state.x;
+    const double dy = -(p.y() - model.state.y);  // vertical axis is flipped
+    double mouse_yaw = atan2(dy, dx);
+    if (mouse_event->modifiers() & Qt::ShiftModifier)
+      mouse_yaw = discretize_angle(mouse_yaw);
+    latest_rotate_model->set_final_destination(mouse_yaw);
+    undo_stack.push(latest_rotate_model);
+    clicked_idx = -1;  // we're done rotating it now
+    setWindowModified(true);
+    // now re-render the whole scene (could optimize in the future...)
+    create_scene();
+  }
+  else if (t == MOUSE_MOVE)
+  {
+    if (clicked_idx < 0)
+      return;// nothing currently selected. nothing to do.
+
+    // re-orient the mouse_motion_model item and heading indicator as needed
+    const Model& model =
+      project.building.levels[level_idx].models[clicked_idx];
+    const double dx = p.x() - model.state.x;
+    const double dy = -(p.y() - model.state.y);  // vertical axis is flipped
+    double mouse_yaw = atan2(dy, dx);
+    if (mouse_event->modifiers() & Qt::ShiftModifier)
+      mouse_yaw = discretize_angle(mouse_yaw);
+    const double r = static_cast<double>(ROTATION_INDICATOR_RADIUS);
+    mouse_motion_line->setLine(
+      model.state.x,
+      model.state.y,
+      model.state.x + r * cos(mouse_yaw),
+      model.state.y - r * sin(mouse_yaw));
+
+    if (mouse_motion_model)
+      mouse_motion_model->setRotation(
+        (-mouse_yaw + M_PI / 2.0) * 180.0 / M_PI);
+  }
+}
+
+QGraphicsPixmapItem* Editor::get_closest_pixmap_item(const QPointF& p)
+{
+  // todo: use fancier calls if the scene graph gets so big that a linear
+  // search becomes intolerably slow
+  const QList<QGraphicsItem*> items = scene->items();
+  QGraphicsPixmapItem* pixmap_item = nullptr;
+  double min_dist = 1.0e9;
+  for (const auto item : items)
+  {
+    if (item->type() != QGraphicsPixmapItem::Type)
+      continue;// ignore anything other than the pixmaps (models)
+    const double model_click_distance = QLineF(p, item->pos()).length();
+    const double width = item->boundingRect().width();
+    const double height = item->boundingRect().height();
+    printf("model_click_distance = %.2f bounds = (%.1f, %.1f)\n",
+      model_click_distance, width, height);
+    if (model_click_distance < min_dist)
+    {
+      min_dist = model_click_distance;
+      pixmap_item = qgraphicsitem_cast<QGraphicsPixmapItem*>(item);
+    }
+  }
+  return pixmap_item;
+}
+
+void Editor::mouse_add_polygon(
+  const MouseType t,
+  QMouseEvent* e,
+  const QPointF& p,
+  const Polygon::Type& polygon_type)
+{
+  if (t == MOUSE_PRESS)
+  {
+    if (e->buttons() & Qt::LeftButton)
+    {
+      const Project::NearestItem ni =
+        project.nearest_items(mode, level_idx, p.x(), p.y());
+      clicked_idx = ni.vertex_dist < 10.0 ? ni.vertex_idx : -1;
+      if (clicked_idx < 0)
+        return;// nothing to do. click wasn't on a vertex.
+
+      Vertex* v = nullptr;
+      if (mode == MODE_BUILDING)
+        v = &project.building.levels[level_idx].vertices[clicked_idx];
+      else if (mode == MODE_SCENARIO)
+        v = &project.scenario_level(level_idx)->vertices[clicked_idx];
+
+      v->selected = true;  // todo: colorize it?
+
+      if (mouse_motion_polygon == nullptr)
+      {
+        QVector<QPointF> polygon_vertices;
+        polygon_vertices.append(QPointF(v->x, v->y));
+        QPolygonF polygon(polygon_vertices);
+        mouse_motion_polygon = scene->addPolygon(
+          polygon,
+          QPen(Qt::black),
+          QBrush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5)));
+        mouse_motion_polygon_vertices.clear();
+      }
+
+      // only add vertex_idx is NOT already in the vertex list
+      if (std::find(
+          mouse_motion_polygon_vertices.begin(),
+          mouse_motion_polygon_vertices.end(),
+          clicked_idx) == mouse_motion_polygon_vertices.end())
+        mouse_motion_polygon_vertices.push_back(clicked_idx);
+    }
+    else if (e->buttons() & Qt::RightButton)
+    {
+      if (mouse_motion_polygon == nullptr)
+        return;
+      if (mouse_motion_polygon_vertices.size() >= 3)
+      {
+        Polygon polygon;
+        polygon.type = polygon_type;
+        polygon.create_required_parameters();
+        for (const auto& i : mouse_motion_polygon_vertices)
+        {
+          polygon.vertices.push_back(i);
+        }
+
+        AddPolygonCommand* command = new AddPolygonCommand(
+          &project,
+          mode,
+          polygon,
+          level_idx);
+
+        undo_stack.push(command);
+      }
+      scene->removeItem(mouse_motion_polygon);
+      delete mouse_motion_polygon;
+      mouse_motion_polygon = nullptr;
+
+      setWindowModified(true);
+      project.clear_selection(level_idx);
+      create_scene();
+    }
+  }
+  else if (t == MOUSE_MOVE)
+  {
+    if (mouse_motion_polygon == nullptr)
+      return;
+
+    // first, remove the previous polygon
+    scene->removeItem(mouse_motion_polygon);
+    delete mouse_motion_polygon;
+
+    // now, make the updated polygon
+    QVector<QPointF> polygon_vertices;
+    for (const auto& vertex_idx: mouse_motion_polygon_vertices)
+    {
+      const Vertex* v = nullptr;
+      if (mode == MODE_BUILDING)
+        v = &project.building.levels[level_idx].vertices[vertex_idx];
+      else if (mode == MODE_SCENARIO)
+        v = &project.scenario_level(level_idx)->vertices[vertex_idx];
+
+      polygon_vertices.append(QPointF(v->x, v->y));
+    }
+    polygon_vertices.append(QPointF(p.x(), p.y()));
+
+    // insert the updated polygon into the scene
+    QPolygonF polygon(polygon_vertices);
+    mouse_motion_polygon = scene->addPolygon(
+      polygon,
+      QPen(Qt::black),
+      QBrush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5)));
+  }
+}
+
+void Editor::mouse_add_floor(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_polygon(t, e, p, Polygon::FLOOR);
+}
+
+void Editor::mouse_add_hole(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_polygon(t, e, p, Polygon::HOLE);
+}
+
+void Editor::mouse_add_roi(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  mouse_add_polygon(t, e, p, Polygon::ROI);
+}
+
+void Editor::mouse_edit_polygon(
+  const MouseType t, QMouseEvent* e, const QPointF& p)
+{
+  if (selected_polygon == nullptr)
+    return;// no polygon is selected, nothing to do
+
+  if (t == MOUSE_PRESS)
+  {
+    if (e->buttons() & Qt::RightButton)
+    {
+      const Project::NearestItem ni = project.nearest_items(
+        mode, level_idx, p.x(), p.y());
+      if (ni.vertex_dist > 10.0)
+      {
+        printf("right-click wasn't near a vertex: %.1f\n", ni.vertex_dist);
+        return;  // click wasn't near a vertex
+      }
+      else
+      {
+        printf("removing vertex %d\n", ni.vertex_idx);
+      }
+      PolygonRemoveVertCommand* command = new PolygonRemoveVertCommand(
+        selected_polygon, ni.vertex_idx);
+      undo_stack.push(command);
+      setWindowModified(true);
+      create_scene();
+    }
+    else if (e->buttons() & Qt::LeftButton)
+    {
+      mouse_edge_drag_polygon =
+        project.polygon_edge_drag_press(
+        mode,
+        level_idx,
+        selected_polygon,
+        p.x(),
+        p.y());
+      if (mouse_edge_drag_polygon.movable_vertex < 0)
+        return;
+
+      if (mouse_motion_polygon != nullptr)
+      {
+        qWarning("edit_polygon_release() without null mouse_motion_polygon!");
+        return;
+      }
+
+      mouse_motion_polygon = scene->addPolygon(
+        mouse_edge_drag_polygon.polygon,
+        QPen(Qt::black),
+        QBrush(QColor::fromRgbF(1.0, 1.0, 0.5, 0.5)));
+    }
+  }
+  else if (t == MOUSE_RELEASE)
+  {
+    // todo by drag mode (left/right button?)
+    if (mouse_motion_polygon == nullptr)
+    {
+      qInfo("woah! edit_polygon_release() with null mouse_motion_polygon!");
+      return;
+    }
+    printf("replacing vertices of polygon...\n");
+    scene->removeItem(mouse_motion_polygon);
+    delete mouse_motion_polygon;
+    mouse_motion_polygon = nullptr;
+
+    const Project::NearestItem ni = project.nearest_items(
+      mode, level_idx, p.x(), p.y());
+
+    if (ni.vertex_dist > 10.0)
+      return;// nothing to do; didn't release near a vertex
+
+    const int release_vertex_idx = ni.vertex_idx;
+
+    if (std::find(
+        selected_polygon->vertices.begin(),
+        selected_polygon->vertices.end(),
+        release_vertex_idx) != selected_polygon->vertices.end())
+      return;// Release vertex is already in the polygon. Don't do anything.
+
+    PolygonAddVertCommand* command = new PolygonAddVertCommand(
+      selected_polygon,
+      mouse_edge_drag_polygon.movable_vertex,
+      release_vertex_idx);
+
+    undo_stack.push(command);
+
+    setWindowModified(true);
+    create_scene();
+  }
+  else if (t == MOUSE_MOVE)
+  {
+    if (e->buttons() & Qt::LeftButton)
+    {
+      if (mouse_motion_polygon == nullptr)
+      {
+        qInfo("woah! edit_polygon_release() with null mouse_motion_polygon!");
+        return;
+      }
+      QPolygonF polygon = mouse_motion_polygon->polygon();
+      polygon[mouse_edge_drag_polygon.movable_vertex] = QPointF(p.x(), p.y());
+      mouse_motion_polygon->setPolygon(polygon);
+    }
+  }
+}
+
+void Editor::number_key_pressed(const int n)
+{
+  bool found_edge = false;
+  for (auto& edge : project.building.levels[level_idx].edges)
+  {
+    if (edge.selected && edge.type == Edge::LANE)
+    {
+      edge.set_graph_idx(n);
+      found_edge = true;
+    }
+  }
+  if (found_edge)
+  {
+    create_scene();
+    update_property_editor();
+  }
+
+  project.traffic_map_idx = n;
+  traffic_table->update(project);
+}
+
+bool Editor::maybe_save()
+{
+  if (!isWindowModified())
+    return true;// no need to ask to save the document
+  const QMessageBox::StandardButton button_clicked =
+    QMessageBox::warning(
+    this,
+    "Project not saved!",
+    "Do you want to save your changes?",
+    QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
+  switch (button_clicked)
+  {
+    case QMessageBox::Save:
+      return project_save();
+    case QMessageBox::Cancel:
+      return false;
+    default:
+      break;
+  }
+  return true;
+}
+
+void Editor::showEvent(QShowEvent* event)
+{
+  QMainWindow::showEvent(event);
+#ifdef HAS_IGNITION_PLUGIN
+  sim_thread.start();
+#endif
+}
+
+void Editor::closeEvent(QCloseEvent* event)
+{
+#ifdef HAS_IGNITION_PLUGIN
+  printf("waiting on sim_thread...\n");
+  sim_thread.requestInterruption();
+  sim_thread.quit();
+  sim_thread.wait();
+#endif
+
+  // save window geometry
+  QSettings settings;
+  settings.setValue(preferences_keys::window_left, geometry().x());
+  settings.setValue(preferences_keys::window_top, geometry().y());
+  settings.setValue(preferences_keys::window_width, geometry().width());
+  settings.setValue(preferences_keys::window_height, geometry().height());
+
+  // save viewport center and scale
+  const QPoint p_center_window(
+    map_view->viewport()->width() / 2,
+    map_view->viewport()->height() / 2);
+  const QPointF p_center_scene = map_view->mapToScene(p_center_window);
+
+  printf("closeEvent:  (%d, %d) -> (%.1f, %.1f)\n",
+    p_center_window.x(),
+    p_center_window.y(),
+    p_center_scene.x(),
+    p_center_scene.y());
+
+  const double scale = map_view->transform().m11();
+  settings.setValue(preferences_keys::viewport_center_x, p_center_scene.x());
+  settings.setValue(preferences_keys::viewport_center_y, p_center_scene.y());
+  settings.setValue(preferences_keys::viewport_scale, scale);
+
+  if (!project.building.levels.empty())
+    settings.setValue(
+      preferences_keys::level_name,
+      QString::fromStdString(project.building.levels[level_idx].name));
+
+  if (maybe_save())
+    event->accept();
+  else
+    event->ignore();
+}
+
+void Editor::set_tool_visibility(const ToolId id, const bool visible)
+{
+  QAction* a = tools[id];
+  if (a)
+    a->setVisible(visible);
+  else
+    printf("unable to find tool action %d\n", static_cast<int>(id));
+}
+
+void Editor::set_mode(const EditorModeId _mode, const QString& mode_string)
+{
+  if (mode_combo_box->currentText() != mode_string)
+  {
+    mode_combo_box->blockSignals(true);
+    mode_combo_box->setCurrentText(mode_string);
+    mode_combo_box->blockSignals(false);
+  }
+
+  mode = _mode;
+
+  // building tools
+  set_tool_visibility(TOOL_ADD_WALL, mode == MODE_BUILDING);
+  set_tool_visibility(TOOL_ADD_MEAS, mode == MODE_BUILDING);
+  set_tool_visibility(TOOL_ADD_DOOR, mode == MODE_BUILDING);
+  set_tool_visibility(TOOL_ADD_MODEL, mode == MODE_BUILDING);
+  set_tool_visibility(TOOL_ADD_FLOOR, mode == MODE_BUILDING);
+  set_tool_visibility(TOOL_ADD_HOLE, mode == MODE_BUILDING);
+  set_tool_visibility(TOOL_ADD_FIDUCIAL, mode == MODE_BUILDING);
+
+  // traffic tools
+  set_tool_visibility(TOOL_ADD_LANE, mode == MODE_TRAFFIC);
+
+  // scenario tools
+  set_tool_visibility(TOOL_ADD_ROI, mode == MODE_SCENARIO);
+
+  // crowd_sim tools
+  set_tool_visibility(TOOL_ADD_HUMAN_LANE, mode == MODE_CROWD_SIM);
+
+  // "multi-purpose" tools
+  set_tool_visibility(TOOL_EDIT_POLYGON,
+    mode != MODE_TRAFFIC && mode != MODE_CROWD_SIM);
+}
+
+void Editor::update_tables()
+{
+  populate_layers_table();
+  level_table->update(project.building);
+  lift_table->update(project.building);
+  scenario_table->update(project);
+  traffic_table->update(project);
+  crowd_sim_table->update();
+}
+
+void Editor::clear_current_tool_buffer()
+{
+  if (
+    tool_id == TOOL_ADD_WALL
+    || tool_id == TOOL_ADD_LANE
+    || tool_id == TOOL_ADD_MEAS
+    || tool_id == TOOL_ADD_HUMAN_LANE
+    || tool_id == TOOL_ADD_DOOR)
+  {
+    prev_clicked_idx = -1;
+    clicked_idx = -1;
+    delete latest_add_edge;
+    latest_add_edge = NULL;
+  }
+}
+
+#ifdef HAS_IGNITION_PLUGIN
+void Editor::sim_reset()
+{
+  printf("TODO: sim_reset()\n");
+  // todo: signal to the sim thread to reset the project
+}
+
+void Editor::sim_play_pause()
+{
+  printf("sim_play_pause()\n");
+  project.sim_is_paused = !project.sim_is_paused;
+}
+
+void Editor::sim_tick()
+{
+  // called from sim thread
+
+  if (!project.sim_is_paused)
+    project.sim_tick();
+}
+
+#ifdef HAS_OPENCV
+void Editor::record_start_stop()
+{
+  is_recording = !is_recording;
+}
+
+void Editor::record_frame_to_video()
+{
+  if (!is_recording)
+    return;
+
+  QPixmap pixmap = map_view->viewport()->grab();
+  const int w = pixmap.size().width();
+  const int h = pixmap.size().height();
+  QImage image(pixmap.toImage());
+  // int format = static_cast<int>(image.format());
+  cv::Mat mat(
+    h,
+    w,
+    CV_8UC4,
+    const_cast<uchar*>(image.bits()),
+    static_cast<size_t>(image.bytesPerLine()));
+  cv::Mat mat_rgb_swap;
+  cv::cvtColor(mat, mat_rgb_swap, cv::COLOR_RGBA2BGRA);
+
+  if (video_writer == nullptr)
+  {
+    printf("initializing video writer...\n");
+    video_writer =
+      new cv::VideoWriter(
+      "test.avi",
+      cv::VideoWriter::fourcc('M', 'J', 'P', 'G'),
+      30,
+      cv::Size(w, h));
+  }
+
+  video_writer->write(mat_rgb_swap);
+}
+#endif  // HAS_OPENCV
+
+#endif  // HAS_IGNITION_PLUGIN
diff --git a/traffic_editor/gui/editor.h b/traffic_editor/gui/editor.h
new file mode 100644
index 0000000..33c9641
--- /dev/null
+++ b/traffic_editor/gui/editor.h
@@ -0,0 +1,357 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef EDITOR_H
+#define EDITOR_H
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include <QGraphicsItem>
+#include <QGraphicsEllipseItem>
+#include <QGraphicsPixmapItem>
+#include <QGraphicsPolygonItem>
+#include <QGraphicsScene>
+#include <QMainWindow>
+#include <QSettings>
+#include <QUndoStack>
+
+#include "project.h"
+#include "actions/add_edge.h"
+#include "actions/move_fiducial.h"
+#include "actions/move_model.h"
+#include "actions/move_vertex.h"
+#include "actions/rotate_model.h"
+#include "traffic_editor/editor_model.h"
+#include "editor_mode_id.h"
+
+#ifdef HAS_IGNITION_PLUGIN
+#include "sim_thread.h"
+#endif
+
+#include "crowd_sim/crowd_sim_editor_table.h"
+
+class BuildingLevelTable;
+class MapView;
+class Level;
+class LiftTable;
+class ScenarioTable;
+class TrafficTable;
+class CrowdSimTable;
+
+#ifdef HAS_OPENCV
+namespace cv {
+class VideoWriter;
+}
+#endif
+
+QT_BEGIN_NAMESPACE
+class QAction;
+class QButtonGroup;
+class QComboBox;
+class QGraphicsView;
+class QHBoxLayout;
+class QLabel;
+class QLineEdit;
+class QListWidget;
+class QMenu;
+class QMouseEvent;
+class QPushButton;
+class QTableWidget;
+class QTableWidgetItem;
+class QTabWidget;
+class QTimer;
+class QToolButton;
+QT_END_NAMESPACE
+
+
+class Editor : public QMainWindow
+{
+  Q_OBJECT
+
+public:
+  Editor();
+  ~Editor();
+
+  static Editor* get_instance();
+
+  /// Load a project, replacing the current project being edited
+  bool load_project(const QString& filename);
+
+  /// Attempt to load the most recently saved project, just for convenience
+  /// when starting the application since often we want to 'resume' editing.
+  bool load_previous_project();
+
+  /// Attempt to restore the previous viewport scale and center point
+  void restore_previous_viewport();
+
+protected:
+  void mousePressEvent(QMouseEvent* e);
+  void mouseReleaseEvent(QMouseEvent* e);
+  void mouseMoveEvent(QMouseEvent* e);
+  void keyPressEvent(QKeyEvent* event);
+  void closeEvent(QCloseEvent* event);
+  void showEvent(QShowEvent* event) override;
+
+private:
+
+  QUndoStack undo_stack;
+  EditorModeId mode = MODE_BUILDING;
+
+  void set_mode(const EditorModeId _mode, const QString& mode_string);
+
+  enum ToolId
+  {
+    TOOL_SELECT = 1,
+    TOOL_ADD_VERTEX,
+    TOOL_MOVE,
+    TOOL_ADD_LANE,
+    TOOL_ADD_WALL,
+    TOOL_ADD_MEAS,
+    TOOL_ADD_DOOR,
+    TOOL_ADD_MODEL,
+    TOOL_ROTATE,
+    TOOL_ADD_FLOOR,
+    TOOL_EDIT_POLYGON,
+    TOOL_ADD_ZONE,
+    TOOL_ADD_FIDUCIAL,
+    TOOL_ADD_ROI,
+    TOOL_ADD_HOLE,
+    TOOL_ADD_HUMAN_LANE,
+  } tool_id = TOOL_SELECT;
+
+  std::map<ToolId, QAction*> tools;
+
+  void set_tool_visibility(const ToolId id, const bool visible);
+
+  /////////////////
+  // MENU ACTIONS
+  void project_new();
+  void project_open();
+  bool project_save();
+
+  bool maybe_save();
+  void edit_undo();
+  void edit_redo();
+  void edit_preferences();
+  void edit_building_properties();
+  void edit_project_properties();
+  void edit_transform();
+
+  void level_add();
+  void level_edit();
+  void update_level_buttons();
+
+  void zoom_fit();
+  void view_models();
+
+  void help_about();
+
+  bool is_mouse_event_in_map(QMouseEvent* e, QPointF& p_scene);
+
+  QToolBar* toolbar;
+  QToolButton* create_tool_button(
+    const ToolId id,
+    const QString& icon_filename,
+    const QString& tooltip);
+  void tool_toggled(int id, bool checked);
+
+  QComboBox* mode_combo_box;
+
+/////////////////////////////
+  static Editor* instance;  // there will only be one instance
+
+  Project project;
+  int level_idx = 0;  // level that we are currently editing
+  int clicked_idx = -1;  // point most recently clicked
+  int prev_clicked_idx = -1; // Previously clicked ID.
+  //int polygon_idx = -1;  // currently selected polygon
+  Polygon* selected_polygon = nullptr;
+
+  QButtonGroup* level_button_group;
+  QHBoxLayout* level_button_hbox_layout;
+  QGraphicsScene* scene;
+  MapView* map_view;
+
+  QAction* save_action;
+  QAction* zoom_in_action, * zoom_out_action;
+  QAction* zoom_normal_action, * zoom_fit_action;
+  QAction* view_models_action;
+
+  const QString tool_id_to_string(const int id);
+  QButtonGroup* tool_button_group;
+
+  QTabWidget* right_tab_widget;
+
+  QTableWidget* create_tabbed_table();
+  void update_tables();
+
+  QTableWidget* layers_table;
+  void populate_layers_table();
+  void layers_table_set_row(
+    const int row_idx,
+    const QString& label,
+    const bool checked);
+  void layer_edit_button_clicked(const std::string& label);
+  void layer_add_button_clicked();
+
+  BuildingLevelTable* level_table;
+  LiftTable* lift_table;
+  ScenarioTable* scenario_table;
+  TrafficTable* traffic_table;
+  CrowdSimEditorTable* crowd_sim_table;
+
+  QTableWidget* property_editor;
+  void update_property_editor();
+  void clear_property_editor();
+  void populate_property_editor(const Edge& edge);
+  void populate_property_editor(const Model& model);
+  void populate_property_editor(const Vertex& vertex);
+  void populate_property_editor(const Fiducial& fiducial);
+  void populate_property_editor(const Polygon& polygon);
+
+  QTableWidgetItem* create_table_item(const QString& str,
+    bool editable = false);
+  void property_editor_cell_changed(int row, int column);
+  void property_editor_set_row(
+    const int row_idx,
+    const QString& label,
+    const QString& value,
+    const bool editable = false);
+  void property_editor_set_row(
+    const int row_idx,
+    const QString& label,
+    const int& value,
+    const bool editable = false);
+  void property_editor_set_row(
+    const int row_idx,
+    const QString& label,
+    const double& value,
+    const int max_decimal_places = 3,
+    const bool editable = false);
+  QPushButton* add_param_button, * delete_param_button;
+  void add_param_button_clicked();
+  void delete_param_button_clicked();
+  void clear_current_tool_buffer(); // Necessary for tools like edge drawing that store temporary states
+
+#ifdef HAS_IGNITION_PLUGIN
+  QAction* sim_reset_action;
+  QAction* sim_play_pause_action;
+  void sim_reset();
+  void sim_play_pause();
+  SimThread sim_thread;
+  QTimer* scene_update_timer;
+  void scene_update_timer_timeout();
+#endif
+
+public:
+  void sim_tick();  // called by SimThread
+
+private:
+
+#if defined(HAS_IGNITION_PLUGIN) && defined(HAS_OPENCV)
+  QAction* record_start_stop_action;
+  bool is_recording = false;
+  void record_start_stop();
+  void record_frame_to_video();
+  cv::VideoWriter* video_writer = nullptr;
+#endif
+
+  std::vector<EditorModel> editor_models;
+  EditorModel* mouse_motion_editor_model = nullptr;
+  void load_model_names();
+
+  bool create_scene();
+
+  const static int ROTATION_INDICATOR_RADIUS = 50;
+  QGraphicsLineItem* mouse_motion_line = nullptr;
+  QGraphicsEllipseItem* mouse_motion_ellipse = nullptr;
+  QGraphicsPixmapItem* mouse_motion_model = nullptr;
+  QGraphicsPolygonItem* mouse_motion_polygon = nullptr;
+
+  int mouse_model_idx = -1;
+  int mouse_vertex_idx = -1;
+  int mouse_fiducial_idx = -1;
+  std::vector<int> mouse_motion_polygon_vertices;
+  //int mouse_motion_polygon_vertex_idx = -1;
+  Polygon::EdgeDragPolygon mouse_edge_drag_polygon;
+
+  void draw_mouse_motion_line_item(const double mouse_x, const double mouse_y);
+  void remove_mouse_motion_item();
+
+  void number_key_pressed(const int n);
+
+  // mouse handlers for various tools
+  enum MouseType
+  {
+    MOUSE_UNDEFINED = 0,
+    MOUSE_PRESS = 1,
+    MOUSE_RELEASE = 2,
+    MOUSE_MOVE = 3
+  };
+
+  void mouse_event(const MouseType t, QMouseEvent* e);
+
+  // helper function to avoid repeating lots of "add edge" code
+  void mouse_add_edge(
+    const MouseType t,
+    QMouseEvent* e,
+    const QPointF& p,
+    const Edge::Type& edge_type);
+
+  // helper function to avoid repeating lots of "add polygon" code
+  void mouse_add_polygon(
+    const MouseType t,
+    QMouseEvent* e,
+    const QPointF& p,
+    const Polygon::Type& polygon_type);
+
+  QGraphicsPixmapItem* get_closest_pixmap_item(const QPointF& p);
+  double discretize_angle(const double& angle);
+  void align_point(const QPointF& start, QPointF& end);
+
+  void mouse_select(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_move(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_rotate(const MouseType t, QMouseEvent* e, const QPointF& p);
+
+  void mouse_add_vertex(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_fiducial(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_lane(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_wall(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_meas(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_door(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_model(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_floor(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_hole(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_add_roi(const MouseType t, QMouseEvent* e, const QPointF& p);
+  void mouse_edit_polygon(const MouseType t, QMouseEvent* e, const QPointF& p);
+
+  void mouse_add_human_lane(const MouseType t, QMouseEvent* e,
+    const QPointF& p);
+
+  QPointF previous_mouse_point;
+
+  // For undo related support
+  AddEdgeCommand* latest_add_edge;
+  MoveFiducialCommand* latest_move_fiducial;
+  MoveModelCommand* latest_move_model;
+  MoveVertexCommand* latest_move_vertex;
+  RotateModelCommand* latest_rotate_model;
+};
+
+#endif
diff --git a/traffic_editor/gui/editor_mode_id.h b/traffic_editor/gui/editor_mode_id.h
new file mode 100644
index 0000000..8e16e49
--- /dev/null
+++ b/traffic_editor/gui/editor_mode_id.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef EDITOR_MODE_ID_H
+#define EDITOR_MODE_ID_H
+
+enum EditorModeId
+{
+  MODE_BUILDING = 1,
+  MODE_TRAFFIC = 2,
+  MODE_SCENARIO = 3,
+  MODE_CROWD_SIM = 4
+};
+
+#endif
diff --git a/traffic_editor/gui/editor_model.cpp b/traffic_editor/gui/editor_model.cpp
new file mode 100644
index 0000000..72cb6ec
--- /dev/null
+++ b/traffic_editor/gui/editor_model.cpp
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+
+#include <QDir>
+#include <QImage>
+#include <QImageReader>
+#include <QSettings>
+
+#include "traffic_editor/editor_model.h"
+
+using std::string;
+
+
+EditorModel::EditorModel(const string _name, const double _meters_per_pixel)
+: name(_name),
+  name_lowercase(_name),
+  meters_per_pixel(_meters_per_pixel)
+{
+  // make a lowercase copy for fast auto-complete
+  std::transform(
+    name_lowercase.begin(),
+    name_lowercase.end(),
+    name_lowercase.begin(),
+    [](unsigned char c) { return std::tolower(c); });
+}
+
+EditorModel::~EditorModel()
+{
+}
+
+QPixmap EditorModel::get_pixmap()
+{
+  if (!pixmap.isNull())
+    return pixmap;
+
+  // if we get here, we have to load the image from disk and generate pixmap
+
+  const QString THUMBNAIL_PATH_KEY("editor/thumbnail_path");
+  QSettings settings;
+  QString thumbnail_path(settings.value(THUMBNAIL_PATH_KEY).toString());
+
+  string filename =
+    thumbnail_path.toStdString() +
+    "/images/cropped/" +
+    name +
+    string(".png");
+  // qInfo("loading: [%s]", filename.c_str());
+  QImageReader image_reader(QString::fromStdString(filename));
+  image_reader.setAutoTransform(true);  // not sure what this does
+  QImage image = image_reader.read();
+  if (image.isNull())
+  {
+    qWarning("unable to read %s: %s",
+      filename.c_str(),
+      qUtf8Printable(image_reader.errorString()));
+    return QPixmap();
+  }
+  pixmap = QPixmap::fromImage(image);
+  return pixmap;
+}
diff --git a/traffic_editor/gui/fiducial.cpp b/traffic_editor/gui/fiducial.cpp
new file mode 100644
index 0000000..fc5dcff
--- /dev/null
+++ b/traffic_editor/gui/fiducial.cpp
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <cmath>
+
+#include <QGraphicsScene>
+#include <QGraphicsSimpleTextItem>
+
+#include "traffic_editor/fiducial.h"
+using std::string;
+
+Fiducial::Fiducial()
+{
+  uuid = QUuid::createUuid();
+}
+
+Fiducial::Fiducial(double _x, double _y, const string& _name)
+: x(_x), y(_y), name(_name)
+{
+}
+
+void Fiducial::from_yaml(const YAML::Node& data)
+{
+  if (!data.IsSequence())
+    throw std::runtime_error("Vertex::from_yaml expected a sequence");
+  x = data[0].as<double>();
+  y = data[1].as<double>();
+  name = data[2].as<string>();
+}
+
+YAML::Node Fiducial::to_yaml() const
+{
+  // This is in image space. I think it's safe to say nobody is clicking
+  // with more than 1/1000 precision inside a single pixel.
+  YAML::Node node;
+  node.SetStyle(YAML::EmitterStyle::Flow);
+  node.push_back(std::round(x * 1000.0) / 1000.0);
+  node.push_back(std::round(y * 1000.0) / 1000.0);
+  node.push_back(name);
+  return node;
+}
+
+void Fiducial::draw(
+  QGraphicsScene* scene,
+  const double meters_per_pixel) const
+{
+  const double a = 0.5;
+  const QColor color = QColor::fromRgbF(0.0, 0.0, 1.0, a);
+  const QColor selected_color = QColor::fromRgbF(1.0, 0.0, 0.0, a);
+
+  QPen pen(selected ? selected_color : color);
+  pen.setWidth(0.2 / meters_per_pixel);
+  const double radius = 0.5 / meters_per_pixel;
+
+  scene->addEllipse(
+    x - radius,
+    y - radius,
+    2 * radius,
+    2 * radius,
+    pen);
+  scene->addLine(x, y - 2 * radius, x, y + 2 * radius, pen);
+  scene->addLine(x - 2 * radius, y, x + 2 * radius, y, pen);
+
+  if (!name.empty())
+  {
+    QGraphicsSimpleTextItem* item = scene->addSimpleText(
+      QString::fromStdString(name));
+    item->setBrush(QColor(0, 0, 255, 255));
+    item->setPos(x, y + radius);
+  }
+}
+
+double Fiducial::distance(const Fiducial& f)
+{
+  const double dx = f.x - x;
+  const double dy = f.y - y;
+  return std::sqrt(dx*dx + dy*dy);
+}
diff --git a/traffic_editor/gui/layer.cpp b/traffic_editor/gui/layer.cpp
new file mode 100644
index 0000000..e8380a2
--- /dev/null
+++ b/traffic_editor/gui/layer.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <QImageReader>
+#include "traffic_editor/layer.h"
+using std::string;
+using std::vector;
+
+Layer::Layer()
+{
+}
+
+Layer::~Layer()
+{
+}
+
+bool Layer::from_yaml(const std::string& _name, const YAML::Node& y)
+{
+  if (!y.IsMap())
+    throw std::runtime_error("Layer::from_yaml() expected a map");
+  name = _name;
+  filename = y["filename"].as<string>();
+  meters_per_pixel = y["meters_per_pixel"].as<double>();
+  translation_x = y["translation_x"].as<double>();
+  translation_y = y["translation_y"].as<double>();
+  rotation = y["rotation"].as<double>();
+  if (y["visible"])
+    visible = y["visible"].as<bool>();
+
+  // now try to load the image
+  QImageReader image_reader(QString::fromStdString(filename));
+  image_reader.setAutoTransform(true);
+  QImage image = image_reader.read();
+  if (image.isNull())
+  {
+    qWarning("unable to read %s: %s",
+      qUtf8Printable(QString::fromStdString(filename)),
+      qUtf8Printable(image_reader.errorString()));
+    return false;
+  }
+  image = image.convertToFormat(QImage::Format_Grayscale8);
+  pixmap = QPixmap::fromImage(image);
+  printf("successfully opened %s\n", filename.c_str());
+
+  return true;
+}
+
+YAML::Node Layer::to_yaml() const
+{
+  YAML::Node y;
+  y.SetStyle(YAML::EmitterStyle::Flow);
+  y["filename"] = filename;
+  y["meters_per_pixel"] = meters_per_pixel;
+  y["translation_x"] = translation_x;
+  y["translation_y"] = translation_y;
+  y["rotation"] = rotation;
+  y["visible"] = visible;
+  return y;
+}
diff --git a/traffic_editor/gui/layer_dialog.cpp b/traffic_editor/gui/layer_dialog.cpp
new file mode 100644
index 0000000..261c3eb
--- /dev/null
+++ b/traffic_editor/gui/layer_dialog.cpp
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "layer_dialog.h"
+#include <QtWidgets>
+
+
+LayerDialog::LayerDialog(QWidget* parent, Layer& _layer, bool edit_mode)
+: QDialog(parent),
+  layer(_layer),
+  _edit_mode(edit_mode)
+{
+  setWindowTitle("Layer Properties");
+  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  bottom_buttons_layout->addWidget(ok_button);
+  connect(
+    ok_button, &QAbstractButton::clicked,
+    this, &LayerDialog::ok_button_clicked);
+
+  // When using this dialog in "edit mode," it is modeless and instantly
+  // updating, so there is no "cancel" function.
+  if (!edit_mode)
+  {
+    cancel_button = new QPushButton("Cancel", this);
+    bottom_buttons_layout->addWidget(cancel_button);
+    connect(
+      cancel_button, &QAbstractButton::clicked,
+      this, &QDialog::reject);
+  }
+
+  QHBoxLayout* name_hbox_layout = new QHBoxLayout;
+  name_line_edit = new QLineEdit(QString::fromStdString(layer.name), this);
+  name_hbox_layout->addWidget(new QLabel("name:"));
+  name_hbox_layout->addWidget(name_line_edit);
+
+  QHBoxLayout* filename_layout = new QHBoxLayout;
+  filename_line_edit = new QLineEdit(
+    QString::fromStdString(layer.filename), this);
+  filename_button = new QPushButton("Find...", this);
+  filename_layout->addWidget(new QLabel("image:"));
+  filename_layout->addWidget(filename_line_edit);
+  filename_layout->addWidget(filename_button);
+  connect(
+    filename_button, &QAbstractButton::clicked,
+    this, &LayerDialog::filename_button_clicked);
+  connect(
+    filename_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &LayerDialog::filename_line_edited);
+
+  QHBoxLayout* scale_hbox_layout = new QHBoxLayout;
+  scale_hbox_layout->addWidget(new QLabel("Meters per pixel:"));
+  scale_line_edit = new QLineEdit(
+    QString::number(layer.meters_per_pixel),
+    this);
+  scale_hbox_layout->addWidget(scale_line_edit);
+
+  QHBoxLayout* translation_x_hbox_layout = new QHBoxLayout;
+  translation_x_hbox_layout->addWidget(new QLabel("X translation (meters):"));
+  translation_x_line_edit = new QLineEdit(
+    QString::number(layer.translation_x),
+    this);
+  translation_x_hbox_layout->addWidget(translation_x_line_edit);
+
+  QHBoxLayout* translation_y_hbox_layout = new QHBoxLayout;
+  translation_y_hbox_layout->addWidget(new QLabel("Y translation (meters):"));
+  translation_y_line_edit = new QLineEdit(
+    QString::number(layer.translation_y),
+    this);
+  translation_y_hbox_layout->addWidget(translation_y_line_edit);
+
+  QHBoxLayout* rotation_hbox_layout = new QHBoxLayout;
+  rotation_hbox_layout->addWidget(new QLabel("Rotation (radians):"));
+  rotation_line_edit = new QLineEdit(
+    QString::number(layer.rotation),
+    this);
+  rotation_hbox_layout->addWidget(rotation_line_edit);
+
+  QVBoxLayout* vbox_layout = new QVBoxLayout;
+  vbox_layout->addLayout(name_hbox_layout);
+  vbox_layout->addLayout(filename_layout);
+  vbox_layout->addLayout(scale_hbox_layout);
+  vbox_layout->addLayout(translation_x_hbox_layout);
+  vbox_layout->addLayout(translation_y_hbox_layout);
+  vbox_layout->addLayout(rotation_hbox_layout);
+  // todo: some sort of separator (?)
+  vbox_layout->addLayout(bottom_buttons_layout);
+
+  connect(
+    filename_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &LayerDialog::update_layer);
+
+  connect(
+    scale_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &LayerDialog::update_layer);
+
+  connect(
+    translation_x_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &LayerDialog::update_layer);
+
+  connect(
+    translation_y_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &LayerDialog::update_layer);
+
+  connect(
+    rotation_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &LayerDialog::update_layer);
+
+  setLayout(vbox_layout);
+}
+
+LayerDialog::~LayerDialog()
+{
+}
+
+void LayerDialog::filename_button_clicked()
+{
+  QFileDialog file_dialog(this, "Find Image");
+  file_dialog.setFileMode(QFileDialog::ExistingFile);
+  file_dialog.setNameFilter("*.png");
+  if (file_dialog.exec() != QDialog::Accepted)
+  {
+    return;  // user clicked 'cancel'
+  }
+  const QString filename = file_dialog.selectedFiles().first();
+  if (!QFileInfo(filename).exists())
+  {
+    QMessageBox::critical(
+      this,
+      "Image file does not exist",
+      "File does not exist.");
+    return;
+  }
+  filename_line_edit->setText(
+    QDir::current().relativeFilePath(filename));
+}
+
+void LayerDialog::ok_button_clicked()
+{
+  if (!filename_line_edit->text().isEmpty())
+  {
+    // make sure the drawing file exists
+    if (!QFileInfo(filename_line_edit->text()).exists())
+    {
+      QMessageBox::critical(
+        this,
+        "Image file must exist",
+        "Image file must exist");
+      return;
+    }
+  }
+  /*
+  // todo: figure out how to test for valid numeric values;
+  // this doesn't work but there must be a similar function somewhere
+  if (!x_line_edit->text().isNumber() || !y_line_edit->text().isNumber()) {
+    QMessageBox::critical(
+        this,
+        "X and Y dimensions must be numbers",
+        "X and Y dimensions must be numbers");
+    return;
+  }
+  */
+  if (name_line_edit->text().isEmpty())
+  {
+    QMessageBox::critical(
+      this,
+      "Name must not be empty",
+      "Name must not be empty");
+    return;
+  }
+  update_layer();
+
+  accept();
+}
+
+void LayerDialog::filename_line_edited(const QString& /*text*/)
+{
+  // todo: render on parent if file exists?
+}
+
+void LayerDialog::update_layer()
+{
+  layer.name = name_line_edit->text().toStdString();
+  layer.filename = filename_line_edit->text().toStdString();
+  layer.rotation = rotation_line_edit->text().toDouble();
+  layer.translation_x = translation_x_line_edit->text().toDouble();
+  layer.translation_y = translation_y_line_edit->text().toDouble();
+  layer.meters_per_pixel = scale_line_edit->text().toDouble();
+  emit redraw();
+}
diff --git a/traffic_editor/gui/layer_dialog.h b/traffic_editor/gui/layer_dialog.h
new file mode 100644
index 0000000..bbbf209
--- /dev/null
+++ b/traffic_editor/gui/layer_dialog.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LAYER_DIALOG_H
+#define LAYER_DIALOG_H
+
+#include <QDialog>
+#include <QObject>
+#include "traffic_editor/layer.h"
+class QLineEdit;
+
+
+class LayerDialog : public QDialog
+{
+  Q_OBJECT
+
+public:
+  LayerDialog(QWidget* parent, Layer& _layer, bool edit_mode = true);
+  ~LayerDialog();
+
+private:
+  Layer& layer;
+  bool _edit_mode = true;
+
+  QLineEdit* name_line_edit;
+  QLineEdit* filename_line_edit;
+  QLineEdit* scale_line_edit;
+  QLineEdit* translation_x_line_edit;
+  QLineEdit* translation_y_line_edit;
+  QLineEdit* rotation_line_edit;
+
+  QPushButton* filename_button;
+  QPushButton* ok_button, * cancel_button;
+
+  void update_layer();
+
+private slots:
+  void filename_button_clicked();
+  void ok_button_clicked();
+  void filename_line_edited(const QString& text);
+
+signals:
+  void redraw();
+};
+
+#endif
diff --git a/traffic_editor/gui/level.cpp b/traffic_editor/gui/level.cpp
new file mode 100644
index 0000000..6fd2558
--- /dev/null
+++ b/traffic_editor/gui/level.cpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+#include <cmath>
+
+#include <QGraphicsScene>
+#include <QImage>
+#include <QImageReader>
+
+#include "traffic_editor/level.h"
+using std::string;
+using std::vector;
+
+
+Level::Level()
+{
+}
+
+Level::~Level()
+{
+}
+
+void Level::load_yaml_edge_sequence(
+  const YAML::Node& data,
+  const char* sequence_name,
+  const Edge::Type type)
+{
+  if (!data[sequence_name] || !data[sequence_name].IsSequence())
+    return;
+
+  const YAML::Node& yl = data[sequence_name];
+  for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
+  {
+    Edge e;
+    e.from_yaml(*it, type);
+    edges.push_back(e);
+  }
+}
+
+double Level::point_to_line_segment_distance(
+  const double x, const double y,
+  const double x0, const double y0,
+  const double x1, const double y1,
+  double& x_proj, double& y_proj)
+{
+  // this portion figures out which edge is closest to (x, y) by repeatedly
+  // testing the distance from the click to each edge in the polygon, using
+  // geometry similar to that explained in:
+  // https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
+
+  const double dx = x1 - x0;
+  const double dy = y1 - y0;
+  const double segment_length_squared = dx*dx + dy*dy;
+
+  const double dx0 = x - x0;
+  const double dy0 = y - y0;
+  const double dot = dx0*dx + dy0*dy;
+  const double t = std::max(
+    0.0,
+    std::min(1.0, dot / segment_length_squared));
+
+  x_proj = x0 + t * dx;
+  y_proj = y0 + t * dy;
+
+  const double dx_proj = x - x_proj;
+  const double dy_proj = y - y_proj;
+
+  const double dist = std::sqrt(dx_proj * dx_proj + dy_proj * dy_proj);
+
+  /*
+  printf("   p=(%.1f, %.1f) p0=(%.1f, %.1f) p1=(%.1f, %.1f) t=%.3f proj=(%.1f, %.1f) dist=%.3f\n",
+      x, y, x0, y0, x1, y1, t, x_proj, y_proj, dist);
+  */
+
+  return dist;
+}
+
+/*
+ * This function returns the index of the polygon vertex that will be
+ * 'split' by the newly created edge
+ */
+Polygon::EdgeDragPolygon Level::polygon_edge_drag_press(
+  const Polygon* polygon,
+  const double x,
+  const double y)
+{
+  Polygon::EdgeDragPolygon edp;
+
+  if (polygon == nullptr || polygon->vertices.empty())
+    return edp;
+
+  // cruise along all possible line segments and calculate the distance
+  // to this point
+
+  int min_idx = 0;
+  double min_dist = 1.0e9;
+
+  for (size_t v0_idx = 0; v0_idx < polygon->vertices.size(); v0_idx++)
+  {
+    const size_t v1_idx =
+      v0_idx < polygon->vertices.size() - 1 ? v0_idx + 1 : 0;
+    const size_t v0 = polygon->vertices[v0_idx];
+    const size_t v1 = polygon->vertices[v1_idx];
+
+    const double x0 = vertices[v0].x;
+    const double y0 = vertices[v0].y;
+    const double x1 = vertices[v1].x;
+    const double y1 = vertices[v1].y;
+
+    double x_proj = 0, y_proj = 0;
+    const double dist = point_to_line_segment_distance(
+      x, y, x0, y0, x1, y1, x_proj, y_proj);
+
+    if (dist < min_dist)
+    {
+      min_idx = v0;
+      min_dist = dist;
+
+      // save the nearest projected point to help debug this visually
+      polygon_edge_proj_x = x_proj;
+      polygon_edge_proj_y = y_proj;
+    }
+  }
+
+  // create the mouse motion polygon and insert a new edge
+  QVector<QPointF> polygon_vertices;
+  for (size_t i = 0; i < polygon->vertices.size(); i++)
+  {
+    const int v_idx = polygon->vertices[i];
+    const Vertex& v = vertices[v_idx];
+    polygon_vertices.append(QPointF(v.x, v.y));
+    if (v_idx == min_idx)
+    {
+      polygon_vertices.append(QPointF(x, y));  // current mouse location
+      edp.movable_vertex = i + 1;
+    }
+  }
+  edp.polygon = QPolygonF(polygon_vertices);
+
+  return edp;
+}
+
+bool Level::parse_vertices(const YAML::Node& _data)
+{
+  if (_data["vertices"] && _data["vertices"].IsSequence())
+  {
+    const YAML::Node& pts = _data["vertices"];
+    for (YAML::const_iterator it = pts.begin(); it != pts.end(); ++it)
+    {
+      Vertex v;
+      v.from_yaml(*it);
+      vertices.push_back(v);
+    }
+  }
+  return true;
+}
+
+void Level::add_vertex(const double x, const double y)
+{
+  vertices.push_back(Vertex(x, y));
+}
+
+size_t Level::get_vertex_by_id(QUuid vertex_id)
+{
+  for (size_t i = 0; i < vertices.size(); i++)
+  {
+    if (vertices[i].uuid == vertex_id)
+    {
+      return i;
+    }
+  }
+  return vertices.size()+1;
+}
diff --git a/traffic_editor/gui/lift.cpp b/traffic_editor/gui/lift.cpp
new file mode 100644
index 0000000..a0b022a
--- /dev/null
+++ b/traffic_editor/gui/lift.cpp
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+#include <cmath>
+
+#include <QGraphicsScene>
+#include <QGraphicsSimpleTextItem>
+
+#include "traffic_editor/lift.h"
+using std::string;
+
+
+Lift::Lift()
+{
+}
+
+void Lift::from_yaml(const std::string& _name, const YAML::Node& data,
+  const std::vector<BuildingLevel>& levels)
+{
+  if (!data.IsMap())
+    throw std::runtime_error("Lift::from_yaml() expected a map");
+  x = data["x"].as<double>();
+  y = data["y"].as<double>();
+  yaw = data["yaw"].as<double>();
+  name = _name;
+  reference_floor_name = data["reference_floor_name"].as<string>();
+  if (data["initial_floor_name"])
+    initial_floor_name = data["initial_floor_name"].as<string>();
+  else
+    initial_floor_name = reference_floor_name;
+  width = data["width"].as<double>();
+  depth = data["depth"].as<double>();
+  if (data["plugins"])
+    plugins = data["plugins"].as<bool>();
+  else
+    plugins = true;
+
+  if (data["doors"] && data["doors"].IsMap())
+  {
+    const YAML::Node& yd = data["doors"];
+    for (YAML::const_iterator it = yd.begin(); it != yd.end(); ++it)
+    {
+      LiftDoor door;
+      door.from_yaml(it->first.as<string>(), it->second);
+      doors.push_back(door);
+    }
+  }
+
+  if (data["highest_floor"])
+    highest_floor = data["highest_floor"].as<string>();
+  if (data["lowest_floor"])
+    lowest_floor = data["lowest_floor"].as<string>();
+  for (const auto& level : levels)
+  {
+    if (level.name == highest_floor)
+      highest_elevation = level.elevation;
+    if (level.name == lowest_floor)
+      lowest_elevation = level.elevation;
+  }
+
+  // for every level, load if every door can open
+  if (data["level_doors"] && data["level_doors"].IsMap())
+  {
+    const YAML::Node ym = data["level_doors"];
+    for (YAML::const_iterator it = ym.begin(); it != ym.end(); ++it)
+    {
+      const std::string level_name = it->first.as<string>();
+      const YAML::Node& ds = it->second;  // doors sequence node
+      if (ds.IsSequence())
+      {
+        for (YAML::const_iterator dit = ds.begin(); dit != ds.end(); ++dit)
+        {
+          const std::string door_name = (*dit).as<string>();
+          level_doors[level_name].push_back(door_name);
+        }
+      }
+    }
+  }
+}
+
+YAML::Node Lift::to_yaml() const
+{
+  // This is in image space. I think it's safe to say nobody is clicking
+  // with more than 1/1000 precision inside a single pixel.
+
+  YAML::Node n;
+  n["x"] = std::round(x * 1000.0) / 1000.0;
+  n["y"] = std::round(y * 1000.0) / 1000.0;
+  // let's give yaw another decimal place because, I don't know, reasons (?)
+  n["yaw"] = std::round(yaw * 10000.0) / 10000.0;
+  n["reference_floor_name"] = reference_floor_name;
+  n["highest_floor"] = highest_floor;
+  n["lowest_floor"] = lowest_floor;
+  n["initial_floor_name"] = initial_floor_name;
+  n["width"] = std::round(width * 1000.0) / 1000.0;
+  n["depth"] = std::round(depth * 1000.0) / 1000.0;
+  n["plugins"] = plugins;
+
+  n["doors"] = YAML::Node(YAML::NodeType::Map);
+  for (const auto& door : doors)
+    n["doors"][door.name] = door.to_yaml();
+
+  n["level_doors"] = YAML::Node(YAML::NodeType::Map);
+  for (LevelDoorMap::const_iterator level_it = level_doors.begin();
+    level_it != level_doors.end();
+    ++level_it)
+  {
+    const DoorNameList& dlist = level_it->second;
+    for (DoorNameList::const_iterator door_it = dlist.begin();
+      door_it != dlist.end();
+      ++door_it)
+    {
+      n["level_doors"][level_it->first].push_back(*door_it);
+      n["level_doors"][level_it->first].SetStyle(YAML::EmitterStyle::Flow);
+    }
+  }
+  return n;
+}
+
+/// The level_name parameter is required in order to know how to draw the
+/// doors, since many lifts have more than one set of doors, which open on
+/// some but not all floors. It's not being used (yet).
+void Lift::draw(
+  QGraphicsScene* scene,
+  const double meters_per_pixel,
+  const string& level_name,
+  const double elevation,
+  const bool apply_transformation,
+  const double scale,
+  const double translate_x,
+  const double translate_y) const
+{
+  if (elevation > highest_elevation || elevation < lowest_elevation)
+    return;
+  const double cabin_w = width / meters_per_pixel;
+  const double cabin_d = depth / meters_per_pixel;
+  QPen cabin_pen(Qt::black);
+  cabin_pen.setWidth(0.05 / meters_per_pixel);
+
+  QGraphicsRectItem* cabin_rect = new QGraphicsRectItem(
+    -cabin_w / 2.0,
+    -cabin_d / 2.0,
+    cabin_w,
+    cabin_d);
+  cabin_rect->setPen(cabin_pen);
+  auto it = level_doors.find(level_name);
+  if (it == level_doors.end())
+    cabin_rect->setBrush(QBrush(QColor::fromRgbF(1.0, 0.3, 0.3, 0.3)));
+  else
+    cabin_rect->setBrush(QBrush(QColor::fromRgbF(0.5, 1.0, 0.5, 0.5)));
+  scene->addItem(cabin_rect);
+
+  QList<QGraphicsItem*> items;
+  items.append(cabin_rect);
+
+  if (!name.empty())
+  {
+    QFont font("Helvetica");
+    font.setPointSize(0.2 / meters_per_pixel);
+    QGraphicsSimpleTextItem* text_item = scene->addSimpleText(
+      QString::fromStdString(name), font);
+    text_item->setBrush(QColor(255, 0, 0, 255));
+    text_item->setPos(-cabin_w / 3.0, 0.0);
+
+    // todo: set font size to something reasonable
+    // todo: center-align text?
+    items.append(text_item);
+  }
+
+  if (it != level_doors.end())
+  {
+    for (const LiftDoor& door : doors)
+    {
+      if (find(it->second.begin(), it->second.end(), door.name)
+        == it->second.end())
+        continue;
+      const double door_x = door.x / meters_per_pixel;
+      const double door_y = -door.y / meters_per_pixel;
+      const double door_w = door.width / meters_per_pixel;
+      const double door_thickness = 0.2 / meters_per_pixel;
+      QGraphicsRectItem* door_item = new QGraphicsRectItem(
+        -door_w / 2.0,
+        -door_thickness / 2.0,
+        door_w,
+        door_thickness);
+      door_item->setRotation(-180.0 / 3.1415926 * door.motion_axis_orientation);
+      door_item->setPos(door_x, door_y);
+
+      QPen door_pen(Qt::red);
+      door_pen.setWidth(0.05 / meters_per_pixel);
+      door_item->setPen(door_pen);
+      door_item->setBrush(QBrush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5)));
+
+      items.append(door_item);
+    }
+  }
+
+  QGraphicsItemGroup* group = scene->createItemGroup(items);
+
+  if (apply_transformation)
+  {
+    group->setRotation(-180.0 / 3.1415926 * yaw);
+    group->setPos(x * scale + translate_x, y * scale + translate_y);
+  }
+}
+
+bool Lift::level_door_opens(
+  const std::string& level_name,
+  const std::string& door_name,
+  const std::vector<BuildingLevel>& levels) const
+{
+  LevelDoorMap::const_iterator level_it = level_doors.find(level_name);
+  if (level_it == level_doors.end())
+    return false;
+  for (const auto& level : levels)
+  {
+    if (level.name == level_name)
+    {
+      if (level.elevation < lowest_elevation ||
+        level.elevation > highest_elevation)
+        return false;
+      break;
+    }
+  }
+  const DoorNameList& names = level_it->second;
+  if (std::find(names.begin(), names.end(), door_name) == names.end())
+    return false;
+  return true;
+}
diff --git a/traffic_editor/gui/lift_dialog.cpp b/traffic_editor/gui/lift_dialog.cpp
new file mode 100644
index 0000000..538fcd8
--- /dev/null
+++ b/traffic_editor/gui/lift_dialog.cpp
@@ -0,0 +1,592 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "lift_dialog.h"
+#include <cfloat>
+#include <QtWidgets>
+using std::vector;
+
+
+LiftDialog::LiftDialog(Lift& lift, Building& building)
+: QDialog(),
+  _lift(lift),
+  _building(building)
+{
+  setWindowTitle("Lift Properties");
+  for (const auto& level : building.levels)
+    _level_names.push_back(QString::fromStdString(level.name));
+
+  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
+  _ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  bottom_buttons_hbox->addWidget(_ok_button);
+  connect(
+    _ok_button, &QAbstractButton::clicked,
+    this, &LiftDialog::ok_button_clicked);
+
+  _cancel_button = new QPushButton("Cancel", this);
+  bottom_buttons_hbox->addWidget(_cancel_button);
+  connect(
+    _cancel_button,
+    &QAbstractButton::clicked,
+    this,
+    &QDialog::reject);
+
+  QHBoxLayout* name_hbox = new QHBoxLayout;
+  name_hbox->addWidget(new QLabel("Name:"));
+  _name_line_edit =
+    new QLineEdit(QString::fromStdString(_lift.name), this);
+  connect(
+    _name_line_edit,
+    &QLineEdit::textEdited,
+    [this](const QString& text)
+    {
+      _lift.name = text.toStdString();
+      update_lift_view();
+      emit redraw();
+    });
+  name_hbox->addWidget(_name_line_edit);
+
+  QHBoxLayout* ref_name_hbox = new QHBoxLayout;
+  ref_name_hbox->addWidget(new QLabel("Reference floor:"));
+  _reference_floor_combo_box = new QComboBox;
+  for (const QString& level_name : _level_names)
+    _reference_floor_combo_box->addItem(level_name);
+  _reference_floor_combo_box->setCurrentText(
+    QString::fromStdString(_lift.reference_floor_name));
+  connect(
+    _reference_floor_combo_box,
+    &QComboBox::currentTextChanged,
+    [this](const QString& text)
+    {
+      _lift.reference_floor_name = text.toStdString();
+      emit redraw();
+    });
+  ref_name_hbox->addWidget(_reference_floor_combo_box);
+
+  QHBoxLayout* init_floor_hbox = new QHBoxLayout;
+  init_floor_hbox->addWidget(new QLabel("Initial floor:"));
+  _initial_floor_combo_box = new QComboBox;
+  for (const QString& level_name : _level_names)
+    _initial_floor_combo_box->addItem(level_name);
+  _initial_floor_combo_box->setCurrentText(
+    QString::fromStdString(_lift.initial_floor_name));
+  connect(
+    _initial_floor_combo_box,
+    &QComboBox::currentTextChanged,
+    [this](const QString& text)
+    {
+      _lift.initial_floor_name = text.toStdString();
+      emit redraw();
+    });
+  init_floor_hbox->addWidget(_initial_floor_combo_box);
+
+  QHBoxLayout* highest_name_hbox = new QHBoxLayout;
+  highest_name_hbox->addWidget(new QLabel("Highest floor:"));
+  _highest_floor_combo_box = new QComboBox;
+  for (const QString& level_name : _level_names)
+    _highest_floor_combo_box->addItem(level_name);
+  _highest_floor_combo_box->addItem("");  // empty string for not specifying
+  _highest_floor_combo_box->setCurrentText(
+    QString::fromStdString(_lift.highest_floor));
+  connect(
+    _highest_floor_combo_box,
+    &QComboBox::currentTextChanged,
+    [this](const QString& text)
+    {
+      _lift.highest_floor = text.toStdString();
+      if (_lift.highest_floor.empty())
+        _lift.highest_elevation = DBL_MAX;
+      else
+      {
+        for (const auto& level : _building.levels)
+        {
+          if (level.name == _lift.highest_floor)
+          {
+            _lift.highest_elevation = level.elevation;
+            break;
+          }
+        }
+      }
+      update_level_table();
+      emit redraw();
+    });
+  highest_name_hbox->addWidget(_highest_floor_combo_box);
+
+  QHBoxLayout* lowest_name_hbox = new QHBoxLayout;
+  lowest_name_hbox->addWidget(new QLabel("Lowest floor:"));
+  _lowest_floor_combo_box = new QComboBox;
+  for (const QString& level_name : _level_names)
+    _lowest_floor_combo_box->addItem(level_name);
+  _lowest_floor_combo_box->addItem("");
+  _lowest_floor_combo_box->setCurrentText(
+    QString::fromStdString(_lift.lowest_floor));
+  connect(
+    _lowest_floor_combo_box,
+    &QComboBox::currentTextChanged,
+    [this](const QString& text)
+    {
+      _lift.lowest_floor = text.toStdString();
+      if (_lift.lowest_floor.empty())
+        _lift.lowest_elevation = -DBL_MAX;
+      else
+      {
+        for (const auto& level : _building.levels)
+        {
+          if (level.name == _lift.lowest_floor)
+          {
+            _lift.lowest_elevation = level.elevation;
+            break;
+          }
+        }
+      }
+      update_level_table();
+      emit redraw();
+    });
+  lowest_name_hbox->addWidget(_lowest_floor_combo_box);
+
+  QHBoxLayout* x_hbox = new QHBoxLayout;
+  x_hbox->addWidget(new QLabel("X:"));
+  _x_line_edit =
+    new QLineEdit(QString::number(_lift.x), this);
+  connect(
+    _x_line_edit,
+    &QLineEdit::textEdited,
+    [this](const QString& text)
+    {
+      _lift.x = text.toDouble();
+      update_lift_wps();
+    });
+  x_hbox->addWidget(_x_line_edit);
+
+  QHBoxLayout* y_hbox = new QHBoxLayout;
+  y_hbox->addWidget(new QLabel("Y:"));
+  _y_line_edit =
+    new QLineEdit(QString::number(_lift.y), this);
+  connect(
+    _y_line_edit,
+    &QLineEdit::textEdited,
+    [this](const QString& text)
+    {
+      _lift.y = text.toDouble();
+      update_lift_wps();
+    });
+  y_hbox->addWidget(_y_line_edit);
+
+  QHBoxLayout* yaw_hbox = new QHBoxLayout;
+  yaw_hbox->addWidget(new QLabel("Yaw:"));
+  _yaw_line_edit =
+    new QLineEdit(QString::number(_lift.yaw), this);
+  connect(
+    _yaw_line_edit,
+    &QLineEdit::textEdited,
+    [this](const QString& text)
+    {
+      _lift.yaw = text.toDouble();
+      update_lift_view();
+      emit redraw();
+    });
+  yaw_hbox->addWidget(_yaw_line_edit);
+
+  QHBoxLayout* width_hbox = new QHBoxLayout;
+  width_hbox->addWidget(new QLabel("Cabin width:"));
+  _width_line_edit =
+    new QLineEdit(QString::number(_lift.width), this);
+  connect(
+    _width_line_edit,
+    &QLineEdit::textEdited,
+    [this](const QString& text)
+    {
+      _lift.width = text.toDouble();
+      update_lift_view();
+      emit redraw();
+    });
+  width_hbox->addWidget(_width_line_edit);
+
+  QHBoxLayout* depth_hbox = new QHBoxLayout;
+  depth_hbox->addWidget(new QLabel("Cabin depth:"));
+  _depth_line_edit =
+    new QLineEdit(QString::number(_lift.depth), this);
+  connect(
+    _depth_line_edit,
+    &QLineEdit::textEdited,
+    [this](const QString& text)
+    {
+      _lift.depth = text.toDouble();
+      update_lift_view();
+      emit redraw();
+    });
+  depth_hbox->addWidget(_depth_line_edit);
+
+  QHBoxLayout* plugin_hbox = new QHBoxLayout;
+  plugin_hbox->addWidget(new QLabel("Plugin:"));
+  _plugin_yes_radio_button = new QRadioButton("Yes");
+  _plugin_no_radio_button = new QRadioButton("No");
+  if (_lift.plugins)
+    _plugin_yes_radio_button->setChecked(true);
+  else
+    _plugin_no_radio_button->setChecked(true);
+
+  plugin_hbox->addWidget(_plugin_yes_radio_button);
+  plugin_hbox->addWidget(_plugin_no_radio_button);
+
+  QHBoxLayout* add_wp_hbox = new QHBoxLayout;
+  _add_wp_button = new QPushButton("Add lift waypoints", this);
+  add_wp_hbox->addWidget(_add_wp_button);
+  connect(
+    _add_wp_button, &QAbstractButton::clicked,
+    this, &LiftDialog::update_lift_wps);
+
+  _level_table = new QTableWidget;
+  _level_table->setMinimumSize(200, 200);
+  _level_table->verticalHeader()->setVisible(false);
+  _level_table->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
+
+  _level_table->setHorizontalHeaderItem(0, new QTableWidgetItem("Level name"));
+  /*
+  _level_table->horizontalHeader()->setSectionResizeMode(
+      0, QHeaderView::Stretch);
+  */
+
+  _door_table = new QTableWidget;
+  _door_table->setMinimumSize(400, 200);
+  _door_table->verticalHeader()->setVisible(false);
+  _door_table->setColumnCount(6);
+  _door_table->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
+
+  _door_table->setHorizontalHeaderItem(0, new QTableWidgetItem("Door name"));
+  _door_table->horizontalHeader()->setSectionResizeMode(
+    0, QHeaderView::Stretch);
+
+  _door_table->setHorizontalHeaderItem(1, new QTableWidgetItem("Door type"));
+  _door_table->horizontalHeader()->setSectionResizeMode(
+    1, QHeaderView::ResizeToContents);
+
+  _door_table->setHorizontalHeaderItem(2, new QTableWidgetItem("X"));
+  _door_table->horizontalHeader()->setSectionResizeMode(
+    2, QHeaderView::ResizeToContents);
+
+  _door_table->setHorizontalHeaderItem(3, new QTableWidgetItem("Y"));
+  _door_table->horizontalHeader()->setSectionResizeMode(
+    3, QHeaderView::ResizeToContents);
+
+  _door_table->setHorizontalHeaderItem(4, new QTableWidgetItem("Orientation"));
+  _door_table->horizontalHeader()->setSectionResizeMode(
+    4, QHeaderView::ResizeToContents);
+
+  _door_table->setHorizontalHeaderItem(5, new QTableWidgetItem("Width"));
+  _door_table->horizontalHeader()->setSectionResizeMode(
+    5, QHeaderView::ResizeToContents);
+
+  _door_table->verticalHeader()->setSectionResizeMode(
+    QHeaderView::ResizeToContents);
+
+  QVBoxLayout* left_vbox = new QVBoxLayout;
+  left_vbox->addLayout(name_hbox);
+  left_vbox->addLayout(ref_name_hbox);
+  left_vbox->addLayout(highest_name_hbox);
+  left_vbox->addLayout(lowest_name_hbox);
+  left_vbox->addLayout(init_floor_hbox);
+  left_vbox->addLayout(x_hbox);
+  left_vbox->addLayout(y_hbox);
+  left_vbox->addLayout(yaw_hbox);
+  left_vbox->addLayout(width_hbox);
+  left_vbox->addLayout(depth_hbox);
+  left_vbox->addLayout(plugin_hbox);
+  left_vbox->addLayout(add_wp_hbox);
+  left_vbox->addWidget(_level_table);
+
+  QVBoxLayout* right_vbox = new QVBoxLayout;
+
+  _lift_scene = new QGraphicsScene;
+
+  _lift_view = new QGraphicsView;
+  _lift_view->setScene(_lift_scene);
+  _lift_view->setMinimumSize(400, 400);
+  right_vbox->addWidget(_lift_view, 1);
+
+  right_vbox->addWidget(_door_table);
+
+  QHBoxLayout* top_hbox = new QHBoxLayout;
+  top_hbox->addLayout(left_vbox);
+  top_hbox->addLayout(right_vbox, 1);
+
+  QVBoxLayout* top_vbox = new QVBoxLayout;
+  top_vbox->addLayout(top_hbox);
+  // todo: some sort of separator (?)
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  setLayout(top_vbox);
+
+  _name_line_edit->setFocus(Qt::OtherFocusReason);
+
+  update_door_table();
+  update_level_table();
+
+  connect(
+    _door_table, &QTableWidget::cellChanged,
+    this, &LiftDialog::door_table_cell_changed);
+
+  update_lift_view();
+  adjustSize();
+}
+
+LiftDialog::~LiftDialog()
+{
+}
+
+void LiftDialog::ok_button_clicked()
+{
+  if (_name_line_edit->text().isEmpty())
+  {
+    QMessageBox::critical(this, "Error", "Lift name is empty");
+    return;
+  }
+
+  if (_lift.lowest_elevation > _lift.highest_elevation)
+  {
+    QMessageBox::critical(this, "Error", "Lowest floor above highest floor");
+    return;
+  }
+
+  _lift.name = _name_line_edit->text().toStdString();
+  _lift.reference_floor_name =
+    _reference_floor_combo_box->currentText().toStdString();
+  _lift.highest_floor = _highest_floor_combo_box->currentText().toStdString();
+  _lift.lowest_floor = _lowest_floor_combo_box->currentText().toStdString();
+  _lift.initial_floor_name =
+    _initial_floor_combo_box->currentText().toStdString();
+
+  _lift.x = _x_line_edit->text().toDouble();
+  _lift.y = _y_line_edit->text().toDouble();
+  _lift.yaw = _yaw_line_edit->text().toDouble();
+
+  _lift.width = _width_line_edit->text().toDouble();
+  _lift.depth = _depth_line_edit->text().toDouble();
+
+  if (_plugin_yes_radio_button->isChecked())
+    _lift.plugins = true;
+  else if (_plugin_no_radio_button->isChecked())
+    _lift.plugins = false;
+
+  // grab all the level-door checkbox matrix states and save them
+  for (int level_row = 0; level_row < _level_table->rowCount(); level_row++)
+  {
+    const std::string level_name =
+      _level_table->item(level_row, 0)->text().toStdString();
+    _lift.level_doors.erase(level_name);
+    for (int door_col = 1; door_col < _level_table->columnCount(); door_col++)
+    {
+      const std::string door_name =
+        _level_table->horizontalHeaderItem(door_col)->text().toStdString();
+      const QWidget* widget = _level_table->cellWidget(level_row, door_col);
+      const QCheckBox* checkbox = qobject_cast<const QCheckBox*>(widget);
+      if (checkbox)
+      {
+        const bool checked = checkbox->isChecked();
+        printf("level %s door %s: %d\n",
+          level_name.c_str(),
+          door_name.c_str(),
+          checked ? 1 : 0);
+        if (checked)
+          _lift.level_doors[level_name].push_back(door_name);
+      }
+      else
+      {
+        printf("level %s door %s: indeterminate state!\n",
+          level_name.c_str(),
+          door_name.c_str());
+      }
+    }
+  }
+  update_lift_view();
+  emit redraw();
+  accept();
+}
+
+void LiftDialog::update_lift_wps()
+{
+  const QPointF from_point = QPointF(_lift.x, _lift.y);
+  QPointF to_point;
+
+  bool found = false;
+  for (size_t level_idx = 0; level_idx < _level_names.size(); level_idx++)
+  {
+    const std::string level_name = _level_names[level_idx].toStdString();
+    // Vertices will only be generated on levels that the lift is serving (has
+    // a door opening on that level)
+    if (_lift.level_doors[level_name].size() != 0)
+    {
+      _building.transform_between_levels(
+        _lift.reference_floor_name,
+        from_point,
+        _building.levels[level_idx].name,
+        to_point);
+      found = false;
+
+      for (auto& v : _building.levels[level_idx].vertices)
+      {
+        auto it = v.params.find("lift_cabin");
+        if ((it != v.params.end()) && (it->second.value_string == _lift.name))
+        {
+          v.x = to_point.x();
+          v.y = to_point.y();
+          found = true;
+        }
+      }
+      if (!found)
+      {
+        _building.add_vertex(level_idx, to_point.x(), to_point.y());
+        _building.levels[level_idx].vertices.back().params["lift_cabin"] =
+          _lift.name;
+      }
+    }
+  }
+  emit redraw();
+}
+
+void LiftDialog::update_door_table()
+{
+  _door_table->setRowCount(1 + _lift.doors.size());
+  for (size_t i = 0; i < _lift.doors.size(); i++)
+  {
+    const LiftDoor& door = _lift.doors[i];  // save some typing
+    set_door_cell(i, 0, QString::fromStdString(door.name));
+
+    // set the numeric fields
+    set_door_cell(i, 2, QString::number(door.x));
+    set_door_cell(i, 3, QString::number(door.y));
+    set_door_cell(i, 4, QString::number(door.motion_axis_orientation));
+    _door_table->setCellWidget(i, 5, nullptr);
+    set_door_cell(i, 5, QString::number(door.width));
+
+    // create a drop-down list for the door type
+    QComboBox* type_box = new QComboBox;
+    type_box->addItem("<undefined>", QVariant(0));
+    type_box->addItem("Single sliding", QVariant(1));
+    type_box->addItem("Double sliding", QVariant(2));
+    type_box->addItem("Single telescoping", QVariant(3));
+    type_box->addItem("Double telescoping", QVariant(4));
+    type_box->setCurrentIndex(static_cast<int>(door.door_type));
+
+    _door_table->setCellWidget(i, 1, type_box);
+  }
+
+  // we'll use the last row for the "Add" button
+  const int last_row_idx = static_cast<int>(_lift.doors.size());
+  _door_table->setCellWidget(last_row_idx, 0, nullptr);
+  _door_table->setCellWidget(last_row_idx, 1, nullptr);
+  _door_table->setCellWidget(last_row_idx, 2, nullptr);
+  _door_table->setCellWidget(last_row_idx, 3, nullptr);
+  _door_table->setCellWidget(last_row_idx, 4, nullptr);
+  QPushButton* add_button = new QPushButton("Add...", this);
+  _door_table->setCellWidget(last_row_idx, 5, add_button);
+  connect(
+    add_button,
+    &QAbstractButton::clicked,
+    [this]()
+    {
+      LiftDoor door;
+      door.name = "name";
+      door.door_type = LiftDoor::DOUBLE_SLIDING;
+      _lift.doors.push_back(door);
+      update_door_table();
+      update_lift_view();
+    });
+}
+
+void LiftDialog::set_door_cell(
+  const int row,
+  const int col,
+  const QString& text)
+{
+  _door_table->setItem(row, col, new QTableWidgetItem(text));
+}
+
+void LiftDialog::update_level_table()
+{
+  _level_table->setColumnCount(1 + static_cast<int>(_lift.doors.size()));
+  _level_table->setHorizontalHeaderItem(0, new QTableWidgetItem("Level"));
+  for (size_t door_idx = 0; door_idx < _lift.doors.size(); door_idx++)
+  {
+    _level_table->setHorizontalHeaderItem(
+      door_idx + 1,
+      new QTableWidgetItem(
+        QString::fromStdString(_lift.doors[door_idx].name)));
+  }
+  //blockSignals(true);
+  _level_table->setRowCount(_level_names.size());
+  for (size_t level_idx = 0; level_idx < _level_names.size(); level_idx++)
+  {
+    const QString& level_name = _level_names[level_idx];
+    QTableWidgetItem* name_item = new QTableWidgetItem(level_name);
+    name_item->setFlags(name_item->flags() & ~Qt::ItemIsEditable);
+    _level_table->setItem(level_idx, 0, name_item);
+
+    for (size_t door_idx = 0; door_idx < _lift.doors.size(); door_idx++)
+    {
+      QCheckBox* checkbox = new QCheckBox;
+      checkbox->setStyleSheet("margin-left: 50%; margin-right: 50%");
+      if (_lift.level_door_opens(
+          level_name.toStdString(),
+          _lift.doors[door_idx].name,
+          _building.levels))
+        checkbox->setChecked(true);
+      _level_table->setCellWidget(level_idx, door_idx + 1, checkbox);
+    }
+  }
+  //blockSignals(false);
+}
+
+void LiftDialog::door_table_cell_changed(int row, int col)
+{
+  // printf("door_table_cell_changed(%d, %d)\n", row, col);
+  if (row >= static_cast<int>(_lift.doors.size()))
+  {
+    printf("invalid door row: %d\n", row);
+    return;  // let's not crash
+  }
+
+  // If a door name was changed, we need to update the options shown in all
+  // the level_table combo boxes
+  if (col == 0)  // name
+  {
+    _lift.doors[row].name = _door_table->item(row, col)->text().toStdString();
+    update_level_table();
+  }
+  else if (col == 1)
+  {
+    // todo: door type
+  }
+  else if (col == 2) // x
+    _lift.doors[row].x = _door_table->item(row, col)->text().toDouble();
+  else if (col == 3) // y
+    _lift.doors[row].y = _door_table->item(row, col)->text().toDouble();
+  else if (col == 4) // orientation
+    _lift.doors[row].motion_axis_orientation =
+      _door_table->item(row, col)->text().toDouble();
+  else if (col == 5) // width
+    _lift.doors[row].width = _door_table->item(row, col)->text().toDouble();
+
+  update_lift_view();
+  emit redraw();
+}
+
+void LiftDialog::update_lift_view()
+{
+  _lift_scene->clear();
+  _lift.draw(_lift_scene, 0.01, std::string(), _lift.lowest_elevation, false);
+}
diff --git a/traffic_editor/gui/lift_dialog.h b/traffic_editor/gui/lift_dialog.h
new file mode 100644
index 0000000..4ce5fee
--- /dev/null
+++ b/traffic_editor/gui/lift_dialog.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LIFT_DIALOG_H
+#define LIFT_DIALOG_H
+
+#include <vector>
+
+#include <QDialog>
+#include <QObject>
+#include <QRadioButton>
+
+#include "traffic_editor/lift.h"
+#include "traffic_editor/building.h"
+
+class QLineEdit;
+class QLabel;
+class QTableWidget;
+class QComboBox;
+
+
+class LiftDialog : public QDialog
+{
+  Q_OBJECT
+
+public:
+  LiftDialog(Lift& lift, Building& building);
+  ~LiftDialog();
+
+private:
+  Lift& _lift;
+  Building& _building;
+
+  std::vector<QString> _level_names;
+
+  QLineEdit* _name_line_edit;
+  QComboBox* _reference_floor_combo_box;
+  QComboBox* _highest_floor_combo_box;
+  QComboBox* _lowest_floor_combo_box;
+  QComboBox* _initial_floor_combo_box;
+  QLineEdit* _x_line_edit;
+  QLineEdit* _y_line_edit;
+  QLineEdit* _yaw_line_edit;
+  QLineEdit* _width_line_edit;
+  QLineEdit* _depth_line_edit;
+  QRadioButton* _plugin_yes_radio_button;
+  QRadioButton* _plugin_no_radio_button;
+
+  QTableWidget* _door_table;
+  QTableWidget* _level_table;
+
+  QGraphicsView* _lift_view;
+  QGraphicsScene* _lift_scene;
+
+  QPushButton* _ok_button, * _cancel_button;
+  QPushButton* _add_wp_button;
+
+  void update_door_table();
+  void set_door_cell(const int row, const int col, const QString& text);
+  void door_table_cell_changed(int row, int col);
+
+  void update_level_table();
+  void update_lift_view();
+
+  void update_lift_wps();
+
+private slots:
+  void ok_button_clicked();
+
+signals:
+  void redraw();
+};
+
+#endif
diff --git a/traffic_editor/gui/lift_door.cpp b/traffic_editor/gui/lift_door.cpp
new file mode 100644
index 0000000..590782c
--- /dev/null
+++ b/traffic_editor/gui/lift_door.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <cmath>
+
+#include "traffic_editor/lift_door.h"
+
+YAML::Node LiftDoor::to_yaml() const
+{
+  // This is in image space. I think it's safe to say nobody is clicking
+  // with more than 1/1000 precision inside a single pixel.
+
+  YAML::Node n;
+  n["x"] = std::round(x * 1000.0) / 1000.0;
+  n["y"] = std::round(y * 1000.0) / 1000.0;
+  n["width"] = std::round(width * 1000.0) / 1000.0;
+  n["door_type"] = static_cast<int>(door_type);
+  // let's give yaw another decimal place because, I don't know, reasons (?)
+  n["motion_axis_orientation"] =
+    std::round(motion_axis_orientation * 10000.0) / 10000.0;
+  return n;
+}
+
+void LiftDoor::from_yaml(const std::string& _name, const YAML::Node& data)
+{
+  if (!data.IsMap())
+    throw std::runtime_error("LiftDoor::from_yaml() expected a map");
+  x = data["x"].as<double>();
+  y = data["y"].as<double>();
+  width = data["width"].as<double>();
+  door_type = static_cast<DoorType>(data["door_type"].as<int>());
+  motion_axis_orientation = data["motion_axis_orientation"].as<double>();
+  name = _name;
+}
diff --git a/traffic_editor/gui/lift_table.cpp b/traffic_editor/gui/lift_table.cpp
new file mode 100644
index 0000000..c689e45
--- /dev/null
+++ b/traffic_editor/gui/lift_table.cpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "lift_dialog.h"
+#include "lift_table.h"
+#include <QtWidgets>
+
+LiftTable::LiftTable()
+: TableList()
+{
+  const QStringList labels = { "Name", "" };
+  setHorizontalHeaderLabels(labels);
+}
+
+LiftTable::~LiftTable()
+{
+}
+
+void LiftTable::update(Building& building)
+{
+  blockSignals(true);
+  setRowCount(1 + building.lifts.size());
+  for (size_t i = 0; i < building.lifts.size(); i++)
+  {
+    setItem(
+      i,
+      0,
+      new QTableWidgetItem(
+        QString::fromStdString(building.lifts[i].name)));
+
+    QPushButton* edit_button = new QPushButton("Edit...", this);
+    setCellWidget(i, 1, edit_button);
+
+    connect(
+      edit_button,
+      &QAbstractButton::clicked,
+      [this, &building, i]()
+      {
+        /*
+        LiftDialog lift_dialog(building.lifts[i], building);
+        lift_dialog.exec();
+        update(building);
+        emit redraw();
+        */
+        LiftDialog* dialog = new LiftDialog(building.lifts[i], building);
+        dialog->show();
+        dialog->raise();
+        dialog->activateWindow();
+        connect(
+          dialog,
+          &LiftDialog::redraw,
+          [this]() { emit redraw(); });
+      });
+  }
+
+  // we'll use the last row for the "Add" button
+  const int last_row_idx = static_cast<int>(building.lifts.size());
+  setCellWidget(last_row_idx, 0, nullptr);
+  setItem(
+    last_row_idx,
+    0,
+    new QTableWidgetItem(
+      QString::fromStdString("")));
+  QPushButton* add_button = new QPushButton("Add...", this);
+  setCellWidget(last_row_idx, 1, add_button);
+  connect(
+    add_button, &QAbstractButton::clicked,
+    [this, &building]()
+    {
+      Lift lift;
+      LiftDialog lift_dialog(lift, building);
+      if (lift_dialog.exec() == QDialog::Accepted)
+      {
+        building.lifts.push_back(lift);
+        update(building);
+        emit redraw();
+      }
+    });
+
+  blockSignals(false);
+}
diff --git a/traffic_editor/gui/lift_table.h b/traffic_editor/gui/lift_table.h
new file mode 100644
index 0000000..f682613
--- /dev/null
+++ b/traffic_editor/gui/lift_table.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LIFT_TABLE_H
+#define LIFT_TABLE_H
+
+#include <QTableWidget>
+
+#include "table_list.h"
+#include "traffic_editor/building.h"
+
+class LiftTable : public TableList
+{
+public:
+  LiftTable();
+  ~LiftTable();
+
+  void update(Building& building);
+};
+
+#endif
diff --git a/traffic_editor/gui/main.cpp b/traffic_editor/gui/main.cpp
new file mode 100644
index 0000000..91b3b83
--- /dev/null
+++ b/traffic_editor/gui/main.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "editor.h"
+#include "preferences_keys.h"
+#include <QtWidgets>
+#include <string>
+#include <QSettings>
+
+int main(int argc, char* argv[])
+{
+  QApplication app(argc, argv);
+  app.setOrganizationName("open-robotics");
+  app.setOrganizationDomain("openrobotics.org");
+  app.setApplicationName("traffic-editor");
+
+  QCommandLineParser parser;
+  parser.addHelpOption();
+  parser.addPositionalArgument("[project]", "Project to open");
+  parser.process(QCoreApplication::arguments());
+
+  Editor editor;
+  QSettings settings;
+
+  const bool load_previous = settings.value(
+    preferences_keys::open_previous_project, QVariant(true)).toBool();
+
+  if (load_previous && parser.positionalArguments().isEmpty())
+    editor.load_previous_project();
+
+  if (parser.positionalArguments().length() >= 1)
+    editor.load_project(parser.positionalArguments().at(0));
+
+  editor.show();
+
+  editor.restore_previous_viewport();
+
+  return app.exec();
+}
diff --git a/traffic_editor/gui/map_view.cpp b/traffic_editor/gui/map_view.cpp
new file mode 100644
index 0000000..b1d5260
--- /dev/null
+++ b/traffic_editor/gui/map_view.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "map_view.h"
+#include <QScrollBar>
+
+MapView::MapView(QWidget* parent)
+: QGraphicsView(parent),
+  is_panning(false),
+  pan_start_x(0),
+  pan_start_y(0)
+{
+  setMouseTracking(true);
+  viewport()->setMouseTracking(true);
+  setTransformationAnchor(QGraphicsView::NoAnchor);
+}
+
+void MapView::wheelEvent(QWheelEvent* e)
+{
+  // calculate the map position before we scale things
+  const QPointF p_start = mapToScene(e->pos());
+
+  // scale things
+  if (e->delta() > 0)
+    scale(1.1, 1.1);
+  else
+    scale(0.9, 0.9);
+
+  // calculate the mouse map position now that we've scaled
+  const QPointF p_end = mapToScene(e->pos());
+
+  // translate the map back so hopefully the mouse stays in the same spot
+  const QPointF diff = p_end - p_start;
+  translate(diff.x(), diff.y());
+}
+
+void MapView::mousePressEvent(QMouseEvent* e)
+{
+  if (e->button() == Qt::MiddleButton)
+  {
+    is_panning = true;
+    pan_start_x = e->x();
+    pan_start_y = e->y();
+    // setCursor(Qt::ClosedHandCursor);
+    e->accept();
+    return;
+  }
+  e->ignore();
+}
+
+void MapView::mouseReleaseEvent(QMouseEvent* e)
+{
+  if (e->button() == Qt::MiddleButton)
+  {
+    is_panning = false;
+    e->accept();
+    return;
+  }
+  e->ignore();
+}
+
+void MapView::mouseMoveEvent(QMouseEvent* e)
+{
+  if (is_panning)
+  {
+    const int dx = e->x() - pan_start_x;
+    const int dy = e->y() - pan_start_y;
+    horizontalScrollBar()->setValue(horizontalScrollBar()->value() - dx);
+    verticalScrollBar()->setValue(verticalScrollBar()->value() - dy);
+    pan_start_x = e->x();
+    pan_start_y = e->y();
+    e->accept();
+    return;
+  }
+  e->ignore();
+}
+
+void MapView::zoom_fit(const Building& building, int level_index)
+{
+  if (building.levels.empty())
+    return;
+  const BuildingLevel& level = building.levels[level_index];
+  const int w = level.drawing_width;
+  const int h = level.drawing_height;
+  const double cx = w / 2;
+  const double cy = h / 2;
+  // todo: this doesn't seem to work. not sure how to use this function.
+  ensureVisible(cx, cy, w, h);
+  //resetTransform();
+  //fitInView(cx, cy, w, h, Qt::KeepAspectRatio);
+  //centerOn(cx, cy);
+}
diff --git a/traffic_editor/gui/map_view.h b/traffic_editor/gui/map_view.h
new file mode 100644
index 0000000..867b100
--- /dev/null
+++ b/traffic_editor/gui/map_view.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef MAP_VIEW_H
+#define MAP_VIEW_H
+
+#include <QGraphicsView>
+#include <QWheelEvent>
+
+#include "traffic_editor/building.h"
+
+
+class MapView : public QGraphicsView
+{
+  Q_OBJECT
+
+public:
+  MapView(QWidget* parent = nullptr);
+  void zoom_fit(const Building& building, int level_index);
+
+protected:
+  void wheelEvent(QWheelEvent* event);
+  void mouseMoveEvent(QMouseEvent* e);
+  void mousePressEvent(QMouseEvent* e);
+  void mouseReleaseEvent(QMouseEvent* e);
+
+  bool is_panning;
+  int pan_start_x, pan_start_y;
+};
+
+#endif
diff --git a/traffic_editor/gui/model.cpp b/traffic_editor/gui/model.cpp
new file mode 100644
index 0000000..faeff67
--- /dev/null
+++ b/traffic_editor/gui/model.cpp
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <cmath>
+
+#include <QtGlobal>
+#include <QGraphicsPixmapItem>
+#include <QGraphicsColorizeEffect>
+
+#include "traffic_editor/model.h"
+using std::string;
+
+// String comparison helper
+bool iequals(const string& a, const string& b)
+{
+  return std::equal(a.begin(), a.end(),
+      b.begin(), b.end(),
+      [](char _a, char _b)
+      {
+        return tolower(_a) == tolower(_b);
+      });
+}
+
+Model::Model()
+{
+  uuid = QUuid::createUuid();
+}
+
+void Model::from_yaml(const YAML::Node& data, const string& level_name)
+{
+  if (!data.IsMap())
+    throw std::runtime_error("Model::from_yaml() expected a map");
+  state.x = data["x"].as<double>();
+  state.y = data["y"].as<double>();
+  if (data["z"])
+  {
+    state.z = data["z"].as<double>();
+  }
+  else
+  {
+    qWarning(
+      "parsed a deprecated .building.yaml, models should have z defined.");
+    state.z = 0.0;
+  }
+  state.yaw = data["yaw"].as<double>();
+
+  model_name = data["model_name"].as<string>();
+  instance_name = data["name"].as<string>();
+
+  state.level_name = level_name;
+  starting_level = level_name;
+
+  if (data["static"])
+    is_static = data["static"].as<bool>();
+  else
+    is_static = true;
+}
+
+YAML::Node Model::to_yaml() const
+{
+  // This is in image space. I think it's safe to say nobody is clicking
+  // with more than 1/1000 precision inside a single pixel.
+
+  YAML::Node n;
+  n.SetStyle(YAML::EmitterStyle::Flow);
+  n["x"] = std::round(state.x * 1000.0) / 1000.0;
+  n["y"] = std::round(state.y * 1000.0) / 1000.0;
+  n["z"] = std::round(state.z * 1000.0) / 1000.0;
+  // let's give yaw another decimal place because, I don't know, reasons (?)
+  n["yaw"] = std::round(state.yaw * 10000.0) / 10000.0;
+  n["name"] = instance_name;
+  n["model_name"] = model_name;
+  n["static"] = is_static;
+  return n;
+}
+
+void Model::set_param(const std::string& name, const std::string& value)
+{
+  if (name == "elevation")
+  {
+    try
+    {
+      state.z = std::stod(value);
+    }
+    catch (const std::exception& e)
+    {
+      qWarning("[elevation] field can only be a double/float.");
+    }
+  }
+  else if (name == "static")
+  {
+    // not sure if there is a super elite way to parse 'true' in STL
+    string lowercase(value);
+    std::transform(
+      lowercase.begin(),
+      lowercase.end(),
+      lowercase.begin(),
+      [](char c) { return std::tolower(c); });
+
+    if (value == "true")
+      is_static = true;
+    else
+      is_static = false;
+  }
+  else if (name == "name")
+  {
+    instance_name = value;
+  }
+  else
+  {
+    printf("WARNING: setting unknown model parameter: [%s]\n", name.c_str());
+  }
+}
+
+void Model::draw(
+  QGraphicsScene* scene,
+  std::vector<EditorModel>& editor_models,
+  const double drawing_meters_per_pixel)
+{
+  if (pixmap_item == nullptr)
+  {
+    // find the pixmap we need for this model
+    QPixmap pixmap;
+    double model_meters_per_pixel = 1.0;  // will get overridden
+    for (auto& editor_model : editor_models)
+    {
+      if (editor_model.name == model_name)
+      {
+        pixmap = editor_model.get_pixmap();
+        model_meters_per_pixel = editor_model.meters_per_pixel;
+        break;
+      }
+    }
+    if (pixmap.isNull())
+    {
+      // BACKWARDS COMPATIBILITY PATCH: Try again, but...
+      // Use the first matching namespaced thumbnail for a
+      // specified non-namespaced model, with warnings.
+
+      // (Also modifies the model name inplace!)
+      for (auto& editor_model : editor_models)
+      {
+        // Get ending token
+        std::string ending_token;
+        size_t delimiter_index = editor_model.name.find("/");
+
+        if (delimiter_index != std::string::npos)
+        {
+          ending_token = editor_model.name
+            .substr(delimiter_index + 1, editor_model.name.length());
+        }
+        else
+        {
+          ending_token = editor_model.name;
+        }
+
+        // Check if namespaced model_name is the name we are looking for
+        // Match mismatched cases
+        if (iequals(ending_token, model_name))
+        {
+          // Skip rematches from previous for loop
+          if (model_name == editor_model.name)
+            continue;
+
+          pixmap = editor_model.get_pixmap();
+          model_meters_per_pixel = editor_model.meters_per_pixel;
+
+          printf("\n[WARNING] Thumbnail %1$s not found, "
+            "substituting %2$s instead!\n"
+            "(%1$s will be saved as %2$s)\n\n",
+            model_name.c_str(), editor_model.name.c_str());
+
+          // And reassign it!
+          model_name = editor_model.name;
+          break;
+        }
+      }
+
+      // Check again for pixmap find status
+      if (pixmap.isNull())
+      {
+        if (!error_printed)
+        {
+          printf("[ERROR] No thumbnail found: %s\n", model_name.c_str());
+          error_printed = true;
+        }
+        return;  // couldn't load the pixmap; ignore it.
+      }
+    }
+
+    pixmap_item = scene->addPixmap(pixmap);
+    pixmap_item->setOffset(-pixmap.width()/2, -pixmap.height()/2);
+    pixmap_item->setScale(model_meters_per_pixel / drawing_meters_per_pixel);
+    pixmap_item->setZValue(100.0);  // just anything taller than 0
+  }
+
+  pixmap_item->setPos(state.x, state.y);
+  pixmap_item->setRotation((-state.yaw + M_PI / 2.0) * 180.0 / M_PI);
+
+  // make the model "glow" if it is selected
+  if (selected)
+  {
+    QGraphicsColorizeEffect* colorize = new QGraphicsColorizeEffect;
+    colorize->setColor(QColor::fromRgbF(1.0, 0.2, 0.0, 1.0));
+    colorize->setStrength(1.0);
+    pixmap_item->setGraphicsEffect(colorize);
+  }
+}
+
+void Model::clear_scene()
+{
+  pixmap_item = nullptr;
+}
diff --git a/traffic_editor/gui/model_dialog.cpp b/traffic_editor/gui/model_dialog.cpp
new file mode 100644
index 0000000..418a2ff
--- /dev/null
+++ b/traffic_editor/gui/model_dialog.cpp
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "model_dialog.h"
+#include <QtWidgets>
+using std::vector;
+
+
+ModelDialog::ModelDialog(
+  QWidget* parent,
+  Model& model,
+  const vector<EditorModel>& editor_models)
+: QDialog(parent),
+  _model(model),
+  _editor_models(editor_models)
+{
+  setWindowTitle("Model Properties");
+  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
+  _ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  bottom_buttons_layout->addWidget(_ok_button);
+  connect(
+    _ok_button, &QAbstractButton::clicked,
+    this, &ModelDialog::ok_button_clicked);
+
+  _cancel_button = new QPushButton("Cancel", this);
+  bottom_buttons_layout->addWidget(_cancel_button);
+  connect(
+    _cancel_button, &QAbstractButton::clicked,
+    this, &QDialog::reject);
+
+  QVBoxLayout* model_name_vbox_layout = new QVBoxLayout;
+  model_name_vbox_layout->addWidget(new QLabel("Name:"));
+
+  _model_name_line_edit =
+    new QLineEdit(QString::fromStdString(_model.model_name), this);
+  model_name_vbox_layout->addWidget(_model_name_line_edit);
+  connect(
+    _model_name_line_edit,
+    &QLineEdit::textEdited,
+    this,
+    &ModelDialog::model_name_line_edited);
+
+  _model_name_list_widget = new QListWidget;
+  model_name_vbox_layout->addWidget(_model_name_list_widget);
+  connect(
+    _model_name_list_widget,
+    &QListWidget::currentRowChanged,
+    this,
+    &ModelDialog::model_name_list_widget_changed);
+
+  _model_preview_label = new QLabel;
+  _model_preview_label->setMinimumSize(400, 400);
+  _model_preview_label->setSizePolicy(
+    QSizePolicy::MinimumExpanding,
+    QSizePolicy::Expanding);
+
+  QHBoxLayout* top_hbox_layout = new QHBoxLayout;
+  top_hbox_layout->addLayout(model_name_vbox_layout);
+  top_hbox_layout->addWidget(_model_preview_label);
+
+  QVBoxLayout* vbox_layout = new QVBoxLayout;
+  vbox_layout->addLayout(top_hbox_layout);
+  // todo: some sort of separator (?)
+  vbox_layout->addLayout(bottom_buttons_layout);
+
+  setLayout(vbox_layout);
+
+  for (const auto& em : _editor_models)
+    _model_name_list_widget->addItem(QString::fromStdString(em.name));
+
+  if (!_editor_models.empty())
+    _model_name_list_widget->setCurrentItem(
+      _model_name_list_widget->item(0));
+
+  _model_name_line_edit->setFocus(Qt::OtherFocusReason);
+}
+
+ModelDialog::~ModelDialog()
+{
+}
+
+void ModelDialog::ok_button_clicked()
+{
+  if (_model.model_name.empty())  // _model_name_line_edit->text().isEmpty())
+  {
+    QMessageBox::critical(this, "Error", "Model name missing");
+    return;
+  }
+
+  accept();
+}
+
+void ModelDialog::model_name_line_edited(const QString& text)
+{
+  // todo: render on parent if file exists?
+  if (_model_name_list_widget->count() == 0)
+  {
+    qWarning("model name list widget is empty :(");
+    return;  // nothing to do; there is no available model list
+  }
+
+  // see if we can auto-complete with anything in the list box
+  // scroll the list box to the first thing
+  const std::string user_text_lower(text.toLower().toStdString());
+  // could become super fancy but for now let's just do linear search...
+  size_t closest_idx = 0;
+  for (size_t i = 0; i < _editor_models.size(); i++)
+  {
+    if (user_text_lower < _editor_models[i].name_lowercase)
+    {
+      closest_idx = i;
+      break;
+    }
+  }
+  QListWidgetItem* item = _model_name_list_widget->item(closest_idx);
+  _model_name_list_widget->setCurrentItem(item);
+  _model_name_list_widget->scrollToItem(
+    item,
+    QAbstractItemView::PositionAtTop);
+}
+
+void ModelDialog::model_name_list_widget_changed(int row)
+{
+  _model.model_name = _editor_models[row].name;
+  const QPixmap& model_pixmap = _editor_models[row].get_pixmap();
+  if (model_pixmap.isNull())
+    return;// we don't have a pixmap to draw :(
+  // scale the pixmap so it fits within the currently allotted space
+  const int w = _model_preview_label->width();
+  const int h = _model_preview_label->height();
+  _model_preview_label->setPixmap(
+    model_pixmap.scaled(w, h, Qt::KeepAspectRatio));
+}
diff --git a/traffic_editor/gui/model_dialog.h b/traffic_editor/gui/model_dialog.h
new file mode 100644
index 0000000..436d95b
--- /dev/null
+++ b/traffic_editor/gui/model_dialog.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef MODEL_DIALOG_H
+#define MODEL_DIALOG_H
+
+#include <QDialog>
+#include <QObject>
+#include "traffic_editor/model.h"
+#include "traffic_editor/editor_model.h"
+#include <vector>
+class QLineEdit;
+class QListWidget;
+class QLabel;
+
+
+class ModelDialog : public QDialog
+{
+  Q_OBJECT
+
+public:
+  ModelDialog(
+    QWidget* parent,
+    Model& model,
+    const std::vector<EditorModel>& editor_models);
+  ~ModelDialog();
+
+private:
+  Model& _model;
+  std::vector<EditorModel> _editor_models;
+
+  QLineEdit* _model_name_line_edit;
+  QListWidget* _model_name_list_widget;
+  QLabel* _model_preview_label;
+
+  QPushButton* _ok_button, * _cancel_button;
+
+private slots:
+  void ok_button_clicked();
+  void model_name_line_edited(const QString& text);
+  void model_name_list_widget_changed(int row);
+};
+
+#endif
diff --git a/traffic_editor/gui/multi_select_combo_box.cpp b/traffic_editor/gui/multi_select_combo_box.cpp
new file mode 100644
index 0000000..b15cd74
--- /dev/null
+++ b/traffic_editor/gui/multi_select_combo_box.cpp
@@ -0,0 +1,93 @@
+#include <multi_select_combo_box.h>
+
+#include <iostream>
+
+void MultiSelectComboBox::build_list()
+{
+  pListWidget = new QListWidget(this);
+  pLineEdit = new QLineEdit(this);
+  pLineEdit->setReadOnly(true);
+
+  connect(
+    pLineEdit,
+    &QLineEdit::textChanged,
+    [this](const QString& text)
+    {
+      text_changed(text);
+    }
+  );
+
+  for (size_t i = 0; i < selections.size(); i++)
+  {
+    QListWidgetItem* pListItem = new QListWidgetItem(pListWidget);
+    pListWidget->addItem(pListItem);
+    QCheckBox* pCheckBox =
+      new QCheckBox(QString::fromStdString(selections[i].first));
+    pListWidget->setItemWidget(pListItem, pCheckBox);
+
+    connect(
+      pCheckBox,
+      &QCheckBox::stateChanged,
+      [this](int state)
+      {
+        box_checked(state);
+      }
+    );
+  }
+
+  this->setModel(pListWidget->model());
+  this->setView(pListWidget);
+  this->setLineEdit(pLineEdit);
+}
+
+
+void MultiSelectComboBox::box_checked(int state)
+{
+  blockSignals(true);
+  size_t list_count = pListWidget->count();
+  selectedText.clear();
+
+  for (size_t i = 0; i < list_count; i++)
+  {
+    QListWidgetItem* pItem = pListWidget->item(i);
+    QCheckBox* pCheckBox = static_cast<QCheckBox*>(pListWidget->itemWidget(
+        pItem));
+    if (pCheckBox->isChecked())
+    {
+      QString checkbox_text = pCheckBox->text();
+      selectedText.append(checkbox_text).append(";");
+      selections[i].second = true;
+    }
+    else
+    {
+      selections[i].second = false;
+    }
+  }
+
+  if (selectedText.isEmpty())
+  {
+    pLineEdit->clear();
+    return;
+  }
+  pLineEdit->setText(selectedText);
+  pLineEdit->setToolTip(selectedText);
+  blockSignals(false);
+}
+
+void MultiSelectComboBox::text_changed(const QString& text)
+{
+  pLineEdit->setText(text);
+}
+
+std::vector<std::string> MultiSelectComboBox::getCheckResult()
+{
+  std::vector<std::string> result;
+  for (auto item : selections)
+  {
+    if (item.second)
+    {
+      result.emplace_back(item.first);
+    }
+  }
+  return result;
+}
\ No newline at end of file
diff --git a/traffic_editor/gui/multi_select_combo_box.h b/traffic_editor/gui/multi_select_combo_box.h
new file mode 100644
index 0000000..054d1b1
--- /dev/null
+++ b/traffic_editor/gui/multi_select_combo_box.h
@@ -0,0 +1,79 @@
+#ifndef MULTI_SELECT_COMBO_BOX__H
+#define MULTI_SELECT_COMBO_BOX__H
+
+#include <QComboBox>
+#include <QtWidgets>
+
+#include <string>
+#include <sstream>
+#include <vector>
+#include <set>
+
+class MultiSelectComboBox : public QComboBox
+{
+public:
+  template<typename ITEM_TYPE>
+  MultiSelectComboBox(const std::vector<ITEM_TYPE>& selection_list)
+  {
+    selections.clear();
+    for (auto item : selection_list)
+    {
+      selections.emplace_back(type_to_string(item), false);
+    }
+    build_list();
+  }
+
+  ~MultiSelectComboBox() {}
+
+  template<typename ITEM_TYPE>
+  void showCheckedItem(const std::set<ITEM_TYPE>& checked_list)
+  {
+    std::set<std::string> checked_item;
+    for (auto item : checked_list)
+    {
+      checked_item.insert(type_to_string(item) );
+    }
+
+    auto list_count = pListWidget->count();
+    for (auto i = 0; i < list_count; i++)
+    {
+      QListWidgetItem* pItem = pListWidget->item(i);
+      QCheckBox* pCheckBox =
+        static_cast<QCheckBox*>(pListWidget->itemWidget(pItem));
+      auto checkbox_text = pCheckBox->text();
+      if (checked_item.find(checkbox_text.toStdString() ) ==
+        checked_item.end() )
+      {
+        // original goal area in project might be deleted, so we won't update the old version
+        continue;
+      }
+      pCheckBox->setCheckState(Qt::Checked);
+    }
+  }
+
+  template<typename ITEM_TYPE>
+  std::string type_to_string(ITEM_TYPE& input)
+  {
+    std::stringstream s;
+    std::string temp;
+    s << input;
+    s >> temp;
+    return temp;
+  }
+
+  std::vector<std::string> getCheckResult();
+
+private:
+  void build_list();
+  void box_checked(int state);
+  void text_changed(const QString& text);
+
+  std::vector<std::pair<std::string, bool>> selections;
+  QString selectedText;
+
+  QListWidget* pListWidget;
+  QLineEdit* pLineEdit;
+
+};
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/gui/param.cpp b/traffic_editor/gui/param.cpp
new file mode 100644
index 0000000..b4340fd
--- /dev/null
+++ b/traffic_editor/gui/param.cpp
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "traffic_editor/param.h"
+using std::string;
+
+
+Param::Param()
+: type(UNDEFINED), value_int(0), value_double(0.0), value_bool(false)
+{
+}
+
+Param::Param(const Type& t)
+: type(t), value_int(0), value_double(0.0), value_bool(false)
+{
+}
+
+Param::Param(const std::string& s)
+: type(STRING),
+  value_int(0),
+  value_double(0.0),
+  value_string(s),
+  value_bool(false)
+{
+}
+
+Param::Param(const int& i)
+: type(INT), value_int(i), value_double(0.0), value_bool(false)
+{
+}
+
+Param::Param(const double& d)
+: type(DOUBLE), value_int(0), value_double(d), value_bool(false)
+{
+}
+
+Param::Param(const bool& b)
+: type(BOOL), value_int(0), value_double(0.0), value_bool(b)
+{
+}
+
+Param::~Param()
+{
+}
+
+void Param::from_yaml(const YAML::Node& data)
+{
+  if (!data.IsSequence())
+    throw std::runtime_error("Param::from_yaml expected a YAML sequence");
+  type = static_cast<Type>(data[0].as<int>());
+  if (type == STRING)
+    value_string = data[1].as<string>();
+  else if (type == INT)
+    value_int = data[1].as<int>();
+  else if (type == DOUBLE)
+    value_double = data[1].as<double>();
+  else if (type == BOOL)
+    value_bool = data[1].as<bool>();
+  else
+    throw std::runtime_error("Param::from_yaml found an unknown type");
+}
+
+YAML::Node Param::to_yaml() const
+{
+  if (type == UNDEFINED)
+    return YAML::Node();
+
+  YAML::Node y;
+  y.push_back(static_cast<int>(type));
+  if (type == STRING)
+    y.push_back(value_string);
+  else if (type == INT)
+    y.push_back(value_int);
+  else if (type == DOUBLE)
+    y.push_back(value_double);
+  else if (type == BOOL)
+    y.push_back(value_bool);
+  else
+    throw std::runtime_error("Param::to_yaml found an unknown type");
+  return y;
+}
+
+void Param::set(const std::string& value)
+{
+  if (type == INT)
+    value_int = stoi(value);
+  else if (type == DOUBLE)
+    value_double = stod(value);
+  else if (type == STRING)
+    value_string = value;
+  else if (type == BOOL)
+    value_bool = (value == "true") || (value == "True");
+  else
+    throw std::runtime_error("Param::set() found an unknown type");
+}
+
+QString Param::to_qstring() const
+{
+  if (type == DOUBLE)
+    return QString::number(value_double);
+  else if (type == BOOL)
+    return value_bool ? QString("true") : QString("false");
+  else if (type == STRING)
+    return QString::fromStdString(value_string);
+  else if (type == INT)
+    return QString::number(value_int);
+  else
+    return QString("unknown type!");
+}
diff --git a/traffic_editor/gui/polygon.cpp b/traffic_editor/gui/polygon.cpp
new file mode 100644
index 0000000..d545777
--- /dev/null
+++ b/traffic_editor/gui/polygon.cpp
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "traffic_editor/polygon.h"
+using std::string;
+using std::vector;
+
+
+Polygon::Polygon()
+{
+  create_required_parameters();
+}
+
+Polygon::~Polygon()
+{
+}
+
+void Polygon::from_yaml(const YAML::Node& data, const Type polygon_type)
+{
+  if (!data.IsMap())
+    throw std::runtime_error("Polygon::from_yaml() expected a map");
+  type = polygon_type;
+  for (YAML::const_iterator it = data["vertices"].begin();
+    it != data["vertices"].end(); ++it)
+  {
+    vertices.push_back(it->as<int>());
+  }
+
+  // load the parameters
+  if (data["parameters"])
+  {
+    for (YAML::const_iterator it = data["parameters"].begin();
+      it != data["parameters"].end();
+      ++it)
+    {
+      Param p;
+      p.from_yaml(it->second);
+      params[it->first.as<string>()] = p;
+    }
+  }
+
+  create_required_parameters();
+}
+
+YAML::Node Polygon::to_yaml() const
+{
+  YAML::Node y;
+  for (const auto& vertex_idx : vertices)
+    y["vertices"].push_back(vertex_idx);
+  y["vertices"].SetStyle(YAML::EmitterStyle::Flow);
+  y["parameters"] = YAML::Node(YAML::NodeType::Map);
+  for (const auto& param : params)
+    y["parameters"][param.first] = param.second.to_yaml();
+  y["parameters"].SetStyle(YAML::EmitterStyle::Flow);
+  return y;
+}
+
+void Polygon::remove_vertex(const int vertex_idx)
+{
+  // find first occurrence of this vertex_idx
+  int vertex_occurrence_idx = -1;
+  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
+  {
+    if (vertices[i] == vertex_idx)
+    {
+      vertex_occurrence_idx = i;
+      break;
+    }
+  }
+  if (vertex_occurrence_idx < 0)
+  {
+    printf("never found vertex %d\n", vertex_idx);
+    return;  // never found it. so sad.
+  }
+  printf("found vertex %d at polygon vertices idx %d\n",
+    vertex_idx,
+    vertex_occurrence_idx);
+
+  vertices.erase(vertices.begin() + vertex_occurrence_idx);
+
+  // not sure what's going on here, but it doesn't work :(
+  //vector<int> &v = vertices;  // save typing
+  //v.erase(std::remove(v.begin(), v.end(), vertex_idx), v.end());
+}
+
+void Polygon::set_param(const std::string& name, const std::string& value)
+{
+  auto it = params.find(name);
+  if (it == params.end())
+  {
+    printf("tried to set unknown parameter [%s]\n", name.c_str());
+    return;  // unknown parameter
+  }
+  it->second.set(value);
+}
+
+void Polygon::create_required_parameters()
+{
+  // create required parameters if they don't exist yet on this edge
+  if (type == FLOOR)
+  {
+    create_param_if_needed(
+      "texture_name",
+      Param::STRING,
+      std::string("blue_linoleum"));
+    create_param_if_needed("texture_scale", Param::DOUBLE, 1.0);
+    create_param_if_needed("texture_rotation", Param::DOUBLE, 0.0);
+  }
+}
+
+template<typename T>
+void Polygon::create_param_if_needed(
+  const std::string& name,
+  const Param::Type& param_type,
+  const T& param_value)
+{
+  auto it = params.find(name);
+  if (it == params.end() || it->second.type != param_type)
+    params[name] = param_value;
+}
diff --git a/traffic_editor/gui/preferences_dialog.cpp b/traffic_editor/gui/preferences_dialog.cpp
new file mode 100644
index 0000000..e489b3e
--- /dev/null
+++ b/traffic_editor/gui/preferences_dialog.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "preferences_dialog.h"
+#include "preferences_keys.h"
+#include <QtWidgets>
+
+
+PreferencesDialog::PreferencesDialog(QWidget* parent)
+: QDialog(parent)
+{
+  setWindowTitle("Preferences");
+
+  QSettings settings;
+
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  cancel_button = new QPushButton("Cancel", this);
+
+  QHBoxLayout* thumbnail_path_layout = new QHBoxLayout;
+  thumbnail_path_line_edit = new QLineEdit(
+    settings.value(preferences_keys::thumbnail_path).toString(), this);
+  thumbnail_path_button = new QPushButton("Find...", this);
+  thumbnail_path_layout->addWidget(new QLabel("thumbnail path:"));
+  thumbnail_path_layout->addWidget(thumbnail_path_line_edit);
+  thumbnail_path_layout->addWidget(thumbnail_path_button);
+  connect(
+    thumbnail_path_button, &QAbstractButton::clicked,
+    this, &PreferencesDialog::thumbnail_path_button_clicked);
+
+  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
+  bottom_buttons_layout->addWidget(cancel_button);
+  bottom_buttons_layout->addWidget(ok_button);
+  connect(
+    ok_button, &QAbstractButton::clicked,
+    this, &PreferencesDialog::ok_button_clicked);
+  connect(
+    cancel_button, &QAbstractButton::clicked,
+    this, &QDialog::reject);
+
+  open_previous_project_checkbox = new QCheckBox(
+    "Open previous project at startup", this);
+  open_previous_project_checkbox->setChecked(
+    settings.value(preferences_keys::open_previous_project).toBool());
+
+  QVBoxLayout* vbox_layout = new QVBoxLayout;
+  vbox_layout->addWidget(open_previous_project_checkbox);
+  vbox_layout->addLayout(thumbnail_path_layout);
+  // todo: some sort of separator (?)
+  vbox_layout->addLayout(bottom_buttons_layout);
+
+  setLayout(vbox_layout);
+}
+
+PreferencesDialog::~PreferencesDialog()
+{
+}
+
+void PreferencesDialog::thumbnail_path_button_clicked()
+{
+  QFileDialog file_dialog(this, "Find Thumbnail Path");
+  file_dialog.setFileMode(QFileDialog::Directory);
+  file_dialog.setOption(QFileDialog::ShowDirsOnly);
+  if (file_dialog.exec() != QDialog::Accepted)
+    return;// user clicked 'cancel'
+
+  const QString path = file_dialog.selectedFiles().first();
+  if (!QFileInfo(path).exists())
+  {
+    QMessageBox::critical(
+      this,
+      "path does not exist",
+      "path does not exist");
+    return;
+  }
+  thumbnail_path_line_edit->setText(path);
+}
+
+void PreferencesDialog::ok_button_clicked()
+{
+  if (!thumbnail_path_line_edit->text().isEmpty())
+  {
+    // make sure the path exists
+    if (!QFileInfo(thumbnail_path_line_edit->text()).exists())
+    {
+      QMessageBox::critical(
+        this,
+        "Thumbnail path must exist",
+        "Thumbnail path must exist");
+      return;
+    }
+  }
+
+  QSettings settings;
+
+  settings.setValue(
+    preferences_keys::thumbnail_path,
+    thumbnail_path_line_edit->text());
+
+  settings.setValue(
+    preferences_keys::open_previous_project,
+    open_previous_project_checkbox->isChecked());
+
+  accept();
+}
diff --git a/traffic_editor/gui/preferences_dialog.h b/traffic_editor/gui/preferences_dialog.h
new file mode 100644
index 0000000..c52e8d2
--- /dev/null
+++ b/traffic_editor/gui/preferences_dialog.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef PREFERENCES_DIALOG_H
+#define PREFERENCES_DIALOG_H
+
+#include <QDialog>
+class QLineEdit;
+class QCheckBox;
+
+
+class PreferencesDialog : public QDialog
+{
+public:
+  PreferencesDialog(QWidget* parent);
+  ~PreferencesDialog();
+
+private:
+  QLineEdit* thumbnail_path_line_edit;
+  QPushButton* thumbnail_path_button;
+  QCheckBox* open_previous_project_checkbox;
+  QPushButton* ok_button, * cancel_button;
+
+private slots:
+  void thumbnail_path_button_clicked();
+  void ok_button_clicked();
+};
+
+#endif
diff --git a/traffic_editor/gui/preferences_keys.cpp b/traffic_editor/gui/preferences_keys.cpp
new file mode 100644
index 0000000..0e69b5c
--- /dev/null
+++ b/traffic_editor/gui/preferences_keys.cpp
@@ -0,0 +1,20 @@
+#include "preferences_keys.h"
+
+const QString preferences_keys::thumbnail_path(
+  "editor/thumbnail_path");
+
+const QString preferences_keys::open_previous_project(
+  "editor/open_previous_project");
+
+const QString preferences_keys::previous_project_path(
+  "editor/previous_project_path");
+
+const QString preferences_keys::window_width("editor/window_width");
+const QString preferences_keys::window_height("editor/window_height");
+const QString preferences_keys::window_left("editor/window_left");
+const QString preferences_keys::window_top("editor/window_top");
+
+const QString preferences_keys::viewport_center_x("editor/viewport_center_x");
+const QString preferences_keys::viewport_center_y("editor/viewport_center_y");
+const QString preferences_keys::viewport_scale("editor/viewport_scale");
+const QString preferences_keys::level_name("editor/level_name");
diff --git a/traffic_editor/gui/preferences_keys.h b/traffic_editor/gui/preferences_keys.h
new file mode 100644
index 0000000..66fe640
--- /dev/null
+++ b/traffic_editor/gui/preferences_keys.h
@@ -0,0 +1,21 @@
+#ifndef PREFERENCES_KEYS_H
+#define PREFERENCES_KEYS_H
+
+#include <QString>
+
+namespace preferences_keys {
+
+extern const QString thumbnail_path;
+extern const QString open_previous_project;
+extern const QString previous_project_path;
+extern const QString window_width;
+extern const QString window_height;
+extern const QString window_left;
+extern const QString window_top;
+extern const QString viewport_center_x;
+extern const QString viewport_center_y;
+extern const QString viewport_scale;
+extern const QString level_name;
+}
+
+#endif
diff --git a/traffic_editor/gui/project.cpp b/traffic_editor/gui/project.cpp
new file mode 100644
index 0000000..11ef959
--- /dev/null
+++ b/traffic_editor/gui/project.cpp
@@ -0,0 +1,746 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <cmath>
+#include <fstream>
+
+#include "project.h"
+#include "yaml_utils.h"
+
+#include <QFileInfo>
+#include <QDir>
+#include <QGraphicsItem>
+
+using std::string;
+using std::vector;
+
+
+Project::Project()
+{
+  for (size_t i = 0; i < rendering_options.show_building_lanes.size(); i++)
+    rendering_options.show_building_lanes[i] = true;
+}
+
+Project::~Project()
+{
+}
+
+bool Project::load_yaml_file(const std::string& _filename)
+{
+  filename = _filename;
+
+  YAML::Node yaml;
+  try
+  {
+    yaml = YAML::LoadFile(filename.c_str());
+  }
+  catch (const std::exception& e)
+  {
+    printf("couldn't parse %s: %s", filename.c_str(), e.what());
+    return false;
+  }
+
+  // change directory to the path of the file, so that we can correctly open
+  // relative paths recorded in the file
+
+  // TODO: save previous directory and restore it, in case other files
+  // we load are in different directories (!)
+
+  QString dir(QFileInfo(QString::fromStdString(filename)).absolutePath());
+  printf("changing directory to [%s]", qUtf8Printable(dir));
+  if (!QDir::setCurrent(dir))
+  {
+    printf("couldn't change directory\n");
+    return false;
+  }
+
+  if (yaml["name"])
+    name = yaml["name"].as<string>();
+
+  if (yaml["building"] && yaml["building"].IsMap())
+  {
+    if (!yaml["building"]["filename"])
+    {
+      printf("expected a 'filename' key within the 'building' map\n");
+      return false;
+    }
+    building.filename = yaml["building"]["filename"].as<string>();
+    if (!building.load_yaml_file())
+      return false;
+  }
+
+  if (yaml["scenarios"] && yaml["scenarios"].IsSequence())
+  {
+    for (YAML::const_iterator scenario_node = yaml["scenarios"].begin();
+      scenario_node != yaml["scenarios"].end();
+      ++scenario_node)
+    {
+      std::unique_ptr<Scenario> scenario(new Scenario);
+      scenario->filename = (*scenario_node)["filename"].as<string>();
+      if (!scenario->load())
+      {
+        printf("couldn't load [%s]\n", scenario->filename.c_str());
+        //return false;
+      }
+      scenarios.push_back(std::move(scenario));
+    }
+    if (!scenarios.empty())
+      scenario_idx = 0;
+  }
+
+  if (yaml["traffic_maps"] && yaml["traffic_maps"].IsMap())
+  {
+    const YAML::Node& ytm = yaml["traffic_maps"];
+    for (YAML::const_iterator it = ytm.begin(); it != ytm.end(); ++it)
+    {
+      TrafficMap tm;
+      tm.from_project_yaml(it->first.as<string>(), it->second);
+      traffic_maps.push_back(tm);
+    }
+  }
+
+  return true;
+}
+
+bool Project::save_yaml_file() const
+{
+  printf("Project::save_yaml_file()\n");
+
+  YAML::Node y;
+  y["version"] = 1;
+  y["name"] = name;
+
+  y["building"] = YAML::Node(YAML::NodeType::Map);
+  y["building"]["filename"] = building.filename;
+
+  for (const auto& scenario : scenarios)
+  {
+    printf("saving scenario\n");
+    YAML::Node scenario_node;
+    scenario_node["filename"] = scenario->filename;
+    y["scenarios"].push_back(scenario_node);
+  }
+
+  y["traffic_maps"] = YAML::Node(YAML::NodeType::Map);
+  for (const auto& traffic_map : traffic_maps)
+    y["traffic_maps"][traffic_map.name] = traffic_map.to_project_yaml();
+
+  YAML::Emitter emitter;
+  yaml_utils::write_node(y, emitter);
+  std::ofstream fout(filename);
+  fout << emitter.c_str() << std::endl;
+
+  return true;
+}
+
+bool Project::save()
+{
+  if (!save_yaml_file())
+    return false;
+
+  building.save_yaml_file();
+
+  /*
+  // TODO: currently the scenarios are not fully parsed, so we
+  // can't save them back to disk without data loss
+  for (const auto& scenario : scenarios)
+    if (!scenario->save())
+      return false;
+  */
+
+  return true;
+}
+
+bool Project::load(const std::string& _filename)
+{
+  // future extension point: dispatch based on file type (json/yaml/...)
+  return load_yaml_file(_filename);
+}
+
+void Project::add_scenario_vertex(
+  const int level_idx,
+  const double x,
+  const double y)
+{
+  printf("add_scenario_vertex(%d, %.3f, %.3f)\n", level_idx, x, y);
+  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
+    return;
+  scenarios[scenario_idx]->add_vertex(building.levels[level_idx].name, x, y);
+}
+
+void Project::scenario_row_clicked(const int row)
+{
+  printf("Project::scenario_row_clicked(%d)\n", row);
+  if (row < 0 || row >= static_cast<int>(scenarios.size()))
+  {
+    scenario_idx = -1;
+    return;
+  }
+  scenario_idx = row;
+}
+
+void Project::draw(
+  QGraphicsScene* scene,
+  const int level_idx,
+  std::vector<EditorModel>& editor_models)
+{
+  std::lock_guard<std::mutex> building_guard(building.building_mutex);
+
+  if (building.levels.empty())
+  {
+    printf("nothing to draw!\n");
+    return;
+  }
+
+  building.levels[level_idx].draw(scene, editor_models, rendering_options);
+  building.draw_lifts(scene, level_idx);
+
+  if (scenario_idx >= 0)
+    scenarios[scenario_idx]->draw(
+      scene,
+      building.levels[level_idx].name,
+      building.levels[level_idx].drawing_meters_per_pixel,
+      editor_models);
+}
+
+void Project::clear_selection(const int level_idx)
+{
+  if (building.levels.empty())
+    return;
+  building.levels[level_idx].clear_selection();
+
+  if (scenario_idx >= 0)
+    scenarios[scenario_idx]->clear_selection(building.levels[level_idx].name);
+}
+
+bool Project::can_delete_current_selection(const int level_idx)
+{
+  if (level_idx >= static_cast<int>(building.levels.size()))
+    return false;
+  return building.levels[level_idx].can_delete_current_selection();
+}
+
+bool Project::delete_selected(const int level_idx)
+{
+  if (building.levels.empty())
+    return false;
+  if (!building.delete_selected(level_idx))
+    return false;
+  const std::string level_name = building.levels[level_idx].name;
+  if (scenario_idx >= 0 &&
+    !scenarios[scenario_idx]->delete_selected(level_name))
+    return false;
+  return true;
+}
+
+void Project::get_selected_items(
+  const int level_idx,
+  std::vector<BuildingLevel::SelectedItem>& selected)
+{
+  building.levels[level_idx].get_selected_items(selected);
+}
+
+Project::NearestItem Project::nearest_items(
+  EditorModeId mode,
+  const int level_index,
+  const double x,
+  const double y)
+{
+  NearestItem ni;
+
+  if (level_index >= static_cast<int>(building.levels.size()))
+    return ni;
+  const BuildingLevel& building_level = building.levels[level_index];
+
+  if (mode == MODE_BUILDING)
+  {
+    for (size_t i = 0; i < building_level.vertices.size(); i++)
+    {
+      const Vertex& p = building_level.vertices[i];
+      const double dx = x - p.x;
+      const double dy = y - p.y;
+      const double dist = std::sqrt(dx*dx + dy*dy);
+      if (dist < ni.vertex_dist)
+      {
+        ni.vertex_dist = dist;
+        ni.vertex_idx = i;
+      }
+    }
+
+    for (size_t i = 0; i < building_level.fiducials.size(); i++)
+    {
+      const Fiducial& f = building_level.fiducials[i];
+      const double dx = x - f.x;
+      const double dy = y - f.y;
+      const double dist = std::sqrt(dx*dx + dy*dy);
+      if (dist < ni.fiducial_dist)
+      {
+        ni.fiducial_dist = dist;
+        ni.fiducial_idx = i;
+      }
+    }
+
+    for (size_t i = 0; i < building_level.models.size(); i++)
+    {
+      const Model& m = building_level.models[i];
+      const double dx = x - m.state.x;
+      const double dy = y - m.state.y;
+      const double dist = std::sqrt(dx*dx + dy*dy);  // no need for sqrt each time
+      if (dist < ni.model_dist)
+      {
+        ni.model_dist = dist;
+        ni.model_idx = i;
+      }
+    }
+  }
+  else if (mode == MODE_SCENARIO)
+  {
+    if (scenario_idx < 0 ||
+      scenario_idx >= static_cast<int>(scenarios.size()))
+      return ni;
+    const Scenario& scenario = *scenarios[scenario_idx];
+
+    for (const ScenarioLevel& scenario_level : scenario.levels)
+    {
+      if (scenario_level.name != building_level.name)
+        continue;
+
+      for (size_t i = 0; i < scenario_level.vertices.size(); i++)
+      {
+        const Vertex& p = scenario_level.vertices[i];
+        const double dx = x - p.x;
+        const double dy = y - p.y;
+        const double dist = std::sqrt(dx*dx + dy*dy);
+        if (dist < ni.vertex_dist)
+        {
+          ni.vertex_dist = dist;
+          ni.vertex_idx = i;
+        }
+      }
+    }
+  }
+
+  return ni;
+}
+
+ScenarioLevel* Project::scenario_level(const int building_level_idx)
+{
+  if (building_level_idx >= static_cast<int>(building.levels.size()))
+    return nullptr;
+  const BuildingLevel& building_level = building.levels[building_level_idx];
+
+  if (scenario_idx < 0 ||
+    scenario_idx >= static_cast<int>(scenarios.size()))
+    return nullptr;
+  // I'm sure this is a horrific abomination. Fix someday.
+  Scenario& scenario = *scenarios[scenario_idx];
+  for (size_t i = 0; i < scenario.levels.size(); i++)
+  {
+    if (scenario.levels[i].name == building_level.name)
+      return &scenario.levels[i];
+  }
+  return nullptr;
+}
+
+void Project::mouse_select_press(
+  const EditorModeId mode,
+  const int level_idx,
+  const double x,
+  const double y,
+  QGraphicsItem* graphics_item)
+{
+  clear_selection(level_idx);
+  const NearestItem ni = nearest_items(mode, level_idx, x, y);
+
+  const double vertex_dist_thresh =
+    building.levels[level_idx].vertex_radius /
+    building.levels[level_idx].drawing_meters_per_pixel;
+
+  if (mode == MODE_BUILDING)
+  {
+    // todo: use QGraphics stuff to see if we clicked a model pixmap...
+    const double model_dist_thresh = 0.5 /
+      building.levels[level_idx].drawing_meters_per_pixel;
+
+    if (rendering_options.show_models &&
+      ni.model_idx >= 0 &&
+      ni.model_dist < model_dist_thresh)
+      building.levels[level_idx].models[ni.model_idx].selected = true;
+    else if (ni.vertex_idx >= 0 && ni.vertex_dist < vertex_dist_thresh)
+      building.levels[level_idx].vertices[ni.vertex_idx].selected = true;
+    else if (ni.fiducial_idx >= 0 && ni.fiducial_dist < 10.0)
+      building.levels[level_idx].fiducials[ni.fiducial_idx].selected = true;
+    else
+    {
+      // use the QGraphics stuff to see if it's an edge segment or polygon
+      if (graphics_item)
+      {
+        switch (graphics_item->type())
+        {
+          case QGraphicsLineItem::Type:
+            set_selected_line_item(
+              level_idx,
+              qgraphicsitem_cast<QGraphicsLineItem*>(graphics_item),
+              mode);
+            break;
+
+          case QGraphicsPolygonItem::Type:
+            set_selected_containing_polygon(mode, level_idx, x, y);
+            break;
+
+          default:
+            printf("clicked unhandled type: %d\n",
+              static_cast<int>(graphics_item->type()));
+            break;
+        }
+      }
+    }
+  }
+  else if (mode == MODE_TRAFFIC || mode == MODE_CROWD_SIM)
+  {
+    // todo: keep traffic-map vertices separate from building vertices
+    // for now, they're using the same vertex list.
+
+    if (ni.vertex_idx >= 0 && ni.vertex_dist < vertex_dist_thresh)
+      building.levels[level_idx].vertices[ni.vertex_idx].selected = true;
+    else
+    {
+      // use the QGraphics stuff to see if it's an edge segment or polygon
+      if (graphics_item)
+      {
+        switch (graphics_item->type())
+        {
+          case QGraphicsLineItem::Type:
+            set_selected_line_item(
+              level_idx,
+              qgraphicsitem_cast<QGraphicsLineItem*>(graphics_item),
+              mode);
+            break;
+
+          default:
+            printf("clicked unhandled type: %d\n",
+              static_cast<int>(graphics_item->type()));
+            break;
+        }
+      }
+    }
+  }
+  else if (mode == MODE_SCENARIO && scenario_idx >= 0)
+  {
+    ScenarioLevel* level = scenario_level(level_idx);
+    if (ni.vertex_dist < 10.0)
+      level->vertices[ni.vertex_idx].selected = true;
+    else
+    {
+      // use the QGraphics stuff to see if it's an edge segment or polygon
+      if (graphics_item)
+      {
+        switch (graphics_item->type())
+        {
+          case QGraphicsPolygonItem::Type:
+            set_selected_containing_polygon(mode, level_idx, x, y);
+            break;
+
+          default:
+            printf("clicked unhandled type: %d\n",
+              static_cast<int>(graphics_item->type()));
+            break;
+        }
+      }
+
+    }
+  }
+}
+
+void Project::set_selected_line_item(
+  const int level_idx,
+  QGraphicsLineItem* line_item,
+  const EditorModeId mode)
+{
+  clear_selection(level_idx);
+
+  if (line_item == nullptr)
+    return;
+
+  // find if any of our lanes match those vertices
+  for (auto& edge : building.levels[level_idx].edges)
+  {
+    if (mode == MODE_TRAFFIC)
+    {
+      if (edge.type != Edge::LANE)
+        continue;
+      if (edge.get_graph_idx() != traffic_map_idx)
+        continue;
+    }
+
+    if (mode == MODE_CROWD_SIM)
+    {
+      if (edge.type != Edge::HUMAN_LANE)
+        continue;
+      if (edge.get_graph_idx() != traffic_map_idx)
+        continue;
+    }
+
+    if (mode == MODE_BUILDING &&
+      (edge.type == Edge::LANE || edge.type == Edge::HUMAN_LANE) )
+      continue;
+
+    // look up the line's vertices
+    const double x1 = line_item->line().x1();
+    const double y1 = line_item->line().y1();
+    const double x2 = line_item->line().x2();
+    const double y2 = line_item->line().y2();
+
+    const auto& v_start = building.levels[level_idx].vertices[edge.start_idx];
+    const auto& v_end = building.levels[level_idx].vertices[edge.end_idx];
+
+    // calculate distances
+    const double dx1 = v_start.x - x1;
+    const double dy1 = v_start.y - y1;
+    const double dx2 = v_end.x - x2;
+    const double dy2 = v_end.y - y2;
+    const double v1_dist = std::sqrt(dx1*dx1 + dy1*dy1);
+    const double v2_dist = std::sqrt(dx2*dx2 + dy2*dy2);
+
+    const double thresh = 10.0;  // it should be really tiny if it matches
+    if (v1_dist < thresh && v2_dist < thresh)
+    {
+      edge.selected = true;
+      return;  // stop after first one is found, don't select multiple
+    }
+  }
+}
+
+Polygon::EdgeDragPolygon Project::polygon_edge_drag_press(
+  const EditorModeId mode,
+  const int level_idx,
+  const Polygon* polygon,
+  const double x,
+  const double y)
+{
+  Polygon::EdgeDragPolygon edp;
+
+  if (level_idx < 0 || level_idx > static_cast<int>(building.levels.size()))
+    return edp;// oh no
+
+  if (mode == MODE_BUILDING)
+    return building.levels[level_idx].polygon_edge_drag_press(polygon, x, y);
+  else if (mode == MODE_SCENARIO)
+  {
+    ScenarioLevel* slevel = scenario_level(level_idx);
+    if (slevel == nullptr)
+      return edp;
+    return slevel->polygon_edge_drag_press(polygon, x, y);
+  }
+
+  return edp;
+}
+
+Polygon* Project::get_selected_polygon(
+  const EditorModeId mode,
+  const int level_idx)
+{
+  if (mode == MODE_BUILDING)
+  {
+    for (size_t i = 0; i < building.levels[level_idx].polygons.size(); i++)
+    {
+      if (building.levels[level_idx].polygons[i].selected)
+        return &building.levels[level_idx].polygons[i];// abomination
+    }
+  }
+  else if (mode == MODE_SCENARIO)
+  {
+    ScenarioLevel* slevel = scenario_level(level_idx);
+    if (slevel)
+    {
+      for (size_t i = 0; i < slevel->polygons.size(); i++)
+      {
+        if (slevel->polygons[i].selected)
+          return &slevel->polygons[i];// abomination
+      }
+    }
+  }
+  return nullptr;
+}
+
+void Project::set_selected_containing_polygon(
+  const EditorModeId mode,
+  const int level_idx,
+  const double x,
+  const double y)
+{
+  Level* level = nullptr;
+  if (mode == MODE_BUILDING)
+    level = &building.levels[level_idx];
+  else if (mode == MODE_SCENARIO)
+    level = scenario_level(level_idx);
+
+  if (level == nullptr)
+    return;
+
+  // holes are "higher" in our Z-stack (to make them clickable), so first
+  // we need to make a list of all polygons that contain this point.
+  vector<Polygon*> containing_polygons;
+  for (size_t i = 0; i < level->polygons.size(); i++)
+  {
+    Polygon& polygon = level->polygons[i];
+    QVector<QPointF> polygon_vertices;
+    for (const auto& vertex_idx: polygon.vertices)
+    {
+      const Vertex& v = level->vertices[vertex_idx];
+      polygon_vertices.append(QPointF(v.x, v.y));
+    }
+    QPolygonF qpolygon(polygon_vertices);
+    if (qpolygon.containsPoint(QPoint(x, y), Qt::OddEvenFill))
+      containing_polygons.push_back(&level->polygons[i]);
+  }
+
+  // first search for holes
+  for (Polygon* p : containing_polygons)
+  {
+    if (p->type == Polygon::HOLE)
+    {
+      p->selected = true;
+      return;
+    }
+  }
+
+  // if we get here, just return the first thing.
+  for (Polygon* p : containing_polygons)
+  {
+    p->selected = true;
+    return;
+  }
+}
+
+void Project::clear()
+{
+  building.clear();
+  name.clear();
+  filename.clear();
+  scenarios.clear();
+  scenario_idx = -1;
+}
+
+#ifdef HAS_IGNITION_PLUGIN
+void Project::sim_tick()
+{
+  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
+    return;
+  scenarios[scenario_idx]->sim_tick(building);
+}
+
+void Project::sim_reset()
+{
+  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
+    return;
+  scenarios[scenario_idx]->sim_reset(building);
+}
+#endif
+
+void Project::clear_scene()
+{
+  building.clear_scene();
+
+#ifdef HAS_IGNITION_PLUGIN
+  for (auto& scenario : scenarios)
+    scenario->clear_scene();
+#endif
+}
+
+void Project::add_lane(
+  const int level_idx,
+  const int start_idx,
+  const int end_idx)
+{
+  building.add_lane(level_idx, start_idx, end_idx, traffic_map_idx);
+}
+
+#ifdef HAS_IGNITION_PLUGIN
+void Project::scenario_scene_update(
+  QGraphicsScene* scene,
+  const int level_idx)
+{
+  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
+    return;
+  scenarios[scenario_idx]->scene_update(scene, building, level_idx);
+}
+
+bool Project::has_sim_plugin()
+{
+  for (const auto& scenario : scenarios)
+  {
+    if (scenario->sim_plugin)
+      return true;
+  }
+  return false;
+}
+#endif
+
+bool Project::set_filename(const std::string& _fn)
+{
+  const string suffix(".project.yaml");
+
+  // ensure there is at least one character in addition to the suffix length
+  if (_fn.size() <= suffix.size())
+  {
+    printf("Project::set_filename() too short: [%s]\n", _fn.c_str());
+    return false;
+  }
+
+  // ensure the filename ends in .project.yaml
+  // it should, because the "save as" dialog appends it, but...
+  if (_fn.compare(_fn.size() - suffix.size(), suffix.size(), suffix))
+  {
+    printf(
+      "Project::set_filename() filename had unexpected suffix: [%s]\n",
+      _fn.c_str());
+    return false;
+  }
+
+  const string no_suffix(_fn.substr(0, _fn.size() - suffix.size()));
+
+  const size_t last_slash_pos = no_suffix.rfind('/', no_suffix.size());
+
+  const string stem(
+    (last_slash_pos == string::npos) ?
+    no_suffix :
+    string(no_suffix, last_slash_pos + 1));
+
+  filename = _fn;
+
+  if (name.empty())
+  {
+    name = stem;
+  }
+
+  if (building.name.empty())
+  {
+    building.name = stem;
+  }
+  if (building.filename.empty())
+  {
+    building.filename = stem + std::string(".building.yaml");
+  }
+
+  printf(
+    "set project filename to [%s] stem: [%s] building filename: [%s]\n",
+    filename.c_str(),
+    stem.c_str(),
+    building.filename.c_str());
+  return true;
+}
diff --git a/traffic_editor/gui/project.h b/traffic_editor/gui/project.h
new file mode 100644
index 0000000..f668cd2
--- /dev/null
+++ b/traffic_editor/gui/project.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef PROJECT_H
+#define PROJECT_H
+
+#include "traffic_editor/building.h"
+#include "traffic_editor/editor_model.h"
+#include "editor_mode_id.h"
+#include "scenario.h"
+#include "traffic_map.h"
+
+#include <array>
+#include <memory>
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+
+class QGraphicsScene;
+class QGraphicsItem;
+class QGraphicsLineItem;
+
+
+class Project
+{
+public:
+  std::string name;
+
+  Building building;
+  std::vector<std::unique_ptr<Scenario>> scenarios;
+  std::vector<TrafficMap> traffic_maps;
+
+  int scenario_idx = -1;  // the current scenario being viewed/edited
+  int traffic_map_idx = 0;  // the current traffic map being viewed/edited
+
+  /////////////////////////////////
+  Project();
+  ~Project();
+
+  bool save();
+  bool load(const std::string& _filename);
+
+  void clear();
+
+  void add_scenario_vertex(int level_index, double x, double y);
+  void scenario_row_clicked(const int row);
+
+  void clear_scene();
+
+  void draw(
+    QGraphicsScene* scene,
+    const int level_idx,
+    std::vector<EditorModel>& editor_models);
+
+  void scenario_scene_update(
+    QGraphicsScene* scene,
+    const int level_idx);
+
+  void clear_selection(const int level_idx);
+  bool can_delete_current_selection(const int level_idx);
+  bool delete_selected(const int level_idx);
+
+  void get_selected_items(const int level_idx,
+    std::vector<BuildingLevel::SelectedItem>& selected);
+
+  struct NearestItem
+  {
+    double model_dist = 1e100;
+    int model_idx = -1;
+
+    double vertex_dist = 1e100;
+    int vertex_idx = -1;
+
+    double fiducial_dist = 1e100;
+    int fiducial_idx = -1;
+  };
+
+  NearestItem nearest_items(
+    EditorModeId mode,
+    const int level_index,
+    const double x,
+    const double y);
+
+  ScenarioLevel* scenario_level(const int building_level_idx);
+
+  void set_selected_containing_polygon(
+    const EditorModeId mode,
+    const int level_idx,
+    const double x,
+    const double y);
+
+  void mouse_select_press(
+    const EditorModeId mode,
+    const int level_idx,
+    const double x,
+    const double y,
+    QGraphicsItem* graphics_item);
+
+  Polygon::EdgeDragPolygon polygon_edge_drag_press(
+    const EditorModeId mode,
+    const int level_idx,
+    const Polygon* polygon,
+    const double x,
+    const double y);
+
+  Polygon* get_selected_polygon(const EditorModeId mode, const int level_idx);
+
+  void add_lane(
+    const int level_idx,
+    const int start_idx,
+    const int end_idx);
+
+#ifdef HAS_IGNITION_PLUGIN
+  // simulation stuff
+  void sim_reset();
+  void sim_tick();
+  bool sim_is_paused = true;
+  bool has_sim_plugin();
+#endif
+
+  RenderingOptions rendering_options;
+
+  bool set_filename(const std::string& _filename);
+  std::string get_filename() { return filename; }
+
+private:
+  bool load_yaml_file(const std::string& _filename);
+  bool save_yaml_file() const;
+
+  void set_selected_line_item(
+    const int level_idx,
+    QGraphicsLineItem* line_item,
+    const EditorModeId mode);
+
+  std::string filename;
+};
+
+#endif
diff --git a/traffic_editor/gui/project_dialog.cpp b/traffic_editor/gui/project_dialog.cpp
new file mode 100644
index 0000000..d09cee5
--- /dev/null
+++ b/traffic_editor/gui/project_dialog.cpp
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "project_dialog.h"
+#include <QtWidgets>
+
+
+ProjectDialog::ProjectDialog(Project& _project)
+: QDialog(),
+  project(_project)
+{
+  setWindowTitle("Project Properties");
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  cancel_button = new QPushButton("Cancel", this);
+
+  QHBoxLayout* name_hbox = new QHBoxLayout;
+  name_hbox->addWidget(new QLabel("Project name:"));
+  name_line_edit = new QLineEdit(QString::fromStdString(project.name));
+  name_hbox->addWidget(name_line_edit);
+
+  QHBoxLayout* building_hbox = new QHBoxLayout;
+  building_path_line_edit = new QLineEdit(
+    QString::fromStdString(project.building.filename));
+  QPushButton* building_path_button = new QPushButton("Find...");
+  connect(
+    building_path_button,
+    &QAbstractButton::clicked,
+    this,
+    &ProjectDialog::building_path_button_clicked);
+
+  building_hbox->addWidget(new QLabel("Building path:"));
+  building_hbox->addWidget(building_path_line_edit);
+  building_hbox->addWidget(building_path_button);
+
+  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
+  bottom_buttons_hbox->addWidget(cancel_button);
+  bottom_buttons_hbox->addWidget(ok_button);
+  connect(
+    ok_button,
+    &QAbstractButton::clicked,
+    this,
+    &ProjectDialog::ok_button_clicked);
+  connect(
+    cancel_button,
+    &QAbstractButton::clicked,
+    this,
+    &QDialog::reject);
+
+  QVBoxLayout* top_vbox = new QVBoxLayout;
+  top_vbox->addLayout(name_hbox);
+  top_vbox->addLayout(building_hbox);
+  // todo: some sort of separator (?)
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  setLayout(top_vbox);
+}
+
+ProjectDialog::~ProjectDialog()
+{
+}
+
+void ProjectDialog::ok_button_clicked()
+{
+  project.name = name_line_edit->text().toStdString();
+
+  // if the building filename has changed, load it.
+  const std::string previous_building_filename = project.building.filename;
+  project.building.filename = building_path_line_edit->text().toStdString();
+  if (project.building.filename != previous_building_filename)
+    project.building.load_yaml_file();
+
+  accept();
+}
+
+void ProjectDialog::building_path_button_clicked()
+{
+  QFileDialog file_dialog(this, "Building File");
+  file_dialog.setFileMode(QFileDialog::ExistingFile);
+  file_dialog.setNameFilter("*.building.yaml");
+  if (file_dialog.exec() != QDialog::Accepted)
+    return;// user clicked 'cancel' in the QFileDialog
+  const QString filename = file_dialog.selectedFiles().first();
+  if (!QFileInfo(filename).exists())  // is this check even needed?
+  {
+    QMessageBox::critical(
+      this,
+      "Building file does not exist",
+      "File does not exist.");
+    return;
+  }
+  // todo: probably should change to the path of this project before
+  // calculating the relative path. This is already done
+  // implicitly, but maybe should be more explicit here.
+  building_path_line_edit->setText(
+    QDir::current().relativeFilePath(filename));
+}
diff --git a/traffic_editor/gui/project_dialog.h b/traffic_editor/gui/project_dialog.h
new file mode 100644
index 0000000..d1ef8f5
--- /dev/null
+++ b/traffic_editor/gui/project_dialog.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef PROJECT_DIALOG_H
+#define PROJECT_DIALOG_H
+
+#include <QDialog>
+#include "project.h"
+class QLineEdit;
+class QComboBox;
+
+
+class ProjectDialog : public QDialog
+{
+public:
+  ProjectDialog(Project& _project);
+  ~ProjectDialog();
+
+private:
+  Project& project;
+
+  QLineEdit* name_line_edit;
+  QLineEdit* building_path_line_edit;
+  QPushButton* ok_button, * cancel_button;
+
+private slots:
+  void ok_button_clicked();
+  void building_path_button_clicked();
+};
+
+#endif
diff --git a/traffic_editor/gui/scenario.cpp b/traffic_editor/gui/scenario.cpp
new file mode 100644
index 0000000..cd4155b
--- /dev/null
+++ b/traffic_editor/gui/scenario.cpp
@@ -0,0 +1,259 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <fstream>
+
+#ifdef HAS_IGNITION_PLUGIN
+#include <ignition/common/SystemPaths.hh>
+#endif
+
+#include "scenario.h"
+#include "yaml_utils.h"
+
+using std::string;
+using std::unique_ptr;
+
+
+Scenario::Scenario()
+{
+}
+
+Scenario::~Scenario()
+{
+}
+
+bool Scenario::load()
+{
+  printf("Scenario::load(%s)\n", filename.c_str());
+  YAML::Node yaml;
+  try
+  {
+    yaml = YAML::LoadFile(filename.c_str());
+  }
+  catch (const std::exception& e)
+  {
+    printf("couldn't parse %s: %s", filename.c_str(), e.what());
+    return false;
+  }
+
+  if (yaml["name"])
+    name = yaml["name"].as<string>();
+
+  levels.clear();
+  if (yaml["levels"])
+  {
+    const YAML::Node yl = yaml["levels"];
+    for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
+    {
+      ScenarioLevel l;
+      l.from_yaml(it->first.as<string>(), it->second);
+      levels.push_back(l);
+    }
+  }
+
+#ifdef HAS_IGNITION_PLUGIN
+  if (yaml["plugin_name"])
+  {
+    string plugin_path = yaml["plugin_path"].as<string>();
+    ignition::common::SystemPaths paths;
+    paths.AddPluginPaths(plugin_path);
+
+    const string plugin_name = yaml["plugin_name"].as<string>();
+    std::string lib_path = paths.FindSharedLibrary(plugin_name);
+    printf("FindSharedLibrary returned [%s]\n", lib_path.c_str());
+
+    ignition::plugin::Loader loader;
+    std::unordered_set<string> plugin_libs = loader.LoadLib(lib_path);
+    std::unordered_set<string> sim_libs =
+      loader.PluginsImplementing("Simulation");
+
+    for (const auto& s : plugin_libs)
+      printf("  found plugin library: [%s]\n", s.c_str());
+
+    for (const auto& s : sim_libs)
+      printf("  found simulation library: [%s]\n", s.c_str());
+
+    for (const std::string& plugin_class_name : plugin_libs)
+    {
+      if (sim_libs.find(plugin_class_name) != sim_libs.end())
+      {
+        printf(
+          "trying to instantiate [%s] from library [%s]...\n",
+          plugin_class_name.c_str(),
+          plugin_name.c_str());
+        sim_plugin = loader.Instantiate(plugin_class_name);
+
+        if (sim_plugin.IsEmpty())
+        {
+          printf("simulation plugin instantiation failed :(\n");
+          break;
+        }
+
+        printf("success! created a simulation plugin instance!\n");
+        Simulation* sim = sim_plugin->QueryInterface<Simulation>();
+        if (!sim)
+        {
+          printf("woah! couldn't get interface to plugin!\n");
+          break;
+        }
+
+        sim->load(yaml["plugin_config"]);
+        break;
+      }
+    }
+  }
+#endif
+
+  print();
+
+  return true;
+}
+
+void Scenario::print() const
+{
+  printf("scenario: [%s]\n", name.c_str());
+  printf("  filename: [%s]\n", filename.c_str());
+}
+
+bool Scenario::save() const
+{
+  YAML::Node y;
+  y["version"] = 1;
+  y["name"] = name;
+
+  y["levels"] = YAML::Node(YAML::NodeType::Map);
+  for (const ScenarioLevel& level : levels)
+    y["levels"][level.name] = level.to_yaml();
+
+  YAML::Emitter emitter;
+  yaml_utils::write_node(y, emitter);
+  std::ofstream fout(filename);
+  fout << emitter.c_str() << std::endl;
+
+  return true;
+}
+
+void Scenario::draw(
+  QGraphicsScene* scene,
+  const std::string& level_name,
+  const double meters_per_pixel,
+  std::vector<EditorModel>& /*editor_models*/) const
+{
+  printf("Scenario::draw(%s)\n", level_name.c_str());
+  for (const ScenarioLevel& level : levels)
+  {
+    if (level.name == level_name)
+    {
+      level.draw(scene, meters_per_pixel);
+      break;
+    }
+  }
+}
+
+void Scenario::add_vertex(
+  const std::string& level_name,
+  const double x,
+  const double y)
+{
+  printf("Scenario::add_vertex(%s, %.1f, %.1f)\n", level_name.c_str(), x, y);
+  for (ScenarioLevel& level : levels)
+  {
+    if (level.name == level_name)
+    {
+      level.add_vertex(x, y);
+      return;
+    }
+  }
+  // if we get here, we didn't find a ScenarioLevel for this level name,
+  // so we have to add it now.
+  printf("adding level [%s] to scenario\n", level_name.c_str());
+  ScenarioLevel level;
+  level.name = level_name;
+  level.add_vertex(x, y);
+  levels.push_back(level);
+}
+
+void Scenario::clear_selection(const std::string& level_name)
+{
+  for (ScenarioLevel& level : levels)
+  {
+    if (level.name == level_name)
+      level.clear_selection();
+  }
+}
+
+bool Scenario::delete_selected(const std::string& level_name)
+{
+  for (ScenarioLevel& level : levels)
+  {
+    if (level.name == level_name)
+      return level.delete_selected();
+  }
+  return true;
+}
+
+#ifdef HAS_IGNITION_PLUGIN
+void Scenario::sim_tick(Building& building)
+{
+  if (!sim_plugin.IsEmpty())
+  {
+    std::lock_guard<std::mutex> building_guard(building.building_mutex);
+    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
+    if (sim)
+      sim->tick(building);
+  }
+}
+
+void Scenario::sim_reset(Building& building)
+{
+  if (!sim_plugin.IsEmpty())
+  {
+    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
+    if (sim)
+      sim->reset(building);
+  }
+
+  sim_time_seconds = 0.0;
+  sim_tick_counter = 0;
+}
+
+void Scenario::clear_scene()
+{
+  printf("Scenario::clear_scene()\n");
+
+  if (!sim_plugin.IsEmpty())
+  {
+    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
+    if (sim)
+      sim->scene_clear();
+  }
+}
+
+void Scenario::scene_update(
+  QGraphicsScene* scene,
+  Building& building,
+  const int level_idx)
+{
+  if (!sim_plugin.IsEmpty())
+  {
+    std::lock_guard<std::mutex> building_guard(building.building_mutex);
+    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
+    if (sim)
+      sim->scene_update(scene, building, level_idx);
+  }
+}
+#endif
diff --git a/traffic_editor/gui/scenario.h b/traffic_editor/gui/scenario.h
new file mode 100644
index 0000000..6d77a30
--- /dev/null
+++ b/traffic_editor/gui/scenario.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef SCENARIO_H
+#define SCENARIO_H
+
+#include "traffic_editor/building.h"
+#include "traffic_editor/editor_model.h"
+#include "traffic_editor/model.h"
+#include "scenario_level.h"
+#include "traffic_editor/vertex.h"
+#include "plugins/simulation.h"
+
+#ifdef HAS_IGNITION_PLUGIN
+#include <ignition/plugin/SpecializedPluginPtr.hh>
+#include <ignition/plugin/Loader.hh>
+#endif
+
+#include <map>
+#include <memory>
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+
+class Scenario
+{
+public:
+  std::string name;
+  std::string filename;
+  std::vector<ScenarioLevel> levels;
+
+  /////////////////////////////////
+  Scenario();
+  ~Scenario();
+
+  bool load();
+  bool save() const;
+
+  void clear_scene();
+
+  void draw(
+    QGraphicsScene* scene,
+    const std::string& level_name,
+    const double meters_per_pixel,
+    std::vector<EditorModel>& editor_models) const;
+
+  void add_vertex(
+    const std::string& level_name,
+    const double x,
+    const double y);
+
+  void clear_selection(const std::string& level_name);
+  bool delete_selected(const std::string& level_name);
+
+  void print() const;
+
+  // simulation stuff
+  double sim_time_seconds = 0.0;
+  int sim_tick_counter = 0;
+
+  void sim_tick(Building& building);
+  void sim_reset(Building& building);
+
+  void scene_update(
+    QGraphicsScene* scene,
+    Building& building,
+    const int level_idx);
+
+  std::vector<std::string> behavior_signals;
+
+#ifdef HAS_IGNITION_PLUGIN
+  ignition::plugin::SpecializedPluginPtr<Simulation> sim_plugin;
+#endif
+};
+
+#endif
diff --git a/traffic_editor/gui/scenario_dialog.cpp b/traffic_editor/gui/scenario_dialog.cpp
new file mode 100644
index 0000000..0c77bac
--- /dev/null
+++ b/traffic_editor/gui/scenario_dialog.cpp
@@ -0,0 +1,132 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "scenario_dialog.h"
+#include <QtWidgets>
+#include <utility>
+using std::unique_ptr;
+
+
+ScenarioDialog::ScenarioDialog(Scenario& _scenario)
+: QDialog(),
+  scenario(_scenario)
+{
+  setWindowTitle("Scenario Properties");
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  cancel_button = new QPushButton("Cancel", this);
+
+  QHBoxLayout* name_hbox = new QHBoxLayout;
+  name_hbox->addWidget(new QLabel("Scenario name:"));
+  name_line_edit = new QLineEdit(QString::fromStdString(scenario.name));
+  name_hbox->addWidget(name_line_edit);
+
+  QHBoxLayout* scenario_hbox = new QHBoxLayout;
+  scenario_path_line_edit = new QLineEdit(
+    QString::fromStdString(scenario.filename));
+  QPushButton* scenario_path_button = new QPushButton("Find...");
+  connect(
+    scenario_path_button,
+    &QAbstractButton::clicked,
+    this,
+    &ScenarioDialog::scenario_path_button_clicked);
+
+  scenario_hbox->addWidget(new QLabel("Scenario path:"));
+  scenario_hbox->addWidget(scenario_path_line_edit);
+  scenario_hbox->addWidget(scenario_path_button);
+
+  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
+  bottom_buttons_hbox->addWidget(cancel_button);
+  bottom_buttons_hbox->addWidget(ok_button);
+  connect(
+    ok_button,
+    &QAbstractButton::clicked,
+    this,
+    &ScenarioDialog::ok_button_clicked);
+  connect(
+    cancel_button,
+    &QAbstractButton::clicked,
+    this,
+    &QDialog::reject);
+
+  QVBoxLayout* top_vbox = new QVBoxLayout;
+  top_vbox->addLayout(name_hbox);
+  top_vbox->addLayout(scenario_hbox);
+  // todo: some sort of separator (?)
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  setLayout(top_vbox);
+}
+
+ScenarioDialog::~ScenarioDialog()
+{
+}
+
+void ScenarioDialog::ok_button_clicked()
+{
+  scenario.name = name_line_edit->text().toStdString();
+
+  if (scenario_path_line_edit->text().isEmpty())
+  {
+    QMessageBox::critical(
+      this,
+      "Scenario filename not provided",
+      "Scenario filename must be defined. Otherwise click [Cancel].");
+    return;
+  }
+
+  if (!scenario_path_line_edit->text().endsWith(".scenario.yaml"))
+  {
+    QMessageBox::critical(
+      this,
+      "Bad scenario filename",
+      "Scenario filename must end in .scenario.yaml");
+    return;
+  }
+
+  scenario.filename = scenario_path_line_edit->text().toStdString();
+
+  accept();
+}
+
+void ScenarioDialog::scenario_path_button_clicked()
+{
+  QFileDialog file_dialog(this, "Scenario File");
+  //file_dialog.setFileMode(QFileDialog::ExistingFile);
+  file_dialog.setNameFilter("*.scenario.yaml");
+  if (file_dialog.exec() != QDialog::Accepted)
+    return;// user clicked 'cancel' in the QFileDialog
+  const QString filename = file_dialog.selectedFiles().first();
+
+  // if the scenario filename has changed, load it.
+  const std::string previous_scenario_filename = scenario.filename;
+
+  scenario_path_line_edit->setText(
+    QDir::current().relativeFilePath(filename));
+
+  scenario.filename = scenario_path_line_edit->text().toStdString();
+
+  if (scenario.filename != previous_scenario_filename)
+  {
+    if (QFileInfo(filename).exists() && !scenario.load())
+    {
+      QMessageBox::critical(
+        this,
+        "Unable to load scenario file",
+        "Unable to load scenario file. Check filename?");
+    }
+  }
+}
diff --git a/traffic_editor/gui/scenario_dialog.h b/traffic_editor/gui/scenario_dialog.h
new file mode 100644
index 0000000..9da4e57
--- /dev/null
+++ b/traffic_editor/gui/scenario_dialog.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef SCENARIO_DIALOG_H
+#define SCENARIO_DIALOG_H
+
+#include <QDialog>
+#include <memory>
+#include "project.h"
+class QLineEdit;
+class QComboBox;
+
+
+class ScenarioDialog : public QDialog
+{
+public:
+  ScenarioDialog(Scenario& _scenario);
+  ~ScenarioDialog();
+
+  Scenario& scenario;
+
+private:
+
+  QLineEdit* name_line_edit;
+  QLineEdit* scenario_path_line_edit;
+  QPushButton* ok_button, * cancel_button;
+
+private slots:
+  void ok_button_clicked();
+  void scenario_path_button_clicked();
+};
+
+#endif
diff --git a/traffic_editor/gui/scenario_level.cpp b/traffic_editor/gui/scenario_level.cpp
new file mode 100644
index 0000000..3e6ed91
--- /dev/null
+++ b/traffic_editor/gui/scenario_level.cpp
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+
+#include <QGraphicsOpacityEffect>
+#include <QGraphicsPixmapItem>
+#include <QGraphicsScene>
+#include <QImage>
+#include <QImageReader>
+
+#include "scenario_level.h"
+using std::string;
+using std::vector;
+
+
+ScenarioLevel::ScenarioLevel()
+: Level()
+{
+}
+
+ScenarioLevel::~ScenarioLevel()
+{
+}
+
+bool ScenarioLevel::from_yaml(
+  const std::string& _name,
+  const YAML::Node& yaml_node)
+{
+  printf("parsing scenario level [%s]\n", _name.c_str());
+
+  name = _name;
+
+  if (!yaml_node.IsMap())
+    throw std::runtime_error("level " + name + " YAML invalid");
+
+  parse_vertices(yaml_node);
+
+  if (yaml_node["roi"] && yaml_node["roi"].IsSequence())
+  {
+    const YAML::Node& y_roi = yaml_node["roi"];
+    for (YAML::const_iterator it = y_roi.begin(); it != y_roi.end(); ++it)
+    {
+      Polygon p;
+      p.from_yaml(*it, Polygon::ROI);
+      polygons.push_back(p);
+    }
+  }
+  return true;
+}
+
+YAML::Node ScenarioLevel::to_yaml() const
+{
+  YAML::Node y;
+  for (const auto& v : vertices)
+    y["vertices"].push_back(v.to_yaml());
+
+  for (const auto& polygon : polygons)
+  {
+    switch (polygon.type)
+    {
+      case Polygon::ROI:
+        y["roi"].push_back(polygon.to_yaml());
+        break;
+      default:
+        printf("tried to save an unknown polygon type: %d\n",
+          static_cast<int>(polygon.type));
+        break;
+    }
+  }
+
+  return y;
+}
+
+bool ScenarioLevel::delete_selected()
+{
+  // Vertices take a lot more care, because we have to check if a vertex
+  // is used in an edge or a polygon before deleting it, and update all
+  // higher-index vertex indices in the edges and polygon vertex lists.
+  // Since this is a potentially expensive operation, first we'll spin
+  // through the vertex list and see if any vertices are selected, and
+  // only then make a copy of the vertex list.
+  int selected_vertex_idx = -1;
+  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
+  {
+    if (vertices[i].selected)
+    {
+      selected_vertex_idx = i;
+      break;  // just grab the index of the first selected vertex
+    }
+  }
+  if (selected_vertex_idx >= 0)
+  {
+    // See if this vertex is used in any edges/polygons.
+    bool vertex_used = false;
+    for (const auto& polygon : polygons)
+    {
+      for (const int& vertex_idx : polygon.vertices)
+      {
+        if (vertex_idx == selected_vertex_idx)
+          vertex_used = true;
+      }
+    }
+    if (vertex_used)
+      return false;// don't try to delete a vertex used in a shape
+
+    // the vertex is not currently being used, so let's erase it
+    vertices.erase(vertices.begin() + selected_vertex_idx);
+
+    for (Polygon& polygon : polygons)
+    {
+      for (int i = 0; i < static_cast<int>(polygon.vertices.size()); i++)
+      {
+        if (polygon.vertices[i] > selected_vertex_idx)
+          polygon.vertices[i]--;
+      }
+    }
+  }
+  return true;
+}
+
+void ScenarioLevel::draw_polygons(QGraphicsScene* scene) const
+{
+  QBrush polygon_brush(QColor::fromRgbF(0.8, 0.8, 0.0, 0.2));
+  QBrush selected_polygon_brush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5));
+
+  for (const auto& polygon : polygons)
+  {
+    // now draw the polygons
+    QVector<QPointF> polygon_vertices;
+    for (const auto& vertex_idx: polygon.vertices)
+    {
+      const Vertex& v = vertices[vertex_idx];
+      polygon_vertices.append(QPointF(v.x, v.y));
+    }
+    scene->addPolygon(
+      QPolygonF(polygon_vertices),
+      QPen(Qt::black),
+      polygon.selected ? selected_polygon_brush : polygon_brush);
+  }
+}
+
+void ScenarioLevel::clear_selection()
+{
+  for (auto& vertex : vertices)
+    vertex.selected = false;
+
+  for (auto& polygon : polygons)
+    polygon.selected = false;
+}
+
+void ScenarioLevel::draw(
+  QGraphicsScene* scene,
+  const double meters_per_pixel) const
+{
+  draw_polygons(scene);
+
+  for (const auto& v : vertices)
+    v.draw(scene, 0.1 / meters_per_pixel, QColor::fromRgbF(1.0, 1.0, 0.0));
+}
diff --git a/traffic_editor/gui/scenario_level.h b/traffic_editor/gui/scenario_level.h
new file mode 100644
index 0000000..eda2503
--- /dev/null
+++ b/traffic_editor/gui/scenario_level.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef SCENARIO_LEVEL_H
+#define SCENARIO_LEVEL_H
+
+#include "traffic_editor/level.h"
+
+#include <yaml-cpp/yaml.h>
+#include <string>
+
+class QGraphicsScene;
+
+
+class ScenarioLevel : public Level
+{
+public:
+  std::string name;
+
+  ScenarioLevel();
+  ~ScenarioLevel();
+
+  bool from_yaml(const std::string& _name, const YAML::Node& yaml_node);
+  YAML::Node to_yaml() const;
+
+  bool delete_selected();
+
+  void clear_selection();
+
+  void draw(
+    QGraphicsScene* scene,
+    const double meters_per_pixel) const;
+
+  void draw_polygons(QGraphicsScene* scene) const;
+};
+
+#endif
diff --git a/traffic_editor/gui/scenario_table.cpp b/traffic_editor/gui/scenario_table.cpp
new file mode 100644
index 0000000..96289b1
--- /dev/null
+++ b/traffic_editor/gui/scenario_table.cpp
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "scenario_dialog.h"
+#include "scenario_table.h"
+#include <QtWidgets>
+using std::unique_ptr;
+
+
+ScenarioTable::ScenarioTable()
+: TableList(2)
+{
+  const QStringList labels = { "#", "Name", "" };
+  setHorizontalHeaderLabels(labels);
+}
+
+ScenarioTable::~ScenarioTable()
+{
+}
+
+void ScenarioTable::update(Project& project)
+{
+  blockSignals(true);
+  setRowCount(1 + project.scenarios.size());
+  for (size_t i = 0; i < project.scenarios.size(); i++)
+  {
+    const Scenario& scenario = *project.scenarios[i];
+
+    QTableWidgetItem* name_item =
+      new QTableWidgetItem(QString::fromStdString(scenario.name));
+
+    if (static_cast<int>(i) == project.scenario_idx)
+      name_item->setBackground(QBrush(QColor("#e0ffe0")));
+
+    setItem(i, 0, name_item);
+
+    QPushButton* edit_button = new QPushButton("Edit...", this);
+    setCellWidget(i, 1, edit_button);
+    connect(
+      edit_button,
+      &QAbstractButton::clicked,
+      [this, &project, i]()
+      {
+        ScenarioDialog dialog(*project.scenarios[i]);
+        dialog.exec();
+        update(project);
+        emit redraw();
+      });
+  }
+
+  // we'll use the last row for the "Add" button
+  const int last_row_idx = static_cast<int>(project.scenarios.size());
+  setCellWidget(last_row_idx, 0, nullptr);
+  QPushButton* add_button = new QPushButton("Add...", this);
+  setCellWidget(last_row_idx, 1, add_button);
+  connect(
+    add_button, &QAbstractButton::clicked,
+    [this, &project]()
+    {
+      unique_ptr<Scenario> scenario = std::make_unique<Scenario>();
+      ScenarioDialog scenario_dialog(*scenario);
+      if (scenario_dialog.exec() == QDialog::Accepted)
+      {
+        project.scenarios.push_back(std::move(scenario));
+        update(project);
+        emit redraw();
+      }
+      else
+        scenario.release();
+    });
+
+  blockSignals(false);
+}
diff --git a/traffic_editor/gui/scenario_table.h b/traffic_editor/gui/scenario_table.h
new file mode 100644
index 0000000..f521254
--- /dev/null
+++ b/traffic_editor/gui/scenario_table.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef SCENARIO_TABLE_H
+#define SCENARIO_TABLE_H
+
+#include <QTableWidget>
+
+#include "table_list.h"
+#include "project.h"
+
+class ScenarioTable : public TableList
+{
+public:
+  ScenarioTable();
+  ~ScenarioTable();
+
+  void update(Project& project);
+};
+
+#endif
diff --git a/traffic_editor/gui/sim_thread.cpp b/traffic_editor/gui/sim_thread.cpp
new file mode 100644
index 0000000..b76b0ab
--- /dev/null
+++ b/traffic_editor/gui/sim_thread.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "sim_thread.h"
+#include <QTimer>
+#include "editor.h"
+
+SimThread::SimThread()
+: QThread()
+{
+}
+
+SimThread::~SimThread()
+{
+}
+
+void SimThread::run()
+{
+  printf("entering SimThread::run()\n");
+  while (true)
+  {
+    usleep(100);  // todo: user-editable parameter here from GUI...
+    if (isInterruptionRequested())
+      break;
+    Editor::get_instance()->sim_tick();
+  }
+}
diff --git a/traffic_editor/gui/sim_thread.h b/traffic_editor/gui/sim_thread.h
new file mode 100644
index 0000000..1e443f6
--- /dev/null
+++ b/traffic_editor/gui/sim_thread.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef SIM_THREAD_H
+#define SIM_THREAD_H
+
+#include <QThread>
+
+class SimThread : public QThread
+{
+  Q_OBJECT
+
+public:
+  SimThread();
+  ~SimThread();
+
+  void run() override;
+};
+
+#endif
diff --git a/traffic_editor/gui/table_list.cpp b/traffic_editor/gui/table_list.cpp
new file mode 100644
index 0000000..9a7e93a
--- /dev/null
+++ b/traffic_editor/gui/table_list.cpp
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "table_list.h"
+#include <QtWidgets>
+
+TableList::TableList(const int num_cols)
+{
+  const char* style =
+    "QTableWidget { background-color: #e0e0e0; color: black; } "
+    "QHeaderView::section { color: black; } "
+    "QLineEdit { background:white; } "
+    "QCheckBox { padding-left: 5px; background-color: #e0e0e0; } "
+    "QPushButton { margin: 5px; background-color: #c0c0c0; border: 1px solid black; } "
+    "QPushButton:pressed { background-color: #808080; }";
+  setStyleSheet(style);
+  setColumnCount(num_cols);
+  setMinimumSize(400, 200);
+
+  verticalHeader()->setVisible(false);
+  verticalHeader()->setSectionResizeMode(
+    QHeaderView::ResizeToContents);
+
+  horizontalHeader()->setVisible(true);
+  horizontalHeader()->setDefaultAlignment(Qt::AlignLeft);
+  horizontalHeader()->setSectionResizeMode(
+    0, QHeaderView::Stretch);
+
+  for (int col = 1; col < num_cols; col++)
+    horizontalHeader()->setSectionResizeMode(
+      col,
+      QHeaderView::ResizeToContents);
+
+  setAutoFillBackground(true);
+
+  setSizePolicy(
+    QSizePolicy::Fixed,
+    QSizePolicy::MinimumExpanding);
+}
+
+TableList::~TableList()
+{
+}
diff --git a/traffic_editor/gui/table_list.h b/traffic_editor/gui/table_list.h
new file mode 100644
index 0000000..8cf9744
--- /dev/null
+++ b/traffic_editor/gui/table_list.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef TABLE_LIST_H
+#define TABLE_LIST_H
+
+#include <QTableWidget>
+
+class TableList : public QTableWidget
+{
+  Q_OBJECT
+
+public:
+  TableList(const int num_cols = 2);
+  ~TableList();
+
+signals:
+  void redraw();
+};
+
+#endif
diff --git a/traffic_editor/gui/traffic_map.cpp b/traffic_editor/gui/traffic_map.cpp
new file mode 100644
index 0000000..236ddbd
--- /dev/null
+++ b/traffic_editor/gui/traffic_map.cpp
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "traffic_map.h"
+#include <yaml-cpp/yaml.h>
+
+using std::string;
+
+TrafficMap::TrafficMap()
+{
+}
+
+TrafficMap::~TrafficMap()
+{
+}
+
+bool TrafficMap::from_project_yaml(const string& _name, const YAML::Node& y)
+{
+  name = _name;
+
+  if (y["offset"] && y["offset"].IsSequence())
+  {
+    x_offset = y["offset"][0].as<double>();
+    y_offset = y["offset"][1].as<double>();
+  }
+
+  // todo: open 'filename' and load its contents
+  if (y["filename"])
+  {
+    filename = y["filename"].as<string>();
+    return load_file();
+  }
+
+  return true;
+}
+
+bool TrafficMap::load_file()
+{
+  printf("Building::load_yaml_file(%s)\n", filename.c_str());
+  YAML::Node y;
+  try
+  {
+    y = YAML::LoadFile(filename.c_str());
+  }
+  catch (const std::exception& e)
+  {
+    printf("couldn't parse %s: %s", filename.c_str(), e.what());
+    return false;
+  }
+  printf("parsed traffic-map file %s\n", filename.c_str());
+
+  return true;
+}
+
+YAML::Node TrafficMap::to_project_yaml() const
+{
+  YAML::Node y;
+  y["filename"] = filename;
+  y["offset"].push_back(x_offset);
+  y["offset"].push_back(y_offset);
+  y["offset"].SetStyle(YAML::EmitterStyle::Flow);
+  return y;
+}
diff --git a/traffic_editor/gui/traffic_map.h b/traffic_editor/gui/traffic_map.h
new file mode 100644
index 0000000..0d74011
--- /dev/null
+++ b/traffic_editor/gui/traffic_map.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef TRAFFIC_MAP_H
+#define TRAFFIC_MAP_H
+
+#include <string>
+#include <yaml-cpp/yaml.h>
+
+class TrafficMap
+{
+public:
+  std::string name;
+  std::string filename;
+  double x_offset = 0;
+  double y_offset = 0;
+  bool visible = true;
+
+  /////////////////////////////////
+  TrafficMap();
+  ~TrafficMap();
+
+  bool from_project_yaml(const std::string& name, const YAML::Node& data);
+  YAML::Node to_project_yaml() const;
+
+  bool load_file();
+};
+
+#endif
diff --git a/traffic_editor/gui/traffic_map_dialog.cpp b/traffic_editor/gui/traffic_map_dialog.cpp
new file mode 100644
index 0000000..fb57961
--- /dev/null
+++ b/traffic_editor/gui/traffic_map_dialog.cpp
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "traffic_map_dialog.h"
+#include <QtWidgets>
+
+
+TrafficMapDialog::TrafficMapDialog(TrafficMap& _traffic_map)
+: QDialog(),
+  traffic_map(_traffic_map)
+{
+  setWindowTitle("Traffic Map Properties");
+  ok_button = new QPushButton("OK", this);  // first button = [enter] button
+  cancel_button = new QPushButton("Cancel", this);
+
+  QHBoxLayout* name_hbox = new QHBoxLayout;
+  name_hbox->addWidget(new QLabel("Traffic map name:"));
+  name_line_edit = new QLineEdit(QString::fromStdString(traffic_map.name));
+  name_hbox->addWidget(name_line_edit);
+
+  QHBoxLayout* path_hbox = new QHBoxLayout;
+  path_line_edit =
+    new QLineEdit(QString::fromStdString(traffic_map.filename));
+  QPushButton* path_button = new QPushButton("Find...");
+  connect(
+    path_button,
+    &QAbstractButton::clicked,
+    this,
+    &TrafficMapDialog::path_button_clicked);
+
+  path_hbox->addWidget(new QLabel("Traffic map path:"));
+  path_hbox->addWidget(path_line_edit);
+  path_hbox->addWidget(path_button);
+
+  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
+  bottom_buttons_hbox->addWidget(cancel_button);
+  bottom_buttons_hbox->addWidget(ok_button);
+  connect(
+    ok_button,
+    &QAbstractButton::clicked,
+    this,
+    &TrafficMapDialog::ok_button_clicked);
+  connect(
+    cancel_button,
+    &QAbstractButton::clicked,
+    this,
+    &QDialog::reject);
+
+  QVBoxLayout* top_vbox = new QVBoxLayout;
+  top_vbox->addLayout(name_hbox);
+  top_vbox->addLayout(path_hbox);
+  // todo: some sort of separator (?)
+  top_vbox->addLayout(bottom_buttons_hbox);
+
+  setLayout(top_vbox);
+}
+
+TrafficMapDialog::~TrafficMapDialog()
+{
+}
+
+void TrafficMapDialog::ok_button_clicked()
+{
+  traffic_map.name = name_line_edit->text().toStdString();
+
+  if (path_line_edit->text().isEmpty())
+  {
+    QMessageBox::critical(
+      this,
+      "Filename not provided",
+      "Filename must be defined. Otherwise click [Cancel].");
+    return;
+  }
+
+  if (!path_line_edit->text().endsWith(".traffic_map.yaml"))
+  {
+    QMessageBox::critical(
+      this,
+      "Bad filename",
+      "Filename must end in .traffic_map.yaml");
+    return;
+  }
+
+  traffic_map.filename = path_line_edit->text().toStdString();
+
+  accept();
+}
+
+void TrafficMapDialog::path_button_clicked()
+{
+  QFileDialog file_dialog(this, "Traffic Map File");
+  //file_dialog.setFileMode(QFileDialog::ExistingFile);
+  file_dialog.setNameFilter("*.traffic_map.yaml");
+  if (file_dialog.exec() != QDialog::Accepted)
+    return;// user clicked 'cancel' in the QFileDialog
+  const QString filename = file_dialog.selectedFiles().first();
+
+  // if the filename has changed, load it.
+  const std::string previous_filename = traffic_map.filename;
+
+  path_line_edit->setText(QDir::current().relativeFilePath(filename));
+
+  traffic_map.filename = path_line_edit->text().toStdString();
+
+  if (traffic_map.filename != previous_filename)
+  {
+    if (QFileInfo(filename).exists() && !traffic_map.load_file())
+    {
+      QMessageBox::critical(
+        this,
+        "Unable to load file",
+        "Unable to load file. Check filename?");
+    }
+  }
+}
diff --git a/traffic_editor/gui/traffic_map_dialog.h b/traffic_editor/gui/traffic_map_dialog.h
new file mode 100644
index 0000000..9bcede7
--- /dev/null
+++ b/traffic_editor/gui/traffic_map_dialog.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef TRAFFIC_MAP_DIALOG_H
+#define TRAFFIC_MAP_DIALOG_H
+
+#include <QDialog>
+#include "project.h"
+#include "traffic_map.h"
+class QLineEdit;
+class QComboBox;
+
+
+class TrafficMapDialog : public QDialog
+{
+public:
+  TrafficMapDialog(TrafficMap& _scenario);
+  ~TrafficMapDialog();
+
+private:
+  TrafficMap& traffic_map;
+
+  QLineEdit* name_line_edit;
+  QLineEdit* path_line_edit;
+  QPushButton* ok_button, * cancel_button;
+
+private slots:
+  void ok_button_clicked();
+  void path_button_clicked();
+};
+
+#endif
diff --git a/traffic_editor/gui/traffic_table.cpp b/traffic_editor/gui/traffic_table.cpp
new file mode 100644
index 0000000..43aa7b1
--- /dev/null
+++ b/traffic_editor/gui/traffic_table.cpp
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include "traffic_table.h"
+#include "traffic_map_dialog.h"
+#include <QtWidgets>
+
+
+TrafficTable::TrafficTable()
+: TableList(3)
+{
+  const QStringList labels = { "Show", "Name", "" };
+  setHorizontalHeaderLabels(labels);
+  horizontalHeader()->setSectionResizeMode(
+    0, QHeaderView::ResizeToContents);
+  horizontalHeader()->setSectionResizeMode(
+    1, QHeaderView::Stretch);
+}
+
+TrafficTable::~TrafficTable()
+{
+}
+
+void TrafficTable::update(Project& project)
+{
+  RenderingOptions& opts = project.rendering_options;
+
+  const size_t num_internal_lanes = opts.show_building_lanes.size();
+
+  blockSignals(true);
+  setRowCount(
+    1 +
+    num_internal_lanes +
+    project.traffic_maps.size());
+
+  // first render the 10 "internal" traffic maps stored in the building yaml
+  for (size_t i = 0; i < num_internal_lanes; i++)
+  {
+    QCheckBox* checkbox = new QCheckBox;
+    checkbox->setChecked(opts.show_building_lanes[i]);
+    setCellWidget(i, 0, checkbox);
+    connect(
+      checkbox,
+      &QAbstractButton::clicked,
+      [this, &project, i](bool box_checked)
+      {
+        project.rendering_options.show_building_lanes[i] = box_checked;
+        emit redraw();
+      });
+
+
+    QTableWidgetItem* name_item =
+      new QTableWidgetItem(QString("Graph %1").arg(i));
+
+    if (static_cast<int>(i) == project.traffic_map_idx)
+      name_item->setBackground(QBrush(QColor("#e0ffe0")));
+
+    setItem(i, 1, name_item);
+  }
+
+  // now the "explicitly linked" external traffic maps
+  for (size_t i = 0; i < project.traffic_maps.size(); i++)
+  {
+    const TrafficMap& traffic_map = project.traffic_maps[i];
+
+    QCheckBox* checkbox = new QCheckBox;
+    checkbox->setChecked(traffic_map.visible);
+    setCellWidget(num_internal_lanes + i, 0, checkbox);
+    connect(
+      checkbox,
+      &QAbstractButton::clicked,
+      [this, &project, i](bool box_checked)
+      {
+        project.traffic_maps[i].visible = box_checked;
+        emit redraw();
+      });
+
+    QTableWidgetItem* name_item =
+      new QTableWidgetItem(QString::fromStdString(traffic_map.name));
+    setItem(num_internal_lanes + i, 1, name_item);
+
+    QPushButton* edit_button = new QPushButton("Edit...", this);
+    setCellWidget(num_internal_lanes + i, 2, edit_button);
+    connect(
+      edit_button,
+      &QAbstractButton::clicked,
+      [this, &project, i]()
+      {
+        TrafficMapDialog dialog(project.traffic_maps[i]);
+        dialog.exec();
+        update(project);
+        emit redraw();
+      });
+  }
+
+  // we'll use the last row for the "Add" button
+  const int last_row_idx =
+    static_cast<int>(num_internal_lanes + project.traffic_maps.size());
+
+  setCellWidget(last_row_idx, 0, nullptr);
+  setCellWidget(last_row_idx, 1, nullptr);
+  QPushButton* add_button = new QPushButton("Add...", this);
+  setCellWidget(last_row_idx, 2, add_button);
+  connect(
+    add_button,
+    &QAbstractButton::clicked,
+    [this, &project]()
+    {
+      TrafficMap traffic_map;
+      TrafficMapDialog dialog(traffic_map);
+      if (dialog.exec() == QDialog::Accepted)
+      {
+        project.traffic_maps.push_back(traffic_map);
+        update(project);
+        emit redraw();
+      }
+    });
+
+  blockSignals(false);
+}
diff --git a/traffic_editor/gui/traffic_table.h b/traffic_editor/gui/traffic_table.h
new file mode 100644
index 0000000..b5bf495
--- /dev/null
+++ b/traffic_editor/gui/traffic_table.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef TRAFFIC_TABLE_H
+#define TRAFFIC_TABLE_H
+
+#include <QTableWidget>
+
+#include "table_list.h"
+#include "project.h"
+
+class TrafficTable : public TableList
+{
+public:
+  TrafficTable();
+  ~TrafficTable();
+
+  void update(Project& project);
+};
+
+#endif
diff --git a/traffic_editor/gui/transform_dialog.ui b/traffic_editor/gui/transform_dialog.ui
new file mode 100644
index 0000000..e08187f
--- /dev/null
+++ b/traffic_editor/gui/transform_dialog.ui
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>TransformDialog</class>
+ <widget class="QDialog" name="TransformDialog">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>379</width>
+    <height>152</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>Dialog</string>
+  </property>
+  <layout class="QFormLayout" name="formLayout">
+   <item row="0" column="0">
+    <widget class="QLabel" name="rotate_all_models_label">
+     <property name="text">
+      <string>Rotate all models:</string>
+     </property>
+    </widget>
+   </item>
+   <item row="0" column="1">
+    <widget class="QLineEdit" name="rotate_all_models_line_edit">
+     <property name="text">
+      <string>0</string>
+     </property>
+    </widget>
+   </item>
+   <item row="2" column="1">
+    <widget class="QDialogButtonBox" name="buttonBox">
+     <property name="standardButtons">
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
+     </property>
+     <property name="centerButtons">
+      <bool>false</bool>
+     </property>
+    </widget>
+   </item>
+   <item row="1" column="1">
+    <spacer name="verticalSpacer">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeType">
+      <enum>QSizePolicy::MinimumExpanding</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>40</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>TransformDialog</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>273</x>
+     <y>121</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>189</x>
+     <y>75</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>TransformDialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>273</x>
+     <y>121</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>189</x>
+     <y>75</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>
diff --git a/traffic_editor/gui/vertex.cpp b/traffic_editor/gui/vertex.cpp
new file mode 100644
index 0000000..2dcd166
--- /dev/null
+++ b/traffic_editor/gui/vertex.cpp
@@ -0,0 +1,142 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <cmath>
+
+#include <QGraphicsScene>
+#include <QGraphicsSimpleTextItem>
+
+#include "traffic_editor/vertex.h"
+using std::string;
+using std::vector;
+using std::pair;
+
+const vector<pair<string, Param::Type>> Vertex::allowed_params
+{
+  { "is_parking_spot", Param::Type::BOOL },
+  { "is_charger", Param::Type::BOOL},
+  { "dock_name", Param::Type::STRING},
+  { "workcell_name", Param::Type::STRING },
+  { "spawn_robot_type", Param::Type::STRING },
+  { "spawn_robot_name", Param::Type::STRING },
+  { "is_holding_point", Param::Type::BOOL },
+  { "is_passthrough_point", Param::Type::BOOL },
+  { "human_goal_set_name", Param::Type::STRING },
+};
+
+
+Vertex::Vertex()
+: x(0), y(0), selected(false)
+{
+  uuid = QUuid::createUuid();
+}
+
+Vertex::Vertex(double _x, double _y, const string& _name)
+: x(_x), y(_y), name(_name), selected(false)
+{
+  uuid = QUuid::createUuid();
+}
+
+void Vertex::from_yaml(const YAML::Node& data)
+{
+  if (!data.IsSequence())
+    throw std::runtime_error("Vertex::from_yaml expected a sequence");
+  x = data[0].as<double>();
+  y = data[1].as<double>();
+  if (data.size() < 4)
+    return;// todo: remove... intended only during format transition
+  // skip the z-offset in data[2] for now
+  name = data[3].as<string>();
+
+  // load the parameters, all of which (including the params map) are
+  // optional at the moment.
+  if (data.size() >= 4)
+  {
+    for (YAML::const_iterator it = data[4].begin(); it != data[4].end(); ++it)
+    {
+      Param p;
+      p.from_yaml(it->second);
+      params[it->first.as<string>()] = p;
+    }
+  }
+}
+
+YAML::Node Vertex::to_yaml() const
+{
+  // This is in image space. I think it's safe to say nobody is clicking
+  // with more than 1/1000 precision inside a single pixel.
+
+  YAML::Node vertex_node;
+  vertex_node.SetStyle(YAML::EmitterStyle::Flow);
+  vertex_node.push_back(std::round(x * 1000.0) / 1000.0);
+  vertex_node.push_back(std::round(y * 1000.0) / 1000.0);
+  vertex_node.push_back(0.0);  // placeholder for Z offsets in the future
+  vertex_node.push_back(name);
+
+  if (!params.empty())
+  {
+    YAML::Node params_node(YAML::NodeType::Map);
+    for (const auto& param : params)
+      params_node[param.first] = param.second.to_yaml();
+    vertex_node.push_back(params_node);
+  }
+  return vertex_node;
+}
+
+void Vertex::draw(
+  QGraphicsScene* scene,
+  const double radius,
+  const QColor& color) const
+{
+  QPen vertex_pen(Qt::black);
+  vertex_pen.setWidthF(radius / 2.0);
+
+  const double a = 0.5;
+
+  QColor nonselected_color(color);
+  nonselected_color.setAlphaF(a);
+
+  QColor selected_color = QColor::fromRgbF(1.0, 0.0, 0.0, a);
+
+  scene->addEllipse(
+    x - radius,
+    y - radius,
+    2 * radius,
+    2 * radius,
+    vertex_pen,
+    selected ? QBrush(selected_color) : QBrush(nonselected_color));
+
+  if (!name.empty())
+  {
+    QGraphicsSimpleTextItem* item = scene->addSimpleText(
+      QString::fromStdString(name),
+      QFont("Helvetica", 6));
+    item->setBrush(selected ? selected_color : color);
+    item->setPos(x, y + radius);
+  }
+}
+
+void Vertex::set_param(const std::string& param_name, const std::string& value)
+{
+  auto it = params.find(param_name);
+  if (it == params.end())
+  {
+    printf("tried to set unknown parameter [%s]\n", param_name.c_str());
+    return;  // unknown parameter
+  }
+  it->second.set(value);
+}
diff --git a/traffic_editor/gui/yaml_utils.cpp b/traffic_editor/gui/yaml_utils.cpp
new file mode 100644
index 0000000..9f00add
--- /dev/null
+++ b/traffic_editor/gui/yaml_utils.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <algorithm>
+
+#include "yaml_utils.h"
+
+#include <string>
+using std::string;
+
+
+// Recursive function to write YAML ordered maps. Credit: Dave Hershberger
+// posted to this GitHub issue: https://github.com/jbeder/yaml-cpp/issues/169
+void yaml_utils::write_node(
+  const YAML::Node& node,
+  YAML::Emitter& emitter)
+{
+  switch (node.Style())
+  {
+    case YAML::EmitterStyle::Block:
+      emitter << YAML::Block;
+      break;
+    case YAML::EmitterStyle::Flow:
+      emitter << YAML::Flow;
+      break;
+    default:
+      break;
+  }
+
+  switch (node.Type())
+  {
+    case YAML::NodeType::Sequence:
+    {
+      emitter << YAML::BeginSeq;
+      for (size_t i = 0; i < node.size(); i++)
+        write_node(node[i], emitter);
+      emitter << YAML::EndSeq;
+      break;
+    }
+    case YAML::NodeType::Map:
+    {
+      emitter << YAML::BeginMap;
+      // the keys are stored in random order, so we need to collect and sort
+      std::vector<string> keys;
+      keys.reserve(node.size());
+      for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
+        keys.push_back(it->first.as<string>());
+      std::sort(keys.begin(), keys.end());
+      for (size_t i = 0; i < keys.size(); i++)
+      {
+        emitter << YAML::Key << keys[i] << YAML::Value;
+        write_node(node[keys[i]], emitter);
+      }
+      emitter << YAML::EndMap;
+      break;
+    }
+    default:
+      emitter << node;
+      break;
+  }
+}
diff --git a/traffic_editor/gui/yaml_utils.h b/traffic_editor/gui/yaml_utils.h
new file mode 100644
index 0000000..50458a8
--- /dev/null
+++ b/traffic_editor/gui/yaml_utils.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef YAML_UTILS_H
+#define YAML_UTILS_H
+
+#include <yaml-cpp/yaml.h>
+
+namespace yaml_utils {
+
+// Recursive function to write YAML ordered maps. Credit: Dave Hershberger
+void write_node(const YAML::Node& node, YAML::Emitter& emitter);
+
+}
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/building.h b/traffic_editor/include/traffic_editor/building.h
new file mode 100644
index 0000000..8c4dcdd
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/building.h
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_H
+#define BUILDING_H
+
+
+class QGraphicsScene;
+
+#include <memory>
+#include <mutex>
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+
+#include <QGraphicsLineItem>
+#include <QPointF>
+
+#include "building_level.h"
+#include "lift.h"
+#include <traffic_editor/crowd_sim/crowd_sim_impl.h>
+
+class Building
+{
+public:
+  Building();
+  virtual ~Building();
+
+  std::string name;
+  std::string reference_level_name;
+  std::vector<BuildingLevel> levels;
+  std::vector<Lift> lifts;
+  std::mutex building_mutex;
+
+  mutable crowd_sim::CrowdSimImplPtr crowd_sim_impl;
+
+  std::string filename;
+
+  bool load_yaml_file();
+  bool save_yaml_file();
+  void clear();  // clear all internal data structures
+
+  void add_level(const BuildingLevel& level);
+
+  void add_vertex(int level_index, double x, double y);
+  QUuid add_fiducial(int level_index, double x, double y);
+
+  int find_nearest_vertex_index(
+    int level_index, double x, double y, double& distance);
+
+  enum ItemType { VERTEX=1, MODEL, FIDUCIAL };
+  struct NearestItem
+  {
+    double model_dist = 1e100;
+    int model_idx = -1;
+
+    double vertex_dist = 1e100;
+    int vertex_idx = -1;
+
+    double fiducial_dist = 1e100;
+    int fiducial_idx = -1;
+  };
+
+  NearestItem nearest_items(
+    const int level_index,
+    const double x,
+    const double y);
+
+  int nearest_item_index_if_within_distance(
+    const int level_index,
+    const double x,
+    const double y,
+    const double distance_threshold,
+    const ItemType item_type);
+
+  void add_edge(
+    const int level_idx,
+    const int start_idx,
+    const int end_idx,
+    const Edge::Type edge_type);
+
+  void add_lane(
+    const int level_idx,
+    const int start_idx,
+    const int end_idx,
+    const int graph_idx);
+
+  QUuid add_model(
+    const int level_idx,
+    const double x,
+    const double y,
+    const double z,
+    const double yaw,
+    const std::string& model_name);
+
+  bool delete_selected(const int level_index);
+
+  void set_model_yaw(
+    const int level_idx,
+    const int model_idx,
+    const double yaw);
+
+  void draw_lifts(QGraphicsScene* scene, const int level_idx);
+
+  bool transform_between_levels(
+    const std::string& from_level_name,
+    const QPointF& from_point,
+    const std::string& to_level_name,
+    QPointF& to_point);
+
+  bool transform_between_levels(
+    const int from_level_idx,
+    const QPointF& from_point,
+    const int to_level_idx,
+    QPointF& to_point);
+
+  void clear_transform_cache();
+
+  struct LevelPair
+  {
+    int from_idx = -1;
+    int to_idx = -1;
+
+    bool operator<(const LevelPair& rhs) const
+    {
+      return std::tie(from_idx, to_idx) < std::tie(rhs.from_idx, rhs.to_idx);
+    }
+  };
+
+  // to apply transform: first scale, then translate
+  struct Transform
+  {
+    double scale = 1.0;
+    double dx = 0.0;
+    double dy = 0.0;
+  };
+  typedef std::map<LevelPair, Transform> TransformMap;
+  TransformMap transforms;
+
+  Transform compute_transform(
+    const int from_level_idx,
+    const int to_level_idx);
+
+  Transform get_transform(
+    const int from_level_idx,
+    const int to_level_idx);
+
+  void calculate_all_transforms();
+
+  int get_reference_level_idx();
+
+  void clear_scene();
+
+  double level_meters_per_pixel(const std::string& level_name) const;
+
+  void rotate_all_models(const double rotation);
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/building_level.h b/traffic_editor/include/traffic_editor/building_level.h
new file mode 100644
index 0000000..edd51e1
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/building_level.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef BUILDING_LEVEL_H
+#define BUILDING_LEVEL_H
+
+#include "traffic_editor/level.h"
+
+#include <yaml-cpp/yaml.h>
+#include <string>
+
+#include "traffic_editor/edge.h"
+#include "traffic_editor/editor_model.h"
+#include "traffic_editor/fiducial.h"
+#include "traffic_editor/layer.h"
+#include "traffic_editor/model.h"
+#include "traffic_editor/polygon.h"
+#include "traffic_editor/rendering_options.h"
+#include "traffic_editor/vertex.h"
+
+#include <QPixmap>
+#include <QPainterPath>
+class QGraphicsScene;
+
+
+class BuildingLevel : public Level
+{
+public:
+  BuildingLevel();
+  ~BuildingLevel();
+
+  std::string drawing_filename;
+  int drawing_width = 0;
+  int drawing_height = 0;
+  double drawing_meters_per_pixel = 0.05;
+  double elevation = 0.0;
+  const double vertex_radius = 0.1;  // meters
+
+  double x_meters = 10.0;  // manually specified if no drawing supplied
+  double y_meters = 10.0;  // manually specified if no drawing supplied
+
+  // when generating the building in "flattened" mode, the levels have
+  // to be offset in the (x, y) plane to avoid clobbering each other.
+  double flattened_x_offset = 0.0;
+  double flattened_y_offset = 0.0;
+
+  std::vector<Model> models;
+  std::vector<Fiducial> fiducials;
+
+  QPixmap floorplan_pixmap;
+
+  bool from_yaml(const std::string& name, const YAML::Node& data);
+  YAML::Node to_yaml() const;
+
+  struct SelectedItem
+  {
+    int model_idx = -1;
+    int vertex_idx = -1;
+    int fiducial_idx = -1;
+    int edge_idx = -1;
+    int polygon_idx = -1;
+  };
+
+  bool can_delete_current_selection();
+  bool delete_selected();
+  void calculate_scale();
+  void clear_selection();
+  void get_selected_items(std::vector<SelectedItem>& selected_items);
+
+
+  void draw(
+    QGraphicsScene* scene,
+    std::vector<EditorModel>& editor_models,
+    const RenderingOptions& rendering_options);
+
+  void clear_scene();
+
+  bool load_drawing();
+
+private:
+  void draw_lane(
+    QGraphicsScene* scene,
+    const Edge& edge,
+    const RenderingOptions& rendering_options) const;
+
+  void draw_wall(QGraphicsScene* scene, const Edge& edge) const;
+  void draw_meas(QGraphicsScene* scene, const Edge& edge) const;
+  void draw_door(QGraphicsScene* scene, const Edge& edge) const;
+  void draw_fiducials(QGraphicsScene* scene) const;
+  void draw_polygons(QGraphicsScene* scene) const;
+
+  // helper function
+  void draw_polygon(
+    QGraphicsScene* scene,
+    const QBrush& brush,
+    const Polygon& polygon) const;
+
+  void add_door_swing_path(
+    QPainterPath& path,
+    double hinge_x,
+    double hinge_y,
+    double door_length,
+    double start_angle,
+    double end_angle) const;
+
+  void add_door_slide_path(
+    QPainterPath& path,
+    double hinge_x,
+    double hinge_y,
+    double door_length,
+    double door_angle) const;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/agent_group.h b/traffic_editor/include/traffic_editor/crowd_sim/agent_group.h
new file mode 100644
index 0000000..4434f72
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/agent_group.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_AGENT_GROUP__H
+#define CROWD_SIM_AGENT_GROUP__H
+
+#include <string>
+#include <vector>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+namespace crowd_sim {
+
+class AgentGroup
+{
+public:
+  AgentGroup(size_t group_id, bool is_external_group = false)
+  : _group_id(group_id),
+    _is_external_group(is_external_group),
+    _spawn_point_x(0.0),
+    _spawn_point_y(0.0),
+    _spawn_number(0),
+    _external_agent_name({}),
+    _agent_profile(""),
+    _initial_state("")
+  {}
+  AgentGroup(const YAML::Node& input)
+  : _group_id(65535),
+    _is_external_group(false),
+    _spawn_point_x(0.0),
+    _spawn_point_y(0.0),
+    _spawn_number(0),
+    _external_agent_name({}),
+    _agent_profile(""),
+    _initial_state("")
+  {
+    from_yaml(input);
+  }
+
+  bool is_valid() const
+  {
+    return _agent_profile.size() > 0 && _initial_state.size() > 0;
+  }
+  bool is_external_group() const { return _is_external_group; }
+  size_t get_group_id() const { return _group_id; }
+  std::pair<double, double> get_spawn_point() const
+  {
+    return std::pair<double, double>(_spawn_point_x, _spawn_point_y);
+  }
+  std::vector<std::string> get_external_agent_name() const
+  {
+    return _external_agent_name;
+  }
+  int get_spawn_number() const { return _spawn_number; }
+  std::string get_agent_profile() const { return _agent_profile; }
+  std::string get_initial_state() const { return _initial_state; }
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& input);
+
+  void set_spawn_point(double x, double y)
+  {
+    _spawn_point_x = x;
+    _spawn_point_y = y;
+  }
+  void set_external_agent_name(const std::vector<std::string>& external_name)
+  {
+    _external_agent_name.clear();
+    _external_agent_name = external_name;
+    _spawn_number = _external_agent_name.size();
+  }
+  void set_spawn_number(int number)
+  {
+    _spawn_number = static_cast<size_t>(number);
+  }
+  void set_agent_profile(std::string profile)
+  {
+    _agent_profile = profile;
+  }
+  void set_initial_state(std::string state)
+  {
+    _initial_state = state;
+  }
+
+private:
+  size_t _group_id;
+  bool _is_external_group;
+  double _spawn_point_x, _spawn_point_y;
+  size_t _spawn_number;
+  std::vector<std::string> _external_agent_name;
+  std::string _agent_profile, _initial_state;
+};
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/agent_profile.h b/traffic_editor/include/traffic_editor/crowd_sim/agent_profile.h
new file mode 100644
index 0000000..5ab39fb
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/agent_profile.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_AGENT_PROFILE__H
+#define CROWD_SIM_AGENT_PROFILE__H
+
+#include <string>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+namespace crowd_sim {
+
+class AgentProfile
+{
+public:
+  AgentProfile(std::string profile_name_)
+  : profile_name(profile_name_),
+    profile_class(1),
+    max_neighbors(10),
+    obstacle_set(1),
+    max_accel(0.0),
+    max_angle_vel(0.0),
+    max_speed(0.0),
+    neighbor_dist(5.0),
+    pref_speed(0.0),
+    r(0.25),
+    ORCA_tau(1.0),
+    ORCA_tauObst(0.4)
+  {}
+  AgentProfile(const YAML::Node& input)
+  : profile_name("N.A."),
+    profile_class(1),
+    max_neighbors(10),
+    obstacle_set(1),
+    max_accel(0.0),
+    max_angle_vel(0.0),
+    max_speed(0.0),
+    neighbor_dist(5.0),
+    pref_speed(0.0),
+    r(0.25),
+    ORCA_tau(1.0),
+    ORCA_tauObst(0.4)
+  {
+    from_yaml(input);
+  }
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& input);
+
+  std::string profile_name;
+  size_t profile_class, max_neighbors, obstacle_set;
+  double max_accel, max_angle_vel, max_speed, neighbor_dist, pref_speed, r,
+    ORCA_tau, ORCA_tauObst;
+};
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/condition.h b/traffic_editor/include/traffic_editor/crowd_sim/condition.h
new file mode 100644
index 0000000..8c3a7fe
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/condition.h
@@ -0,0 +1,237 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_CONDITION__H
+#define CROWD_SIM_CONDITION__H
+
+#include <string>
+#include <set>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+namespace crowd_sim {
+
+/*
+ * Condition base class. This base class controls the name and type of all the other kind conditions
+ * and provides the basic interface functions for all conditions
+ */
+class Condition;
+using ConditionPtr = std::shared_ptr<Condition>;
+
+class Condition
+{
+public:
+  enum TYPE
+  {
+    BASE,
+    GOAL,
+    TIMER,
+    AND,
+    OR,
+    NOT
+  };
+
+  Condition()
+  : _name("base_condition"), _type(BASE)
+  {}
+  Condition(std::string name, TYPE type)
+  : _name(name), _type(type)
+  {}
+  virtual ~Condition() {}
+
+  ConditionPtr init_from_yaml(const YAML::Node& input);
+
+  std::string get_condition_name() const { return _name; }
+  TYPE get_type() const { return _type; }
+
+  virtual bool is_valid() const { return false; }
+  virtual YAML::Node to_yaml() const { return YAML::Node(YAML::NodeType::Map); }
+  virtual void from_yaml(const YAML::Node& input)   // default do nothing
+  {
+    if (!input["type"]) printf("Invalid Condition yaml input. \n");
+  }
+
+private:
+  std::string _name;
+  TYPE _type;
+};
+
+/*
+ * LeafCondition class. This class provides the interface function for "goal_reached" condition and "timer" condition
+ */
+class LeafCondition : public Condition
+{
+public:
+  LeafCondition(
+    const std::string& condition_name,
+    Condition::TYPE condition_type)
+  : Condition(condition_name, condition_type),
+    _value(0)
+  {}
+  LeafCondition(
+    const std::string& condition_name,
+    Condition::TYPE condition_type, double condition_value)
+  : Condition(condition_name, condition_type),
+    _value(condition_value)
+  {}
+  virtual ~LeafCondition() {}
+
+  double get_value() const {return _value;}
+  void set_value(double condition_value) { _value = condition_value; }
+
+private:
+  double _value;
+};
+
+/*
+ * BoolCondition class. This class provides the interface function for "and", "or", "not" condition
+ */
+class BoolCondition : public Condition
+{
+public:
+  BoolCondition(
+    const std::string& condition_name,
+    Condition::TYPE condition_type)
+  : Condition(condition_name, condition_type),
+    _condition1(nullptr),
+    _condition2(nullptr)
+  {}
+  BoolCondition(
+    const std::string& condition_name,
+    Condition::TYPE condition_type,
+    ConditionPtr condition_ptr_1)
+  : Condition(condition_name, condition_type),
+    _condition1(condition_ptr_1),
+    _condition2(nullptr)
+  {}
+  BoolCondition(
+    const std::string& condition_name,
+    Condition::TYPE condition_type,
+    ConditionPtr condition_ptr_1,
+    ConditionPtr condition_ptr_2)
+  : Condition(condition_name, condition_type),
+    _condition1(condition_ptr_1),
+    _condition2(condition_ptr_2)
+  {}
+  virtual ~BoolCondition() {}
+
+  void set_condition(ConditionPtr condition, int condition_index);
+  void set_condition(ConditionPtr condition); //default set condition1
+  ConditionPtr get_condition(int condition_index) const;
+  ConditionPtr get_condition() const; //default return condition1
+  bool is_valid() const override;
+
+  virtual YAML::Node to_yaml() const override;
+  virtual void from_yaml(const YAML::Node& input) override;
+
+private:
+  ConditionPtr _condition1, _condition2;
+};
+
+/*
+ * Real Conditions
+ */
+//==============================================================
+class ConditionGOAL final : public LeafCondition
+{
+public:
+  ConditionGOAL()
+  : LeafCondition("goal_reached", GOAL, 0.1)
+  {}
+  ~ConditionGOAL() {}
+
+  bool is_valid() const override { return true; }
+  YAML::Node to_yaml() const override;
+  void from_yaml(const YAML::Node& input) override;
+};
+
+using ConditionGoalPtr = std::shared_ptr<ConditionGOAL>;
+
+//==============================================================
+class ConditionTIMER final : public LeafCondition
+{
+public:
+  ConditionTIMER()
+  : LeafCondition("timer", TIMER, 30.0),
+    _distribution("c")
+  {}
+  ~ConditionTIMER() {}
+
+  std::string get_timer_distribution() const { return this->_distribution;}
+
+  bool is_valid() const override { return true; }
+  YAML::Node to_yaml() const override;
+  void from_yaml(const YAML::Node& input) override;
+
+private:
+  // currently only provides const value distribution for timer
+  std::string _distribution;
+};
+
+using ConditionTimerPtr = std::shared_ptr<ConditionTIMER>;
+
+//==============================================================
+class ConditionAND final : public BoolCondition
+{
+public:
+  ConditionAND()
+  : BoolCondition(
+      "and",
+      AND,
+      std::make_shared<Condition>(),
+      std::make_shared<Condition>())
+  {}
+  ~ConditionAND() {}
+};
+
+using ConditionAndPtr = std::shared_ptr<ConditionAND>;
+
+//==============================================================
+class ConditionOR final : public BoolCondition
+{
+public:
+  ConditionOR()
+  : BoolCondition(
+      "or",
+      OR,
+      std::make_shared<Condition>(),
+      std::make_shared<Condition>())
+  {}
+  ~ConditionOR() {}
+};
+
+using ConditionOrPtr = std::shared_ptr<ConditionOR>;
+
+//==============================================================
+class ConditionNOT final : public BoolCondition
+{
+public:
+  ConditionNOT()
+  : BoolCondition(
+      "not",
+      NOT,
+      std::make_shared<Condition>())
+  {}
+  ~ConditionNOT() {}
+};
+
+using ConditionNotPtr = std::shared_ptr<ConditionNOT>;
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/crowd_sim_impl.h b/traffic_editor/include/traffic_editor/crowd_sim/crowd_sim_impl.h
new file mode 100644
index 0000000..619cbf6
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/crowd_sim_impl.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_IMPL__H
+#define CROWD_SIM_IMPL__H
+
+#include <string>
+#include <set>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+#include <traffic_editor/crowd_sim/state.h>
+#include <traffic_editor/crowd_sim/goal_set.h>
+#include <traffic_editor/crowd_sim/transition.h>
+#include <traffic_editor/crowd_sim/agent_profile.h>
+#include <traffic_editor/crowd_sim/agent_group.h>
+#include <traffic_editor/crowd_sim/model_type.h>
+
+namespace crowd_sim {
+
+class CrowdSimImplementation
+{
+public:
+  CrowdSimImplementation()
+  : _enable_crowd_sim(false),
+    _update_time_step(0.1)
+  {
+    init_default_configure();
+  }
+  ~CrowdSimImplementation() {}
+
+
+  YAML::Node to_yaml();
+  bool from_yaml(const YAML::Node& input);
+  void clear();
+  void init_default_configure();
+
+  void set_navmesh_file_name(std::vector<std::string> navmesh_filename)
+  {
+    _navmesh_filename_list = navmesh_filename;
+  }
+  std::vector<std::string> get_navmesh_file_name() const
+  {
+    return _navmesh_filename_list;
+  }
+
+  void set_enable_crowd_sim(bool is_enable) { _enable_crowd_sim = is_enable; }
+  bool get_enable_crowd_sim() const { return _enable_crowd_sim; }
+
+  void set_update_time_step(double update_time_step)
+  {
+    _update_time_step = update_time_step;
+  }
+  double get_update_time_step() const { return _update_time_step; }
+
+  void set_goal_areas(std::set<std::string> goal_areas)
+  {
+    _goal_areas = goal_areas;
+  }
+  std::vector<std::string> get_goal_areas() const
+  {
+    return std::vector<std::string>(_goal_areas.begin(), _goal_areas.end());
+  }
+
+  void save_goal_sets(const std::vector<GoalSet>& goal_sets);
+  std::vector<GoalSet> get_goal_sets() const { return _goal_sets; }
+
+  void save_states(const std::vector<State>& states);
+  std::vector<State> get_states() const { return _states; }
+
+  void save_transitions(const std::vector<Transition>& transitions);
+  std::vector<Transition> get_transitions() const { return _transitions; }
+
+  void save_agent_profiles(const std::vector<AgentProfile>& agent_profiles);
+  std::vector<AgentProfile> get_agent_profiles() const
+  {
+    return _agent_profiles;
+  }
+
+  void save_agent_groups(const std::vector<AgentGroup>& agent_groups);
+  std::vector<AgentGroup> get_agent_groups() const { return _agent_groups; }
+
+  void save_model_types(const std::vector<ModelType>& model_types);
+  std::vector<ModelType> get_model_types() const { return _model_types; }
+
+private:
+  // update from project.building in crowd_sim_table
+  std::set<std::string> _goal_areas;
+  std::vector<std::string> _navmesh_filename_list;
+
+  // real configurations
+  bool _enable_crowd_sim;
+  double _update_time_step;
+  std::vector<State> _states;
+  std::vector<GoalSet> _goal_sets;
+  std::vector<Transition> _transitions;
+  std::vector<AgentProfile> _agent_profiles;
+  std::vector<AgentGroup> _agent_groups;
+  std::vector<ModelType> _model_types;
+
+  void _initialize_state();
+  void _initialize_agent_profile();
+  void _initialize_agent_group();
+  void _initialize_model_type();
+
+  YAML::Node _output_obstacle_node() const;
+};
+
+using CrowdSimImplPtr = std::shared_ptr<CrowdSimImplementation>;
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/goal_set.h b/traffic_editor/include/traffic_editor/crowd_sim/goal_set.h
new file mode 100644
index 0000000..911f5e7
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/goal_set.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_GOAL_SET__H
+#define CROWD_SIM_GOAL_SET__H
+
+#include <string>
+#include <set>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+namespace crowd_sim {
+
+class GoalSet
+{
+public:
+  GoalSet(size_t goal_id)
+  : _id(goal_id),
+    _capacity(1),
+    _goal_area_contained({})
+  {}
+
+  GoalSet(const YAML::Node& input)
+  : _id(65535), //initialize with invalid id
+    _capacity(1),
+    _goal_area_contained({})
+  {
+    from_yaml(input);
+  }
+
+  void add_goal_area(std::string goal_area_name);
+  void set_capacity(size_t capacity) { this->_capacity = capacity; }
+
+  std::set<std::string> get_goal_areas() const
+  {
+    return this->_goal_area_contained;
+  }
+  YAML::Node get_goal_areas_to_yaml() const;
+  size_t get_goal_set_id() const { return this->_id; }
+  size_t get_capacity() const {return this->_capacity; }
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& input);
+
+private:
+  size_t _id;
+  size_t _capacity;
+  std::set<std::string> _goal_area_contained;
+
+  void _set_goal_set_id(size_t id_) { this->_id = id_; }
+};
+
+using GoalSetPtr = std::shared_ptr<GoalSet>;
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/model_type.h b/traffic_editor/include/traffic_editor/crowd_sim/model_type.h
new file mode 100644
index 0000000..ab307f5
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/model_type.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_MODEL_TYPE__H
+#define CROWD_SIM_MODEL_TYPE__H
+
+#include <string>
+#include <vector>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+namespace crowd_sim {
+
+class ModelType
+{
+public:
+  ModelType(std::string type_name, std::string animation_name)
+  : _name(type_name),
+    _animation(animation_name),
+    _animation_speed(0.2),
+    _model_uri(""),
+    _init_pose({0.0, 0.0, 0.0, 0.0, 0.0, 0.0})
+  {}
+
+  ModelType(const YAML::Node& input)
+  : _name("N.A"),
+    _animation("N.A"),
+    _animation_speed(0.2),
+    _model_uri(""),
+    _init_pose({0.0, 0.0, 0.0, 0.0, 0.0, 0.0})
+  {
+    from_yaml(input);
+  }
+
+  std::string get_name() const { return _name; }
+  std::string get_animation() const { return _animation; }
+  double get_animation_speed() const { return _animation_speed; }
+  std::string get_model_uri() const { return _model_uri; }
+  std::vector<double> get_init_pose() const { return _init_pose; }
+
+  void set_name(const std::string& type_name) { _name = type_name; }
+  void set_animation(const std::string& animation_name)
+  {
+    _animation = animation_name;
+  }
+  void set_animation_speed(double speed) { _animation_speed = speed; }
+  void set_model_uri(const std::string& model_uri) { _model_uri = model_uri; }
+  void set_init_pose(const std::vector<double>& init_pose)
+  {
+    _init_pose = init_pose;
+  }
+
+  // check model_uri is "model://"
+  bool is_valid() { return _model_uri.size() > 8; }
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& input);
+
+private:
+  std::string _name, _animation;
+  double _animation_speed;
+  std::string _model_uri;
+  std::vector<double> _init_pose;
+};
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/state.h b/traffic_editor/include/traffic_editor/crowd_sim/state.h
new file mode 100644
index 0000000..ecb17d6
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/state.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_STATE__H
+#define CROWD_SIM_STATE__H
+
+#include <string>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+namespace crowd_sim {
+class State
+{
+public:
+  State(std::string state_name)
+  : _name(state_name),
+    _navmesh_file_name(""),
+    _is_final_state(true),
+    _goal_set_id(-1)
+  {}
+
+  State(const YAML::Node& input)
+  : _name("N.A."),
+    _navmesh_file_name(""),
+    _is_final_state(true),
+    _goal_set_id(-1)
+  {
+    from_yaml(input);
+  }
+
+  void set_navmesh_file_name(std::string file_name)
+  {
+    this->_navmesh_file_name = file_name;
+  }
+  void set_final_state(bool is_final) { this->_is_final_state = is_final; }
+  void set_goal_set_id(size_t goal_set_id)
+  {
+    this->_goal_set_id = static_cast<int>(goal_set_id);
+  }
+  void set_name(std::string name) { this->_name = name; }
+
+  bool is_valid() const;
+  std::string get_name() const {return this->_name;}
+  std::string get_navmesh_file_name() const {return this->_navmesh_file_name;}
+  bool get_final_state() const {return this->_is_final_state;}
+  int get_goal_set_id() const {return this->_goal_set_id;}
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& input);
+
+private:
+  std::string _name;
+  std::string _navmesh_file_name;
+  bool _is_final_state;
+  int _goal_set_id;
+};
+
+using StatePtr = std::shared_ptr<State>;
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/crowd_sim/transition.h b/traffic_editor/include/traffic_editor/crowd_sim/transition.h
new file mode 100644
index 0000000..01e6c4f
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/crowd_sim/transition.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef CROWD_SIM_TRANSITION__H
+#define CROWD_SIM_TRANSITION__H
+
+#include <iostream>
+#include <string>
+#include <set>
+#include <memory>
+
+#include <yaml-cpp/yaml.h>
+
+#include <traffic_editor/crowd_sim/condition.h>
+
+namespace crowd_sim {
+
+class Transition
+{
+public:
+  using StateName = std::string;
+  //store the to_state_name and relevant weight
+  using ToStateType = std::map<StateName, double>;
+
+  Transition(StateName from_state_name)
+  : _from_state_name(from_state_name),
+    _to_state_name({}),
+    _condition(std::make_shared<Condition>())
+  {}
+
+  Transition(const YAML::Node& input)
+  : _from_state_name("N.A."),
+    _to_state_name({}),
+    _condition(std::make_shared<Condition>())
+  {
+    from_yaml(input);
+  }
+  ~Transition() {}
+
+  void set_from_state(StateName state_name)
+  {
+    this->_from_state_name = state_name;
+  }
+  std::string get_from_state() const { return this->_from_state_name; }
+
+  void add_to_state(StateName state_name, double weight = 1.0)
+  {
+    this->_to_state_name.insert(std::make_pair(state_name, weight) );
+  }
+  void delete_to_state(StateName state_name)
+  {
+    this->_to_state_name.erase(state_name);
+  }
+  ToStateType get_to_state() const
+  {
+    return this->_to_state_name;
+  }
+  void clear_to_state()
+  {
+    this->_to_state_name.clear();
+  }
+
+  void set_condition(ConditionPtr condition) { this->_condition = condition; }
+  ConditionPtr get_condition() const { return _condition; }
+
+  bool is_valid()
+  {
+    if (_condition->is_valid() &&
+      _to_state_name.size() > 0 &&
+      _from_state_name.size() > 0)
+      return true;
+    std::cout << "Invalid transition" << std::endl;
+    return false;
+  }
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& input);
+
+private:
+  StateName _from_state_name;
+  ToStateType _to_state_name;
+  ConditionPtr _condition;
+};
+
+} //namespace crowd_sim
+
+#endif
\ No newline at end of file
diff --git a/traffic_editor/include/traffic_editor/edge.h b/traffic_editor/include/traffic_editor/edge.h
new file mode 100644
index 0000000..49eee95
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/edge.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef EDGE_H
+#define EDGE_H
+
+#include <string>
+#include <map>
+
+#include <yaml-cpp/yaml.h>
+
+#include "param.h"
+#include <QString>
+
+
+class Edge
+{
+public:
+  int start_idx, end_idx;
+
+  enum Type
+  {
+    UNDEFINED = 0,
+    LANE,
+    WALL,
+    MEAS,
+    DOOR,
+    HUMAN_LANE,
+  } type;
+
+  bool selected;  // only for visualization, not saved to YAML
+
+  Edge();
+  Edge(const int _start_idx, const int _end_idx, const Type _type);
+  ~Edge();
+
+  std::map<std::string, Param> params;
+
+  void from_yaml(const YAML::Node& data, const Type edge_type);
+  YAML::Node to_yaml() const;
+
+  void set_param(const std::string& name, const std::string& value);
+
+  bool is_bidirectional() const;
+
+  void create_required_parameters();
+
+  template<typename T>
+  void create_param_if_needed(
+    const std::string& name,
+    const Param::Type& param_type,
+    const T& param_value);
+
+  std::string type_to_string() const;
+  QString type_to_qstring() const;
+  void set_graph_idx(const int idx);
+  int get_graph_idx() const;
+
+  double get_width() const;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/editor_model.h b/traffic_editor/include/traffic_editor/editor_model.h
new file mode 100644
index 0000000..508b12e
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/editor_model.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef EDITOR_MODEL_H
+#define EDITOR_MODEL_H
+
+/*
+ * Represents a simulation model class and related helpers for rendering.
+ */
+
+#include <string>
+#include <QPixmap>
+
+class EditorModel
+{
+public:
+  EditorModel(const std::string _name, const double _meters_per_pixel);
+  ~EditorModel();
+
+  std::string name, name_lowercase;
+  QPixmap pixmap;
+  double meters_per_pixel;
+
+  QPixmap get_pixmap();  // will load if needed
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/fiducial.h b/traffic_editor/include/traffic_editor/fiducial.h
new file mode 100644
index 0000000..9f9728a
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/fiducial.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef FIDUCIAL_H
+#define FIDUCIAL_H
+
+#include <map>
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+#include <quuid.h>
+
+class QGraphicsScene;
+
+
+class Fiducial
+{
+public:
+  double x = 0.0;
+  double y = 0.0;
+  std::string name;
+  QUuid uuid;
+
+  bool selected = false;
+
+  Fiducial();
+  Fiducial(double _x, double _y, const std::string& _name = std::string());
+
+  void from_yaml(const YAML::Node& data);
+  YAML::Node to_yaml() const;
+
+  void draw(QGraphicsScene*, const double meters_per_pixel) const;
+
+  double distance(const Fiducial& f);
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/layer.h b/traffic_editor/include/traffic_editor/layer.h
new file mode 100644
index 0000000..0f90f99
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/layer.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LAYER_H
+#define LAYER_H
+
+#include <string>
+
+#include <QPixmap>
+
+#include <yaml-cpp/yaml.h>
+
+
+class Layer
+{
+public:
+  Layer();
+  ~Layer();
+
+  std::string name;
+  std::string filename;
+  bool visible = true;
+
+  double meters_per_pixel = 0.05;  // relative to the parent floorplan scale
+  double translation_x = 0.0;
+  double translation_y = 0.0;
+  double rotation = 0.0;
+
+  QPixmap pixmap;
+
+  bool from_yaml(const std::string& name, const YAML::Node& data);
+  YAML::Node to_yaml() const;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/level.h b/traffic_editor/include/traffic_editor/level.h
new file mode 100644
index 0000000..dba66e0
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/level.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LEVEL_H
+#define LEVEL_H
+
+#include <yaml-cpp/yaml.h>
+#include <string>
+
+#include "edge.h"
+#include "fiducial.h"
+#include "layer.h"
+#include "model.h"
+#include "polygon.h"
+#include "vertex.h"
+
+#include <QPixmap>
+#include <QPainterPath>
+class QGraphicsScene;
+
+
+class Level
+{
+public:
+  Level();
+  ~Level();
+
+  std::string name;
+
+  std::vector<Vertex> vertices;
+  std::vector<Edge> edges;
+  std::vector<Polygon> polygons;
+
+  std::vector<Layer> layers;
+
+  // temporary, just for debugging polygon edge projection...
+  double polygon_edge_proj_x = 0.0;
+  double polygon_edge_proj_y = 0.0;
+
+  virtual bool from_yaml(const std::string& name, const YAML::Node& data) = 0;
+  virtual YAML::Node to_yaml() const = 0;
+
+  virtual bool delete_selected() = 0;
+
+  Polygon::EdgeDragPolygon polygon_edge_drag_press(
+    const Polygon* polygon,
+    const double x,
+    const double y);
+
+  virtual void clear_selection() = 0;
+
+  void add_vertex(const double x, const double y);
+  size_t get_vertex_by_id(QUuid vertex_id);
+
+protected:
+  double point_to_line_segment_distance(
+    const double x,
+    const double y,
+    const double x0,
+    const double y0,
+    const double x1,
+    const double y1,
+    double& x_proj,
+    double& y_proj);
+
+  void load_yaml_edge_sequence(
+    const YAML::Node& data,
+    const char* sequence_name,
+    const Edge::Type type);
+
+  bool parse_vertices(const YAML::Node& _data);
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/lift.h b/traffic_editor/include/traffic_editor/lift.h
new file mode 100644
index 0000000..c18616c
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/lift.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LIFT_H
+#define LIFT_H
+
+class QGraphicsScene;
+class QGraphicsView;
+
+/*
+ * This class represents a lift, including the shape of the lift cabin,
+ * the location and names of its doors, and the floors at which it can stop.
+ */
+
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+#include <cfloat>
+#include "building_level.h"
+#include "lift_door.h"
+
+
+class Lift
+{
+public:
+  std::string name;
+  std::string reference_floor_name;
+  std::string initial_floor_name;
+
+  // (x, y, yaw) of the cabin center, relative to reference_floor_name origin
+  double x = 0.0;
+  double y = 0.0;
+  double yaw = 0.0;
+
+  // for now, we will model all lift cabins as rectangles
+  double width = 1.0;  // meters
+  double depth = 1.0;  // meters
+
+  std::string highest_floor;  // highest floor the lift can reach
+  std::string lowest_floor;  // lowest floor the lift can reach
+  double highest_elevation = DBL_MAX;
+  double lowest_elevation = -DBL_MAX;
+
+  std::vector<LiftDoor> doors;
+
+  // Many lifts have multiple sets of doors which open depending on the
+  // level the lift is visiting. In the most complex case, multiple
+  // sets of doors can open on a level, so unfortunately, the data
+  // structure needs to cater for this, even though it is not common.
+  // If a (level name, door name) combination is not in this data structure,
+  // that means that the door does not open on this level.
+  // It is possible (and expected) that some lifts do not go to all levels,
+  // and that some lifts skip some levels, so this data structure is
+  // expected to be "sparse"
+  typedef std::list<std::string> DoorNameList;
+  typedef std::map<std::string, DoorNameList> LevelDoorMap;
+  LevelDoorMap level_doors;
+
+  // When this option is false, it indicates that a lift plugin and its lift
+  // door plugins should not be included when building the simulation world.
+  // This will help speed up the simulation as well as represent lifts that are
+  // not accessible by AGVs.
+  bool plugins = true;
+
+  ////////////////////////////////////////////////////////////////////////
+
+  Lift();
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const std::string& _name, const YAML::Node& data,
+    const std::vector<BuildingLevel>& levels);
+
+  void draw(
+    QGraphicsScene* scene,
+    const double meters_per_pixel,
+    const std::string& level_name,
+    const double elevation,
+    const bool apply_transformation = true,
+    const double scale = 1.0,
+    const double translate_x = 0.0,
+    const double translate_y = 0.0) const;
+
+  bool level_door_opens(
+    const std::string& level_name,
+    const std::string& door_name,
+    const std::vector<BuildingLevel>& levels) const;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/lift_door.h b/traffic_editor/include/traffic_editor/lift_door.h
new file mode 100644
index 0000000..45bee5b
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/lift_door.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef LIFT_DOOR_H
+#define LIFT_DOOR_H
+
+#include <yaml-cpp/yaml.h>
+
+
+class LiftDoor
+{
+public:
+  std::string name;
+
+  double x = 0.0;  // center of door, relative to the cabin center
+  double y = 0.5;  // center of door, relative to the cabin center
+
+  double width = 1.0;  // doorway width in meters when fully opened
+
+  // Motion axis is defined relative to the cabin orientation.
+  // Typically it will be 0 or pi/2.
+  double motion_axis_orientation = 0.0;
+
+  enum DoorType
+  {
+    UNDEFINED = 0,
+    SINGLE_SLIDING,
+    DOUBLE_SLIDING,
+    SINGLE_TELESCOPE,
+    DOUBLE_TELESCOPE
+  } door_type = DOUBLE_SLIDING;
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const std::string& _name, const YAML::Node& data);
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/model.h b/traffic_editor/include/traffic_editor/model.h
new file mode 100644
index 0000000..fc3c657
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/model.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef MODEL_H
+#define MODEL_H
+
+/*
+ * This class represents an instance of a model on a navigation map
+ * The pixmap for visualization is stored in the EditorModel class; this
+ * class instead represents the _placement_ of a Model reference on
+ * a map.
+ */
+
+#include "editor_model.h"
+#include "model_state.h"
+
+#include <string>
+#include <algorithm>
+#include <yaml-cpp/yaml.h>
+#include <QGraphicsScene>
+#include <QUuid>
+
+class Building;
+class QGraphicsPixmapItem;
+
+
+class Model
+{
+public:
+  ModelState state;
+
+  std::string model_name;
+  std::string instance_name;
+  bool selected = false;  // only for visualization, not saved to YAML
+  bool is_static = true;
+  bool is_active = false;
+  bool error_printed = false;
+  std::string starting_level;  // used when resetting a test scenario
+  QGraphicsPixmapItem* pixmap_item = nullptr;
+  QUuid uuid;
+
+  Model();
+
+  YAML::Node to_yaml() const;
+  void from_yaml(const YAML::Node& data, const std::string& level_name);
+
+  void set_param(const std::string& name, const std::string& value);
+
+  void draw(
+    QGraphicsScene* scene,
+    std::vector<EditorModel>& editor_models,
+    const double meters_per_pixel);
+
+  void clear_scene();
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/model_state.h b/traffic_editor/include/traffic_editor/model_state.h
new file mode 100644
index 0000000..c4a69a6
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/model_state.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef MODEL_STATE_H
+#define MODEL_STATE_H
+
+#include <string>
+
+class ModelState
+{
+public:
+  double x = 0.0;
+  double y = 0.0;
+  double z = 0.0;
+  double yaw = 0.0;
+  std::string level_name;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/param.h b/traffic_editor/include/traffic_editor/param.h
new file mode 100644
index 0000000..1dff577
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/param.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef PARAM_H
+#define PARAM_H
+
+#include <string>
+
+#include <yaml-cpp/yaml.h>
+#include <QString>
+
+
+class Param
+{
+public:
+  enum Type
+  {
+    UNDEFINED = 0,
+    STRING,
+    INT,
+    DOUBLE,
+    BOOL
+  } type;
+
+  Param();
+  ~Param();
+  Param(const std::string& s);
+  Param(const int& i);
+  Param(const double& d);
+  Param(const bool& b);
+  Param(const Type& t);
+
+  void from_yaml(const YAML::Node& data);
+  YAML::Node to_yaml() const;
+
+  int value_int;
+  double value_double;
+  std::string value_string;
+  bool value_bool;
+
+  void set(const std::string& value);
+
+  QString to_qstring() const;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/polygon.h b/traffic_editor/include/traffic_editor/polygon.h
new file mode 100644
index 0000000..65fa382
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/polygon.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef POLYGON_H
+#define POLYGON_H
+
+#include <map>
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+
+#include <QPolygonF>
+
+#include "param.h"
+
+
+class Polygon
+{
+public:
+  std::vector<int> vertices;
+  bool selected = false;
+
+  std::map<std::string, Param> params;
+
+  enum Type
+  {
+    UNDEFINED = 0,
+    FLOOR,
+    ZONE,
+    ROI,
+    HOLE
+  } type = UNDEFINED;
+
+  Polygon();
+  ~Polygon();
+
+  void from_yaml(const YAML::Node& data, const Type polygon_type);
+  YAML::Node to_yaml() const;
+
+  void remove_vertex(const int vertex_idx);
+
+  struct EdgeDragPolygon
+  {
+    QPolygonF polygon;
+    int movable_vertex = -1;
+  };
+
+  void set_param(const std::string& name, const std::string& value);
+  void create_required_parameters();
+
+  template<typename T>
+  void create_param_if_needed(
+    const std::string& name,
+    const Param::Type& param_type,
+    const T& param_value);
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/rendering_options.h b/traffic_editor/include/traffic_editor/rendering_options.h
new file mode 100644
index 0000000..8b15767
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/rendering_options.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef RENDERING_OPTIONS_H
+#define RENDERING_OPTIONS_H
+
+class RenderingOptions
+{
+public:
+  static const int NUM_BUILDING_LANES = 10;
+  std::array<bool, NUM_BUILDING_LANES> show_building_lanes;
+
+  bool show_models = true;
+};
+
+#endif
diff --git a/traffic_editor/include/traffic_editor/vertex.h b/traffic_editor/include/traffic_editor/vertex.h
new file mode 100644
index 0000000..5eebd6a
--- /dev/null
+++ b/traffic_editor/include/traffic_editor/vertex.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2019 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef VERTEX_H
+#define VERTEX_H
+
+#include <QUuid>
+#include <map>
+#include <string>
+#include <vector>
+#include <yaml-cpp/yaml.h>
+
+#include <QColor>
+
+#include "param.h"
+
+class QGraphicsScene;
+
+
+class Vertex
+{
+public:
+  double x;
+  double y;
+  std::string name;
+
+  bool selected;
+
+  QUuid uuid;
+  std::map<std::string, Param> params;
+
+  Vertex();
+  Vertex(double _x, double _y, const std::string& _name = std::string());
+
+  void from_yaml(const YAML::Node& data);
+  YAML::Node to_yaml() const;
+
+  void set_param(const std::string& name, const std::string& value);
+
+  void draw(
+    QGraphicsScene* scene,
+    const double radius,
+    const QColor& color) const;
+
+  ////////////////////////////////////////////////////////////
+  static const std::vector<std::pair<std::string, Param::Type>> allowed_params;
+};
+
+#endif
diff --git a/traffic_editor/package.xml b/traffic_editor/package.xml
new file mode 100644
index 0000000..6efeed8
--- /dev/null
+++ b/traffic_editor/package.xml
@@ -0,0 +1,22 @@
+<?xml version="1.0"?>
+<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
+<package format="3">
+  <name>traffic_editor</name>
+  <version>1.2.0</version>
+  <description>traffic editor</description>
+  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
+  <license>Apache License 2.0</license>
+
+  <build_depend>ament_cmake</build_depend>
+  <build_depend>ament_index_cpp</build_depend>
+  <build_depend>ignition-plugin</build_depend>
+  <build_depend>ignition-common3</build_depend>
+  <build_depend>yaml-cpp</build_depend>
+  <build_depend>libqt5-concurrent</build_depend>
+  <build_depend>libqt5-widgets</build_depend>
+  <build_depend>qtbase5-dev</build_depend>
+    
+  <export>
+    <build_type>ament_cmake</build_type>
+  </export>
+</package>
diff --git a/traffic_editor/plugins/simulation.h b/traffic_editor/plugins/simulation.h
new file mode 100644
index 0000000..90dad17
--- /dev/null
+++ b/traffic_editor/plugins/simulation.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2019-2020 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#ifndef PLUGINS_SIMULATION_H
+#define PLUGINS_SIMULATION_H
+
+#include "traffic_editor/building.h"
+
+class QGraphicsScene;
+
+class Simulation
+{
+public:
+  virtual ~Simulation() = default;
+
+  virtual void load(const YAML::Node& config_data) = 0;
+  virtual void tick(Building& building) = 0;
+  virtual void reset(Building& building) = 0;
+
+  virtual void scene_update(
+    QGraphicsScene* scene,
+    Building& building,
+    const int level_idx) = 0;
+
+  virtual void scene_clear() = 0;
+};
+
+#endif
diff --git a/traffic_editor/resources/icons/door.svg b/traffic_editor/resources/icons/door.svg
new file mode 100644
index 0000000..beb2a42
--- /dev/null
+++ b/traffic_editor/resources/icons/door.svg
@@ -0,0 +1,77 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="door.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="11.2"
+     inkscape:cx="27.100113"
+     inkscape:cy="33.864481"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="1920"
+     inkscape:window-height="1027"
+     inkscape:window-x="0"
+     inkscape:window-y="25"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:none;stroke:#000000;stroke-width:0.265;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
+       d="m 4.6274451,295.74794 v -14.31585 h 8.1812699 l 0.01885,14.29223 z"
+       id="path815"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc" />
+    <circle
+       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26499999;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="path817"
+       cx="11.528274"
+       cy="289.65305"
+       r="0.49609375" />
+    <rect
+       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.29922625;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="rect821"
+       width="5.7535338"
+       height="5.1629467"
+       x="5.8284969"
+       y="282.58313" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/fiducial.svg b/traffic_editor/resources/icons/fiducial.svg
new file mode 100644
index 0000000..dfd317f
--- /dev/null
+++ b/traffic_editor/resources/icons/fiducial.svg
@@ -0,0 +1,93 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933333 16.933334"
+   version="1.1"
+   id="svg19"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="fiducial.svg">
+  <defs
+     id="defs13">
+    <marker
+       inkscape:stockid="Arrow1Lend"
+       orient="auto"
+       refY="0.0"
+       refX="0.0"
+       id="Arrow1Lend"
+       style="overflow:visible;"
+       inkscape:isstock="true">
+      <path
+         id="path4555"
+         d="M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z "
+         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#999999;fill-opacity:1"
+         transform="scale(0.8) rotate(180) translate(12.5,0)" />
+    </marker>
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="16"
+     inkscape:cx="64.533408"
+     inkscape:cy="32.137345"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="3840"
+     inkscape:window-height="2132"
+     inkscape:window-x="3840"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1"
+     inkscape:measure-start="-22.7284,31.8198"
+     inkscape:measure-end="7.82868,32.5774" />
+  <metadata
+     id="metadata16">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <circle
+       style="fill:none;stroke:#000000;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none"
+       id="path40"
+       cx="8.4666672"
+       cy="288.53333"
+       r="5.8462968" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="M 0.26458333,288.53332 H 16.66875"
+       id="path12"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="M 8.4666667,280.33123 V 296.7354"
+       id="path12-3"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/floor.svg b/traffic_editor/resources/icons/floor.svg
new file mode 100644
index 0000000..8632e08
--- /dev/null
+++ b/traffic_editor/resources/icons/floor.svg
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="floor.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="11.2"
+     inkscape:cx="23.307062"
+     inkscape:cy="26.535094"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="1920"
+     inkscape:window-height="1027"
+     inkscape:window-x="0"
+     inkscape:window-y="25"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:#9d9d9d;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 1.8544457,294.89749 v -7.21698 h 7.1815476 v -6.07124 h 6.4610307 v 10.97312 z"
+       id="path3718"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccccc" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/hole.svg b/traffic_editor/resources/icons/hole.svg
new file mode 100644
index 0000000..fecf43a
--- /dev/null
+++ b/traffic_editor/resources/icons/hole.svg
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="floor_hole.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="7.919596"
+     inkscape:cx="12.655125"
+     inkscape:cy="20.619827"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="1920"
+     inkscape:window-height="1027"
+     inkscape:window-x="0"
+     inkscape:window-y="25"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:#9d9d9d;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 1.8544457,294.89749 v -7.21698 h 7.1815476 v -6.07124 h 6.4610307 v 10.97312 z"
+       id="path3718"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccccc" />
+    <path
+       style="fill:#ffffff;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"
+       d="m 7.7248884,290.62163 5.1026786,-4.08686 0.377976,5.31529 z"
+       id="path831"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/measurement.svg b/traffic_editor/resources/icons/measurement.svg
new file mode 100644
index 0000000..6c6e359
--- /dev/null
+++ b/traffic_editor/resources/icons/measurement.svg
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="measurement.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="11.2"
+     inkscape:cx="6.6106333"
+     inkscape:cy="32.695808"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="1920"
+     inkscape:window-height="1027"
+     inkscape:window-x="0"
+     inkscape:window-y="25"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:none;stroke:#f758ea;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="M 2.3151041,291.75557 14.882812,284.19604"
+       id="path833"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <circle
+       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.265;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
+       id="path816"
+       cx="2.3032923"
+       cy="291.67288"
+       r="1.7634745" />
+    <circle
+       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26499999;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="path816-3"
+       cx="14.811942"
+       cy="284.1488"
+       r="1.7634746" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/move.svg b/traffic_editor/resources/icons/move.svg
new file mode 100644
index 0000000..54300f1
--- /dev/null
+++ b/traffic_editor/resources/icons/move.svg
@@ -0,0 +1,92 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="move.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="22.4"
+     inkscape:cx="56.802761"
+     inkscape:cy="26.1421"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="3840"
+     inkscape:window-height="2132"
+     inkscape:window-x="3840"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <rect
+       style="fill:#000000;stroke-width:0.30093893"
+       id="rect8"
+       width="2.1764336"
+       height="11.822602"
+       x="7.5017977"
+       y="282.69199" />
+    <rect
+       style="fill:#000000;stroke-width:0.30093893"
+       id="rect10"
+       width="11.527037"
+       height="2.4182594"
+       x="2.7996266"
+       y="287.36731" />
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 0.73614025,288.54953 3.62765145,-2.55579 v 5.24849 z"
+       id="path14"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 16.212895,288.57437 -3.627652,-2.55578 v 5.24848 z"
+       id="path14-3"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 8.733064,296.34817 2.815297,-3.29326 H 5.7669502 Z"
+       id="path14-3-6"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 8.5573865,280.88938 2.8152975,3.29326 H 5.5912728 Z"
+       id="path14-3-6-7"
+       inkscape:connector-curvature="0" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/roi.svg b/traffic_editor/resources/icons/roi.svg
new file mode 100644
index 0000000..8068fda
--- /dev/null
+++ b/traffic_editor/resources/icons/roi.svg
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="roi.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="22.4"
+     inkscape:cx="32.521772"
+     inkscape:cy="27.966633"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="3840"
+     inkscape:window-height="2107"
+     inkscape:window-x="0"
+     inkscape:window-y="25"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:#fff93b;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 1.8544457,294.89749 v -7.21698 h 7.1815476 v -6.07124 h 6.4610307 v 10.97312 z"
+       id="path3718"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccccc" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/rotate.svg b/traffic_editor/resources/icons/rotate.svg
new file mode 100644
index 0000000..c4d9a3e
--- /dev/null
+++ b/traffic_editor/resources/icons/rotate.svg
@@ -0,0 +1,99 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933333 16.933334"
+   version="1.1"
+   id="svg19"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="rotate.svg">
+  <defs
+     id="defs13">
+    <marker
+       inkscape:stockid="Arrow1Lend"
+       orient="auto"
+       refY="0.0"
+       refX="0.0"
+       id="Arrow1Lend"
+       style="overflow:visible;"
+       inkscape:isstock="true">
+      <path
+         id="path4555"
+         d="M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z "
+         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#999999;fill-opacity:1"
+         transform="scale(0.8) rotate(180) translate(12.5,0)" />
+    </marker>
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="15.839192"
+     inkscape:cx="26.167374"
+     inkscape:cy="32.289048"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="3840"
+     inkscape:window-height="2132"
+     inkscape:window-x="3840"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1"
+     inkscape:measure-start="-22.7284,31.8198"
+     inkscape:measure-end="7.82868,32.5774" />
+  <metadata
+     id="metadata16">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:none;stroke:#000000;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none"
+       id="path40"
+       sodipodi:type="arc"
+       sodipodi:cx="8.5359201"
+       sodipodi:cy="288.24695"
+       sodipodi:rx="5.8033128"
+       sodipodi:ry="5.8033128"
+       sodipodi:start="2.1655519"
+       sodipodi:end="0.92116654"
+       sodipodi:open="true"
+       d="m 5.2842873,293.05375 a 5.8033128,5.8033128 0 0 1 -2.3197665,-6.43098 5.8033128,5.8033128 0 0 1 5.4121932,-4.17695 5.8033128,5.8033128 0 0 1 5.633139,3.87382 5.8033128,5.8033128 0 0 1 -1.963557,6.54853" />
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 10.590555,294.64467 0.584652,-3.20723 2.438834,2.25509 z"
+       id="path4838"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccc" />
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 6.4834057,294.562 -0.584652,-3.20723 -2.438834,2.25509 z"
+       id="path4838-3"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccc" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/select.svg b/traffic_editor/resources/icons/select.svg
new file mode 100644
index 0000000..2b66ea7
--- /dev/null
+++ b/traffic_editor/resources/icons/select.svg
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933333 16.933334"
+   version="1.1"
+   id="svg4861"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="select.svg">
+  <defs
+     id="defs4855" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="15.839192"
+     inkscape:cx="34.481937"
+     inkscape:cy="43.697704"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     inkscape:window-width="3840"
+     inkscape:window-height="2132"
+     inkscape:window-x="3840"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1"
+     units="px" />
+  <metadata
+     id="metadata4858">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:#000000;stroke:#000000;stroke-width:0.35283428px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+       d="m 5.4563332,281.5101 v 11.44989 l 2.6731238,-1.06925 1.2697335,3.76464 2.0493945,-0.82421 -1.336562,-3.67555 2.433616,-0.93 z"
+       id="path4882"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cccccccc" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/vertex.svg b/traffic_editor/resources/icons/vertex.svg
new file mode 100644
index 0000000..52db02e
--- /dev/null
+++ b/traffic_editor/resources/icons/vertex.svg
@@ -0,0 +1,64 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="add_vertex.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="11.2"
+     inkscape:cx="49.261772"
+     inkscape:cy="8.1624995"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="3840"
+     inkscape:window-height="2132"
+     inkscape:window-x="3840"
+     inkscape:window-y="0"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <circle
+       style="fill:#008000;stroke-width:0.52625465"
+       id="path29"
+       cx="8.5292225"
+       cy="288.44189"
+       r="4.9172764" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/icons/wall.svg b/traffic_editor/resources/icons/wall.svg
new file mode 100644
index 0000000..2f2fae9
--- /dev/null
+++ b/traffic_editor/resources/icons/wall.svg
@@ -0,0 +1,76 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="64"
+   height="64"
+   viewBox="0 0 16.933334 16.933334"
+   version="1.1"
+   id="svg8"
+   inkscape:version="0.92.3 (2405546, 2018-03-11)"
+   sodipodi:docname="wall.svg">
+  <defs
+     id="defs2" />
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="11.2"
+     inkscape:cx="23.574919"
+     inkscape:cy="33.052951"
+     inkscape:document-units="mm"
+     inkscape:current-layer="layer1"
+     showgrid="false"
+     units="px"
+     inkscape:window-width="1920"
+     inkscape:window-height="1027"
+     inkscape:window-x="0"
+     inkscape:window-y="25"
+     inkscape:window-maximized="1" />
+  <metadata
+     id="metadata5">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title />
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Layer 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(0,-280.06665)">
+    <path
+       style="fill:none;stroke:#1812f4;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       d="M 2.3151041,291.75557 14.882812,284.19604"
+       id="path833"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="cc" />
+    <circle
+       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.265;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
+       id="path816"
+       cx="2.3032923"
+       cy="291.67288"
+       r="1.7634745" />
+    <circle
+       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26499999;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
+       id="path816-3"
+       cx="14.811942"
+       cy="284.1488"
+       r="1.7634746" />
+  </g>
+</svg>
diff --git a/traffic_editor/resources/resource.qrc b/traffic_editor/resources/resource.qrc
new file mode 100644
index 0000000..f6141bb
--- /dev/null
+++ b/traffic_editor/resources/resource.qrc
@@ -0,0 +1,16 @@
+<!DOCTYPE RCC>
+<RCC version="1.0">
+<qresource>
+  <file>icons/vertex.svg</file>
+  <file>icons/move.svg</file>
+  <file>icons/rotate.svg</file>
+  <file>icons/select.svg</file>
+  <file>icons/fiducial.svg</file>
+  <file>icons/roi.svg</file>
+  <file>icons/floor.svg</file>
+  <file>icons/hole.svg</file>
+  <file>icons/wall.svg</file>
+  <file>icons/door.svg</file>
+  <file>icons/measurement.svg</file>
+</qresource>
+</RCC>
diff --git a/traffic_editor/scripts/generate_model_list.py b/traffic_editor/scripts/generate_model_list.py
new file mode 100755
index 0000000..79398d4
--- /dev/null
+++ b/traffic_editor/scripts/generate_model_list.py
@@ -0,0 +1,78 @@
+#!/usr/bin/env python3
+
+# Copyright 2020 Open Source Robotics Foundation, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import pit_crew
+
+import sys
+import yaml
+import argparse
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument(
+        'output_yaml',
+        help='Output yaml file that the directory of models will be added to.'
+    )
+    parser.add_argument(
+        '-d', '--model-dir', help='Directory of models to be added.'
+    )
+    parser.add_argument(
+        '-b', '--blacklist-models', default='',
+        help='Optional blacklisted models that will be excluded from your '
+        'model directory'
+    )
+    parser.add_argument(
+        '--meters-per-pixel', type=float, default=0.004,
+        help='Scale of models in meters per pixel for the images.'
+    )
+    args = parser.parse_args(sys.argv[1:])
+
+    y = {}
+    y['models'] = []
+
+    blacklist_yaml = None
+    if args.blacklist_models != '':
+        print('Blacklisted models:')
+        with open(args.blacklist_models) as f:
+            blacklist_yaml = yaml.load(f)
+            print(blacklist_yaml)
+
+    models = pit_crew.get_local_model_name_tuples(path=args.model_dir,
+                                                  lower=False,
+                                                  use_dir_as_name=True)
+
+    for model in models:
+        if blacklist_yaml is not None and \
+                model.model_name in blacklist_yaml['blacklist']:
+            print('ignoring {} because it is blacklisted'.format(
+                    model.model_name))
+            continue
+
+        if model.author_name:
+            y['models'].append("%s/%s" % (model.author_name,
+                                          model.model_name))
+        else:
+            y['models'].append(model.model_name)
+
+    assert len(y['models']) > 0, "No models found!"
+    print('found {} models'.format(len(y['models'])))
+
+    y['models'] = sorted(y['models'], key=lambda s: s.lower())
+    y['meters_per_pixel'] = 0.004
+
+    with open(args.output_yaml, 'w') as f:
+        yaml.dump(y, f, default_flow_style=False)
diff --git a/traffic_editor/scripts/generate_thumbnails.py b/traffic_editor/scripts/generate_thumbnails.py
new file mode 100755
index 0000000..7a819d6
--- /dev/null
+++ b/traffic_editor/scripts/generate_thumbnails.py
@@ -0,0 +1,79 @@
+#!/usr/bin/env python
+
+# Copyright 2020 Open Source Robotics Foundation, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import os
+import sys
+import yaml
+import argparse
+
+
+class ThumbnailsGenerator:
+    def __init__(self, argv=sys.argv):
+        parser = argparse.ArgumentParser()
+        parser.add_argument(
+                'models_dir', default='~/.gazebo/models',
+                help='Directory of models to be added')
+        parser.add_argument(
+                'model_list', default='../test/model_list.yaml',
+                help='Path of model_list.yaml')
+        parser.add_argument(
+                'output_dir', default='.',
+                help='Directory where the output images will be saved')
+        # Optional arguments
+        parser.add_argument(
+                '--size', dest='img_size', default=4000,
+                help='Output thumbnail Image pixel size')
+        parser.add_argument(
+                '--height', dest='cam_height', default=200,
+                help='Scene camara height')
+        parser.add_argument(
+                '--hfov', dest='cam_hfov', default=0.08,
+                help='Scene camera horizontal FOV')
+        args = parser.parse_args(argv[1:])
+
+        self.output_dir = args.output_dir
+        self.models_dir = args.models_dir
+        self.img_size = args.img_size
+        self.cam_height = args.cam_height
+        self.cam_hfov = args.cam_hfov
+
+        self.yaml = None
+        with open(args.model_list) as f:
+            self.yaml = yaml.load(f)
+        print(self.yaml)
+
+    def run(self):
+        for full_model_name in self.yaml['models']:
+            model_name = full_model_name.split("/")[-1]
+            sdf_path = "{}/{}/model.sdf".format(self.models_dir, model_name)
+
+            if os.path.exists(sdf_path) is False:
+                print(" Warn!! {} doesnt exist, skip!".format(model_name))
+                continue
+
+            command = "gzserver -s libthumbnail_generator.so \
+                    empty.world --input '{}' --output '{}' \
+                    --img-size {} --cam-height {} --cam-hfov {} ".format(
+                    sdf_path, self.output_dir, self.img_size,
+                    self.cam_height, self.cam_hfov)
+            print("------------------------------------------------------")
+            os.system(command)
+
+
+if __name__ == '__main__':
+    thumbnails_generator = ThumbnailsGenerator(sys.argv)
+    thumbnails_generator.run()
+    print("Done All")
diff --git a/traffic_editor/scripts/merge_model_lists.py b/traffic_editor/scripts/merge_model_lists.py
new file mode 100755
index 0000000..081a0ee
--- /dev/null
+++ b/traffic_editor/scripts/merge_model_lists.py
@@ -0,0 +1,64 @@
+#!/usr/bin/env python
+
+# Copyright 2020 Open Source Robotics Foundation, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import os
+import sys
+import yaml
+import argparse
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument(
+        'destination',
+        help='Destination list of models which the source will be '
+        'merged into.'
+    )
+    parser.add_argument('-s', '--source', help='Source list of models.')
+    args = parser.parse_args(sys.argv[1:])
+
+    if not os.path.exists(args.source):
+        print('Source model list not found: {}'.format(args.source))
+        exit()
+    if not os.path.exists(args.destination):
+        print('Destination model list not found: {}'.format(args.destination))
+        exit()
+
+    source_yaml = None
+    with open(args.source) as f:
+        source_yaml = yaml.load(f)
+
+    destination_yaml = None
+    with open(args.destination) as f:
+        destination_yaml = yaml.load(f)
+
+    if abs(source_yaml['meters_per_pixel'] -
+            destination_yaml['meters_per_pixel']) > 1e-6:
+        print('Both model lists have different meters_per_pixel.')
+        exit()
+
+    for model_name in source_yaml['models']:
+        if model_name in destination_yaml['models']:
+            print('Skipping model {} because it already exists'.format(
+                    model_name))
+            continue
+        destination_yaml['models'].append(model_name)
+
+    destination_yaml['models'] = sorted(
+            destination_yaml['models'], key=lambda s: s.lower())
+
+    with open(args.destination, 'w') as f:
+        yaml.dump(destination_yaml, f, default_flow_style=False)
diff --git a/traffic_editor/scripts/sort_model_list.py b/traffic_editor/scripts/sort_model_list.py
new file mode 100755
index 0000000..3382301
--- /dev/null
+++ b/traffic_editor/scripts/sort_model_list.py
@@ -0,0 +1,43 @@
+#!/usr/bin/env python
+
+# Copyright 2020 Open Source Robotics Foundation, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import os
+import sys
+import yaml
+import argparse
+
+
+if __name__ == '__main__':
+    parser = argparse.ArgumentParser()
+    parser.add_argument(
+        'model_list',
+        help='model_list.yaml file that needs to be sorted.'
+    )
+    args = parser.parse_args(sys.argv[1:])
+
+    if not os.path.exists(args.model_list):
+        print('Model list file not found: {}'.format(args.source))
+        exit()
+
+    model_list_yaml = None
+    with open(args.model_list) as f:
+        model_list_yaml = yaml.load(f)
+
+    model_list_yaml['models'] = sorted(
+            model_list_yaml['models'], key=lambda s: s.lower())
+
+    with open(args.model_list, 'w') as f:
+        yaml.dump(model_list_yaml, f, default_flow_style=False)
diff --git a/traffic_editor/test/model_blacklist.yaml b/traffic_editor/test/model_blacklist.yaml
new file mode 100644
index 0000000..3461878
--- /dev/null
+++ b/traffic_editor/test/model_blacklist.yaml
@@ -0,0 +1,2 @@
+blacklist:
+- Humans
diff --git a/traffic_editor/test/model_list.yaml b/traffic_editor/test/model_list.yaml
new file mode 100644
index 0000000..d8c2157
--- /dev/null
+++ b/traffic_editor/test/model_list.yaml
@@ -0,0 +1,5 @@
+meters_per_pixel: 0.004
+models:
+  - ambulance
+  - beer
+  - coke_can
-- 
2.25.1

