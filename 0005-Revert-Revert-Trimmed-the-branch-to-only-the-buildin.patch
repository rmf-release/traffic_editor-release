From 3a5471f581f24b20f8dea4bb96f3ed53663458b9 Mon Sep 17 00:00:00 2001
From: "Marco A. Gutierrez" <marco@openrobotics.org>
Date: Thu, 7 Jan 2021 16:53:05 +0800
Subject: [PATCH 5/9] Revert "Revert "Trimmed the branch to only the
 building_map_tools sub directory""

This reverts commit 443d239e2cbbd34e918ab26118b3ab272815e241.
---
 .github/workflows/build.yaml                  |   40 -
 .github/workflows/style.yaml                  |   22 -
 .../CHANGELOG.rst => CHANGELOG.rst            |    0
 README.md                                     |   24 -
 .../building_map => building_map}/__init__.py |    0
 .../building_map => building_map}/building.py |    0
 .../doors/__init__.py                         |    0
 .../doors/door.py                             |    0
 .../doors/double_sliding_door.py              |    0
 .../doors/double_swing_door.py                |    0
 .../doors/sliding_door.py                     |    0
 .../doors/swing_door.py                       |    0
 .../building_map => building_map}/edge.py     |    0
 .../etree_utils.py                            |    0
 .../building_map => building_map}/fiducial.py |    0
 .../building_map => building_map}/floor.py    |    0
 .../generator.py                              |    0
 .../building_map => building_map}/hole.py     |    0
 .../building_map => building_map}/level.py    |    0
 .../building_map => building_map}/lift.py     |    0
 .../building_map => building_map}/model.py    |    0
 .../param_value.py                            |    0
 .../templates/gz_world.sdf                    |    0
 .../templates/ign_world.sdf                   |    0
 .../transform.py                              |    0
 .../building_map => building_map}/utils.py    |    0
 .../building_map => building_map}/vertex.py   |    0
 .../building_map => building_map}/wall.py     |    0
 .../__init__.py                               |    0
 .../_init_argparse.py                         |    0
 .../building_map_generator.py                 |    0
 .../textures/beige_tiles.png                  |  Bin
 .../textures/blue_linoleum.png                |  Bin
 .../textures/blue_linoleum_high_contrast.png  |  Bin
 .../textures/brown_marble.png                 |  Bin
 .../textures/carpark_walkway.png              |  Bin
 .../textures/concrete.png                     |  Bin
 .../textures/concrete2.png                    |  Bin
 .../textures/concrete3.png                    |  Bin
 .../textures/concrete4.png                    |  Bin
 .../textures/default.png                      |  Bin
 .../textures/gray_flooring.png                |  Bin
 .../textures/red_tiles.png                    |  Bin
 .../textures/wall.png                         |  Bin
 .../textures/white_marble.png                 |  Bin
 .../__init__.py                               |    0
 .../building_map_model_downloader.py          |    0
 building_map_msgs/CHANGELOG.rst               |   25 -
 building_map_msgs/CMakeLists.txt              |   46 -
 building_map_msgs/msg/AffineImage.msg         |    7 -
 building_map_msgs/msg/BuildingMap.msg         |    3 -
 building_map_msgs/msg/Door.msg                |   44 -
 building_map_msgs/msg/Graph.msg               |    4 -
 building_map_msgs/msg/GraphEdge.msg           |    9 -
 building_map_msgs/msg/GraphNode.msg           |    4 -
 building_map_msgs/msg/Level.msg               |    7 -
 building_map_msgs/msg/Lift.msg                |   14 -
 building_map_msgs/msg/Param.msg               |   13 -
 building_map_msgs/msg/Place.msg               |    6 -
 building_map_msgs/package.xml                 |   29 -
 building_map_msgs/srv/GetBuildingMap.srv      |    2 -
 .../__init__.py                               |    0
 .../building_map_server.py                    |    0
 .../test/test_map_client.py                   |    0
 .../building_gazebo_plugins/CHANGELOG.rst     |   39 -
 .../building_gazebo_plugins/CMakeLists.txt    |  191 --
 .../building_gazebo_plugins/package.xml       |   37 -
 .../src/crowd_simulator.cpp                   |  318 ---
 .../src/crowd_simulator.hpp                   |   92 -
 .../building_gazebo_plugins/src/door.cpp      |  110 -
 .../building_gazebo_plugins/src/lift.cpp      |   95 -
 .../building_gazebo_plugins/src/slotcar.cpp   |  151 --
 .../src/thumbnail_generator.cpp               |  317 ---
 .../src/toggle_floors.cpp                     |  136 -
 .../building_ignition_plugins/CHANGELOG.rst   |   12 -
 .../building_ignition_plugins/CMakeLists.txt  |  180 --
 .../building_ignition_plugins/package.xml     |   30 -
 .../src/crowd_simulator.cpp                   |  429 ---
 .../src/crowd_simulator.hpp                   |   91 -
 .../building_ignition_plugins/src/door.cpp    |  158 --
 .../building_ignition_plugins/src/lift.cpp    |  146 -
 .../building_ignition_plugins/src/slotcar.cpp |  220 --
 .../building_plugins_common/CHANGELOG.rst     |   15 -
 .../building_plugins_common/CMakeLists.txt    |  174 --
 .../crowd_simulator_common.hpp                |  434 ---
 .../building_sim_common/door_common.hpp       |  265 --
 .../building_sim_common/lift_common.hpp       |  263 --
 .../building_sim_common/slotcar_common.hpp    |  252 --
 .../include/building_sim_common/utils.hpp     |  234 --
 .../building_plugins_common/package.xml       |   37 -
 .../src/crowd_simulator_common.cpp            |  243 --
 .../src/door_common.cpp                       |  201 --
 .../src/lift_common.cpp                       |  342 ---
 .../src/slotcar_common.cpp                    |  456 ----
 .../building_plugins_common/src/utils.cpp     |  117 -
 .../__init__.py                               |    0
 .../model_downloader.py                       |    0
 building_map_tools/package.xml => package.xml |    0
 .../pit_crew => pit_crew}/__init__.py         |    0
 .../pit_crew => pit_crew}/pit_crew.py         |    0
 .../pit_crew => pit_crew}/usage_examples.py   |    0
 .../resource => resource}/building_map_tools  |    0
 building_map_tools/setup.cfg => setup.cfg     |    0
 building_map_tools/setup.py => setup.py       |    0
 test_maps/CHANGELOG.rst                       |   23 -
 test_maps/CMakeLists.txt                      |   57 -
 .../door_madness/door_madness.building.yaml   |   49 -
 .../door_madness/door_madness.project.yaml    |    4 -
 test_maps/package.xml                         |   19 -
 traffic_editor/CHANGELOG.rst                  |  345 ---
 traffic_editor/CMakeLists.txt                 |  119 -
 traffic_editor/LICENSE                        |  201 --
 traffic_editor/README.md                      |  146 -
 traffic_editor/gui/add_param_dialog.cpp       |   82 -
 traffic_editor/gui/add_param_dialog.h         |   47 -
 traffic_editor/gui/building.cpp               |  667 -----
 traffic_editor/gui/building_dialog.cpp        |   76 -
 traffic_editor/gui/building_dialog.h          |   44 -
 traffic_editor/gui/building_level.cpp         |  897 ------
 traffic_editor/gui/building_level_dialog.cpp  |  251 --
 traffic_editor/gui/building_level_dialog.h    |   53 -
 traffic_editor/gui/building_level_table.cpp   |  114 -
 traffic_editor/gui/building_level_table.h     |   40 -
 traffic_editor/gui/edge.cpp                   |  175 --
 traffic_editor/gui/editor.cpp                 | 2411 -----------------
 traffic_editor/gui/editor.h                   |  325 ---
 traffic_editor/gui/editor_mode_id.h           |   28 -
 traffic_editor/gui/editor_model.cpp           |   76 -
 traffic_editor/gui/fiducial.cpp               |   91 -
 traffic_editor/gui/layer.cpp                  |   73 -
 traffic_editor/gui/layer_dialog.cpp           |  216 --
 traffic_editor/gui/layer_dialog.h             |   60 -
 traffic_editor/gui/level.cpp                  |  176 --
 traffic_editor/gui/lift.cpp                   |  239 --
 traffic_editor/gui/lift_dialog.cpp            |  572 ----
 traffic_editor/gui/lift_dialog.h              |   85 -
 traffic_editor/gui/lift_door.cpp              |   48 -
 traffic_editor/gui/lift_table.cpp             |   95 -
 traffic_editor/gui/lift_table.h               |   35 -
 traffic_editor/gui/main.cpp                   |   53 -
 traffic_editor/gui/map_view.cpp               |  106 -
 traffic_editor/gui/map_view.h                 |   45 -
 traffic_editor/gui/model.cpp                  |  226 --
 traffic_editor/gui/model_dialog.cpp           |  147 -
 traffic_editor/gui/model_dialog.h             |   58 -
 traffic_editor/gui/param.cpp                  |  123 -
 traffic_editor/gui/polygon.cpp                |  134 -
 traffic_editor/gui/preferences_dialog.cpp     |  118 -
 traffic_editor/gui/preferences_dialog.h       |   43 -
 traffic_editor/gui/preferences_keys.cpp       |   20 -
 traffic_editor/gui/preferences_keys.h         |   21 -
 traffic_editor/gui/project.cpp                |  716 -----
 traffic_editor/gui/project.h                  |  147 -
 traffic_editor/gui/project_dialog.cpp         |  110 -
 traffic_editor/gui/project_dialog.h           |   45 -
 traffic_editor/gui/scenario.cpp               |  252 --
 traffic_editor/gui/scenario.h                 |   86 -
 traffic_editor/gui/scenario_dialog.cpp        |  132 -
 traffic_editor/gui/scenario_dialog.h          |   47 -
 traffic_editor/gui/scenario_level.cpp         |  174 --
 traffic_editor/gui/scenario_level.h           |   51 -
 traffic_editor/gui/scenario_table.cpp         |   87 -
 traffic_editor/gui/scenario_table.h           |   35 -
 traffic_editor/gui/sim_thread.cpp             |   41 -
 traffic_editor/gui/sim_thread.h               |   34 -
 traffic_editor/gui/table_list.cpp             |   57 -
 traffic_editor/gui/table_list.h               |   35 -
 traffic_editor/gui/traffic_map.cpp            |   77 -
 traffic_editor/gui/traffic_map.h              |   43 -
 traffic_editor/gui/traffic_map_dialog.cpp     |  129 -
 traffic_editor/gui/traffic_map_dialog.h       |   46 -
 traffic_editor/gui/traffic_table.cpp          |  134 -
 traffic_editor/gui/traffic_table.h            |   35 -
 traffic_editor/gui/transform_dialog.ui        |   94 -
 traffic_editor/gui/vertex.cpp                 |  139 -
 traffic_editor/gui/yaml_utils.cpp             |   75 -
 traffic_editor/gui/yaml_utils.h               |   30 -
 .../include/traffic_editor/building.h         |  171 --
 .../include/traffic_editor/building_level.h   |  117 -
 traffic_editor/include/traffic_editor/edge.h  |   73 -
 .../include/traffic_editor/editor_model.h     |   41 -
 .../include/traffic_editor/fiducial.h         |   49 -
 traffic_editor/include/traffic_editor/layer.h |   49 -
 traffic_editor/include/traffic_editor/level.h |   87 -
 traffic_editor/include/traffic_editor/lift.h  |   97 -
 .../include/traffic_editor/lift_door.h        |   51 -
 traffic_editor/include/traffic_editor/model.h |   69 -
 .../include/traffic_editor/model_state.h      |   33 -
 traffic_editor/include/traffic_editor/param.h |   60 -
 .../include/traffic_editor/polygon.h          |   72 -
 .../traffic_editor/rendering_options.h        |   30 -
 .../include/traffic_editor/vertex.h           |   61 -
 traffic_editor/package.xml                    |   22 -
 traffic_editor/plugins/simulation.h           |   42 -
 traffic_editor/resources/icons/door.svg       |   77 -
 traffic_editor/resources/icons/fiducial.svg   |   93 -
 traffic_editor/resources/icons/floor.svg      |   64 -
 traffic_editor/resources/icons/hole.svg       |   69 -
 .../resources/icons/measurement.svg           |   76 -
 traffic_editor/resources/icons/move.svg       |   92 -
 traffic_editor/resources/icons/roi.svg        |   64 -
 traffic_editor/resources/icons/rotate.svg     |   99 -
 traffic_editor/resources/icons/select.svg     |   64 -
 traffic_editor/resources/icons/vertex.svg     |   64 -
 traffic_editor/resources/icons/wall.svg       |   76 -
 traffic_editor/resources/resource.qrc         |   16 -
 traffic_editor/scripts/generate_model_list.py |   78 -
 traffic_editor/scripts/generate_thumbnails.py |   79 -
 traffic_editor/scripts/merge_model_lists.py   |   64 -
 traffic_editor/scripts/sort_model_list.py     |   43 -
 traffic_editor/test/model_blacklist.yaml      |    2 -
 traffic_editor/test/model_list.yaml           |    5 -
 212 files changed, 20217 deletions(-)
 delete mode 100644 .github/workflows/build.yaml
 delete mode 100644 .github/workflows/style.yaml
 rename building_map_tools/CHANGELOG.rst => CHANGELOG.rst (100%)
 delete mode 100644 README.md
 rename {building_map_tools/building_map => building_map}/__init__.py (100%)
 rename {building_map_tools/building_map => building_map}/building.py (100%)
 rename {building_map_tools/building_map => building_map}/doors/__init__.py (100%)
 rename {building_map_tools/building_map => building_map}/doors/door.py (100%)
 rename {building_map_tools/building_map => building_map}/doors/double_sliding_door.py (100%)
 rename {building_map_tools/building_map => building_map}/doors/double_swing_door.py (100%)
 rename {building_map_tools/building_map => building_map}/doors/sliding_door.py (100%)
 rename {building_map_tools/building_map => building_map}/doors/swing_door.py (100%)
 rename {building_map_tools/building_map => building_map}/edge.py (100%)
 rename {building_map_tools/building_map => building_map}/etree_utils.py (100%)
 rename {building_map_tools/building_map => building_map}/fiducial.py (100%)
 rename {building_map_tools/building_map => building_map}/floor.py (100%)
 rename {building_map_tools/building_map => building_map}/generator.py (100%)
 rename {building_map_tools/building_map => building_map}/hole.py (100%)
 rename {building_map_tools/building_map => building_map}/level.py (100%)
 rename {building_map_tools/building_map => building_map}/lift.py (100%)
 rename {building_map_tools/building_map => building_map}/model.py (100%)
 rename {building_map_tools/building_map => building_map}/param_value.py (100%)
 rename {building_map_tools/building_map => building_map}/templates/gz_world.sdf (100%)
 rename {building_map_tools/building_map => building_map}/templates/ign_world.sdf (100%)
 rename {building_map_tools/building_map => building_map}/transform.py (100%)
 rename {building_map_tools/building_map => building_map}/utils.py (100%)
 rename {building_map_tools/building_map => building_map}/vertex.py (100%)
 rename {building_map_tools/building_map => building_map}/wall.py (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/__init__.py (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/_init_argparse.py (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/building_map_generator.py (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/beige_tiles.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/blue_linoleum.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/blue_linoleum_high_contrast.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/brown_marble.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/carpark_walkway.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/concrete.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/concrete2.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/concrete3.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/concrete4.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/default.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/gray_flooring.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/red_tiles.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/wall.png (100%)
 rename {building_map_tools/building_map_generator => building_map_generator}/textures/white_marble.png (100%)
 rename {building_map_tools/building_map_model_downloader => building_map_model_downloader}/__init__.py (100%)
 rename {building_map_tools/building_map_model_downloader => building_map_model_downloader}/building_map_model_downloader.py (100%)
 delete mode 100644 building_map_msgs/CHANGELOG.rst
 delete mode 100644 building_map_msgs/CMakeLists.txt
 delete mode 100644 building_map_msgs/msg/AffineImage.msg
 delete mode 100644 building_map_msgs/msg/BuildingMap.msg
 delete mode 100644 building_map_msgs/msg/Door.msg
 delete mode 100644 building_map_msgs/msg/Graph.msg
 delete mode 100644 building_map_msgs/msg/GraphEdge.msg
 delete mode 100644 building_map_msgs/msg/GraphNode.msg
 delete mode 100644 building_map_msgs/msg/Level.msg
 delete mode 100644 building_map_msgs/msg/Lift.msg
 delete mode 100644 building_map_msgs/msg/Param.msg
 delete mode 100644 building_map_msgs/msg/Place.msg
 delete mode 100644 building_map_msgs/package.xml
 delete mode 100644 building_map_msgs/srv/GetBuildingMap.srv
 rename {building_map_tools/building_map_server => building_map_server}/__init__.py (100%)
 rename {building_map_tools/building_map_server => building_map_server}/building_map_server.py (100%)
 rename {building_map_tools/building_map_server => building_map_server}/test/test_map_client.py (100%)
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/CMakeLists.txt
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/package.xml
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/door.cpp
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/lift.cpp
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp
 delete mode 100644 building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp
 delete mode 100644 building_sim_plugins/building_ignition_plugins/CHANGELOG.rst
 delete mode 100644 building_sim_plugins/building_ignition_plugins/CMakeLists.txt
 delete mode 100644 building_sim_plugins/building_ignition_plugins/package.xml
 delete mode 100644 building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp
 delete mode 100644 building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp
 delete mode 100644 building_sim_plugins/building_ignition_plugins/src/door.cpp
 delete mode 100644 building_sim_plugins/building_ignition_plugins/src/lift.cpp
 delete mode 100644 building_sim_plugins/building_ignition_plugins/src/slotcar.cpp
 delete mode 100644 building_sim_plugins/building_plugins_common/CHANGELOG.rst
 delete mode 100644 building_sim_plugins/building_plugins_common/CMakeLists.txt
 delete mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp
 delete mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp
 delete mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp
 delete mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp
 delete mode 100644 building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp
 delete mode 100644 building_sim_plugins/building_plugins_common/package.xml
 delete mode 100644 building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp
 delete mode 100644 building_sim_plugins/building_plugins_common/src/door_common.cpp
 delete mode 100644 building_sim_plugins/building_plugins_common/src/lift_common.cpp
 delete mode 100644 building_sim_plugins/building_plugins_common/src/slotcar_common.cpp
 delete mode 100644 building_sim_plugins/building_plugins_common/src/utils.cpp
 rename {building_map_tools/model_downloader => model_downloader}/__init__.py (100%)
 rename {building_map_tools/model_downloader => model_downloader}/model_downloader.py (100%)
 rename building_map_tools/package.xml => package.xml (100%)
 rename {building_map_tools/pit_crew => pit_crew}/__init__.py (100%)
 rename {building_map_tools/pit_crew => pit_crew}/pit_crew.py (100%)
 rename {building_map_tools/pit_crew => pit_crew}/usage_examples.py (100%)
 rename {building_map_tools/resource => resource}/building_map_tools (100%)
 rename building_map_tools/setup.cfg => setup.cfg (100%)
 rename building_map_tools/setup.py => setup.py (100%)
 delete mode 100644 test_maps/CHANGELOG.rst
 delete mode 100644 test_maps/CMakeLists.txt
 delete mode 100644 test_maps/maps/door_madness/door_madness.building.yaml
 delete mode 100644 test_maps/maps/door_madness/door_madness.project.yaml
 delete mode 100644 test_maps/package.xml
 delete mode 100644 traffic_editor/CHANGELOG.rst
 delete mode 100644 traffic_editor/CMakeLists.txt
 delete mode 100644 traffic_editor/LICENSE
 delete mode 100644 traffic_editor/README.md
 delete mode 100644 traffic_editor/gui/add_param_dialog.cpp
 delete mode 100644 traffic_editor/gui/add_param_dialog.h
 delete mode 100644 traffic_editor/gui/building.cpp
 delete mode 100644 traffic_editor/gui/building_dialog.cpp
 delete mode 100644 traffic_editor/gui/building_dialog.h
 delete mode 100644 traffic_editor/gui/building_level.cpp
 delete mode 100644 traffic_editor/gui/building_level_dialog.cpp
 delete mode 100644 traffic_editor/gui/building_level_dialog.h
 delete mode 100644 traffic_editor/gui/building_level_table.cpp
 delete mode 100644 traffic_editor/gui/building_level_table.h
 delete mode 100644 traffic_editor/gui/edge.cpp
 delete mode 100644 traffic_editor/gui/editor.cpp
 delete mode 100644 traffic_editor/gui/editor.h
 delete mode 100644 traffic_editor/gui/editor_mode_id.h
 delete mode 100644 traffic_editor/gui/editor_model.cpp
 delete mode 100644 traffic_editor/gui/fiducial.cpp
 delete mode 100644 traffic_editor/gui/layer.cpp
 delete mode 100644 traffic_editor/gui/layer_dialog.cpp
 delete mode 100644 traffic_editor/gui/layer_dialog.h
 delete mode 100644 traffic_editor/gui/level.cpp
 delete mode 100644 traffic_editor/gui/lift.cpp
 delete mode 100644 traffic_editor/gui/lift_dialog.cpp
 delete mode 100644 traffic_editor/gui/lift_dialog.h
 delete mode 100644 traffic_editor/gui/lift_door.cpp
 delete mode 100644 traffic_editor/gui/lift_table.cpp
 delete mode 100644 traffic_editor/gui/lift_table.h
 delete mode 100644 traffic_editor/gui/main.cpp
 delete mode 100644 traffic_editor/gui/map_view.cpp
 delete mode 100644 traffic_editor/gui/map_view.h
 delete mode 100644 traffic_editor/gui/model.cpp
 delete mode 100644 traffic_editor/gui/model_dialog.cpp
 delete mode 100644 traffic_editor/gui/model_dialog.h
 delete mode 100644 traffic_editor/gui/param.cpp
 delete mode 100644 traffic_editor/gui/polygon.cpp
 delete mode 100644 traffic_editor/gui/preferences_dialog.cpp
 delete mode 100644 traffic_editor/gui/preferences_dialog.h
 delete mode 100644 traffic_editor/gui/preferences_keys.cpp
 delete mode 100644 traffic_editor/gui/preferences_keys.h
 delete mode 100644 traffic_editor/gui/project.cpp
 delete mode 100644 traffic_editor/gui/project.h
 delete mode 100644 traffic_editor/gui/project_dialog.cpp
 delete mode 100644 traffic_editor/gui/project_dialog.h
 delete mode 100644 traffic_editor/gui/scenario.cpp
 delete mode 100644 traffic_editor/gui/scenario.h
 delete mode 100644 traffic_editor/gui/scenario_dialog.cpp
 delete mode 100644 traffic_editor/gui/scenario_dialog.h
 delete mode 100644 traffic_editor/gui/scenario_level.cpp
 delete mode 100644 traffic_editor/gui/scenario_level.h
 delete mode 100644 traffic_editor/gui/scenario_table.cpp
 delete mode 100644 traffic_editor/gui/scenario_table.h
 delete mode 100644 traffic_editor/gui/sim_thread.cpp
 delete mode 100644 traffic_editor/gui/sim_thread.h
 delete mode 100644 traffic_editor/gui/table_list.cpp
 delete mode 100644 traffic_editor/gui/table_list.h
 delete mode 100644 traffic_editor/gui/traffic_map.cpp
 delete mode 100644 traffic_editor/gui/traffic_map.h
 delete mode 100644 traffic_editor/gui/traffic_map_dialog.cpp
 delete mode 100644 traffic_editor/gui/traffic_map_dialog.h
 delete mode 100644 traffic_editor/gui/traffic_table.cpp
 delete mode 100644 traffic_editor/gui/traffic_table.h
 delete mode 100644 traffic_editor/gui/transform_dialog.ui
 delete mode 100644 traffic_editor/gui/vertex.cpp
 delete mode 100644 traffic_editor/gui/yaml_utils.cpp
 delete mode 100644 traffic_editor/gui/yaml_utils.h
 delete mode 100644 traffic_editor/include/traffic_editor/building.h
 delete mode 100644 traffic_editor/include/traffic_editor/building_level.h
 delete mode 100644 traffic_editor/include/traffic_editor/edge.h
 delete mode 100644 traffic_editor/include/traffic_editor/editor_model.h
 delete mode 100644 traffic_editor/include/traffic_editor/fiducial.h
 delete mode 100644 traffic_editor/include/traffic_editor/layer.h
 delete mode 100644 traffic_editor/include/traffic_editor/level.h
 delete mode 100644 traffic_editor/include/traffic_editor/lift.h
 delete mode 100644 traffic_editor/include/traffic_editor/lift_door.h
 delete mode 100644 traffic_editor/include/traffic_editor/model.h
 delete mode 100644 traffic_editor/include/traffic_editor/model_state.h
 delete mode 100644 traffic_editor/include/traffic_editor/param.h
 delete mode 100644 traffic_editor/include/traffic_editor/polygon.h
 delete mode 100644 traffic_editor/include/traffic_editor/rendering_options.h
 delete mode 100644 traffic_editor/include/traffic_editor/vertex.h
 delete mode 100644 traffic_editor/package.xml
 delete mode 100644 traffic_editor/plugins/simulation.h
 delete mode 100644 traffic_editor/resources/icons/door.svg
 delete mode 100644 traffic_editor/resources/icons/fiducial.svg
 delete mode 100644 traffic_editor/resources/icons/floor.svg
 delete mode 100644 traffic_editor/resources/icons/hole.svg
 delete mode 100644 traffic_editor/resources/icons/measurement.svg
 delete mode 100644 traffic_editor/resources/icons/move.svg
 delete mode 100644 traffic_editor/resources/icons/roi.svg
 delete mode 100644 traffic_editor/resources/icons/rotate.svg
 delete mode 100644 traffic_editor/resources/icons/select.svg
 delete mode 100644 traffic_editor/resources/icons/vertex.svg
 delete mode 100644 traffic_editor/resources/icons/wall.svg
 delete mode 100644 traffic_editor/resources/resource.qrc
 delete mode 100755 traffic_editor/scripts/generate_model_list.py
 delete mode 100755 traffic_editor/scripts/generate_thumbnails.py
 delete mode 100755 traffic_editor/scripts/merge_model_lists.py
 delete mode 100755 traffic_editor/scripts/sort_model_list.py
 delete mode 100644 traffic_editor/test/model_blacklist.yaml
 delete mode 100644 traffic_editor/test/model_list.yaml

diff --git a/.github/workflows/build.yaml b/.github/workflows/build.yaml
deleted file mode 100644
index 45a8e95..0000000
--- a/.github/workflows/build.yaml
+++ /dev/null
@@ -1,40 +0,0 @@
-name: build
-on: [push, pull_request]
-jobs:
-  build:
-    runs-on: ubuntu-18.04
-    container:
-      image: docker://ros:eloquent-ros-base-bionic
-    
-    steps:
-    - name: osrf-repo
-      shell: bash
-      run: |
-        sudo apt-get update
-        sudo apt-get install -y wget
-        echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable bionic main" > /etc/apt/sources.list.d/gazebo-stable.list
-        wget https://packages.osrfoundation.org/gazebo.key -O - | apt-key add -
-        sudo apt-get update
-        sudo apt-get install -y libignition-plugin-dev libignition-common3-dev
-
-    - name: ros-workspace
-      run: |
-        mkdir -p ws/src
-
-    - name: checkout
-      uses: actions/checkout@v2
-      with:
-        path: ws/src/traffic_editor
-
-    - name: non-ros-deps
-      run: |
-        sudo apt-get update
-        sudo apt-get install -y git cmake wget libyaml-cpp-dev qt5-default \
-          libopencv-dev libopencv-videoio-dev
-
-    - name: build
-      shell: bash
-      run: |
-        cd ws
-        source /opt/ros/eloquent/setup.bash
-        colcon build --packages-select traffic_editor --cmake-args -DNO_DOWNLOAD_MODELS=True
diff --git a/.github/workflows/style.yaml b/.github/workflows/style.yaml
deleted file mode 100644
index 775d68e..0000000
--- a/.github/workflows/style.yaml
+++ /dev/null
@@ -1,22 +0,0 @@
-name: style
-on: [push, pull_request]
-jobs:
-  build:
-    runs-on: ubuntu-18.04
-    container:
-      image: docker://ros:eloquent-ros-base-bionic
-    steps:
-    - uses: actions/checkout@v1
-    - name: deps
-      run: |
-        sudo apt-get update
-        sudo apt-get install pycodestyle wget
-    - name: pycodestyle
-      run: |
-        pycodestyle .
-    - name: rmf_uncrustify
-      shell: bash
-      run: |
-        wget https://raw.githubusercontent.com/osrf/rmf_core/master/rmf_utils/test/format/rmf_code_style.cfg
-        source /opt/ros/eloquent/setup.bash
-        ament_uncrustify -c rmf_code_style.cfg .
diff --git a/building_map_tools/CHANGELOG.rst b/CHANGELOG.rst
similarity index 100%
rename from building_map_tools/CHANGELOG.rst
rename to CHANGELOG.rst
diff --git a/README.md b/README.md
deleted file mode 100644
index aff28d9..0000000
--- a/README.md
+++ /dev/null
@@ -1,24 +0,0 @@
-![](https://github.com/osrf/traffic_editor/workflows/build/badge.svg)
-![](https://github.com/osrf/traffic_editor/workflows/style/badge.svg)
-
-# traffic\_editor
-
-Welcome!
-
-This repository has the following directories:
- * `traffic_editor`: GUI for annotating floorplans to create traffic patterns
- * `building_map_msgs`: messages that can carry these traffic plans
- * `building_map_tools`: Python-based tools to use and manipulate the map files created by `traffic_editor`, such as:
-   * a ROS 2 node to serve maps using `building_map_msgs`
-   * translators to simulators such as Gazebo
-   * translators to navigation packages such as `rmf_core`
-
-# Installation
-
-This repository is structed as a collection of ROS 2 packages and can be built using `colcon`.
-
-The `building_map_tools` package requires the following Python 3 dependencies to generate worlds:
-
-```
-sudo apt install python3-shapely python3-yaml python3-requests
-```
diff --git a/building_map_tools/building_map/__init__.py b/building_map/__init__.py
similarity index 100%
rename from building_map_tools/building_map/__init__.py
rename to building_map/__init__.py
diff --git a/building_map_tools/building_map/building.py b/building_map/building.py
similarity index 100%
rename from building_map_tools/building_map/building.py
rename to building_map/building.py
diff --git a/building_map_tools/building_map/doors/__init__.py b/building_map/doors/__init__.py
similarity index 100%
rename from building_map_tools/building_map/doors/__init__.py
rename to building_map/doors/__init__.py
diff --git a/building_map_tools/building_map/doors/door.py b/building_map/doors/door.py
similarity index 100%
rename from building_map_tools/building_map/doors/door.py
rename to building_map/doors/door.py
diff --git a/building_map_tools/building_map/doors/double_sliding_door.py b/building_map/doors/double_sliding_door.py
similarity index 100%
rename from building_map_tools/building_map/doors/double_sliding_door.py
rename to building_map/doors/double_sliding_door.py
diff --git a/building_map_tools/building_map/doors/double_swing_door.py b/building_map/doors/double_swing_door.py
similarity index 100%
rename from building_map_tools/building_map/doors/double_swing_door.py
rename to building_map/doors/double_swing_door.py
diff --git a/building_map_tools/building_map/doors/sliding_door.py b/building_map/doors/sliding_door.py
similarity index 100%
rename from building_map_tools/building_map/doors/sliding_door.py
rename to building_map/doors/sliding_door.py
diff --git a/building_map_tools/building_map/doors/swing_door.py b/building_map/doors/swing_door.py
similarity index 100%
rename from building_map_tools/building_map/doors/swing_door.py
rename to building_map/doors/swing_door.py
diff --git a/building_map_tools/building_map/edge.py b/building_map/edge.py
similarity index 100%
rename from building_map_tools/building_map/edge.py
rename to building_map/edge.py
diff --git a/building_map_tools/building_map/etree_utils.py b/building_map/etree_utils.py
similarity index 100%
rename from building_map_tools/building_map/etree_utils.py
rename to building_map/etree_utils.py
diff --git a/building_map_tools/building_map/fiducial.py b/building_map/fiducial.py
similarity index 100%
rename from building_map_tools/building_map/fiducial.py
rename to building_map/fiducial.py
diff --git a/building_map_tools/building_map/floor.py b/building_map/floor.py
similarity index 100%
rename from building_map_tools/building_map/floor.py
rename to building_map/floor.py
diff --git a/building_map_tools/building_map/generator.py b/building_map/generator.py
similarity index 100%
rename from building_map_tools/building_map/generator.py
rename to building_map/generator.py
diff --git a/building_map_tools/building_map/hole.py b/building_map/hole.py
similarity index 100%
rename from building_map_tools/building_map/hole.py
rename to building_map/hole.py
diff --git a/building_map_tools/building_map/level.py b/building_map/level.py
similarity index 100%
rename from building_map_tools/building_map/level.py
rename to building_map/level.py
diff --git a/building_map_tools/building_map/lift.py b/building_map/lift.py
similarity index 100%
rename from building_map_tools/building_map/lift.py
rename to building_map/lift.py
diff --git a/building_map_tools/building_map/model.py b/building_map/model.py
similarity index 100%
rename from building_map_tools/building_map/model.py
rename to building_map/model.py
diff --git a/building_map_tools/building_map/param_value.py b/building_map/param_value.py
similarity index 100%
rename from building_map_tools/building_map/param_value.py
rename to building_map/param_value.py
diff --git a/building_map_tools/building_map/templates/gz_world.sdf b/building_map/templates/gz_world.sdf
similarity index 100%
rename from building_map_tools/building_map/templates/gz_world.sdf
rename to building_map/templates/gz_world.sdf
diff --git a/building_map_tools/building_map/templates/ign_world.sdf b/building_map/templates/ign_world.sdf
similarity index 100%
rename from building_map_tools/building_map/templates/ign_world.sdf
rename to building_map/templates/ign_world.sdf
diff --git a/building_map_tools/building_map/transform.py b/building_map/transform.py
similarity index 100%
rename from building_map_tools/building_map/transform.py
rename to building_map/transform.py
diff --git a/building_map_tools/building_map/utils.py b/building_map/utils.py
similarity index 100%
rename from building_map_tools/building_map/utils.py
rename to building_map/utils.py
diff --git a/building_map_tools/building_map/vertex.py b/building_map/vertex.py
similarity index 100%
rename from building_map_tools/building_map/vertex.py
rename to building_map/vertex.py
diff --git a/building_map_tools/building_map/wall.py b/building_map/wall.py
similarity index 100%
rename from building_map_tools/building_map/wall.py
rename to building_map/wall.py
diff --git a/building_map_tools/building_map_generator/__init__.py b/building_map_generator/__init__.py
similarity index 100%
rename from building_map_tools/building_map_generator/__init__.py
rename to building_map_generator/__init__.py
diff --git a/building_map_tools/building_map_generator/_init_argparse.py b/building_map_generator/_init_argparse.py
similarity index 100%
rename from building_map_tools/building_map_generator/_init_argparse.py
rename to building_map_generator/_init_argparse.py
diff --git a/building_map_tools/building_map_generator/building_map_generator.py b/building_map_generator/building_map_generator.py
similarity index 100%
rename from building_map_tools/building_map_generator/building_map_generator.py
rename to building_map_generator/building_map_generator.py
diff --git a/building_map_tools/building_map_generator/textures/beige_tiles.png b/building_map_generator/textures/beige_tiles.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/beige_tiles.png
rename to building_map_generator/textures/beige_tiles.png
diff --git a/building_map_tools/building_map_generator/textures/blue_linoleum.png b/building_map_generator/textures/blue_linoleum.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/blue_linoleum.png
rename to building_map_generator/textures/blue_linoleum.png
diff --git a/building_map_tools/building_map_generator/textures/blue_linoleum_high_contrast.png b/building_map_generator/textures/blue_linoleum_high_contrast.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/blue_linoleum_high_contrast.png
rename to building_map_generator/textures/blue_linoleum_high_contrast.png
diff --git a/building_map_tools/building_map_generator/textures/brown_marble.png b/building_map_generator/textures/brown_marble.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/brown_marble.png
rename to building_map_generator/textures/brown_marble.png
diff --git a/building_map_tools/building_map_generator/textures/carpark_walkway.png b/building_map_generator/textures/carpark_walkway.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/carpark_walkway.png
rename to building_map_generator/textures/carpark_walkway.png
diff --git a/building_map_tools/building_map_generator/textures/concrete.png b/building_map_generator/textures/concrete.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/concrete.png
rename to building_map_generator/textures/concrete.png
diff --git a/building_map_tools/building_map_generator/textures/concrete2.png b/building_map_generator/textures/concrete2.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/concrete2.png
rename to building_map_generator/textures/concrete2.png
diff --git a/building_map_tools/building_map_generator/textures/concrete3.png b/building_map_generator/textures/concrete3.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/concrete3.png
rename to building_map_generator/textures/concrete3.png
diff --git a/building_map_tools/building_map_generator/textures/concrete4.png b/building_map_generator/textures/concrete4.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/concrete4.png
rename to building_map_generator/textures/concrete4.png
diff --git a/building_map_tools/building_map_generator/textures/default.png b/building_map_generator/textures/default.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/default.png
rename to building_map_generator/textures/default.png
diff --git a/building_map_tools/building_map_generator/textures/gray_flooring.png b/building_map_generator/textures/gray_flooring.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/gray_flooring.png
rename to building_map_generator/textures/gray_flooring.png
diff --git a/building_map_tools/building_map_generator/textures/red_tiles.png b/building_map_generator/textures/red_tiles.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/red_tiles.png
rename to building_map_generator/textures/red_tiles.png
diff --git a/building_map_tools/building_map_generator/textures/wall.png b/building_map_generator/textures/wall.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/wall.png
rename to building_map_generator/textures/wall.png
diff --git a/building_map_tools/building_map_generator/textures/white_marble.png b/building_map_generator/textures/white_marble.png
similarity index 100%
rename from building_map_tools/building_map_generator/textures/white_marble.png
rename to building_map_generator/textures/white_marble.png
diff --git a/building_map_tools/building_map_model_downloader/__init__.py b/building_map_model_downloader/__init__.py
similarity index 100%
rename from building_map_tools/building_map_model_downloader/__init__.py
rename to building_map_model_downloader/__init__.py
diff --git a/building_map_tools/building_map_model_downloader/building_map_model_downloader.py b/building_map_model_downloader/building_map_model_downloader.py
similarity index 100%
rename from building_map_tools/building_map_model_downloader/building_map_model_downloader.py
rename to building_map_model_downloader/building_map_model_downloader.py
diff --git a/building_map_msgs/CHANGELOG.rst b/building_map_msgs/CHANGELOG.rst
deleted file mode 100644
index c58da7e..0000000
--- a/building_map_msgs/CHANGELOG.rst
+++ /dev/null
@@ -1,25 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package building_map_msgs
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-1.0.0 (2020-06-22)
-------------------
-* merging master
-* Merge branch 'master' into ch3/migrate-traffic-editor-thumbnails
-* Merge branch 'master' into ch3/author-namespaced-thumbnails
-* Merge pull request `#131 <https://github.com/osrf/traffic_editor/issues/131>`_ from osrf/bug/building_map_server
-  Fix coordinate frame of lifts and doors in building_map_server
-* Fixed coordinate system for lifts and doors populated in BuildingMap msg
-* Merge pull request `#122 <https://github.com/osrf/traffic_editor/issues/122>`_ from osrf/fix/building_map_server
-  Fix/building map server
-* Merge pull request `#121 <https://github.com/osrf/traffic_editor/issues/121>`_ from osrf/bug/fix_pkg_dependencies
-  adding missing pkg dependencies
-* Lift skeleton
-* Fixed format
-* doors populated in map server
-* adding missing pkg dependencies
-* Merge pull request `#16 <https://github.com/osrf/traffic_editor/issues/16>`_ from osrf/repository_reorganization
-  Repository reorganization
-* add lift cabin reference point
-* grand reorganization as colcon-buildable packages for ros2 integration
-* Contributors: Marco A. Gutierrez, Marco A. Gutiérrez, Morgan Quigley, Yadu, Yadunund, methylDragon
diff --git a/building_map_msgs/CMakeLists.txt b/building_map_msgs/CMakeLists.txt
deleted file mode 100644
index 248481a..0000000
--- a/building_map_msgs/CMakeLists.txt
+++ /dev/null
@@ -1,46 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-
-project(building_map_msgs)
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  # we dont use add_compile_options with pedantic in message packages
-  # because the Python C extensions dont comply with it
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wpedantic")
-endif()
-
-find_package(ament_cmake REQUIRED)
-find_package(builtin_interfaces REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(rosidl_default_generators REQUIRED)
-
-set(msg_files
-  "msg/AffineImage.msg"
-  "msg/BuildingMap.msg"
-  "msg/Door.msg"
-  "msg/Graph.msg"
-  "msg/GraphEdge.msg"
-  "msg/GraphNode.msg"
-  "msg/Level.msg"
-  "msg/Lift.msg"
-  "msg/Param.msg"
-  "msg/Place.msg"
-)
-
-set(srv_files
-  "srv/GetBuildingMap.srv"
-)
-
-rosidl_generate_interfaces(${PROJECT_NAME}
-  ${msg_files}
-  ${srv_files}
-  DEPENDENCIES builtin_interfaces
-  ADD_LINTER_TESTS
-)
-
-ament_export_dependencies(rosidl_default_runtime)
-
-ament_package()
diff --git a/building_map_msgs/msg/AffineImage.msg b/building_map_msgs/msg/AffineImage.msg
deleted file mode 100644
index f08234b..0000000
--- a/building_map_msgs/msg/AffineImage.msg
+++ /dev/null
@@ -1,7 +0,0 @@
-string name
-float32 x_offset
-float32 y_offset
-float32 yaw
-float32 scale
-string encoding
-uint8[] data
diff --git a/building_map_msgs/msg/BuildingMap.msg b/building_map_msgs/msg/BuildingMap.msg
deleted file mode 100644
index 734755b..0000000
--- a/building_map_msgs/msg/BuildingMap.msg
+++ /dev/null
@@ -1,3 +0,0 @@
-string name
-Level[] levels
-Lift[] lifts
diff --git a/building_map_msgs/msg/Door.msg b/building_map_msgs/msg/Door.msg
deleted file mode 100644
index 1b9c001..0000000
--- a/building_map_msgs/msg/Door.msg
+++ /dev/null
@@ -1,44 +0,0 @@
-string name
-
-# CONVENTIONS
-# ===========
-# single hinge doors:
-#   * hinge is located at (v1_x, v1_y)
-#   * door extends till (v2_x, v2_y)
-#   * motion_range = door swing range in DEGREES
-#   * there are two possible motions: clockwise and anti-clockwise
-#     selected by the motion_direction parameter, which is +1 or -1
-#
-# double hinge doors:
-#   * hinges are located at both (v1_x, v1_y) and (v2_x, v2_y)
-#   * motion range = door swing ranges in DEGREES (assume symmetric)
-#   * same motion-direction selection as single hinge
-#
-# single sliding doors:
-#   * the door slides from (v2_x, v2_y) towards (v1_x, v1_y)
-#   * range of motion is entire distance from v2->v1. No need to specify.
-#
-# double sliding doors:
-#   * door panels slide from the centerpoint of v1<->v2 towards v1 and v2
-#
-# single/double telescoping doors:
-#   * common in elevators; same parameters as sliding doors; they just
-#     open/close faster and take up less space inside the wall.
-
-float32 v1_x
-float32 v1_y
-
-float32 v2_x
-float32 v2_y
-
-uint8 door_type
-uint8 DOOR_TYPE_UNDEFINED=0
-uint8 DOOR_TYPE_SINGLE_SLIDING=1
-uint8 DOOR_TYPE_DOUBLE_SLIDING=2
-uint8 DOOR_TYPE_SINGLE_TELESCOPE=3
-uint8 DOOR_TYPE_DOUBLE_TELESCOPE=4
-uint8 DOOR_TYPE_SINGLE_SWING=5
-uint8 DOOR_TYPE_DOUBLE_SWING=6
-
-float32 motion_range
-int32 motion_direction
diff --git a/building_map_msgs/msg/Graph.msg b/building_map_msgs/msg/Graph.msg
deleted file mode 100644
index a5b7f99..0000000
--- a/building_map_msgs/msg/Graph.msg
+++ /dev/null
@@ -1,4 +0,0 @@
-string name
-GraphNode[] vertices
-GraphEdge[] edges
-Param[] params
diff --git a/building_map_msgs/msg/GraphEdge.msg b/building_map_msgs/msg/GraphEdge.msg
deleted file mode 100644
index 7457537..0000000
--- a/building_map_msgs/msg/GraphEdge.msg
+++ /dev/null
@@ -1,9 +0,0 @@
-uint32 v1_idx
-uint32 v2_idx
-Param[] params
-
-# when edge_type is UNIDIRECTIONAL, it means v1 -> v2
-# when edge_type is BIDIRECTIONAL, it means v1 <-> v2
-uint8 edge_type
-uint8 EDGE_TYPE_BIDIRECTIONAL=0
-uint8 EDGE_TYPE_UNIDIRECTIONAL=1
diff --git a/building_map_msgs/msg/GraphNode.msg b/building_map_msgs/msg/GraphNode.msg
deleted file mode 100644
index ed498c4..0000000
--- a/building_map_msgs/msg/GraphNode.msg
+++ /dev/null
@@ -1,4 +0,0 @@
-float32 x
-float32 y
-string name
-Param[] params
diff --git a/building_map_msgs/msg/Level.msg b/building_map_msgs/msg/Level.msg
deleted file mode 100644
index 4ea3d4f..0000000
--- a/building_map_msgs/msg/Level.msg
+++ /dev/null
@@ -1,7 +0,0 @@
-string name
-float32 elevation
-AffineImage[] images
-Place[] places
-Door[] doors
-Graph[] nav_graphs
-Graph wall_graph
diff --git a/building_map_msgs/msg/Lift.msg b/building_map_msgs/msg/Lift.msg
deleted file mode 100644
index 1167df7..0000000
--- a/building_map_msgs/msg/Lift.msg
+++ /dev/null
@@ -1,14 +0,0 @@
-string name
-string[] levels
-Door[] doors
-Graph wall_graph
-
-# (ref_x, ref_y, ref_yaw) is a "reference orientation" of the lift cabin
-# which can be used to align floors.
-float32 ref_x
-float32 ref_y
-float32 ref_yaw
-
-# width and depth of the cabin
-float32 width
-float32 depth
\ No newline at end of file
diff --git a/building_map_msgs/msg/Param.msg b/building_map_msgs/msg/Param.msg
deleted file mode 100644
index a8fd90e..0000000
--- a/building_map_msgs/msg/Param.msg
+++ /dev/null
@@ -1,13 +0,0 @@
-string name
-
-uint32 type
-uint32 TYPE_UNDEFINED=0
-uint32 TYPE_STRING=1
-uint32 TYPE_INT=2
-uint32 TYPE_DOUBLE=3
-uint32 TYPE_BOOL=4
-
-int32 value_int
-float32 value_float
-string value_string
-bool value_bool
diff --git a/building_map_msgs/msg/Place.msg b/building_map_msgs/msg/Place.msg
deleted file mode 100644
index d8e93a8..0000000
--- a/building_map_msgs/msg/Place.msg
+++ /dev/null
@@ -1,6 +0,0 @@
-string name
-float32 x
-float32 y
-float32 yaw
-float32 position_tolerance
-float32 yaw_tolerance
diff --git a/building_map_msgs/package.xml b/building_map_msgs/package.xml
deleted file mode 100644
index 5aa6ffc..0000000
--- a/building_map_msgs/package.xml
+++ /dev/null
@@ -1,29 +0,0 @@
-<?xml version="1.0"?>
-<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
-<package format="3">
-  <name>building_map_msgs</name>
-  <version>1.1.0</version>
-  <description>Messages used to send building maps</description>
-  <maintainer email="mquigley@openrobotics.org">Morgan Quigley</maintainer>
-  <license>Apache License 2.0</license>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <buildtool_depend>rosidl_default_generators</buildtool_depend>
-
-  <build_depend>builtin_interfaces</build_depend>
-  <build_depend>geometry_msgs</build_depend>
-
-  <exec_depend>builtin_interfaces</exec_depend>
-  <exec_depend>geometry_msgs</exec_depend>
-  <exec_depend>rosidl_default_runtime</exec_depend>
-
-  <test_depend>ament_lint_common</test_depend>
-
-  <member_of_group>rosidl_interface_packages</member_of_group>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
-
diff --git a/building_map_msgs/srv/GetBuildingMap.srv b/building_map_msgs/srv/GetBuildingMap.srv
deleted file mode 100644
index 6d54a61..0000000
--- a/building_map_msgs/srv/GetBuildingMap.srv
+++ /dev/null
@@ -1,2 +0,0 @@
----
-BuildingMap building_map
diff --git a/building_map_tools/building_map_server/__init__.py b/building_map_server/__init__.py
similarity index 100%
rename from building_map_tools/building_map_server/__init__.py
rename to building_map_server/__init__.py
diff --git a/building_map_tools/building_map_server/building_map_server.py b/building_map_server/building_map_server.py
similarity index 100%
rename from building_map_tools/building_map_server/building_map_server.py
rename to building_map_server/building_map_server.py
diff --git a/building_map_tools/building_map_server/test/test_map_client.py b/building_map_server/test/test_map_client.py
similarity index 100%
rename from building_map_tools/building_map_server/test/test_map_client.py
rename to building_map_server/test/test_map_client.py
diff --git a/building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst b/building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst
deleted file mode 100644
index aa0226f..0000000
--- a/building_sim_plugins/building_gazebo_plugins/CHANGELOG.rst
+++ /dev/null
@@ -1,39 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package building_gazebo_plugins
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-1.1.0 (2020-09-24)
-------------------
-* Implement model visibility toggling (`#226 <https://github.com/osrf/traffic_editor/issues/226>`_)
-* Add crowd simulation plugin (`#218 <https://github.com/osrf/traffic_editor/issues/218>`_)
-* Foxy support (`#194 <https://github.com/osrf/traffic_editor/issues/194>`_)
-* Add field in lift dialog for initial floor, handle invalid initial floor
-* Modularization of doors and slotcar `#138 <https://github.com/osrf/traffic_editor/issues/138>`_
-* Add gazebo lift plugin
-* Contributors: Charayaphan Nakorn Boon Han, Guoliang (Fred) Shao, Kevin_Skywalker, Luca Della Vedova, MakinoharaShouko, Yadu
-
-1.0.0 (2020-06-22)
-------------------
-* Merge pull request `#151 <https://github.com/osrf/traffic_editor/issues/151>`_ from osrf/fix/slotcar_level_name
-  Slotcar update
-* Level name inferred from elevation. Set publish rate to 2hz.
-* merging master
-* Merge pull request `#139 <https://github.com/osrf/traffic_editor/issues/139>`_ from osrf/feature/adapter_error
-  Report when a new path request is out of date
-* Report when a new path request is out of date
-* Merge pull request `#119 <https://github.com/osrf/traffic_editor/issues/119>`_ from osrf/fix/slotcar_level_name
-  Level name populated in Slotcar RobotState msg
-* Cleanup
-* Level name populated in RobotState msg
-* Merge pull request `#95 <https://github.com/osrf/traffic_editor/issues/95>`_ from osrf/fix/plugin-link-missing
-  changed to using target_link_libraries to be specific
-* changed to using target_link_libraries to be specific
-* Merge pull request `#90 <https://github.com/osrf/traffic_editor/issues/90>`_ from osrf/feature/single-doors
-  Feature/single doors
-* WIP open/close positions flipped at -90 and -1
-* migrated single door changes to plugin
-* Merge branch 'master' into feature/single-doors
-* Merge pull request `#89 <https://github.com/osrf/traffic_editor/issues/89>`_ from osrf/add_gazebo_plugins
-  add gazebo plugins used by building_map_tools generators
-* add gazebo plugins used by building_map_tools generators
-* Contributors: Aaron, Aaron Chong, Michael X. Grey, Morgan Quigley, Yadu, Yadunund
diff --git a/building_sim_plugins/building_gazebo_plugins/CMakeLists.txt b/building_sim_plugins/building_gazebo_plugins/CMakeLists.txt
deleted file mode 100644
index b029acd..0000000
--- a/building_sim_plugins/building_gazebo_plugins/CMakeLists.txt
+++ /dev/null
@@ -1,191 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(building_gazebo_plugins)
-
-find_package(Qt5 COMPONENTS Widgets REQUIRED)
-set(CMAKE_AUTOMOC ON)
-
-# Default to C99
-if(NOT CMAKE_C_STANDARD)
-  set(CMAKE_C_STANDARD 99)
-endif()
-
-# Default to C++17
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 17)
-endif()
-
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic)
-endif()
-
-# find dependencies
-find_package(ament_cmake REQUIRED)
-find_package(rclcpp REQUIRED)
-find_package(gazebo REQUIRED)
-find_package(gazebo_ros REQUIRED)
-find_package(gazebo_dev REQUIRED)
-find_package(OpenCV REQUIRED )
-find_package(gazebo_msgs REQUIRED)
-find_package(tf2_ros REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(std_msgs REQUIRED)
-find_package(std_srvs REQUIRED)
-find_package(rmf_fleet_msgs REQUIRED)
-find_package(rmf_door_msgs REQUIRED)
-find_package(rmf_lift_msgs REQUIRED)
-find_package(building_map_msgs REQUIRED)
-find_package(building_sim_common REQUIRED)
-find_package(menge QUIET)
-
-# TODO this is a dependency of building_sim_common, it shouldn't be needed
-find_package(Eigen3 REQUIRED)
-
-include(GNUInstallDirs)
-
-add_library(slotcar SHARED ${PROJECT_SOURCE_DIR}/src/slotcar.cpp)
-
-ament_target_dependencies(slotcar
-  Eigen3
-  building_sim_common
-  rmf_fleet_msgs
-  rclcpp
-  gazebo_ros
-  std_msgs
-  geometry_msgs
-  tf2_ros
-  building_map_msgs
-)
-
-target_include_directories(slotcar
-  PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-    ${EIGEN3_INCLUDE_DIRS}
-    ${GAZEBO_INCLUDE_DIRS}
-)
-
-###############################
-# door stuff
-###############################
-
-add_library(door SHARED src/door.cpp)
-
-ament_target_dependencies(door
-  building_sim_common
-  rmf_fleet_msgs
-  rclcpp
-  gazebo_ros
-  rmf_door_msgs
-)
-
-target_include_directories(door
-  PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-    ${GAZEBO_INCLUDE_DIRS}
-)
-
-###############################
-# lift stuff
-###############################
-
-add_library(lift SHARED src/lift.cpp)
-
-ament_target_dependencies(lift
-    building_sim_common
-    rmf_fleet_msgs
-    rclcpp
-    gazebo_ros
-    rmf_door_msgs
-    rmf_lift_msgs
-)
-
-target_include_directories(lift
-  PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-    ${GAZEBO_INCLUDE_DIRS}
-)
-
-###############################
-# toggle floor stuff
-###############################
-
-add_library(toggle_floors SHARED src/toggle_floors.cpp)
-
-ament_target_dependencies(toggle_floors
-    Qt5
-    gazebo_ros
-    rmf_fleet_msgs
-    rclcpp
-)
-
-target_include_directories(toggle_floors
-  PUBLIC
-    ${GAZEBO_INCLUDE_DIRS}
-    #${building_sim_common_INCLUDE_DIRS}
-    ${Qt5Core_INCLUDE_DIRS}
-)
-
-###############################
-# thumbnail generation stuff
-###############################
-
-add_library(thumbnail_generator SHARED src/thumbnail_generator.cpp)
-
-target_include_directories(thumbnail_generator
-  PUBLIC
-    ${GAZEBO_INCLUDE_DIRS}
-    ${OpenCV_INCLUDE_DIRS}
-)
-
-target_link_libraries(thumbnail_generator
-  PUBLIC
-    ${OpenCV_LIBS}
-)
-
-###############################
-# crowd simulator stuff
-###############################
-if (menge_FOUND)
-  add_library(crowd_simulator
-    SHARED
-      src/crowd_simulator.cpp
-  )
-
-  ament_target_dependencies(crowd_simulator
-    building_sim_common
-    rclcpp
-    menge
-  )
-
-  target_include_directories(crowd_simulator
-    PUBLIC
-      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-      ${GAZEBO_INCLUDE_DIRS}
-      ${menge_INCLUDE_DIRS}
-      ${building_sim_common_INCLUDE_DIRS}   
-  )
-
-  #install
-  install(
-    TARGETS crowd_simulator
-    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  )
-else (NOT menge_FOUND)
-  message("menge-cmake not found, skipping crowd_simulation gazebo plugins")
-endif()
-
-###############################
-# install stuff
-###############################
-
-install(
-  TARGETS slotcar door lift toggle_floors thumbnail_generator
-  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-)
-
-ament_package()
diff --git a/building_sim_plugins/building_gazebo_plugins/package.xml b/building_sim_plugins/building_gazebo_plugins/package.xml
deleted file mode 100644
index 0e05baa..0000000
--- a/building_sim_plugins/building_gazebo_plugins/package.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<package format="3">
-  <name>building_gazebo_plugins</name>
-  <version>1.1.0</version>
-  <description>
-    Gazebo plugins so that buildings generated by building_map_tools can
-    talk to the ROS 2-based systems in the rmf_core package.
-  </description>
-  <author>Morgan Quigley</author>
-  <author>Michael Grey</author>
-  <author>Roselle Carmen</author>
-  <author>Aaron Chong</author>
-  <author>Brandon Ong</author>
-  <author>Kevin Ma</author>
-  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
-  <license>Apache 2.0</license>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <depend>rclcpp</depend>
-  <depend>gazebo_ros</depend>
-  <depend>gazebo_msgs</depend>
-  <depend>gazebo_dev</depend>
-  <depend>rmf_fleet_msgs</depend>
-  <depend>rmf_door_msgs</depend>
-  <depend>rmf_lift_msgs</depend>
-  <depend>tf2_ros</depend>
-  <depend>geometry_msgs</depend>
-  <depend>std_msgs</depend>
-  <depend>std_srvs</depend>
-  <depend>building_sim_common</depend>
-  <depend>libopencv-dev</depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-
-</package>
diff --git a/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp b/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp
deleted file mode 100644
index e60f8c1..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.cpp
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <memory>
-#include <unordered_set>
-#include <regex>
-#include <cstdlib>
-
-#include <ignition/math/Pose3.hh>
-
-#include "crowd_simulator.hpp"
-
-namespace crowd_simulation_gazebo {
-
-//============================================
-//WorldPlugin
-void CrowdSimulatorPlugin::Load(
-  gazebo::physics::WorldPtr world,
-  sdf::ElementPtr sdf)
-{
-  _world = world;
-
-  if (!_crowd_sim_interface->read_sdf(sdf))
-  {
-    exit(EXIT_FAILURE);
-  }
-
-  if (!_crowd_sim_interface->init_crowd_sim())
-  {
-    RCLCPP_ERROR(
-      _crowd_sim_interface->logger(),
-      "Crowd simulation failed to initialize.");
-    exit(EXIT_FAILURE);
-  }
-
-  if (!_spawn_agents_in_world())
-  {
-    RCLCPP_ERROR(
-      _crowd_sim_interface->logger(),
-      "Crowd simulation failed to spawn agents in the world.");
-    exit(EXIT_FAILURE);
-  }
-
-  _update_connection_ptr = gazebo::event::Events::ConnectWorldUpdateBegin(
-    [this](gazebo::common::UpdateInfo update_info)
-    {
-      _update(update_info);
-    }
-  );
-}
-
-//============================================
-void CrowdSimulatorPlugin::_update(
-  const gazebo::common::UpdateInfo& update_info)
-{
-  //first round do nothing, initialize time stamp
-  if (_last_sim_time == gazebo::common::Time::Zero)
-  {
-    _last_sim_time = update_info.simTime;
-    _last_time = update_info.simTime;
-  }
-
-  if (!_initialized)
-  {
-    // not initizalied
-    _init_spawned_agents();
-    return;
-  }
-
-  auto delta_time = (update_info.simTime - _last_time).Double();
-  _last_time = update_info.simTime;
-
-  auto delta_sim_time = (update_info.simTime - _last_sim_time).Double();
-  if (delta_sim_time - _crowd_sim_interface->get_sim_time_step() < 1e-6)
-  {
-    delta_sim_time = 0.0;
-  }
-  else
-  {
-    _last_sim_time = update_info.simTime;
-    _crowd_sim_interface->one_step_sim();
-  }
-  _update_all_objects(delta_time, delta_sim_time);
-}
-
-//============================================
-void CrowdSimulatorPlugin::_update_all_objects(
-  double delta_time,
-  double delta_sim_time)
-{
-  for (size_t id = 0; id < _objects_count; id++)
-  {
-    ObjectPtr obj_ptr = _crowd_sim_interface->get_object_by_id(id);
-    gazebo::physics::ModelPtr model_ptr = _world->ModelByName(
-      obj_ptr->model_name);
-
-    //update external agents
-    if (obj_ptr->agent_ptr->_external)
-    {
-      ignition::math::Pose3d pose = model_ptr->WorldPose();
-      _crowd_sim_interface->update_external_agent<ignition::math::Pose3d>(
-        obj_ptr->agent_ptr, pose);
-      continue;
-    }
-
-    //update internal agents
-    //not yet reach the simulation time step, the internal agent position only updated at simulation time step
-    if (delta_sim_time - 0.0 < 1e-6)
-      continue;
-    auto type_ptr = _crowd_sim_interface->_model_type_db_ptr->get(
-      obj_ptr->type_name);
-    _update_internal_object(delta_time, delta_sim_time, obj_ptr->agent_ptr,
-      model_ptr, type_ptr);
-  }
-}
-
-//============================================
-void CrowdSimulatorPlugin::_update_internal_object(
-  double delta_time,
-  double delta_sim_time,
-  const crowd_simulator::AgentPtr agent_ptr,
-  const gazebo::physics::ModelPtr model_ptr,
-  const crowd_simulator::ModelTypeDatabase::RecordPtr type_ptr)
-{
-  if (!agent_ptr)
-  {
-    RCLCPP_ERROR(
-      _crowd_sim_interface->logger(), "Null agentPtr when update Object!");
-    return;
-  }
-  if (!model_ptr)
-  {
-    RCLCPP_ERROR(
-      _crowd_sim_interface->logger(), "Null modelPtr when update Object!");
-    return;
-  }
-
-  //update pose from menge to gazebo
-  ignition::math::Pose3d pose =
-    _crowd_sim_interface->get_agent_pose<ignition::math::Pose3d>(agent_ptr,
-      delta_sim_time);
-
-  gazebo::physics::ActorPtr actor_ptr =
-    boost::dynamic_pointer_cast<gazebo::physics::Actor>(model_ptr);
-
-  auto delta_dist_vector = pose.Pos() - actor_ptr->WorldPose().Pos();
-  // might need future work on 3D case
-  // the center of human has a z_elevation, which will make the human keep walking even if he reached the target
-  delta_dist_vector.Z(0.0);
-  double delta_dist = delta_dist_vector.Length();
-
-  // _simTimeStep is small, then deltaDist is small, the scriptTime is small than expected.
-  actor_ptr->SetScriptTime(
-    actor_ptr->ScriptTime() + delta_dist / type_ptr->animation_speed);
-
-  //add on original loaded pose
-  auto animation = actor_ptr->SkeletonAnimations().at(type_ptr->animation);
-  auto anim_pose = _animation_root_pose(actor_ptr, animation);
-  auto init_pose = type_ptr->pose;
-  anim_pose += ignition::math::Pose3d(
-    init_pose.x(), init_pose.y(), init_pose.z(),
-    init_pose.pitch(), init_pose.roll(), init_pose.yaw());
-
-  //update x and y coordinates
-  anim_pose.Pos().X(pose.Pos().X());
-  anim_pose.Pos().Y(pose.Pos().Y());
-  anim_pose.Rot() = pose.Rot() * anim_pose.Rot();
-
-  actor_ptr->SetWorldPose(anim_pose);
-}
-
-//============================================
-void CrowdSimulatorPlugin::_init_spawned_agents()
-{
-  _objects_count = _crowd_sim_interface->get_num_objects();
-  for (size_t id = 0; id < _objects_count; ++id)
-  {
-    ObjectPtr obj_ptr = _crowd_sim_interface->get_object_by_id(id);
-    // spawned agents are not fully loaded
-    if (!_world->ModelByName(obj_ptr->model_name))
-    {
-      _initialized = false;
-      return;
-    }
-    // all agents are loaded, set internal actors as non-static model and set custom trajectory
-    // because only non-static model can interact with slotcars
-    if (!obj_ptr->is_external)
-    {
-      gazebo::physics::ModelPtr model_ptr = _world->ModelByName(
-        obj_ptr->model_name);
-      gazebo::physics::ActorPtr actor_ptr =
-        boost::dynamic_pointer_cast<gazebo::physics::Actor>(model_ptr);
-      gazebo::physics::TrajectoryInfoPtr trajectory_info(new gazebo::physics::
-        TrajectoryInfo()); //matches the actor skeleton
-
-      crowd_simulator::ModelTypeDatabase::RecordPtr type_ptr =
-        _crowd_sim_interface->_model_type_db_ptr->get(obj_ptr->type_name);
-      trajectory_info->type = type_ptr->animation;
-      actor_ptr->SetCustomTrajectory(trajectory_info);
-      actor_ptr->SetStatic(false);
-    }
-  }
-  _initialized = true;
-  RCLCPP_INFO(
-    _crowd_sim_interface->logger(),
-    "Gazebo models all loaded! Start simulating...");
-}
-
-//============================================
-ignition::math::Pose3d CrowdSimulatorPlugin::_animation_root_pose(
-  const gazebo::physics::ActorPtr actor_ptr,
-  const gazebo::common::SkeletonAnimation* animation)
-{
-  auto* root_node = actor_ptr->Mesh()->GetSkeleton()->GetRootNode();
-  auto root_node_name = root_node->GetName();
-  if (!animation->HasNode(root_node_name))
-  {
-    throw std::runtime_error("unable to find root node pose");
-  }
-  //get the animation trans for current time
-  auto anim_trans = animation->PoseAt(actor_ptr->ScriptTime(), true); //map<string, matrix4d>
-  auto& root_anim_trans = anim_trans[root_node_name];
-
-  auto scale_trans = ignition::math::Matrix4d::Identity;
-  auto actor_scale = actor_ptr->Scale();
-  scale_trans.Scale(actor_scale.X(), actor_scale.Y(), actor_scale.Z());
-  root_anim_trans = scale_trans * root_anim_trans;
-  return root_anim_trans.Pose();
-}
-
-
-//============================================
-bool CrowdSimulatorPlugin::_spawn_agents_in_world()
-{
-  //create model in world for each internal agents
-  _objects_count = _crowd_sim_interface->get_num_objects();
-  for (size_t id = 0; id < _objects_count; id++)
-  {
-    if (!_crowd_sim_interface->get_object_by_id(id)->is_external)
-    {
-      auto object_ptr = _crowd_sim_interface->get_object_by_id(id);
-      assert(object_ptr);
-      auto type_ptr = _crowd_sim_interface->_model_type_db_ptr->get(
-        object_ptr->type_name);
-      assert(type_ptr);
-      if (!_create_model(object_ptr->model_name, type_ptr,
-        object_ptr->agent_ptr) )
-      {
-        RCLCPP_INFO(_crowd_sim_interface->logger(),
-          "Failed to insert model [" + object_ptr->model_name + "] in world");
-        return false;
-      }
-    }
-  }
-  return true;
-}
-
-//============================================
-bool CrowdSimulatorPlugin::_create_model(
-  const std::string& model_name,
-  const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr,
-  const crowd_simulator::AgentPtr agent_ptr)
-{
-  sdf::ElementPtr model_element(new sdf::Element());
-  model_element->SetName("actor");
-  model_element->AddAttribute("name", "string", model_name, true);
-
-  sdf::ElementPtr skin_element(new sdf::Element());
-  skin_element->SetName("skin");
-  model_element->InsertElement(skin_element);
-
-  sdf::ElementPtr anim_element(new sdf::Element());
-  anim_element->SetName("animation");
-  anim_element->AddAttribute("name", "string", "walk", true);
-  model_element->InsertElement(anim_element);
-
-  sdf::ElementPtr filename_element(new sdf::Element());
-  filename_element->SetName("filename");
-  filename_element->AddValue("string", model_type_ptr->file_name, true);
-  skin_element->InsertElement(filename_element);
-  anim_element->InsertElement(filename_element);
-
-  sdf::ElementPtr pose_element(new sdf::Element());
-  pose_element->SetName("pose");
-  std::ostringstream oss;
-
-  oss << agent_ptr->_pos.x() << " " << agent_ptr->_pos.y() << " " << "0 0 0 0";
-  pose_element->AddValue("pose", oss.str(), true);
-  model_element->InsertElement(pose_element);
-
-  sdf::SDFPtr sdf(new sdf::SDF());
-  sdf->Root(model_element);
-
-  assert(sdf);
-  _world->InsertModelSDF(*sdf);
-  RCLCPP_INFO(_crowd_sim_interface->logger(),
-    "Insert actor for crowd simulator agent: [" + model_name + "] at ["+ oss.str() +
-    "].");
-  return true;
-}
-
-// insert the plugin
-GZ_REGISTER_WORLD_PLUGIN(CrowdSimulatorPlugin)
-} //namespace crowd_simulation_gazebo
\ No newline at end of file
diff --git a/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp b/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp
deleted file mode 100644
index c442f57..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/crowd_simulator.hpp
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_SIM_COMMON__CROWD_SIMULATOR_GAZEBO_HPP
-#define BUILDING_SIM_COMMON__CROWD_SIMULATOR_GAZEBO_HPP
-
-#include <memory>
-#include <unordered_map>
-
-#include <rclcpp/rclcpp.hpp>
-
-#include <ignition/math/Pose3.hh>
-
-#include <gazebo/common/Plugin.hh>
-#include <gazebo/common/UpdateInfo.hh>
-#include <gazebo/common/Events.hh>
-#include <gazebo/common/Mesh.hh>
-#include <gazebo/common/Skeleton.hh>
-#include <gazebo/common/SkeletonAnimation.hh>
-#include <gazebo/physics/Actor.hh>
-#include <gazebo/physics/physics.hh>
-
-#include <building_sim_common/crowd_simulator_common.hpp>
-
-
-namespace crowd_simulation_gazebo {
-
-using ObjectPtr = crowd_simulator::CrowdSimInterface::ObjectPtr;
-//================================================================
-/*
-* class CrowdSimulatorPlugin
-*/
-
-class CrowdSimulatorPlugin : public gazebo::WorldPlugin
-{
-
-public:
-  CrowdSimulatorPlugin()
-  : _crowd_sim_interface(std::make_shared<crowd_simulator::CrowdSimInterface>()),
-    _initialized(false),
-    _objects_count(0)
-  {}
-
-  void Load(gazebo::physics::WorldPtr world, sdf::ElementPtr sdf) override;
-
-private:
-  std::shared_ptr<crowd_simulator::CrowdSimInterface> _crowd_sim_interface;
-  bool _initialized;
-  size_t _objects_count;
-  gazebo::physics::WorldPtr _world;
-  gazebo::event::ConnectionPtr _update_connection_ptr;
-  gazebo::common::Time _last_time;
-  gazebo::common::Time _last_sim_time;
-
-  bool _spawn_agents_in_world();
-  void _init_spawned_agents();
-  void _update(const gazebo::common::UpdateInfo& update_info); //Update trigger function
-  void _update_all_objects(double delta_time, double delta_sim_time);
-  void _update_internal_object(
-    double delta_time,
-    double delta_sim_time,
-    const crowd_simulator::AgentPtr agent_ptr,
-    const gazebo::physics::ModelPtr model_ptr,
-    const crowd_simulator::ModelTypeDatabase::RecordPtr type_ptr);
-
-  ignition::math::Pose3d _animation_root_pose(
-    const gazebo::physics::ActorPtr actor_ptr,
-    const gazebo::common::SkeletonAnimation* animation);
-
-  bool _create_model(
-    const std::string& model_name,
-    const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr,
-    const crowd_simulator::AgentPtr agent_ptr);
-};
-
-} //namespace crowd_simulation_gazebo
-
-#endif // CROWD_SIMULATION_GAZEBO__CROWD_SIMULATOR_GAZEBO_HPP
\ No newline at end of file
diff --git a/building_sim_plugins/building_gazebo_plugins/src/door.cpp b/building_sim_plugins/building_gazebo_plugins/src/door.cpp
deleted file mode 100644
index 8835047..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/door.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-#include <gazebo/common/Plugin.hh>
-#include <gazebo/physics/Model.hh>
-#include <gazebo/physics/World.hh>
-#include <gazebo/physics/Joint.hh>
-#include <gazebo_ros/node.hpp>
-#include <rclcpp/rclcpp.hpp>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/door_common.hpp>
-
-using namespace building_sim_common;
-
-namespace building_gazebo_plugins {
-//==============================================================================
-
-class DoorPlugin : public gazebo::ModelPlugin
-{
-private:
-  gazebo::event::ConnectionPtr _update_connection;
-  gazebo::physics::ModelPtr _model;
-  std::unordered_map<std::string, gazebo::physics::JointPtr> _joints;
-
-  std::shared_ptr<DoorCommon> _door_common = nullptr;
-
-  bool _initialized = false;
-
-public:
-  DoorPlugin()
-  {
-    // Do nothing
-  }
-
-  void Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf) override
-  {
-    auto _ros_node = gazebo_ros::Node::Get(sdf);
-    _model = model;
-
-    RCLCPP_INFO(
-      _ros_node->get_logger(),
-      "Loading DoorPlugin for [%s]",
-      _model->GetName().c_str());
-
-    _door_common = DoorCommon::make(
-      _model->GetName(),
-      _ros_node,
-      sdf);
-
-    if (!_door_common)
-      return;
-
-    for (const auto& joint_name : _door_common->joint_names())
-    {
-      const auto joint = _model->GetJoint(joint_name);
-      if (!joint)
-      {
-        RCLCPP_ERROR(_ros_node->get_logger(),
-          " -- Model is missing the joint [%s]",
-          joint_name.c_str());
-        return;
-      }
-      _joints.insert(std::make_pair(joint_name, joint));
-    }
-
-    _initialized = true;
-
-    _update_connection = gazebo::event::Events::ConnectWorldUpdateBegin(
-      std::bind(&DoorPlugin::on_update, this));
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Finished loading [%s]",
-      _model->GetName().c_str());
-  }
-
-private:
-
-  void on_update()
-  {
-    if (!_initialized)
-      return;
-
-    const double t = _model->GetWorld()->SimTime().Double();
-
-    // Create DoorUpdateRequest
-    std::vector<DoorCommon::DoorUpdateRequest> requests;
-    for (const auto& joint : _joints)
-    {
-      DoorCommon::DoorUpdateRequest request;
-      request.joint_name = joint.first;
-      request.position = joint.second->Position(0);
-      request.velocity = joint.second->GetVelocity(0);
-      requests.push_back(request);
-    }
-
-    auto results = _door_common->update(t, requests);
-
-    // Apply motions to the joints
-    for (const auto& result : results)
-    {
-      const auto it = _joints.find(result.joint_name);
-      assert(it != _joints.end());
-      it->second->SetParam("vel", 0, result.velocity);
-      it->second->SetParam("fmax", 0, result.fmax);
-    }
-  }
-
-};
-
-GZ_REGISTER_MODEL_PLUGIN(DoorPlugin)
-
-} // namespace building_gazebo_plugins
diff --git a/building_sim_plugins/building_gazebo_plugins/src/lift.cpp b/building_sim_plugins/building_gazebo_plugins/src/lift.cpp
deleted file mode 100644
index 684a645..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/lift.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-#include <gazebo/common/Plugin.hh>
-#include <gazebo/physics/Model.hh>
-#include <gazebo/physics/World.hh>
-#include <gazebo/physics/Joint.hh>
-#include <gazebo_ros/node.hpp>
-#include <rclcpp/rclcpp.hpp>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/lift_common.hpp>
-
-using namespace building_sim_common;
-
-namespace building_sim_gazebo {
-//==============================================================================
-
-class LiftPlugin : public gazebo::ModelPlugin
-{
-private:
-  // Gazebo items
-  gazebo::event::ConnectionPtr _update_connection;
-  gazebo::physics::ModelPtr _model;
-  gazebo::physics::JointPtr _cabin_joint_ptr;
-  gazebo_ros::Node::SharedPtr _ros_node;
-
-  std::unique_ptr<LiftCommon> _lift_common = nullptr;
-
-  bool _initialized;
-
-public:
-  LiftPlugin()
-  {
-    _initialized = false;
-  }
-
-  void Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf) override
-  {
-    _ros_node = gazebo_ros::Node::Get(sdf);
-    _model = model;
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Loading LiftPlugin for [%s]",
-      _model->GetName().c_str());
-
-    // load Lift object
-    _lift_common = LiftCommon::make(_model->GetName(), _ros_node, sdf);
-    if (!_lift_common)
-    {
-      RCLCPP_ERROR(_ros_node->get_logger(),
-        "Failed when loading [%s]",
-        _model->GetName().c_str());
-      return;
-    }
-
-    _cabin_joint_ptr = _model->GetJoint(_lift_common->get_joint_name());
-    if (!_cabin_joint_ptr)
-    {
-      RCLCPP_ERROR(_ros_node->get_logger(),
-        " -- Model is missing the joint [%s]",
-        _lift_common->get_joint_name().c_str());
-      return;
-    }
-
-    _update_connection = gazebo::event::Events::ConnectWorldUpdateBegin(
-      std::bind(&LiftPlugin::on_update, this));
-
-    _cabin_joint_ptr->SetPosition(0, _lift_common->get_elevation());
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Finished loading [%s]",
-      _model->GetName().c_str());
-
-    _initialized = true;
-  }
-
-private:
-  void on_update()
-  {
-    if (!_initialized)
-      return;
-
-    const double t = _model->GetWorld()->SimTime().Double();
-    const double position = _cabin_joint_ptr->Position(0);
-    const double velocity = _cabin_joint_ptr->GetVelocity(0);
-
-    // Send update request
-    auto result = _lift_common->update(t, position, velocity);
-
-    _cabin_joint_ptr->SetParam("vel", 0, result.velocity);
-    _cabin_joint_ptr->SetParam("fmax", 0, result.fmax);
-  }
-};
-
-GZ_REGISTER_MODEL_PLUGIN(LiftPlugin)
-
-} // namespace building_sim_gazebo
diff --git a/building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp b/building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp
deleted file mode 100644
index 648ae57..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/slotcar.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-#include <gazebo/physics/World.hh>
-#include <gazebo/physics/Model.hh>
-#include <gazebo/physics/Joint.hh>
-#include <gazebo_ros/node.hpp>
-
-#include <gazebo/common/Plugin.hh>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/slotcar_common.hpp>
-
-using namespace building_sim_common;
-
-class SlotcarPlugin : public gazebo::ModelPlugin
-{
-public:
-  SlotcarPlugin();
-  ~SlotcarPlugin();
-
-  void Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf) override;
-  void OnUpdate();
-
-private:
-  std::unique_ptr<SlotcarCommon> dataPtr;
-
-  gazebo::event::ConnectionPtr _update_connection;
-  gazebo::physics::ModelPtr _model;
-
-  std::array<gazebo::physics::JointPtr, 2> joints;
-
-  std::unordered_set<gazebo::physics::Model*> infrastructure;
-
-  // Book keeping
-  double last_update_time = 0.0;
-
-  void init_infrastructure();
-
-  std::vector<Eigen::Vector3d> get_obstacle_positions(
-    const gazebo::physics::WorldPtr& world);
-
-  void send_control_signals(const std::pair<double, double>& velocities,
-    const double dt)
-  {
-    std::array<double, 2> w_tire;
-    for (std::size_t i = 0; i < 2; ++i)
-      w_tire[i] = joints[i]->GetVelocity(0);
-    auto joint_signals = dataPtr->calculate_control_signals(w_tire,
-        velocities, dt);
-    for (std::size_t i = 0; i < 2; ++i)
-    {
-      joints[i]->SetParam("vel", 0, joint_signals[i]);
-      joints[i]->SetParam("fmax", 0, 10000000.0); // TODO(MXG): Replace with realistic torque limit
-    }
-  }
-};
-
-SlotcarPlugin::SlotcarPlugin()
-: dataPtr(std::make_unique<SlotcarCommon>())
-{
-  // We do initialization only during ::Load
-}
-
-SlotcarPlugin::~SlotcarPlugin()
-{
-}
-
-void SlotcarPlugin::Load(gazebo::physics::ModelPtr model, sdf::ElementPtr sdf)
-{
-  _model = model;
-  dataPtr->set_model_name(_model->GetName());
-  dataPtr->read_sdf(sdf);
-  gazebo_ros::Node::SharedPtr _ros_node = gazebo_ros::Node::Get(sdf);
-  dataPtr->init_ros_node(_ros_node);
-
-  RCLCPP_INFO(dataPtr->logger(),
-    "Initialising slotcar for " + model->GetName());
-
-  _update_connection = gazebo::event::Events::ConnectWorldUpdateBegin(
-    std::bind(&SlotcarPlugin::OnUpdate, this));
-
-  joints[0] = _model->GetJoint("joint_tire_left");
-  if (!joints[0])
-    RCLCPP_ERROR(dataPtr->logger(),
-      "Could not find tire for [joint_tire_left]");
-
-  joints[1] = _model->GetJoint("joint_tire_right");
-  if (!joints[1])
-    RCLCPP_ERROR(dataPtr->logger(),
-      "Could not find tire for [joint_tire_right]");
-
-}
-
-void SlotcarPlugin::init_infrastructure()
-{
-  const auto& world = _model->GetWorld();
-  infrastructure.insert(_model.get());
-  const auto& all_models = world->Models();
-  for (const auto& m : all_models)
-  {
-    // Object should not be static and part of infrastructure
-    if (!m->IsStatic())
-    {
-      std::string name = m->GetName();
-      std::for_each(name.begin(), name.end(), [](char& c)
-        {
-          c = ::tolower(c);
-        });
-      if (name.find("door") != std::string::npos ||
-        name.find("lift") != std::string::npos)
-        infrastructure.insert(m.get());
-    }
-  }
-}
-
-std::vector<Eigen::Vector3d> SlotcarPlugin::get_obstacle_positions(
-  const gazebo::physics::WorldPtr& world)
-{
-  std::vector<Eigen::Vector3d> obstacle_positions;
-
-  for (const auto& m : world->Models())
-  {
-    // Object should not be static, not part of infrastructure
-    // and close than a threshold (checked by common function)
-    const auto p_obstacle = m->WorldPose().Pos();
-    if (m->IsStatic() == false &&
-      infrastructure.find(m.get()) == infrastructure.end())
-      obstacle_positions.push_back(convert_vec(p_obstacle));
-  }
-
-  return obstacle_positions;
-}
-
-void SlotcarPlugin::OnUpdate()
-{
-  const auto& world = _model->GetWorld();
-  if (infrastructure.empty())
-    init_infrastructure();
-
-  const double time = world->SimTime().Double();
-  const double dt = time - last_update_time;
-  last_update_time = time;
-
-  auto pose = _model->WorldPose();
-  auto obstacle_positions = get_obstacle_positions(world);
-
-  auto velocities =
-    dataPtr->update(convert_pose(pose), obstacle_positions, time);
-
-  send_control_signals(velocities, dt);
-}
-
-GZ_REGISTER_MODEL_PLUGIN(SlotcarPlugin)
diff --git a/building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp b/building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp
deleted file mode 100644
index 584a92f..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/thumbnail_generator.cpp
+++ /dev/null
@@ -1,317 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <string>
-#include <iostream>
-#include <functional>
-#include <boost/program_options.hpp>
-#include <ignition/transport/Node.hh>
-#include <opencv2/opencv.hpp>
-
-#include "gazebo/msgs/msgs.hh"
-#include "gazebo/transport/transport.hh"
-#include "gazebo/sensors/SensorsIface.hh"
-#include "gazebo/common/Plugin.hh"
-#include "gazebo/rendering/rendering.hh"
-#include "gazebo/util/system.hh"
-
-using namespace gazebo;
-namespace po = boost::program_options;
-
-class GZ_PLUGIN_VISIBLE ThumbnailGenerator : public SystemPlugin
-{
-
-public:
-  /////////////////////////////////////////////
-  virtual ~ThumbnailGenerator()
-  {
-    rendering::fini();
-  }
-
-  /////////////////////////////////////////////
-  void Load(int _argc, char** _argv)
-  {
-    // System arguments Parser
-    try
-    {
-      po::options_description option{"Options"};
-      po::options_description config("Optional Configs");
-      po::options_description all_options{"Allowed Options"};
-
-      option.add_options()("input", po::value<std::string>(),
-        "Path of input sdf model")("output", po::value<std::string>(),
-        "Path of output directory");
-
-      config.add_options()("img-size", po::value<int>()->default_value(4000),
-        "Output thumbnail Image pixel size")("cam-height",
-        po::value<double>()->default_value(200),
-        "Scene camara height")("cam-hfov",
-        po::value<double>()->default_value(0.08),
-        "Scene camera horizontal FOV");
-
-      all_options.add(option).add(config);
-      _print_options_stream << all_options;
-
-      po::variables_map vm;
-      po::store(po::command_line_parser(_argc, _argv).options(
-          all_options).allow_unregistered().run(), vm);
-      po::notify(vm);
-
-      _model_path = vm["input"].as<std::string>();
-      _output_path = boost::filesystem::path(vm["output"].as<std::string>());
-      _img_size = vm["img-size"].as<int>();
-      _cam_height = vm["cam-height"].as<double>();
-      _cam_hfov = vm["cam-hfov"].as<double>();
-
-      printf(" - input model: %s \n", _model_path.c_str());
-      printf(" - output dir: %s \n", _output_path.c_str());
-      printf(" - configs: %d, %f, %f \n", _img_size, _cam_height, _cam_hfov);
-    }
-    catch (boost::exception& _e)
-    {
-      std::cerr << "\nError: Invalid arguments\n"<<std::endl;
-      this->PrintHelp();
-      _exit_flag = true;
-      return;
-    }
-
-    if (!boost::filesystem::exists(_output_path))
-      boost::filesystem::create_directories(_output_path);
-
-    std::ifstream ifs(_model_path.c_str());
-    if (!ifs)
-    {
-      std::cerr << "Error: Unable to open file[" << _model_path << "]\n";
-      this->PrintHelp();
-      _exit_flag = true;
-      return;
-    }
-
-    this->_sdf_model.reset(new sdf::SDF());
-    if (!sdf::init(this->_sdf_model))
-    {
-      std::cerr << "ERROR: SDF parsing the xml failed" << std::endl;
-      this->PrintHelp();
-      _exit_flag = true;
-      return;
-    }
-
-    if (!sdf::readFile(_model_path, this->_sdf_model))
-    {
-      std::cerr << "Error: SDF parsing the xml failed\n";
-      this->PrintHelp();
-      _exit_flag = true;
-      return;
-    }
-
-    sdf::ElementPtr model_elem = this->_sdf_model->Root()->GetElement("model");
-    this->_model_name = model_elem->Get<std::string>("name");
-    _exit_flag = false;
-  }
-
-  /////////////////////////////////////////////
-  void Init()
-  {
-    gazebo::sensors::disable();
-
-    this->_world_created_conn = event::Events::ConnectWorldCreated(
-      std::bind(&ThumbnailGenerator::OnWorldCreated, this));
-
-    this->_update_conn = event::Events::ConnectWorldUpdateBegin(
-      std::bind(&ThumbnailGenerator::Update, this));
-
-    this->_transport_node = transport::NodePtr(new transport::Node());
-    this->_transport_node->Init();
-    this->_factory_pub = this->_transport_node->Advertise<msgs::Factory>(
-      "~/factory");
-    this->_server_control_pub =
-      this->_transport_node->Advertise<msgs::ServerControl>(
-      "/gazebo/server/control");
-  }
-
-  /////////////////////////////////////////////
-  void OnWorldCreated()
-  {
-    this->_factory_pub->WaitForConnection();
-
-    if (this->_sdf_model)
-    {
-      msgs::Factory msg;
-      msg.set_sdf(this->_sdf_model->ToString());
-      this->_factory_pub->Publish(msg, true);
-    }
-  }
-
-  /////////////////////////////////////////////
-  void Update()
-  {
-    if (_exit_flag)
-    {
-      // Clean up Connections and Cameras
-      this->_world_created_conn.reset();
-      this->_update_conn.reset();
-      this->_camera.reset();
-
-      // Tell the server to stop.
-      msgs::ServerControl msg;
-      msg.set_stop(true);
-      this->_server_control_pub->Publish(msg);
-      printf(" Done, Exiting \n");
-      return;
-    }
-
-    // Make sure to initialize the rendering engine in the same thread that will
-    // capture images.
-    if (!this->_scene)
-    {
-      printf(" Initializing Thumbnails Gen Plugin \n");
-      rendering::load();
-      rendering::init();
-
-      sdf::ElementPtr cameraSDF(new sdf::Element);
-      sdf::initFile("camera.sdf", cameraSDF);
-
-      this->_scene = rendering::create_scene("default", false, true);
-      this->_camera = this->_scene->CreateCamera("viewing_cam", true);
-      this->_camera->SetCaptureData(true);
-      this->_camera->Load(cameraSDF);
-      this->_camera->Init();
-      this->_camera->SetHFOV(static_cast<ignition::math::Angle>(_cam_hfov));
-      this->_camera->SetImageWidth(_img_size);
-      this->_camera->SetImageHeight(_img_size);
-      this->_camera->CreateRenderTexture("RenderTex");
-      this->_camera->SetClipDist(100, 1000);
-
-      gazebo::rendering::RTShaderSystem::Instance()->UpdateShaders();
-      return;
-    }
-
-    // Main Thumbnail generation
-    if (this->_camera && this->_scene)
-    {
-      printf(" Generating Thumbnail for %s \n", this->_model_name.c_str());
-      event::Events::preRender();
-
-      unsigned char* img_ptr;
-      cv::Mat mask;
-
-      // Render scene with green background
-      this->_scene->SetAmbientColor(ignition::math::Color(1, 1, 1, 1));
-      this->_scene->SetBackgroundColor(ignition::math::Color(0, 1, 0, 1));
-      this->_scene->SetShadowsEnabled(false);
-      this->RenderCameraVisual();
-
-      // Create Mask acording from image with green background
-      // Get Image data from camera in scene
-      img_ptr = (unsigned char*)this->_camera->ImageData();
-      cv::Mat green_img(cv::Size(_img_size, _img_size), CV_8UC3, img_ptr);
-      cv::inRange(green_img, cv::Scalar(0, 245, 0),
-        cv::Scalar(5, 255, 5), mask);
-      cv::bitwise_not(mask, mask);
-
-      // Render scene with white background
-      // then apply "green" mask to white image to avoid green-fringe effects
-      this->_scene->SetAmbientColor(ignition::math::Color(1, 1, 1, 1));
-      this->_scene->SetBackgroundColor(ignition::math::Color(1, 1, 1, 1));
-      this->_scene->SetShadowsEnabled(false);
-      this->RenderCameraVisual();
-
-      // Get Image data from camera in scene
-      img_ptr = (unsigned char*)this->_camera->ImageData();
-      cv::Mat white_img(cv::Size(_img_size, _img_size), CV_8UC3, img_ptr);
-      cv::cvtColor(white_img, white_img, cv::COLOR_BGR2RGB);
-
-      // Created masked img with alpha val, then crop it!
-      cv::Mat masked_img(cv::Size(_img_size, _img_size), CV_8UC4);
-      cv::cvtColor(white_img, masked_img, cv::COLOR_RGB2RGBA);
-      std::vector<cv::Mat> channels;
-      cv::split(white_img, channels);
-      channels.push_back(mask);
-      cv::merge(channels, masked_img);
-      cv::Rect r = cv::boundingRect(channels[3]);
-
-      // output thumbnail png
-      std::string img_name = this->_model_name + ".png";
-      cv::imwrite((_output_path / img_name).string(), masked_img(r));
-      std::cout << img_name << " saved!" << std::endl;
-      _exit_flag = true;
-    }
-  }
-
-  /////////////////////////////////////////////
-  void RenderCameraVisual()
-  {
-    rendering::VisualPtr vis = this->_scene->GetVisual(this->_model_name);
-
-    // unfortunately, IGNITION_MATH_MAJOR_VERSION doesn't seem to be defined.
-    // we'll use the Gazebo version instead, since they usually (always?)
-    // move in lockstep
-#if GAZEBO_MAJOR_VERSION <= 9
-    ignition::math::Box bbox = vis->BoundingBox();
-#else
-    ignition::math::AxisAlignedBox bbox = vis->BoundingBox();
-#endif
-
-    // Place the visual at the origin
-    ignition::math::Vector3d trans = bbox.Center();
-    vis->SetWorldPose(
-      ignition::math::Pose3d(trans.X(), trans.Y(), trans.Z(), 0, 0, 0));
-    bbox = vis->BoundingBox();
-
-    // Generate Top view PNG Img
-    ignition::math::Pose3d pose;
-    pose.Pos().Set(0, 0, _cam_height);
-    pose.Rot().Euler(0, IGN_DTOR(90), 0);
-    this->_camera->SetWorldPose(pose);
-    this->_camera->Update();
-    this->_camera->Render(true);
-    this->_camera->PostRender();
-  }
-
-  /////////////////////////////////////////////
-  void PrintHelp()
-  {
-    std::cout << "Usage: gzserver -s libthumbnail_gen.so empty.world "
-              << "[Options] [Optional Configs] \n"
-              << std::endl;
-    std::cout << _print_options_stream.str() << std::endl;
-  }
-
-private:
-  event::ConnectionPtr _update_conn;
-  event::ConnectionPtr _world_created_conn;
-  transport::NodePtr _transport_node;
-  transport::PublisherPtr _server_control_pub;
-  transport::PublisherPtr _factory_pub;
-  rendering::ScenePtr _scene;
-  rendering::CameraPtr _camera;
-  sdf::SDFPtr _sdf_model;
-
-  bool _exit_flag;
-  std::stringstream _print_options_stream;
-  std::string _model_name;
-  std::string _model_path;
-  boost::filesystem::path _output_path;
-
-  // Optional Configs
-  int _img_size;
-  double _cam_hfov;
-  double _cam_height;
-};
-
-// Register this plugin with the simulator
-GZ_REGISTER_SYSTEM_PLUGIN(ThumbnailGenerator)
diff --git a/building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp b/building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp
deleted file mode 100644
index 5ea1f67..0000000
--- a/building_sim_plugins/building_gazebo_plugins/src/toggle_floors.cpp
+++ /dev/null
@@ -1,136 +0,0 @@
-#include <functional>
-#include <gazebo/common/Plugin.hh>
-#include <gazebo/gui/GuiPlugin.hh>
-#include <gazebo/transport/transport.hh>
-
-#include <gazebo/msgs/msgs.hh>
-#include <gazebo/rendering/rendering.hh>
-
-#include <rclcpp/rclcpp.hpp>
-#include <gazebo_ros/node.hpp>
-#include <rmf_fleet_msgs/msg/fleet_state.hpp>
-#include <rmf_fleet_msgs/msg/robot_state.hpp>
-
-#include <string>
-#include <unordered_map>
-
-using std::string;
-using FleetState = rmf_fleet_msgs::msg::FleetState;
-using RobotState = rmf_fleet_msgs::msg::RobotState;
-
-class ToggleFloors : public gazebo::GUIPlugin
-{
-  Q_OBJECT
-  gazebo::transport::NodePtr node;
-  gazebo::transport::PublisherPtr visual_pub;
-  std::unordered_map<string, std::atomic<bool>> floor_visibility;
-  gazebo_ros::Node::SharedPtr ros_node;
-  rclcpp::Subscription<FleetState>::SharedPtr fleet_state_sub;
-
-public:
-  ToggleFloors()
-  : GUIPlugin()
-  {
-    printf("ToggleFloors::ToggleFloors()\n");
-    node = gazebo::transport::NodePtr(new gazebo::transport::Node());
-    node->Init();
-    visual_pub = node->Advertise<gazebo::msgs::Visual>("~/visual");
-  }
-
-  virtual ~ToggleFloors()
-  {
-  }
-
-  void Load(sdf::ElementPtr sdf)
-  {
-    printf("ToggleFloors::Load()\n");
-    ros_node = gazebo_ros::Node::Get(sdf);
-
-    // toggle non-static robots
-    fleet_state_sub = ros_node->create_subscription<FleetState>(
-      "/fleet_states", rclcpp::SystemDefaultsQoS(),
-      [&](FleetState::UniquePtr msg)
-      {
-        bool visible;
-        gazebo::msgs::Visual visual_msg;
-        visual_msg.set_parent_name("world");
-        for (const RobotState& robot : msg->robots)
-        {
-          visible = floor_visibility[robot.location.level_name];
-          visual_msg.set_name(robot.name);
-          visual_msg.set_visible(visible);
-          visual_pub->Publish(visual_msg);
-        }
-      });
-
-    QHBoxLayout* hbox = new QHBoxLayout;
-
-    for (sdf::ElementPtr floor_ele = sdf->GetFirstElement();
-      floor_ele;
-      floor_ele = floor_ele->GetNextElement("floor"))
-    {
-      if (floor_ele->GetName() != string("floor"))
-        continue;
-      string floor_name = floor_ele->GetAttribute("name")->GetAsString();
-      string model_name =
-        floor_ele->GetAttribute("model_name")->GetAsString();
-
-      std::vector<string> models;
-      auto model_ele = floor_ele->GetElement("model");
-      while (model_ele)
-      {
-        if (model_ele->HasAttribute("name"))
-          models.push_back(model_ele->GetAttribute("name")->GetAsString());
-        model_ele = model_ele->GetNextElement("model");
-      }
-      floor_visibility[floor_name] = true;
-
-      printf(
-        "ToggleFloors::Load found a floor element: [%s]->[%s]\n",
-        floor_name.c_str(),
-        model_name.c_str());
-
-      QPushButton* button =
-        new QPushButton(QString::fromStdString(floor_name));
-      button->setCheckable(true);
-      button->setChecked(true);
-      connect(
-        button,
-        &QAbstractButton::clicked,
-        [this, button, floor_name, model_name, models]()
-        {
-          this->button_clicked(button, floor_name, model_name, models);
-        });
-      hbox->addWidget(button);
-    }
-    setLayout(hbox);
-  }
-
-  void button_clicked(
-    QPushButton* button,
-    string floor_name,
-    string model_name,
-    std::vector<string> models)
-  {
-    bool visible = button->isChecked();
-    floor_visibility[floor_name] = visible;
-    printf(
-      "clicked: [%s] %s\n",
-      model_name.c_str(),
-      visible ? "SHOW" : "HIDE");
-    gazebo::msgs::Visual visual_msg;
-    visual_msg.set_parent_name("world");
-    visual_msg.set_name(model_name);
-    visual_msg.set_visible(visible);
-    visual_pub->Publish(visual_msg);
-    for (const string& model : models)
-    {
-      visual_msg.set_name(model);
-      visual_pub->Publish(visual_msg);
-    }
-  }
-};
-
-#include "toggle_floors.moc"
-
-GZ_REGISTER_GUI_PLUGIN(ToggleFloors)
diff --git a/building_sim_plugins/building_ignition_plugins/CHANGELOG.rst b/building_sim_plugins/building_ignition_plugins/CHANGELOG.rst
deleted file mode 100644
index 402459b..0000000
--- a/building_sim_plugins/building_ignition_plugins/CHANGELOG.rst
+++ /dev/null
@@ -1,12 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package building_ignition_plugins
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-1.1.0 (2020-09-24)
-------------------
-* Focal / Ignition dome dependencies update (`#230 <https://github.com/osrf/traffic_editor/issues/230>`_)
-* Ignition crowd simulation plugin (`#218 <https://github.com/osrf/traffic_editor/issues/218>`_)
-* Create AxisAlignedBox component for slotcar (`#227 <https://github.com/osrf/traffic_editor/issues/227>`_)
-* Ignition plugins and modularization of doors and slotcar `#138 <https://github.com/osrf/traffic_editor/issues/138>`_
-* Adding lift plugin for ignition `#171 <https://github.com/osrf/traffic_editor/issues/171>`_
-* Contributors: Guoliang (Fred) Shao, Luca Della Vedova, Rushyendra Maganty, kevinskwk
diff --git a/building_sim_plugins/building_ignition_plugins/CMakeLists.txt b/building_sim_plugins/building_ignition_plugins/CMakeLists.txt
deleted file mode 100644
index a10057b..0000000
--- a/building_sim_plugins/building_ignition_plugins/CMakeLists.txt
+++ /dev/null
@@ -1,180 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(building_ignition_plugins)
-
-# Default to C99
-if(NOT CMAKE_C_STANDARD)
-  set(CMAKE_C_STANDARD 99)
-endif()
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 17)
-endif()
-
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic)
-endif()
-
-# find dependencies
-find_package(ament_cmake REQUIRED)
-find_package(rclcpp REQUIRED)
-
-find_package(ignition-cmake2 QUIET)
-if (NOT ignition-cmake2_FOUND)
-  message("ignition-cmake not found, skipping ignition gazebo plugins")
-  return()
-endif()
-ign_find_package(ignition-gazebo4 QUIET)
-if (NOT ignition-gazebo4_FOUND)
-  message("Wrong ignition-gazebo version found. Plugins require ignition-gazebo4 (dome)")
-  # To generate a setup.bash and avoid CMake warnings
-  ament_package()
-  return()
-endif()
-set(IGN_GAZEBO_VER 4)
-ign_find_package(ignition-plugin1 REQUIRED COMPONENTS register)
-set(IGN_PLUGIN_VER 1)
-ign_find_package(ignition-common3 REQUIRED)
-set(IGN_COMMON_VER 3)
-ign_find_package(ignition-math6 REQUIRED)
-ign_find_package(sdformat10 REQUIRED)
-set(IGN_MATH_VER 6)
-
-find_package(tf2_ros REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(std_msgs REQUIRED)
-find_package(std_srvs REQUIRED)
-find_package(rmf_fleet_msgs REQUIRED)
-find_package(rmf_door_msgs REQUIRED)
-find_package(rmf_lift_msgs REQUIRED)
-find_package(building_map_msgs REQUIRED)
-find_package(building_sim_common REQUIRED)
-find_package(menge QUIET)
-
-include(GNUInstallDirs)
-
-add_library(slotcar SHARED ${PROJECT_SOURCE_DIR}/src/slotcar.cpp)
-
-target_link_libraries(slotcar
-  PUBLIC
-    ignition-gazebo${IGN_GAZEBO_VER}::ignition-gazebo${IGN_GAZEBO_VER}
-    ignition-plugin${IGN_PLUGIN_VER}::ignition-plugin${IGN_PLUGIN_VER}
-    ${building_sim_common_LIBRARIES}
-    ${rmf_fleet_msgs_LIBRARIES}
-    ${rclcpp_LIBRARIES}
-    ${geometry_msgs_LIBRARIES}
-    ${tf2_ros_LIBRARIES}
-)
-
-target_include_directories(slotcar
-  PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-    ${building_sim_common_INCLUDE_DIRS}
-    ${geometry_msgs_INCLUDE_DIRS}
-    ${std_msgs_INCLUDE_DIRS}
-    ${rmf_fleet_msgs_INCLUDE_DIRS}
-    ${building_map_msgs_INCLUDE_DIRS}
-    ${tf2_ros_INCLUDE_DIRS}
-)
-
-###############################
-# door stuff
-###############################
-
-add_library(door SHARED src/door.cpp)
-
-target_include_directories(door
-  PUBLIC
-    ${building_sim_common_INCLUDE_DIRS}
-    ${geometry_msgs_INCLUDE_DIRS}
-    ${rmf_door_msgs_INCLUDE_DIRS}
-)
-
-target_link_libraries(door
-  PUBLIC
-    ${rclcpp_LIBRARIES}
-    ignition-gazebo${IGN_GAZEBO_VER}::ignition-gazebo${IGN_GAZEBO_VER}
-    ignition-plugin${IGN_PLUGIN_VER}::ignition-plugin${IGN_PLUGIN_VER}
-    ${building_sim_common_LIBRARIES}
-    ${rmf_door_msgs_LIBRARIES}
-    ${rmf_fleet_msgs_LIBRARIES}
-    #${geometry_msgs_LIBRARIES}
-    #${tf2_ros_LIBRARIES}
-)
-
-###############################
-# lift stuff
-###############################
-
-add_library(lift SHARED src/lift.cpp)
-
-target_include_directories(lift
-  PUBLIC
-    ${building_sim_common_INCLUDE_DIRS}
-    ${geometry_msgs_INCLUDE_DIRS}
-    ${rmf_door_msgs_INCLUDE_DIRS}
-    ${rmf_lift_msgs_INCLUDE_DIRS}
-)
-
-target_link_libraries(lift
-  PUBLIC
-    ${rclcpp_LIBRARIES}
-    ignition-gazebo${IGN_GAZEBO_VER}::ignition-gazebo${IGN_GAZEBO_VER}
-    ignition-plugin${IGN_PLUGIN_VER}::ignition-plugin${IGN_PLUGIN_VER}
-    ${building_sim_common_LIBRARIES}
-    ${rmf_door_msgs_LIBRARIES}
-    ${rmf_lift_msgs_LIBRARIES}
-    ${rmf_fleet_msgs_LIBRARIES}
-    #${geometry_msgs_LIBRARIES}
-    #${tf2_ros_LIBRARIES}
-)
-
-###############################
-# crowd simulator stuff
-###############################
-if (menge_FOUND)
-  add_library(crowd_simulator_ign
-    SHARED
-    src/crowd_simulator.cpp
-  )
-
-  target_include_directories(crowd_simulator_ign
-    PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-    ${building_sim_common_INCLUDE_DIRS}
-    ${rclcpp_INCLUDE_DIRS}
-    ${menge_INCLUDE_DIRS}
-    ${IGNITION-COMMON_INCLUDE_DIRS}
-  )
-
-  ament_target_dependencies(crowd_simulator_ign
-    ignition-gazebo${IGN_GAZEBO_VER}
-    ignition-plugin${IGN_PLUGIN_VER}
-    rclcpp
-    building_sim_common
-    menge
-  )
-
-  #install
-  install(
-    TARGETS crowd_simulator_ign
-    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  )
-else (NOT menge_FOUND)
-  message("menge-cmake not found, skipping crowd_simulation ignition plugins")
-endif()
-
-###############################
-# install stuff
-###############################
-
-install(
-  TARGETS slotcar door lift
-  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-)
-
-ament_package()
diff --git a/building_sim_plugins/building_ignition_plugins/package.xml b/building_sim_plugins/building_ignition_plugins/package.xml
deleted file mode 100644
index 856c4ac..0000000
--- a/building_sim_plugins/building_ignition_plugins/package.xml
+++ /dev/null
@@ -1,30 +0,0 @@
-<package format="3">
-  <name>building_ignition_plugins</name>
-  <version>1.1.0</version>
-  <description>
-    Ignition gazebo plugins for building infrastructure simulation
-  </description>
-  <author>Luca Della Vedova</author>
-  <author>Kevin Ma</author>
-  <maintainer email="luca@openrobotics.org">Luca Della Vedova</maintainer>
-  <license>Apache 2.0</license>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <!-- TODO fix dependencies -->
-  <depend>rclcpp</depend>
-  <depend>rmf_fleet_msgs</depend>
-  <depend>rmf_door_msgs</depend>
-  <depend>rmf_lift_msgs</depend>
-  <depend>tf2_ros</depend>
-  <depend>geometry_msgs</depend>
-  <depend>std_msgs</depend>
-  <depend>std_srvs</depend>
-
-  <depend>building_sim_common</depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-
-</package>
diff --git a/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp b/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp
deleted file mode 100644
index f957407..0000000
--- a/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.cpp
+++ /dev/null
@@ -1,429 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <regex>
-#include <cstdlib>
-
-#include <sdf/Actor.hh>
-
-#include <ignition/math/Pose3.hh>
-
-#include <ignition/gazebo/components/Name.hh>
-#include <ignition/gazebo/components/Model.hh>
-#include <ignition/gazebo/components/Actor.hh>
-#include <ignition/gazebo/components/Pose.hh>
-#include <ignition/gazebo/components/Static.hh>
-
-#include "crowd_simulator.hpp"
-
-namespace crowd_simulation_ign {
-
-//=================================================
-void CrowdSimulatorPlugin::Configure(
-  const ignition::gazebo::Entity& entity,
-  const std::shared_ptr<const sdf::Element>& sdf,
-  ignition::gazebo::EntityComponentManager& ecm,
-  ignition::gazebo::EventManager& event_mgr)
-{
-  _world = std::make_shared<ignition::gazebo::Model>(entity);
-  RCLCPP_INFO(_crowd_sim_interface->logger(),
-    "Initializing world plugin with name: " + _world->Name(ecm));
-  _world_name = _world->Name(ecm);
-
-  if (!_crowd_sim_interface->read_sdf(sdf))
-  {
-    RCLCPP_ERROR(_crowd_sim_interface->logger(),
-      "Error loading crowd simulator plugin. Load params failed!");
-    exit(EXIT_FAILURE);
-  }
-
-  if (!_crowd_sim_interface->init_crowd_sim())
-  {
-    RCLCPP_ERROR(_crowd_sim_interface->logger(),
-      "Error loading crowd simulator plugin. Load [ Menge ] failed!");
-    exit(EXIT_FAILURE);
-  }
-
-  if (!_spawn_agents_in_world(ecm))
-  {
-    RCLCPP_ERROR(
-      _crowd_sim_interface->logger(),
-      "Error loading crowd simulator plugin. Crowd Simulator failed to spawn agents in the world!");
-    exit(EXIT_FAILURE);
-  }
-
-}
-
-//=================================================
-void CrowdSimulatorPlugin::PreUpdate(
-  const ignition::gazebo::UpdateInfo& info,
-  ignition::gazebo::EntityComponentManager& ecm)
-{
-  // wait for all the models and actors loaded in ignition rendering
-  if (!_initialized)
-  {
-    _init_spawned_agents(ecm);
-    return;
-  }
-
-  std::chrono::duration<double> delta_time_tmp = info.simTime - _last_time;
-  double delta_time = delta_time_tmp.count();
-  _last_time = info.simTime;
-
-  std::chrono::duration<double> delta_sim_time_tmp = info.simTime -
-    _last_sim_time;
-  double delta_sim_time = delta_sim_time_tmp.count();
-  if (_crowd_sim_interface->get_sim_time_step() > delta_sim_time)  // not reach one time sim update
-  {
-    delta_sim_time = 0.0;
-  }
-  else
-  {
-    this->_last_sim_time = info.simTime;
-    this->_crowd_sim_interface->one_step_sim();
-  }
-
-  this->_update_all_objects(delta_time, delta_sim_time, ecm);
-}
-
-//==========================================================
-bool CrowdSimulatorPlugin::_spawn_agents_in_world(
-  ignition::gazebo::EntityComponentManager& ecm)
-{
-  size_t object_count = this->_crowd_sim_interface->get_num_objects();
-  for (size_t id = 0; id < object_count; ++id)
-  {
-    auto object_ptr = this->_crowd_sim_interface->get_object_by_id(id);
-    assert(object_ptr);
-    _object_dic[object_ptr->model_name] = id;
-
-    if (!object_ptr->is_external)
-    {
-      auto type_ptr = _crowd_sim_interface->_model_type_db_ptr->get(
-        object_ptr->type_name);
-      assert(type_ptr);
-      if (!this->_create_entity(ecm, object_ptr->model_name, type_ptr) )
-      {
-        RCLCPP_ERROR(_crowd_sim_interface->logger(),
-          "Failed to insert model [ " + object_ptr->model_name + " ] in world");
-        return false;
-      }
-    }
-  }
-  return true;
-}
-
-//==========================================================
-void CrowdSimulatorPlugin::_init_spawned_agents(
-  ignition::gazebo::EntityComponentManager& ecm)
-{
-  // check all the models are in the world
-  std::unordered_map<std::string, size_t> objects_name;
-  size_t object_count = _crowd_sim_interface->get_num_objects();
-  for (size_t id = 0; id < object_count; id++)
-  {
-    auto obj = _crowd_sim_interface->get_object_by_id(id);
-    // already found in the Dic
-    if (_entity_dic.find(obj->model_name) != _entity_dic.end())
-      continue;
-    objects_name.insert({obj->model_name, id});
-  }
-  // for external agent
-  ecm.Each<ignition::gazebo::components::Model,
-    ignition::gazebo::components::Name>(
-    [&](const ignition::gazebo::Entity& entity,
-    const ignition::gazebo::components::Model*,
-    const ignition::gazebo::components::Name* name) -> bool
-    {
-      auto it_objects_name = objects_name.find(name->Data());
-      if (it_objects_name != objects_name.end())
-      {
-        // update in entityDic
-        _entity_dic[name->Data()] = entity;
-        auto obj_ptr =
-        _crowd_sim_interface->get_object_by_id(it_objects_name->second);
-        // config internal spawned agent for custom trajectory
-        if (!obj_ptr->is_external)
-        {
-          _config_spawned_agents(obj_ptr, entity, ecm);
-        }
-        objects_name.erase(name->Data());
-        RCLCPP_INFO(_crowd_sim_interface->logger(),
-        "Crowd Simulator found agent: " + name->Data() );
-      }
-      return true;
-    }
-    );
-  // for internal agent
-  ecm.Each<ignition::gazebo::components::Actor,
-    ignition::gazebo::components::Name>(
-    [&](const ignition::gazebo::Entity& entity,
-    const ignition::gazebo::components::Actor*,
-    const ignition::gazebo::components::Name* name) -> bool
-    {
-      auto it_objects_name = objects_name.find(name->Data());
-      if (it_objects_name != objects_name.end())
-      {
-        // update in entityDic
-        _entity_dic[name->Data()] = entity;
-        auto obj_ptr =
-        _crowd_sim_interface->get_object_by_id(it_objects_name->second);
-        // config internal spawned agent for custom trajectory
-        if (!obj_ptr->is_external)
-        {
-          _config_spawned_agents(obj_ptr, entity, ecm);
-        }
-        objects_name.erase(name->Data());
-        RCLCPP_INFO(_crowd_sim_interface->logger(),
-        "Crowd Simulator found agent: " + name->Data() );
-      }
-      return true;
-    }
-    );
-
-  // external agents not found or not loaded yet
-  if (objects_name.size() != 0)
-  {
-    _initialized = false;
-    return;
-  }
-  _initialized = true;
-  RCLCPP_INFO(
-    _crowd_sim_interface->logger(),
-    "Ignition Models are all loaded! Start simulating...");
-}
-
-//===================================================================
-bool CrowdSimulatorPlugin::_create_entity(
-  ignition::gazebo::EntityComponentManager& ecm,
-  const std::string& model_name,
-  const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr) const
-{
-  // Use ignition create service to spawn actors
-  // calling ignition gazebo create service, you can use "ign service -l" to check the service available
-  assert(model_type_ptr);
-  std::string service = "/world/" + this->_world_name + "/create";
-  ignition::msgs::EntityFactory request;
-  request.set_sdf_filename(model_type_ptr->file_name);
-  request.set_name(model_name);
-  ignition::math::Pose3d pose(0, 0, 0, 0, 0, 0);
-
-  ignition::msgs::Boolean response;
-  bool result;
-  uint32_t timeout = 5000;
-  bool executed = this->_transport_node_ptr->Request(service, request, timeout,
-      response, result);
-  if (executed)
-  {
-    if (result && response.data())
-    {
-      RCLCPP_INFO(_crowd_sim_interface->logger(),
-        "Requested creation of entity: " + model_name);
-      return true;
-    }
-    else
-    {
-      RCLCPP_ERROR(_crowd_sim_interface->logger(),
-        "Failed request to create entity.\n" + request.DebugString());
-    }
-  }
-  else
-  {
-    RCLCPP_ERROR(
-      _crowd_sim_interface->logger(),
-      "Request to create entity from service " + service + "timer out ...\n" +
-      request.DebugString());
-  }
-  return false;
-}
-
-//==================================================
-void CrowdSimulatorPlugin::_config_spawned_agents(
-  const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
-  const ignition::gazebo::Entity& entity,
-  ignition::gazebo::EntityComponentManager& ecm) const
-{
-  assert(obj_ptr);
-  auto agent_ptr = obj_ptr->agent_ptr;
-  // different from gazebo plugin, the pose component is the origin of the trajPose
-  ignition::math::Pose3d actor_pose(
-    static_cast<double>(agent_ptr->_pos.x()),
-    static_cast<double>(agent_ptr->_pos.y()), 0.0,
-    0, 0, 0
-  );
-
-  // get pose component for entity
-  auto pose_comp = ecm.Component<ignition::gazebo::components::Pose>(entity);
-  if (nullptr == pose_comp)
-  {
-    // use the initial_pose for actor type
-    ignition::math::Pose3d initial_pose =
-      _crowd_sim_interface->_model_type_db_ptr->get(obj_ptr->type_name)->pose.
-      convert_to_ign_math_pose_3d<ignition::math::Pose3d>();
-    ecm.CreateComponent(entity,
-      ignition::gazebo::components::Pose(initial_pose));
-  }
-  else
-  {
-    // original pose in the world
-    *pose_comp =
-      ignition::gazebo::components::Pose(ignition::math::Pose3d(0, 0, 0, 0, 0,
-        0));
-  }
-
-  // initialize agent animationName
-  std::string animation_name = _crowd_sim_interface->_model_type_db_ptr->get(
-    obj_ptr->type_name)->animation;
-  assert(!animation_name.empty());
-
-  auto animation_name_comp =
-    ecm.Component<ignition::gazebo::components::AnimationName>(entity);
-  if (nullptr == animation_name_comp)
-  {
-    ecm.CreateComponent(entity,
-      ignition::gazebo::components::AnimationName(animation_name));
-  }
-  else
-  {
-    *animation_name_comp = ignition::gazebo::components::AnimationName(
-      animation_name);
-  }
-  // mark as one-time-change
-  ecm.SetChanged(
-    entity,
-    ignition::gazebo::components::AnimationName::typeId,
-    ignition::gazebo::ComponentState::OneTimeChange);
-  // initialize agent animationTime
-  auto anim_time_comp =
-    ecm.Component<ignition::gazebo::components::AnimationTime>(entity);
-  if (nullptr == anim_time_comp)
-  {
-    ecm.CreateComponent(entity, ignition::gazebo::components::AnimationTime());
-  }
-  // having a trajectory pose prevents the actor from moving with the sdf script
-  auto traj_pose_comp =
-    ecm.Component<ignition::gazebo::components::TrajectoryPose>(entity);
-  if (nullptr == traj_pose_comp)
-  {
-    ecm.CreateComponent(entity,
-      ignition::gazebo::components::TrajectoryPose(actor_pose));
-  }
-}
-
-//============================================================================
-void CrowdSimulatorPlugin::_update_all_objects(
-  double delta_time,
-  double delta_sim_time,
-  ignition::gazebo::EntityComponentManager& ecm) const
-{
-  auto objects_count = _crowd_sim_interface->get_num_objects();
-  for (size_t id = 0; id < objects_count; id++)
-  {
-    auto obj_ptr = _crowd_sim_interface->get_object_by_id(id);
-    auto it_entity = _entity_dic.find(obj_ptr->model_name);
-    if (it_entity == _entity_dic.end())   //safe check
-    {
-      RCLCPP_ERROR(_crowd_sim_interface->logger(),
-        "Didn't initialize external agent [" + obj_ptr->model_name + "]");
-      exit(EXIT_FAILURE);
-    }
-    auto entity = it_entity->second;
-
-    // for external agent
-    if (obj_ptr->is_external)
-    {
-      auto model_pose =
-        ecm.Component<ignition::gazebo::components::Pose>(entity)->Data();
-      _crowd_sim_interface->update_external_agent(obj_ptr->agent_ptr,
-        model_pose);
-      continue;
-    }
-
-    // for internal agent
-    if (delta_sim_time - 0.0 < 1e-6)
-      continue;// not yet reach the simulation update time
-    _update_internal_object(delta_sim_time, obj_ptr, entity, ecm);
-  }
-}
-
-void CrowdSimulatorPlugin::_update_internal_object(
-  double delta_sim_time,
-  const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
-  const ignition::gazebo::Entity& entity,
-  ignition::gazebo::EntityComponentManager& ecm) const
-{
-  double animation_speed = _crowd_sim_interface->_model_type_db_ptr->get(
-    obj_ptr->type_name)->animation_speed;
-  ignition::math::Pose3d initial_pose =
-    _crowd_sim_interface->_model_type_db_ptr->get(obj_ptr->type_name)->pose.
-    convert_to_ign_math_pose_3d<ignition::math::Pose3d>();
-  ignition::math::Pose3d agent_pose =
-    _crowd_sim_interface->get_agent_pose<ignition::math::Pose3d>(
-    obj_ptr->agent_ptr, delta_sim_time);
-  agent_pose += initial_pose;
-
-  auto traj_pose_comp =
-    ecm.Component<ignition::gazebo::components::TrajectoryPose>(entity);
-  if (nullptr == traj_pose_comp)
-  {
-    RCLCPP_ERROR(_crowd_sim_interface->logger(),
-      "Model [" + obj_ptr->model_name + "] has no TrajectoryPose component.");
-    exit(EXIT_FAILURE);
-  }
-  ignition::math::Pose3d current_pose = traj_pose_comp->Data();
-
-  auto distance_traveled_vector = agent_pose.Pos() - current_pose.Pos();
-  // might need future work on 3D case
-  // the center of human has a z_elevation, which will make the human keep walking even if he reached the target
-  distance_traveled_vector.Z(0.0);
-  double distance_traveled = distance_traveled_vector.Length();
-
-  // set trajectory
-  *traj_pose_comp = ignition::gazebo::components::TrajectoryPose(agent_pose);
-  ecm.SetChanged(entity,
-    ignition::gazebo::components::TrajectoryPose::typeId,
-    ignition::gazebo::ComponentState::OneTimeChange);
-  //set animation
-  auto anim_time_comp =
-    ecm.Component<ignition::gazebo::components::AnimationTime>(entity);
-  if (nullptr == anim_time_comp)
-  {
-    RCLCPP_ERROR(_crowd_sim_interface->logger(),
-      "Model [" + obj_ptr->model_name + "] has no AnimationTime component");
-    exit(EXIT_FAILURE);
-  }
-  auto anim_time = anim_time_comp->Data() +
-    std::chrono::duration_cast<std::chrono::steady_clock::duration>(
-    std::chrono::duration<double>(distance_traveled / animation_speed));
-
-  *anim_time_comp = ignition::gazebo::components::AnimationTime(anim_time);
-  ecm.SetChanged(entity,
-    ignition::gazebo::components::AnimationTime::typeId,
-    ignition::gazebo::ComponentState::OneTimeChange);
-}
-
-} //namespace crowd_simulation_ign
-
-IGNITION_ADD_PLUGIN(
-  crowd_simulation_ign::CrowdSimulatorPlugin,
-  ignition::gazebo::System,
-  crowd_simulation_ign::CrowdSimulatorPlugin::ISystemConfigure,
-  crowd_simulation_ign::CrowdSimulatorPlugin::ISystemPreUpdate)
-
-// TODO would prefer namespace
-IGNITION_ADD_PLUGIN_ALIAS(crowd_simulation_ign::CrowdSimulatorPlugin,
-  "crowd_simulator")
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp b/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp
deleted file mode 100644
index cb5a910..0000000
--- a/building_sim_plugins/building_ignition_plugins/src/crowd_simulator.hpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <unordered_map>
-
-#include <rclcpp/rclcpp.hpp>
-
-#include <ignition/plugin/Register.hh>
-#include <ignition/gazebo/System.hh>
-#include <ignition/gazebo/Model.hh>
-
-#include <ignition/transport/Node.hh>
-
-#include <building_sim_common/crowd_simulator_common.hpp>
-
-
-namespace crowd_simulation_ign {
-
-class IGNITION_GAZEBO_VISIBLE CrowdSimulatorPlugin
-  : public ignition::gazebo::System,
-  public ignition::gazebo::ISystemConfigure,
-  public ignition::gazebo::ISystemPreUpdate
-{
-public:
-  CrowdSimulatorPlugin()
-  : _transport_node_ptr(std::make_shared<ignition::transport::Node>()),
-    _crowd_sim_interface(std::make_shared<crowd_simulator::CrowdSimInterface>()),
-    _initialized(false)
-  {}
-
-  // inherit from ISystemConfigure
-  void Configure(const ignition::gazebo::Entity& entity,
-    const std::shared_ptr<const sdf::Element>& sdf,
-    ignition::gazebo::EntityComponentManager& ecm,
-    ignition::gazebo::EventManager& event_mgr) override;
-
-  // inherit from ISystemPreUpdate
-  void PreUpdate(const ignition::gazebo::UpdateInfo& info,
-    ignition::gazebo::EntityComponentManager& ecm) override;
-
-private:
-  std::shared_ptr<ignition::transport::Node> _transport_node_ptr;
-  std::shared_ptr<crowd_simulator::CrowdSimInterface> _crowd_sim_interface;
-  bool _initialized;
-  std::chrono::steady_clock::duration _last_sim_time{0};
-  std::chrono::steady_clock::duration _last_time{0};
-
-  std::shared_ptr<ignition::gazebo::Model> _world;
-  std::string _world_name;
-
-  // map for <model_name, object_id>, contains both external (models) and internal agents (actors)
-  std::unordered_map<std::string, size_t> _object_dic;
-  // map for <model_name, entity_id> contains external and internal agents
-  std::unordered_map<std::string, ignition::gazebo::Entity> _entity_dic;
-
-  bool _spawn_agents_in_world(ignition::gazebo::EntityComponentManager& ecm);
-  void _init_spawned_agents(ignition::gazebo::EntityComponentManager& ecm);
-  void _config_spawned_agents(
-    const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
-    const ignition::gazebo::Entity& enity,
-    ignition::gazebo::EntityComponentManager& ecm) const;
-  bool _create_entity(
-    ignition::gazebo::EntityComponentManager& ecm,
-    const std::string& model_name,
-    const crowd_simulator::ModelTypeDatabase::RecordPtr model_type_ptr) const;
-  void _update_all_objects(
-    double delta_time,
-    double delta_sim_time,
-    ignition::gazebo::EntityComponentManager& ecm) const;
-  void _update_internal_object(
-    double delta_sim_time,
-    const crowd_simulator::CrowdSimInterface::ObjectPtr obj_ptr,
-    const ignition::gazebo::Entity& enity,
-    ignition::gazebo::EntityComponentManager& ecm) const;
-};
-
-} //namespace crowd_simulation_ign
\ No newline at end of file
diff --git a/building_sim_plugins/building_ignition_plugins/src/door.cpp b/building_sim_plugins/building_ignition_plugins/src/door.cpp
deleted file mode 100644
index 4f1c67f..0000000
--- a/building_sim_plugins/building_ignition_plugins/src/door.cpp
+++ /dev/null
@@ -1,158 +0,0 @@
-#include <ignition/plugin/Register.hh>
-
-#include <ignition/gazebo/System.hh>
-#include <ignition/gazebo/Model.hh>
-#include <ignition/gazebo/components/JointAxis.hh>
-#include <ignition/gazebo/components/JointPosition.hh>
-#include <ignition/gazebo/components/JointVelocity.hh>
-#include <ignition/gazebo/components/JointVelocityCmd.hh>
-
-#include <rclcpp/rclcpp.hpp>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/door_common.hpp>
-
-// TODO remove this
-using namespace ignition;
-using namespace gazebo;
-using namespace systems;
-
-using namespace building_sim_common;
-
-namespace building_ignition_plugins {
-
-//==============================================================================
-
-class IGNITION_GAZEBO_VISIBLE DoorPlugin
-  : public System,
-  public ISystemConfigure,
-  public ISystemPreUpdate
-{
-private:
-  rclcpp::Node::SharedPtr _ros_node;
-  std::unordered_map<std::string, Entity> _joints;
-
-  std::shared_ptr<DoorCommon> _door_common = nullptr;
-
-  bool _initialized = false;
-
-  void create_entity_components(Entity entity, EntityComponentManager& ecm)
-  {
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointPosition().TypeId()))
-      ecm.CreateComponent(entity, components::JointPosition({0}));
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointVelocity().TypeId()))
-      ecm.CreateComponent(entity, components::JointVelocity({0}));
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointVelocityCmd().TypeId()))
-      ecm.CreateComponent(entity, components::JointVelocityCmd({0}));
-  }
-
-public:
-  DoorPlugin()
-  {
-    // TODO init ros node
-    // Do nothing
-  }
-
-  void Configure(const Entity& entity,
-    const std::shared_ptr<const sdf::Element>& sdf,
-    EntityComponentManager& ecm, EventManager& /*_eventMgr*/) override
-  {
-    //_ros_node = gazebo_ros::Node::Get(sdf);
-    // TODO get properties from sdf instead of hardcoded (will fail for multiple instantiations)
-    // TODO proper rclcpp init (only once and pass args)
-    auto model = Model(entity);
-    char const** argv = NULL;
-    std::string name;
-    auto door_ele = sdf->GetElementImpl("door");
-    get_sdf_attribute_required<std::string>(door_ele, "name", name);
-    if (!rclcpp::is_initialized())
-      rclcpp::init(0, argv);
-    std::string plugin_name("plugin_" + name);
-    ignwarn << "Initializing plugin with name " << plugin_name << std::endl;
-    _ros_node = std::make_shared<rclcpp::Node>(plugin_name);
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Loading DoorPlugin for [%s]",
-      name.c_str());
-
-    _door_common = DoorCommon::make(
-      name,
-      _ros_node,
-      sdf);
-
-    if (!_door_common)
-      return;
-
-    for (const auto& joint_name : _door_common->joint_names())
-    {
-      const auto joint = model.JointByName(ecm, joint_name);
-      if (!joint)
-      {
-        RCLCPP_ERROR(_ros_node->get_logger(),
-          " -- Model is missing the joint [%s]",
-          joint_name.c_str());
-        return;
-      }
-      create_entity_components(joint, ecm);
-      _joints.insert({joint_name, joint});
-    }
-
-    _initialized = true;
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Finished loading [%s]",
-      name.c_str());
-  }
-
-  void PreUpdate(const UpdateInfo& info, EntityComponentManager& ecm) override
-  {
-    // TODO parallel thread executor?
-    rclcpp::spin_some(_ros_node);
-    if (!_initialized)
-      return;
-
-    double t =
-      (std::chrono::duration_cast<std::chrono::nanoseconds>(info.simTime).
-      count()) * 1e-9;
-
-    // Create DoorUpdateRequest
-    std::vector<DoorCommon::DoorUpdateRequest> requests;
-    for (const auto& joint : _joints)
-    {
-      DoorCommon::DoorUpdateRequest request;
-      request.joint_name = joint.first;
-      request.position = ecm.Component<components::JointPosition>(
-        joint.second)->Data()[0];
-      request.velocity = ecm.Component<components::JointVelocity>(
-        joint.second)->Data()[0];
-      requests.push_back(request);
-    }
-
-    auto results = _door_common->update(t, requests);
-
-    // Apply motions to the joints
-    for (const auto& result : results)
-    {
-      const auto it = _joints.find(result.joint_name);
-      assert(it != _joints.end());
-      auto vel_cmd = ecm.Component<components::JointVelocityCmd>(
-        it->second);
-      vel_cmd->Data()[0] = result.velocity;
-    }
-  }
-
-};
-
-IGNITION_ADD_PLUGIN(
-  DoorPlugin,
-  System,
-  DoorPlugin::ISystemConfigure,
-  DoorPlugin::ISystemPreUpdate)
-
-// TODO would prefer namespaced
-IGNITION_ADD_PLUGIN_ALIAS(DoorPlugin, "door")
-
-} // namespace building_ignition_plugins
diff --git a/building_sim_plugins/building_ignition_plugins/src/lift.cpp b/building_sim_plugins/building_ignition_plugins/src/lift.cpp
deleted file mode 100644
index b2fb3a9..0000000
--- a/building_sim_plugins/building_ignition_plugins/src/lift.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-#include <ignition/plugin/Register.hh>
-
-#include <ignition/gazebo/System.hh>
-#include <ignition/gazebo/Model.hh>
-#include <ignition/gazebo/components/JointAxis.hh>
-#include <ignition/gazebo/components/JointPosition.hh>
-#include <ignition/gazebo/components/JointVelocity.hh>
-#include <ignition/gazebo/components/JointVelocityCmd.hh>
-#include <ignition/gazebo/components/JointPositionReset.hh>
-
-#include <rclcpp/rclcpp.hpp>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/lift_common.hpp>
-
-// TODO remove this
-using namespace ignition;
-using namespace gazebo;
-using namespace systems;
-
-using namespace building_sim_common;
-
-namespace building_sim_ign {
-
-//==============================================================================
-
-class IGNITION_GAZEBO_VISIBLE LiftPlugin
-  : public System,
-  public ISystemConfigure,
-  public ISystemPreUpdate
-{
-private:
-  rclcpp::Node::SharedPtr _ros_node;
-  Entity _cabin_joint;
-
-  std::unique_ptr<LiftCommon> _lift_common = nullptr;
-
-  bool _initialized = false;
-
-  void create_entity_components(Entity entity, EntityComponentManager& ecm)
-  {
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointPosition().TypeId()))
-      ecm.CreateComponent(entity, components::JointPosition({0}));
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointPositionReset().TypeId()))
-      ecm.CreateComponent(entity, components::JointPositionReset({0}));
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointVelocity().TypeId()))
-      ecm.CreateComponent(entity, components::JointVelocity({0}));
-    if (!ecm.EntityHasComponentType(entity,
-      components::JointVelocityCmd().TypeId()))
-      ecm.CreateComponent(entity, components::JointVelocityCmd({0}));
-  }
-
-public:
-  LiftPlugin()
-  {
-    // TODO init ros node
-    // Do nothing
-  }
-
-  void Configure(const Entity& entity,
-    const std::shared_ptr<const sdf::Element>& sdf,
-    EntityComponentManager& ecm, EventManager& /*_eventMgr*/) override
-  {
-    //_ros_node = gazebo_ros::Node::Get(sdf);
-    // TODO get properties from sdf instead of hardcoded (will fail for multiple instantiations)
-    // TODO proper rclcpp init (only once and pass args)
-    auto model = Model(entity);
-    char const** argv = NULL;
-    if (!rclcpp::is_initialized())
-      rclcpp::init(0, argv);
-    std::string plugin_name("plugin_" + model.Name(ecm));
-    ignwarn << "Initializing plugin with name " << plugin_name << std::endl;
-    _ros_node = std::make_shared<rclcpp::Node>(plugin_name);
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Loading LiftPlugin for [%s]",
-      model.Name(ecm).c_str());
-
-    _lift_common = LiftCommon::make(
-      model.Name(ecm),
-      _ros_node,
-      sdf);
-
-    if (!_lift_common)
-      return;
-
-    const auto joint = model.JointByName(ecm, _lift_common->get_joint_name());
-    if (!joint)
-    {
-      RCLCPP_ERROR(_ros_node->get_logger(),
-        " -- Model is missing the joint [%s]",
-        _lift_common->get_joint_name().c_str());
-      return;
-    }
-    create_entity_components(joint, ecm);
-    _cabin_joint = joint;
-
-    auto position_cmd = ecm.Component<components::JointPositionReset>(
-      _cabin_joint);
-    position_cmd->Data()[0] = _lift_common->get_elevation();
-
-    _initialized = true;
-
-    RCLCPP_INFO(_ros_node->get_logger(),
-      "Finished loading [%s]",
-      model.Name(ecm).c_str());
-  }
-
-  void PreUpdate(const UpdateInfo& info, EntityComponentManager& ecm) override
-  {
-    // TODO parallel thread executor?
-    rclcpp::spin_some(_ros_node);
-    if (!_initialized)
-      return;
-
-    // Send update request
-    const double t =
-      (std::chrono::duration_cast<std::chrono::nanoseconds>(info.simTime).
-      count()) * 1e-9;
-    const double position = ecm.Component<components::JointPosition>(
-      _cabin_joint)->Data()[0];
-    const double velocity = ecm.Component<components::JointVelocity>(
-      _cabin_joint)->Data()[0];
-
-    auto result = _lift_common->update(t, position, velocity);
-
-    // Apply motion to the joint
-    auto vel_cmd = ecm.Component<components::JointVelocityCmd>(
-      _cabin_joint);
-    vel_cmd->Data()[0] = result.velocity;
-  }
-};
-
-IGNITION_ADD_PLUGIN(
-  LiftPlugin,
-  System,
-  LiftPlugin::ISystemConfigure,
-  LiftPlugin::ISystemPreUpdate)
-
-// TODO would prefer namespaced
-IGNITION_ADD_PLUGIN_ALIAS(LiftPlugin, "lift")
-
-} // namespace building_sim_ign
diff --git a/building_sim_plugins/building_ignition_plugins/src/slotcar.cpp b/building_sim_plugins/building_ignition_plugins/src/slotcar.cpp
deleted file mode 100644
index 539f7a4..0000000
--- a/building_sim_plugins/building_ignition_plugins/src/slotcar.cpp
+++ /dev/null
@@ -1,220 +0,0 @@
-#include <ignition/plugin/Register.hh>
-
-#include <ignition/gazebo/System.hh>
-#include <ignition/gazebo/Model.hh>
-#include <ignition/gazebo/components/JointVelocity.hh>
-#include <ignition/gazebo/components/JointVelocityCmd.hh>
-#include <ignition/gazebo/components/Model.hh>
-#include <ignition/gazebo/components/Name.hh>
-#include <ignition/gazebo/components/Pose.hh>
-#include <ignition/gazebo/components/Static.hh>
-#include <ignition/gazebo/components/AxisAlignedBox.hh>
-
-#include <rclcpp/rclcpp.hpp>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/slotcar_common.hpp>
-
-using namespace ignition::gazebo;
-
-using namespace building_sim_common;
-
-class IGNITION_GAZEBO_VISIBLE SlotcarPlugin
-  : public System,
-  public ISystemConfigure,
-  public ISystemPreUpdate
-{
-public:
-  SlotcarPlugin();
-  ~SlotcarPlugin();
-
-  void Configure(const Entity& entity,
-    const std::shared_ptr<const sdf::Element>& sdf,
-    EntityComponentManager& ecm, EventManager& eventMgr) override;
-  void path_request_cb(const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg);
-  void mode_request_cb(const rmf_fleet_msgs::msg::ModeRequest::SharedPtr msg);
-  void PreUpdate(const UpdateInfo& info, EntityComponentManager& ecm) override;
-
-private:
-  std::unique_ptr<SlotcarCommon> dataPtr;
-
-  rclcpp::Node::SharedPtr _ros_node;
-  Entity _entity;
-
-  std::array<Entity, 2> joints;
-  std::unique_ptr<rclcpp::executors::MultiThreadedExecutor> executor;
-
-  std::unordered_set<Entity> _infrastructure;
-
-  void send_control_signals(EntityComponentManager& ecm,
-    const std::pair<double, double>& velocities,
-    const double dt)
-  {
-    std::array<double, 2> w_tire;
-    for (std::size_t i = 0; i < 2; ++i)
-      w_tire[i] =
-        ecm.Component<components::JointVelocity>(joints[i])->Data()[0];
-    auto joint_signals = dataPtr->calculate_control_signals(w_tire,
-        velocities, dt);
-    for (std::size_t i = 0; i < 2; ++i)
-    {
-      auto vel_cmd = ecm.Component<components::JointVelocityCmd>(joints[i]);
-      vel_cmd->Data()[0] = joint_signals[i];
-    }
-  }
-
-  void init_infrastructure(EntityComponentManager& ecm);
-
-  std::vector<Eigen::Vector3d> get_obstacle_positions(
-    EntityComponentManager& ecm);
-};
-
-SlotcarPlugin::SlotcarPlugin()
-: dataPtr(std::make_unique<SlotcarCommon>())
-{
-  // We do initialization only during ::Configure
-}
-
-SlotcarPlugin::~SlotcarPlugin()
-{
-}
-
-void SlotcarPlugin::Configure(const Entity& entity,
-  const std::shared_ptr<const sdf::Element>& sdf,
-  EntityComponentManager& ecm, EventManager&)
-{
-  _entity = entity;
-  auto model = Model(entity);
-  std::string model_name = model.Name(ecm);
-  dataPtr->set_model_name(model_name);
-  dataPtr->read_sdf(sdf);
-  // TODO proper argc argv
-  char const** argv = NULL;
-  if (!rclcpp::is_initialized())
-    rclcpp::init(0, argv);
-  std::string plugin_name("plugin_" + model_name);
-  _ros_node = std::make_shared<rclcpp::Node>(plugin_name);
-  // TODO Check if executor is getting callbacks
-  //executor = std::make_unique<rclcpp::executors::MultiThreadedExecutor>();
-  //executor->add_node(_ros_node);
-  //executor->spin();
-  dataPtr->init_ros_node(_ros_node);
-
-  joints[0] = model.JointByName(ecm, "joint_tire_left");
-  if (!joints[0])
-    RCLCPP_ERROR(dataPtr->logger(),
-      "Could not find tire for [joint_tire_left]");
-
-  joints[1] = model.JointByName(ecm, "joint_tire_right");
-  if (!joints[1])
-    RCLCPP_ERROR(dataPtr->logger(),
-      "Could not find tire for [joint_tire_right]");
-
-  // Initialise JointVelocityCmd / JointVelocity components for velocity control
-  for (const auto& joint : joints)
-  {
-    if (!ecm.EntityHasComponentType(joint,
-      components::JointVelocityCmd().TypeId()))
-      ecm.CreateComponent(joint, components::JointVelocityCmd({0}));
-    if (!ecm.EntityHasComponentType(joint,
-      components::JointVelocity().TypeId()))
-      ecm.CreateComponent(joint, components::JointVelocity({0}));
-  }
-  // Initialize Pose3d component
-  if (!ecm.EntityHasComponentType(entity, components::Pose().TypeId()))
-    ecm.CreateComponent(entity, components::Pose());
-  // Initialize Bounding Box component
-  if (!ecm.EntityHasComponentType(entity,
-    components::AxisAlignedBox().TypeId()))
-  {
-    ecm.CreateComponent(entity, components::AxisAlignedBox());
-  }
-}
-
-void SlotcarPlugin::init_infrastructure(EntityComponentManager& ecm)
-{
-  // Cycle through all the static entities with Model and Name components
-  ecm.Each<components::Model, components::Name, components::Pose,
-    components::Static>(
-    [&](const Entity& entity,
-    const components::Model*,
-    const components::Name* name,
-    const components::Pose*,
-    const components::Static* is_static
-    ) -> bool
-    {
-      if (is_static->Data() == false)
-      {
-        std::string n = name->Data();
-        std::for_each(n.begin(), n.end(), [](char& c)
-        {
-          c = ::tolower(c);
-        });
-        if (n.find("door") != std::string::npos ||
-        n.find("lift") != std::string::npos)
-          _infrastructure.insert(entity);
-      }
-      return true;
-    });
-  // Also add itself
-  _infrastructure.insert(_entity);
-}
-
-std::vector<Eigen::Vector3d> SlotcarPlugin::get_obstacle_positions(
-  EntityComponentManager& ecm)
-{
-  std::vector<Eigen::Vector3d> obstacle_positions;
-  ecm.Each<components::Model, components::Name, components::Pose,
-    components::Static>(
-    [&](const Entity& entity,
-    const components::Model*,
-    const components::Name*,
-    const components::Pose* pose,
-    const components::Static* is_static
-    ) -> bool
-    {
-      // Object should not be static
-      // It should not be part of infrastructure (doors / lifts)
-      // And it should be closer than the "stop" range (checked by common)
-      const auto obstacle_position = pose->Data().Pos();
-      if (is_static->Data() == false &&
-      _infrastructure.find(entity) == _infrastructure.end())
-      {
-        obstacle_positions.push_back(convert_vec(obstacle_position));
-      }
-      return true;
-    });
-  return obstacle_positions;
-}
-
-void SlotcarPlugin::PreUpdate(const UpdateInfo& info,
-  EntityComponentManager& ecm)
-{
-  // TODO parallel thread executor?
-  rclcpp::spin_some(_ros_node);
-  if (_infrastructure.empty())
-    init_infrastructure(ecm);
-
-  double dt =
-    (std::chrono::duration_cast<std::chrono::nanoseconds>(info.dt).count()) *
-    1e-9;
-  double time =
-    (std::chrono::duration_cast<std::chrono::nanoseconds>(info.simTime).count())
-    * 1e-9;
-
-  auto pose = ecm.Component<components::Pose>(_entity)->Data();
-  auto obstacle_positions = get_obstacle_positions(ecm);
-
-  auto velocities =
-    dataPtr->update(convert_pose(pose), obstacle_positions, time);
-
-  send_control_signals(ecm, velocities, dt);
-}
-
-IGNITION_ADD_PLUGIN(
-  SlotcarPlugin,
-  System,
-  SlotcarPlugin::ISystemConfigure,
-  SlotcarPlugin::ISystemPreUpdate)
-
-IGNITION_ADD_PLUGIN_ALIAS(SlotcarPlugin, "slotcar")
diff --git a/building_sim_plugins/building_plugins_common/CHANGELOG.rst b/building_sim_plugins/building_plugins_common/CHANGELOG.rst
deleted file mode 100644
index dc3349f..0000000
--- a/building_sim_plugins/building_plugins_common/CHANGELOG.rst
+++ /dev/null
@@ -1,15 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package building_sim_common
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-1.1.0 (2020-09-24)
-------------------
-* Crowd simulation plugin (`#218 <https://github.com/osrf/traffic_editor/issues/218>`_)
-* Improve lift initial floor definition `#221 <https://github.com/osrf/traffic_editor/issues/221>`_
-* Update lift session id in lift plugin (`#223 <https://github.com/osrf/traffic_editor/issues/223>`_)
-* Add field in lift dialog for initial floor, handle invalid initial floor
-* Ignition plugins and modularization of doors and slotcar `#138 <https://github.com/osrf/traffic_editor/issues/138>`_
-* Adding lift plugin for ignition `#171 <https://github.com/osrf/traffic_editor/issues/171>`_
-* spawn lifts at respective reference floors
-* stagger door_state publishing
-* Contributors: Charayaphan Nakorn Boon Han, Guoliang (Fred) Shao, Kevin_Skywalker, Luca Della Vedova, MakinoharaShouko
diff --git a/building_sim_plugins/building_plugins_common/CMakeLists.txt b/building_sim_plugins/building_plugins_common/CMakeLists.txt
deleted file mode 100644
index 2eb4904..0000000
--- a/building_sim_plugins/building_plugins_common/CMakeLists.txt
+++ /dev/null
@@ -1,174 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(building_sim_common)
-
-find_package(Qt5 COMPONENTS Widgets REQUIRED)
-set(CMAKE_AUTOMOC ON)
-
-# Default to C99
-if(NOT CMAKE_C_STANDARD)
-  set(CMAKE_C_STANDARD 99)
-endif()
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic)
-endif()
-
-# find dependencies
-find_package(ament_cmake REQUIRED)
-find_package(rclcpp REQUIRED)
-find_package(Eigen3 REQUIRED)
-find_package(tf2_ros REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(std_msgs REQUIRED)
-find_package(std_srvs REQUIRED)
-find_package(rmf_fleet_msgs REQUIRED)
-find_package(rmf_door_msgs REQUIRED)
-find_package(rmf_lift_msgs REQUIRED)
-find_package(building_map_msgs REQUIRED)
-find_package(menge QUIET)
-
-include(GNUInstallDirs)
-
-add_library(slotcar_common SHARED ${PROJECT_SOURCE_DIR}/src/slotcar_common.cpp)
-
-ament_target_dependencies(slotcar_common
-    Eigen3
-    rmf_fleet_msgs
-    building_map_msgs
-    rclcpp
-    std_msgs
-    geometry_msgs
-    tf2_ros
-)
-
-
-target_include_directories(slotcar_common
-  PUBLIC
-    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-    $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-    ${EIGEN3_INCLUDE_DIRS}
-    ${GAZEBO_INCLUDE_DIRS}
-)
-
-###############################
-# door stuff
-###############################
-
-add_library(door_common SHARED src/door_common.cpp)
-
-ament_target_dependencies(door_common
-    rmf_fleet_msgs
-    rclcpp
-    rmf_door_msgs
-)
-
-target_include_directories(door_common
- PUBLIC
-   $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-   $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-)
-
-###############################
-# lift stuff
-###############################
-
-add_library(lift_common SHARED src/lift_common.cpp)
-
-ament_target_dependencies(lift_common
-   rmf_fleet_msgs
-   rclcpp
-   rmf_door_msgs
-   rmf_lift_msgs
-)
-
-
-target_include_directories(lift_common
- PUBLIC
-   $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-   $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-)
-
-###############################
-# crowd simulator stuff
-###############################
-if (menge_FOUND)
-  add_library(crowd_simulator_common
-    SHARED
-    src/crowd_simulator_common.cpp  
-  )
-
-  target_include_directories(crowd_simulator_common
-    PUBLIC
-      $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
-      $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-      ${menge_INCLUDE_DIRS}
-  )
-  
-  ament_target_dependencies(crowd_simulator_common
-    menge
-    rclcpp
-  )
-
-  #crowd_simulation_common_install
-  ament_export_libraries(crowd_simulator_common)
-  install(
-    TARGETS crowd_simulator_common
-    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-  )
-else(NOT menge_FOUND)
-  message("menge-cmake not found, skipping crowd_simulation plugins")
-endif()
-
-###############################
-# install stuff
-###############################
-ament_export_include_directories(include)
-
-if($ENV{ROS_DISTRO} STREQUAL foxy)
-  ament_export_targets(slotcar_common HAS_LIBRARY_TARGET)
-  ament_export_targets(door_common HAS_LIBRARY_TARGET)
-  ament_export_targets(lift_common HAS_LIBRARY_TARGET)
-elseif($ENV{ROS_DISTRO} STREQUAL eloquent)
-  ament_export_interfaces(slotcar_common HAS_LIBRARY_TARGET)
-  ament_export_interfaces(door_common HAS_LIBRARY_TARGET)
-  ament_export_interfaces(lift_common HAS_LIBRARY_TARGET)
-else()
-  message(FATAL_ERROR "Unsupported ROS distribution")
-endif()
-
-ament_export_dependencies(Eigen3)
-
-install(
-  TARGETS slotcar_common 
-  EXPORT slotcar_common
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib
-)
-
-install(
-  TARGETS door_common 
-  EXPORT door_common 
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib
-)
-
-install(
-  TARGETS lift_common
-  EXPORT lift_common 
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib
-)
-
-install(
-  DIRECTORY include/building_sim_common
-  DESTINATION include
-)
-
-ament_package()
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp
deleted file mode 100644
index 96b644a..0000000
--- a/building_sim_plugins/building_plugins_common/include/building_sim_common/crowd_simulator_common.hpp
+++ /dev/null
@@ -1,434 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_SIM_COMMON__CROWD_SIMULATOR_COMMON_HPP
-#define BUILDING_SIM_COMMON__CROWD_SIMULATOR_COMMON_HPP
-
-#include <functional>
-#include <list>
-#include <queue>
-#include <memory>
-#include <regex> //for parsing initial_pose
-
-#include <MengeCore/Runtime/SimulatorDB.h>
-#include <MengeCore/Orca/ORCADBEntry.h>
-#include <MengeCore/Orca/ORCASimulator.h>
-#include <MengeCore/PluginEngine/CorePluginEngine.h>
-
-#include <rclcpp/rclcpp.hpp>
-
-namespace crowd_simulator {
-
-using AgentPtr = std::shared_ptr<Menge::Agents::BaseAgent>;
-
-class AgentPose3d
-{
-public:
-  AgentPose3d()
-  : _x(0), _y(0), _z(0), _roll(0), _pitch(0), _yaw(0)
-  {}
-  AgentPose3d(double x, double y, double z, double roll, double pitch,
-    double yaw)
-  : _x(x), _y(y), _z(z), _roll(roll), _pitch(pitch), _yaw(yaw)
-  {}
-
-  double x() const {return _x;}
-  double y() const {return _y;}
-  double z() const {return _z;}
-  double roll() const {return _roll;}
-  double pitch() const {return _pitch;}
-  double yaw() const {return _yaw;}
-
-  void x(double x) {_x = x;}
-  void y(double y) {_y = y;}
-  void z(double z) {_z = z;}
-  void roll(double roll) {_roll = roll;}
-  void pitch(double pitch) {_pitch = pitch;}
-  void yaw(double yaw) {_yaw = yaw;}
-
-  template<typename IgnMathPose3d>
-  IgnMathPose3d convert_to_ign_math_pose_3d()
-  {
-    return IgnMathPose3d(_x, _y, _z, _roll, _pitch, _yaw);
-  }
-
-private:
-  double _x, _y, _z, _roll, _pitch, _yaw;
-};
-
-//================================================================
-/*
-* class MengeHandle, provides a wrap-up class handle for actual menge lib
-* only exposing several menge function interface
-*/
-class MengeHandle : public std::enable_shared_from_this<MengeHandle>
-{
-public:
-
-  static std::shared_ptr<MengeHandle> init_and_make(
-    const std::string& resource_path,
-    const std::string& behavior_file,
-    const std::string& scene_file,
-    const float sim_time_step
-  );
-
-  MengeHandle(const std::string& resource_path,
-    const std::string& behavior_file,
-    const std::string& scene_file,
-    const float sim_time_step = 0.0
-  )
-  : _resource_path(resource_path),
-    _behavior_file(behavior_file),
-    _scene_file(scene_file),
-    _sim_time_step(sim_time_step),
-    _agent_count(0)
-  {
-    _behavior_file = this->_resource_file_path(_behavior_file);
-    _scene_file = this->_resource_file_path(_scene_file);
-  }
-
-  void set_sim_time_step(float sim_time_step);
-  float get_sim_time_step() const;
-  size_t get_agent_count();
-  void sim_step() const; //proceed one-time simulation step in _sim
-  AgentPtr get_agent(size_t id) const;
-
-private:
-  std::string _resource_path;
-  std::string _behavior_file;
-  std::string _scene_file;
-  float _sim_time_step;
-  size_t _agent_count;
-  std::shared_ptr<Menge::Agents::SimulatorInterface> _sim;
-
-  std::string _resource_file_path(const std::string& relative_path) const;
-  bool _load_simulation(); //initialize simulatorinterface
-};
-
-//================================================================
-/*
-* class ModelTypeDatabase
-*/
-class ModelTypeDatabase
-{
-public:
-  struct Record
-  {
-    std::string type_name;
-    std::string file_name;
-    AgentPose3d pose;
-    std::string animation;
-    double animation_speed;
-  };
-
-  using RecordPtr = std::shared_ptr<Record>;
-
-  //Create a new record and returns a reference to the record
-  RecordPtr emplace(std::string type_name, RecordPtr record_ptr);
-  size_t size() const;
-  RecordPtr get(const std::string& type_name) const;
-
-private:
-  std::unordered_map<std::string, RecordPtr> _records;
-};
-
-//================================================================
-/*
-* class CrowdSimInterface
-* provides the relationship between menge agents and gazebo models
-* provides the interface to set position between gazebo models and menge agents
-*/
-class CrowdSimInterface
-{
-public:
-  struct Object
-  {
-    AgentPtr agent_ptr;
-    std::string model_name;
-    std::string type_name;
-    bool is_external = false;
-  };
-  using ObjectPtr = std::shared_ptr<Object>;
-
-  CrowdSimInterface()
-  : _model_type_db_ptr(std::make_shared<crowd_simulator::ModelTypeDatabase>()),
-    _sdf_loaded(false)
-  {}
-
-  std::shared_ptr<ModelTypeDatabase> _model_type_db_ptr;
-  rclcpp::Logger logger() const;
-  void init_ros_node(const rclcpp::Node::SharedPtr node);
-
-  bool init_crowd_sim();
-  double get_sim_time_step() const;
-  size_t get_num_objects() const;
-  ObjectPtr get_object_by_id(size_t id) const;
-  void one_step_sim() const;
-
-  template<typename SdfPtrT>
-  bool read_sdf(SdfPtrT& sdf);
-
-  template<typename IgnMathPose3d>
-  void update_external_agent(
-    size_t id, const IgnMathPose3d& model_pose);
-
-  template<typename IgnMathPose3d>
-  void update_external_agent(
-    const AgentPtr agent_ptr, const IgnMathPose3d& model_pose);
-
-  template<typename IgnMathPose3d>
-  IgnMathPose3d get_agent_pose(
-    size_t id, double delta_sim_time);
-
-  template<typename IgnMathPose3d>
-  IgnMathPose3d get_agent_pose(
-    const AgentPtr agent_ptr, double delta_sim_time);
-
-private:
-  bool _sdf_loaded;
-  std::vector<ObjectPtr> _objects; //Database, use id to access ObjectPtr
-  std::shared_ptr<MengeHandle> _menge_handle;
-  float _sim_time_step;
-  std::string _resource_path;
-  std::string _behavior_file;
-  std::string _scene_file;
-  std::vector<std::string> _external_agents;
-  rclcpp::Node::SharedPtr _ros_node;
-
-  template<typename SdfPtrT>
-  bool _load_model_init_pose(
-    SdfPtrT& model_type_element, AgentPose3d& result) const;
-
-  bool _spawn_object();
-  void _add_object(
-    AgentPtr agent_ptr, const std::string& model_name,
-    const std::string& type_name, bool is_external);
-};
-
-template<typename SdfPtrT>
-bool CrowdSimInterface::read_sdf(
-  SdfPtrT& sdf)
-{
-  if (!sdf->template HasElement("resource_path"))
-  {
-    char* menge_resource_path;
-    menge_resource_path = getenv("MENGE_RESOURCE_PATH");
-    RCLCPP_WARN(logger(),
-      "No resource path provided! <env MENGE_RESOURCE_PATH> " +
-      std::string(menge_resource_path) + " will be used.");
-    _resource_path = std::string(menge_resource_path);
-  }
-  else
-  {
-    _resource_path =
-      sdf->template GetElementImpl("resource_path")->template Get<std::string>();
-  }
-
-  if (!sdf->template HasElement("behavior_file"))
-  {
-    RCLCPP_ERROR(logger(),
-      "No behavior file found! <behavior_file> Required!");
-    return false;
-  }
-  _behavior_file =
-    sdf->template GetElementImpl("behavior_file")->template Get<std::string>();
-
-  if (!sdf->template HasElement("scene_file"))
-  {
-    RCLCPP_ERROR(logger(),
-      "No scene file found! <scene_file> Required!");
-    return false;
-  }
-  _scene_file =
-    sdf->template GetElementImpl("scene_file")->template Get<std::string>();
-
-  if (!sdf->template HasElement("update_time_step"))
-  {
-    RCLCPP_ERROR(logger(),
-      "No update_time_step found! <update_time_step> Required!");
-    return false;
-  }
-  _sim_time_step =
-    sdf->template GetElementImpl("update_time_step")->template Get<float>();
-
-  if (!sdf->template HasElement("model_type"))
-  {
-    RCLCPP_ERROR(logger(),
-      "No model type for agents found! <model_type> element Required!");
-    return false;
-  }
-  auto model_type_element = sdf->template GetElementImpl("model_type");
-  while (model_type_element)
-  {
-    std::string s;
-    if (!model_type_element->template Get<std::string>("typename", s, ""))
-    {
-      RCLCPP_ERROR(logger(),
-        "No model type name configured in <model_type>! <typename> Required");
-      return false;
-    }
-
-    auto model_type_ptr = this->_model_type_db_ptr->emplace(s,
-        std::make_shared<ModelTypeDatabase::Record>() ); //unordered_map
-    model_type_ptr->type_name = s;
-
-    if (!model_type_element->template Get<std::string>("filename",
-      model_type_ptr->file_name, ""))
-    {
-      RCLCPP_ERROR(logger(),
-        "No actor skin configured in <model_type>! <filename> Required");
-      return false;
-    }
-
-    if (!model_type_element->template Get<std::string>("animation",
-      model_type_ptr->animation, ""))
-    {
-      RCLCPP_ERROR(logger(),
-        "No animation configured in <model_type>! <animation> Required");
-      return false;
-    }
-
-    if (!model_type_element->template Get<double>("animation_speed",
-      model_type_ptr->animation_speed, 0.0))
-    {
-      RCLCPP_ERROR(
-        logger(),
-        "No animation speed configured in <model_type>! <animation_speed> Required");
-      return false;
-    }
-
-    if (!model_type_element->template HasElement("initial_pose"))
-    {
-      RCLCPP_ERROR(
-        logger(),
-        "No model initial pose configured in <model_type>! <initial_pose> Required [" + s +
-        "]");
-      return false;
-    }
-    if (!_load_model_init_pose(model_type_element, model_type_ptr->pose))
-    {
-      RCLCPP_ERROR(
-        logger(),
-        "Error loading model initial pose in <model_type>! Check <initial_pose> in [" + s +
-        "]");
-      return false;
-    }
-
-    model_type_element = model_type_element->template GetNextElement(
-      "model_type");
-  }
-
-  if (!sdf->template HasElement("external_agent"))
-  {
-    RCLCPP_ERROR(
-      logger(),
-      "No external agent provided. <external_agent> is needed with a unique name defined above.");
-  }
-  auto external_agent_element = sdf->template GetElementImpl("external_agent");
-  while (external_agent_element)
-  {
-    auto ex_agent_name = external_agent_element->template Get<std::string>();
-    RCLCPP_INFO(logger(),
-      "Added external agent: [ " + ex_agent_name + " ].");
-    _external_agents.emplace_back(ex_agent_name); //just store the name
-    external_agent_element = external_agent_element->template GetNextElement(
-      "external_agent");
-  }
-
-  _sdf_loaded = true;
-  return true;
-}
-
-template<typename SdfPtrT>
-bool CrowdSimInterface::_load_model_init_pose(
-  SdfPtrT& model_type_element, AgentPose3d& result) const
-{
-  std::string pose_str;
-  if (model_type_element->template Get<std::string>(
-      "initial_pose", pose_str, ""))
-  {
-    std::regex ws_re("\\s+"); //whitespace
-    std::vector<std::string> parts(
-      std::sregex_token_iterator(pose_str.begin(), pose_str.end(), ws_re, -1),
-      std::sregex_token_iterator());
-
-    if (parts.size() != 6)
-    {
-      RCLCPP_ERROR(
-        logger(),
-        "Error loading <initial_pose> in <model_type>, 6 floats (x, y, z, pitch, roll, yaw) expected.");
-      return false;
-    }
-
-    result.x(std::stod(parts[0]) );
-    result.y(std::stod(parts[1]) );
-    result.z(std::stod(parts[2]) );
-    result.pitch(std::stod(parts[3]) );
-    result.roll(std::stod(parts[4]) );
-    result.yaw(std::stod(parts[5]) );
-  }
-  return true;
-}
-
-template<typename IgnMathPose3d>
-IgnMathPose3d CrowdSimInterface::get_agent_pose(
-  size_t id, double delta_sim_time)
-{
-  assert(id < get_num_objects());
-  auto agent_ptr = _objects[id]->agent_ptr;
-  return get_agent_pose<IgnMathPose3d>(agent_ptr, delta_sim_time);
-}
-
-template<typename IgnMathPose3d>
-IgnMathPose3d CrowdSimInterface::get_agent_pose(
-  const AgentPtr agent_ptr, double delta_sim_time)
-{
-  //calculate future position in delta_sim_time. currently in 2d
-  assert(agent_ptr);
-  double px = static_cast<double>(agent_ptr->_pos.x()) +
-    static_cast<double>(agent_ptr->_vel.x()) * delta_sim_time;
-  double py = static_cast<double>(agent_ptr->_pos.y()) +
-    static_cast<double>(agent_ptr->_vel.y()) * delta_sim_time;
-
-  double x_rot = static_cast<double>(agent_ptr->_orient.x());
-  double y_rot = static_cast<double>(agent_ptr->_orient.y());
-
-  IgnMathPose3d agent_pose(px, py, 0, 0, 0, std::atan2(y_rot, x_rot));
-  return agent_pose;
-}
-
-template<typename IgnMathPose3d>
-void CrowdSimInterface::update_external_agent(
-  size_t id, const IgnMathPose3d& model_pose)
-{
-  assert(id < get_num_objects());
-  auto agent_ptr = _objects[id]->agent_ptr;
-  update_external_agent<IgnMathPose3d>(agent_ptr, model_pose);
-}
-
-template<typename IgnMathPose3d>
-void CrowdSimInterface::update_external_agent(
-  const AgentPtr agent_ptr, const IgnMathPose3d& model_pose)
-{
-  assert(agent_ptr);
-  agent_ptr->_pos.setX(model_pose.Pos().X());
-  agent_ptr->_pos.setY(model_pose.Pos().Y());
-}
-
-} // namespace crowd_simulator
-
-#endif // CROWD_SIMULATION_COMMON__CROWD_SIMULATOR_COMMON_HPP
\ No newline at end of file
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp
deleted file mode 100644
index c7ae844..0000000
--- a/building_sim_plugins/building_plugins_common/include/building_sim_common/door_common.hpp
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_SIM_COMMON__DOOR_COMMON_HPP
-#define BUILDING_SIM_COMMON__DOOR_COMMON_HPP
-
-#include <rclcpp/rclcpp.hpp>
-#include <rclcpp/logger.hpp>
-
-#include <rmf_door_msgs/msg/door_mode.hpp>
-#include <rmf_door_msgs/msg/door_state.hpp>
-#include <rmf_door_msgs/msg/door_request.hpp>
-
-#include "utils.hpp"
-
-#include <vector>
-#include <unordered_map>
-#include <unordered_set>
-
-namespace building_sim_common {
-
-using DoorMode = rmf_door_msgs::msg::DoorMode;
-using DoorState = rmf_door_msgs::msg::DoorState;
-using DoorRequest = rmf_door_msgs::msg::DoorRequest;
-
-//==============================================================================
-class DoorCommon
-{
-
-public:
-
-  struct DoorUpdateRequest
-  {
-    std::string joint_name;
-    double position;
-    double velocity;
-  };
-
-  struct DoorUpdateResult
-  {
-    std::string joint_name;
-    double velocity;
-    double fmax;
-  };
-
-  template<typename SdfPtrT>
-  static std::shared_ptr<DoorCommon> make(
-    const std::string& door_name,
-    rclcpp::Node::SharedPtr node,
-    SdfPtrT& sdf);
-
-  rclcpp::Logger logger() const;
-
-  std::vector<std::string> joint_names() const;
-
-  MotionParams& params();
-
-  std::vector<DoorUpdateResult> update(const double time,
-    const std::vector<DoorUpdateRequest>& request);
-
-private:
-
-  struct DoorElement
-  {
-    double closed_position;
-    double open_position;
-    double current_position;
-    double current_velocity;
-
-    DoorElement() {}
-
-    DoorElement(
-      const double lower_limit,
-      const double upper_limit,
-      const bool flip_direction = false)
-    : current_position(0.0),
-      current_velocity(0.0)
-    {
-      if (flip_direction)
-      {
-        closed_position = lower_limit;
-        open_position = upper_limit;
-      }
-      else
-      {
-        closed_position = upper_limit;
-        open_position = lower_limit;
-      }
-    }
-  };
-
-  // Map joint name to its DoorElement
-  using Doors = std::unordered_map<std::string, DoorElement>;
-
-  DoorMode requested_mode() const;
-
-  void publish_state(const uint32_t door_value, const rclcpp::Time& time);
-
-  double calculate_target_velocity(
-    const double target,
-    const double current_position,
-    const double current_velocity,
-    const double dt);
-
-  DoorCommon(const std::string& door_name,
-    rclcpp::Node::SharedPtr node,
-    const MotionParams& params,
-    const Doors& doors);
-
-  bool all_doors_open();
-
-  bool all_doors_closed();
-
-  rclcpp::Node::SharedPtr _ros_node;
-  rclcpp::Publisher<DoorState>::SharedPtr _door_state_pub;
-  rclcpp::Subscription<DoorRequest>::SharedPtr _door_request_sub;
-
-  DoorState _state;
-  DoorRequest _request;
-
-  MotionParams _params;
-
-  double _last_update_time = 0.0;
-  // random start time offset to prevent state message crossfire
-  double _last_pub_time = ((double) std::rand()) / ((double) (RAND_MAX));
-
-  bool _initialized = false;
-
-  // Map of joint_name and corresponding DoorElement
-  Doors _doors;
-};
-
-template<typename SdfPtrT>
-std::shared_ptr<DoorCommon> DoorCommon::make(
-  const std::string& door_name,
-  rclcpp::Node::SharedPtr node,
-  SdfPtrT& sdf)
-{
-  // We work with a clone to avoid const correctness issues with
-  // get_sdf_param functions in utils.hpp
-  auto sdf_clone = sdf->Clone();
-
-  MotionParams params;
-  get_sdf_param_if_available<double>(sdf_clone, "v_max_door", params.v_max);
-  get_sdf_param_if_available<double>(sdf_clone, "a_max_door", params.a_max);
-  get_sdf_param_if_available<double>(sdf_clone, "a_nom_door", params.a_nom);
-  get_sdf_param_if_available<double>(sdf_clone, "dx_min_door", params.dx_min);
-  get_sdf_param_if_available<double>(sdf_clone, "f_max_door", params.f_max);
-
-  auto door_element = sdf_clone;
-  std::string left_door_joint_name;
-  std::string right_door_joint_name;
-  std::string door_type;
-
-  // Get the joint names and door type
-  if (!get_element_required(sdf_clone, "door", door_element) ||
-    !get_sdf_attribute_required<std::string>(
-      door_element, "left_joint_name", left_door_joint_name) ||
-    !get_sdf_attribute_required<std::string>(
-      door_element, "right_joint_name", right_door_joint_name) ||
-    !get_sdf_attribute_required<std::string>(
-      door_element, "type", door_type))
-  {
-    RCLCPP_ERROR(node->get_logger(),
-      " -- Missing required parameters for [%s] plugin",
-      door_name.c_str());
-    return nullptr;
-  }
-
-  if ((left_door_joint_name == "empty_joint" &&
-    right_door_joint_name == "empty_joint") ||
-    (left_door_joint_name.empty() && right_door_joint_name.empty()))
-  {
-    RCLCPP_ERROR(node->get_logger(),
-      " -- Both door joint names are missing for [%s] plugin, at least one"
-      " is required", door_name.c_str());
-    return nullptr;
-  }
-
-  std::unordered_set<std::string> joint_names;
-  if (!left_door_joint_name.empty() && left_door_joint_name != "empty_joint")
-    joint_names.insert(left_door_joint_name);
-  if (!right_door_joint_name.empty() && right_door_joint_name != "empty_joint")
-    joint_names.insert(right_door_joint_name);
-
-  Doors doors;
-
-  auto extract_door = [&](SdfPtrT& joint_sdf)
-    {
-      auto joint_sdf_clone = joint_sdf->Clone();
-      std::string joint_name;
-      get_sdf_attribute_required<std::string>(
-        joint_sdf_clone, "name", joint_name);
-      const auto it = joint_names.find(joint_name);
-      if (it != joint_names.end())
-      {
-        auto element = joint_sdf_clone;
-        get_element_required(joint_sdf_clone, "axis", element);
-        get_element_required(element, "limit", element);
-        double lower_limit = -1.57;
-        double upper_limit = 0.0;
-        get_sdf_param_if_available<double>(element, "lower", lower_limit);
-        get_sdf_param_if_available<double>(element, "upper", upper_limit);
-        DoorCommon::DoorElement door_element;
-        if (joint_name == right_door_joint_name)
-          door_element =
-            DoorCommon::DoorElement{lower_limit, upper_limit, true};
-        else if (joint_name == left_door_joint_name)
-          door_element = DoorCommon::DoorElement{lower_limit, upper_limit};
-        doors.insert({joint_name, door_element});
-      }
-    };
-
-  // Get the joint limits from parent sdf
-  auto parent = sdf->GetParent();
-  if (!parent)
-  {
-    RCLCPP_ERROR(node->get_logger(),
-      "Unable to access parent sdf to retrieve joint limits");
-    return nullptr;
-  }
-
-  auto joint_element = parent->GetElement("joint");
-  if (!joint_element)
-  {
-    RCLCPP_ERROR(node->get_logger(),
-      "Parent sdf missing required joint element");
-    return nullptr;
-  }
-
-  extract_door(joint_element);
-  // Find next joint element if present
-  while (joint_element)
-  {
-    extract_door(joint_element);
-    joint_element = joint_element->GetNextElement("joint");
-  }
-
-  std::shared_ptr<DoorCommon> door_common(new DoorCommon(
-      door_name,
-      node,
-      params,
-      doors));
-
-  return door_common;
-
-}
-
-} // namespace building_sim_common
-
-#endif // BUILDING_SIM_COMMON__DOOR_COMMON_HPP
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp
deleted file mode 100644
index 1e59756..0000000
--- a/building_sim_plugins/building_plugins_common/include/building_sim_common/lift_common.hpp
+++ /dev/null
@@ -1,263 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_SIM_COMMON__LIFT_COMMON_HPP
-#define BUILDING_SIM_COMMON__LIFT_COMMON_HPP
-
-#include <rclcpp/rclcpp.hpp>
-#include <rclcpp/logger.hpp>
-
-#include <rmf_lift_msgs/msg/lift_state.hpp>
-#include <rmf_lift_msgs/msg/lift_request.hpp>
-#include <rmf_door_msgs/msg/door_mode.hpp>
-#include <rmf_door_msgs/msg/door_state.hpp>
-#include <rmf_door_msgs/msg/door_request.hpp>
-
-#include "utils.hpp"
-
-#include <vector>
-#include <utility>
-#include <unordered_map>
-
-namespace building_sim_common {
-
-using LiftState = rmf_lift_msgs::msg::LiftState;
-using LiftRequest = rmf_lift_msgs::msg::LiftRequest;
-using DoorRequest = rmf_door_msgs::msg::DoorRequest;
-using DoorState = rmf_door_msgs::msg::DoorState;
-using DoorMode = rmf_door_msgs::msg::DoorMode;
-
-//==============================================================================
-class LiftCommon
-{
-
-public:
-
-  struct LiftUpdateResult
-  {
-    double velocity;
-    double fmax;
-  };
-
-  template<typename SdfPtrT>
-  static std::unique_ptr<LiftCommon> make(
-    const std::string& lift_name,
-    rclcpp::Node::SharedPtr node,
-    SdfPtrT& sdf);
-
-  rclcpp::Logger logger() const;
-
-  LiftUpdateResult update(const double time, const double position,
-    const double velocity);
-
-  std::string get_joint_name() const;
-
-  double get_elevation() const;
-
-private:
-
-  rclcpp::Node::SharedPtr _ros_node;
-  rclcpp::Publisher<LiftState>::SharedPtr _lift_state_pub;
-  rclcpp::Publisher<DoorRequest>::SharedPtr _door_request_pub;
-  rclcpp::Subscription<LiftRequest>::SharedPtr _lift_request_sub;
-  rclcpp::Subscription<DoorState>::SharedPtr _door_state_sub;
-
-  std::string _lift_name;
-  std::string _cabin_joint_name;
-
-  MotionParams _cabin_motion_params;
-
-  std::vector<std::string> _floor_names;
-  std::unordered_map<std::string, double> _floor_name_to_elevation;
-  std::unordered_map<std::string,
-    std::vector<std::string>> _floor_name_to_shaft_door_name;
-  std::unordered_map<std::string,
-    std::vector<std::string>> _floor_name_to_cabin_door_name;
-  std::unordered_map<std::string, DoorState::SharedPtr> _shaft_door_states;
-  std::unordered_map<std::string, DoorState::SharedPtr> _cabin_door_states;
-
-  LiftState _lift_state;
-  LiftRequest::UniquePtr _lift_request;
-
-  double _last_update_time = 0.0;
-  // random start time offset to prevent state message crossfire
-  double _last_pub_time = ((double) std::rand()) / ((double) (RAND_MAX));
-
-  void publish_door_request(const double time, std::string door_name,
-    uint32_t door_state);
-
-  LiftCommon(rclcpp::Node::SharedPtr node,
-    const std::string& lift_name,
-    const std::string& joint_name,
-    const MotionParams& cabin_motion_params,
-    const std::vector<std::string>& floor_names,
-    const std::unordered_map<std::string, double>& floor_name_to_elevation,
-    std::unordered_map<
-      std::string, std::vector<std::string>> floor_name_to_shaft_door_name,
-    std::unordered_map<
-      std::string, std::vector<std::string>> floor_name_to_cabin_door_name,
-    std::unordered_map<std::string, DoorState::SharedPtr> shaft_door_states,
-    std::unordered_map<std::string, DoorState::SharedPtr> cabin_door_states,
-    std::string initial_floor_name);
-
-  double get_step_velocity(const double dt, const double position,
-    const double velocity);
-
-  void update_cabin_state(const double position, const double velocity);
-
-  void move_doors(const double time, uint32_t door_mode);
-
-  void open_doors(const double time);
-
-  void close_doors(const double time);
-
-  uint32_t get_door_state(
-    const std::unordered_map<std::string,
-    std::vector<std::string>>& floor_to_door_map,
-    const std::unordered_map<std::string, DoorState::SharedPtr>& door_states);
-
-  void pub_lift_state(const double time);
-
-  void update_lift_door_state();
-
-};
-
-template<typename SdfPtrT>
-std::unique_ptr<LiftCommon> LiftCommon::make(
-  const std::string& lift_name,
-  rclcpp::Node::SharedPtr node,
-  SdfPtrT& sdf)
-{
-  MotionParams cabin_motion_params;
-  std::string joint_name;
-  std::vector<std::string> floor_names;
-  std::unordered_map<std::string, double> floor_name_to_elevation;
-  std::unordered_map<std::string,
-    std::vector<std::string>> floor_name_to_shaft_door_name;
-  std::unordered_map<std::string,
-    std::vector<std::string>> floor_name_to_cabin_door_name;
-  std::unordered_map<std::string, DoorState::SharedPtr> shaft_door_states;
-  std::unordered_map<std::string, DoorState::SharedPtr> cabin_door_states;
-
-
-  auto sdf_clone = sdf->Clone();
-
-  // load lift cabin motion parameters
-  get_sdf_param_if_available<double>(sdf_clone, "v_max_cabin",
-    cabin_motion_params.v_max);
-  get_sdf_param_if_available<double>(sdf_clone, "a_max_cabin",
-    cabin_motion_params.a_max);
-  get_sdf_param_if_available<double>(sdf_clone, "a_nom_cabin",
-    cabin_motion_params.a_nom);
-  get_sdf_param_if_available<double>(sdf_clone, "dx_min_cabin",
-    cabin_motion_params.dx_min);
-  get_sdf_param_if_available<double>(sdf_clone, "f_max_cabin",
-    cabin_motion_params.f_max);
-  if (!get_sdf_param_required(sdf_clone, "cabin_joint_name",
-    joint_name))
-    return nullptr;
-
-  // load the floor name and elevation for each floor
-  auto floor_element = sdf_clone;
-  if (!get_element_required(sdf, "floor", floor_element))
-  {
-    RCLCPP_ERROR(node->get_logger(),
-      " -- Missing required floor element for [%s] plugin",
-      lift_name.c_str());
-    return nullptr;
-  }
-
-  while (floor_element)
-  {
-    std::string floor_name;
-    double floor_elevation;
-    if (!get_sdf_attribute_required<std::string>(floor_element, "name",
-      floor_name) ||
-      !get_sdf_attribute_required<double>(floor_element, "elevation",
-      floor_elevation))
-    {
-      RCLCPP_ERROR(
-        node->get_logger(),
-        " -- Missing required floor name or elevation attributes for [%s] plugin",
-        lift_name.c_str());
-      return nullptr;
-    }
-    floor_names.push_back(floor_name);
-    floor_name_to_elevation.insert({floor_name, floor_elevation});
-
-    auto door_pair_element = floor_element;
-    if (get_element_required(floor_element, "door_pair", door_pair_element))
-    {
-      while (door_pair_element)
-      {
-        std::string shaft_door_name;
-        std::string cabin_door_name;
-        if (!get_sdf_attribute_required<std::string>(door_pair_element,
-          "cabin_door", cabin_door_name) ||
-          !get_sdf_attribute_required<std::string>(door_pair_element,
-          "shaft_door", shaft_door_name))
-        {
-          RCLCPP_ERROR(node->get_logger(),
-            " -- Missing required lift door attributes for [%s] plugin",
-            lift_name.c_str());
-          return nullptr;
-        }
-        floor_name_to_cabin_door_name[floor_name].push_back(cabin_door_name);
-        floor_name_to_shaft_door_name[floor_name].push_back(shaft_door_name);
-        shaft_door_states.insert({shaft_door_name, nullptr});
-        cabin_door_states.insert({cabin_door_name, nullptr});
-
-        door_pair_element = door_pair_element->GetNextElement("door_pair");
-      }
-    }
-    floor_element = floor_element->GetNextElement("floor");
-  }
-
-  assert(!floor_names.empty());
-  std::string initial_floor_name = floor_names[0];
-  get_sdf_param_if_available<std::string>(sdf_clone, "initial_floor",
-    initial_floor_name);
-
-  if (std::find(floor_names.begin(), floor_names.end(), initial_floor_name) ==
-    floor_names.end())
-  {
-    RCLCPP_WARN(
-      node->get_logger(),
-      "Initial floor [%s] is not available, changing to deafult",
-      initial_floor_name.c_str());
-    initial_floor_name = floor_names[0];
-  }
-
-  std::unique_ptr<LiftCommon> lift(new LiftCommon(
-      node,
-      lift_name,
-      joint_name,
-      cabin_motion_params,
-      floor_names,
-      floor_name_to_elevation,
-      floor_name_to_shaft_door_name,
-      floor_name_to_cabin_door_name,
-      shaft_door_states,
-      cabin_door_states,
-      initial_floor_name));
-
-  return lift;
-}
-
-} // namespace building_sim_common
-
-#endif // BUILDING_SIM_COMMON__LIFT_COMMON_HPP
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp
deleted file mode 100644
index e1490c0..0000000
--- a/building_sim_plugins/building_plugins_common/include/building_sim_common/slotcar_common.hpp
+++ /dev/null
@@ -1,252 +0,0 @@
-// TODO header guards
-
-#include <rclcpp/rclcpp.hpp>
-#include <Eigen/Geometry>
-#include <tf2_ros/transform_broadcaster.h>
-
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rmf_fleet_msgs/msg/robot_mode.hpp>
-#include <rmf_fleet_msgs/msg/robot_state.hpp>
-#include <rmf_fleet_msgs/msg/path_request.hpp>
-#include <rmf_fleet_msgs/msg/mode_request.hpp>
-#include <building_map_msgs/msg/building_map.hpp>
-
-namespace building_sim_common {
-
-// TODO migrate ign-math-eigen conversions when upgrading to ign-math5
-
-// Edit reference of parameter for template type deduction
-template<typename IgnQuatT>
-inline void convert(const Eigen::Quaterniond& _q, IgnQuatT& quat)
-{
-  quat.W() = _q.w();
-  quat.X() = _q.x();
-  quat.Y() = _q.y();
-  quat.Z() = _q.z();
-}
-
-template<typename IgnVec3T>
-inline void convert(const Eigen::Vector3d& _v, IgnVec3T& vec)
-{
-  vec.X() = _v[0];
-  vec.Y() = _v[1];
-  vec.Z() = _v[2];
-}
-
-template<typename IgnVec3T>
-inline Eigen::Vector3d convert_vec(const IgnVec3T& _v)
-{
-  return Eigen::Vector3d(_v[0], _v[1], _v[2]);
-}
-
-template<typename IgnQuatT>
-inline Eigen::Quaterniond convert_quat(const IgnQuatT& _q)
-{
-  Eigen::Quaterniond quat;
-  quat.w() = _q.W();
-  quat.x() = _q.X();
-  quat.y() = _q.Y();
-  quat.z() = _q.Z();
-
-  return quat;
-}
-
-template<typename IgnPoseT>
-inline auto convert(const Eigen::Isometry3d& _tf)
-{
-  IgnPoseT pose;
-  convert(Eigen::Vector3d(_tf.translation()), pose.Pos());
-  convert(Eigen::Quaterniond(_tf.linear()), pose.Rot());
-
-  return pose;
-}
-
-template<typename IgnPoseT>
-inline Eigen::Isometry3d convert_pose(const IgnPoseT& _pose)
-{
-  Eigen::Isometry3d tf = Eigen::Isometry3d::Identity();
-  tf.translation() = convert_vec(_pose.Pos());
-  tf.linear() = Eigen::Matrix3d(convert_quat(_pose.Rot()));
-
-  return tf;
-}
-
-typedef struct TrajectoryPoint
-{
-  Eigen::Vector3d pos;
-  Eigen::Quaterniond quat;
-  TrajectoryPoint(const Eigen::Vector3d& _pos, const Eigen::Quaterniond& _quat)
-  : pos(_pos), quat(_quat) {}
-} TrajectoryPoint;
-
-class SlotcarCommon
-{
-public:
-  rclcpp::Logger logger() const;
-
-  template<typename SdfPtrT>
-  void read_sdf(SdfPtrT& sdf);
-
-  void set_model_name(const std::string& model_name);
-
-  std::string model_name() const;
-
-  void init_ros_node(const rclcpp::Node::SharedPtr node);
-
-  std::pair<double, double> update(const Eigen::Isometry3d& pose,
-    const std::vector<Eigen::Vector3d>& obstacle_positions,
-    const double time);
-
-  bool emergency_stop(const std::vector<Eigen::Vector3d>& obstacle_positions,
-    const Eigen::Vector3d& current_heading);
-
-  std::array<double, 2> calculate_control_signals(const std::array<double,
-    2>& w_tire,
-    const std::pair<double, double>& velocities,
-    const double dt) const;
-
-  void publish_robot_state(const double time);
-
-private:
-  // Constants for update rate of tf2 and robot_state topic
-  static constexpr float TF2_RATE = 100.0;
-  static constexpr float STATE_TOPIC_RATE = 2.0;
-
-  // Initial distance threshold over which a fleet adapter error is reported
-  static constexpr float INITIAL_DISTANCE_THRESHOLD = 1.0;
-
-  rclcpp::Node::SharedPtr _ros_node;
-
-  double _last_update_time = 0.0;
-  double last_tf2_pub = 0.0;
-  double last_topic_pub = 0.0;
-
-  std::vector<Eigen::Isometry3d> trajectory;
-  std::size_t _traj_wp_idx;
-
-  std::vector<rclcpp::Time> _hold_times;
-
-  std::string _model_name;
-  Eigen::Isometry3d _pose;
-  bool _emergency_stop = false;
-  bool _adapter_error = false;
-
-  std::unordered_map<std::string, double> _level_to_elevation;
-  bool _initialized_levels = false;
-
-  std::shared_ptr<tf2_ros::TransformBroadcaster> _tf2_broadcaster;
-  rclcpp::Publisher<rmf_fleet_msgs::msg::RobotState>::SharedPtr _robot_state_pub;
-
-  rclcpp::Subscription<rmf_fleet_msgs::msg::PathRequest>::SharedPtr _traj_sub;
-  rclcpp::Subscription<rmf_fleet_msgs::msg::ModeRequest>::SharedPtr _mode_sub;
-  rclcpp::Subscription<building_map_msgs::msg::BuildingMap>::SharedPtr
-    _building_map_sub;
-
-  rmf_fleet_msgs::msg::RobotMode _current_mode;
-
-  std::string _current_task_id;
-  std::vector<rmf_fleet_msgs::msg::Location> _remaining_path;
-
-  // Vehicle dynamic constants
-  // TODO(MXG): Consider fetching these values from model data
-  // Radius of a tire
-  double _tire_radius = 0.1;
-  // Distance of a tire from the origin
-  double _base_width = 0.52;
-
-  double _nominal_drive_speed = 0.5;         // nominal robot velocity (m/s)
-  double _nominal_drive_acceleration = 0.05; // nominal robot forward acceleration (m/s^2)
-  double _max_drive_acceleration = 0.1;      // maximum robot forward acceleration (m/s^2)
-
-  double _nominal_turn_speed = M_PI / 8.0;         // nominal robot turning speed (half a rotation per 8 seconds)
-  double _nominal_turn_acceleration = M_PI / 10.0; // nominal robot turning acceleration (rad/s^2)
-
-  double _max_turn_acceleration = M_PI; // maximum robot turning acceleration (rad/s^2)
-
-  double _stop_distance = 1.0;
-  double _stop_radius = 1.0;
-
-  std::string get_level_name(const double z);
-
-  double compute_change_in_rotation(Eigen::Vector3d heading_vec,
-    const Eigen::Vector3d& dpos,
-    double* permissive = nullptr);
-
-  void publish_tf2(const rclcpp::Time& t);
-
-  void publish_state_topic(const rclcpp::Time& t);
-
-  bool path_request_valid(
-    const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg);
-
-  void path_request_cb(const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg);
-
-  void mode_request_cb(const rmf_fleet_msgs::msg::ModeRequest::SharedPtr msg);
-
-  void map_cb(const building_map_msgs::msg::BuildingMap::SharedPtr msg);
-};
-
-template<typename SdfPtrT>
-void SlotcarCommon::read_sdf(SdfPtrT& sdf)
-{
-  if (sdf->HasElement("nominal_drive_speed"))
-    _nominal_drive_speed = sdf->template Get<double>("nominal_drive_speed");
-  RCLCPP_INFO(logger(),
-    "Setting nominal drive speed to: " +
-    std::to_string(_nominal_drive_speed));
-
-  if (sdf->HasElement("nominal_drive_acceleration"))
-    _nominal_drive_acceleration = sdf->template Get<double>(
-      "nominal_drive_acceleration");
-  RCLCPP_INFO(
-    logger(),
-    "Setting nominal drive acceleration to: " + std::to_string(
-      _nominal_drive_acceleration));
-
-  if (sdf->HasElement("max_drive_acceleration"))
-    _max_drive_acceleration =
-      sdf->template Get<double>("max_drive_acceleration");
-  RCLCPP_INFO(logger(),
-    "Setting max drive acceleration to: "
-    + std::to_string(_max_drive_acceleration));
-
-  if (sdf->HasElement("nominal_turn_speed"))
-    _nominal_turn_speed = sdf->template Get<double>("nominal_turn_speed");
-  RCLCPP_INFO(logger(),
-    "Setting nominal turn speed to:"
-    + std::to_string(_nominal_turn_speed));
-
-  if (sdf->HasElement("nominal_turn_acceleration"))
-    _nominal_turn_acceleration = sdf->template Get<double>(
-      "nominal_turn_acceleration");
-  RCLCPP_INFO(logger(), "Setting nominal turn acceleration to:" + std::to_string(
-      _nominal_turn_acceleration));
-
-  if (sdf->HasElement("max_turn_acceleration"))
-    _max_turn_acceleration = sdf->template Get<double>("max_turn_acceleration");
-  RCLCPP_INFO(logger(),
-    "Setting max turn acceleration to:"
-    + std::to_string(_max_turn_acceleration));
-
-  if (sdf->HasElement("stop_distance"))
-    _stop_distance = sdf->template Get<double>("stop_distance");
-  RCLCPP_INFO(logger(),
-    "Setting stop distance to:" + std::to_string(_stop_distance));
-
-  if (sdf->HasElement("stop_radius"))
-    _stop_radius = sdf->template Get<double>("stop_radius");
-  RCLCPP_INFO(logger(),
-    "Setting stop radius to:" + std::to_string(_stop_radius));
-
-  if (sdf->HasElement("tire_radius"))
-    _tire_radius = sdf->template Get<double>("tire_radius");
-  RCLCPP_INFO(logger(),
-    "Setting tire radius to:" + std::to_string(_tire_radius));
-
-  if (sdf->HasElement("base_width"))
-    _base_width = sdf->template Get<double>("base_width");
-  RCLCPP_INFO(logger(), "Setting base width to:" + std::to_string(_base_width));
-
-  RCLCPP_INFO(logger(), "Setting name to: " + _model_name);
-}
-} // namespace building_sim_common
diff --git a/building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp b/building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp
deleted file mode 100644
index c1379fc..0000000
--- a/building_sim_plugins/building_plugins_common/include/building_sim_common/utils.hpp
+++ /dev/null
@@ -1,234 +0,0 @@
-#ifndef SRC__BUILDING_SIM_COMMON__UTILS_HPP
-#define SRC__BUILDING_SIM_COMMON__UTILS_HPP
-
-#include <cmath>
-#include <iostream>
-
-namespace building_sim_common {
-
-// TODO(MXG): Refactor the use of this function to replace it with
-// compute_desired_rate_of_change()
-double compute_ds(
-  double s_target,
-  double v_actual,
-  double v_max,
-  double accel_nom,
-  double accel_max,
-  double dt);
-
-struct MotionParams
-{
-  double v_max = 0.2;
-  double a_max = 0.1;
-  double a_nom = 0.08;
-  double dx_min = 0.01;
-  double f_max = 10000000.0;
-};
-
-//==============================================================================
-double compute_ds(
-  double s_target,
-  double v_actual,
-  const double v_max,
-  const double accel_nom,
-  const double accel_max,
-  const double dt)
-{
-  double sign = 1.0;
-  if (s_target < 0.0)
-  {
-    // Limits get confusing when we need to go backwards, so we'll flip signs
-    // here so that we pretend the target is forwards
-    s_target *= -1.0;
-    v_actual *= -1.0;
-    sign = -1.0;
-  }
-
-  // We should try not to shoot past the targstd::vector<event::ConnectionPtr> connections;et
-  double next_s = s_target / dt;
-
-  // Test velocity limit
-  next_s = std::min(next_s, v_max);
-
-  // Test acceleration limit
-  next_s = std::min(next_s, accel_nom * dt + v_actual);
-
-  if (v_actual > 0.0 && s_target > 0.0)
-  {
-    // This is what our deceleration should be if we want to begin a constant
-    // deceleration from now until we reach the goal
-    double deceleration = pow(v_actual, 2) / s_target;
-    deceleration = std::min(deceleration, accel_max);
-
-    if (accel_nom <= deceleration)
-    {
-      // If the smallest constant deceleration for reaching the goal is
-      // greater than
-      next_s = -deceleration * dt + v_actual;
-    }
-  }
-
-  // Flip the sign the to correct direction before returning the value
-  return sign * next_s;
-}
-
-//==============================================================================
-double compute_desired_rate_of_change(
-  double _s_target,
-  double _v_actual,
-  const MotionParams& _motion_params,
-  const double _dt)
-{
-  double sign = 1.0;
-  if (_s_target < 0.0)
-  {
-    // Limits get confusing when we need to go backwards, so we'll flip signs
-    // here so that we pretend the target is forwards
-    _s_target *= -1.0;
-    _v_actual *= -1.0;
-    sign = -1.0;
-  }
-
-  // We should try not to shoot past the target
-  double v_next = _s_target / _dt;
-
-  // Test velocity limit
-  v_next = std::min(v_next, _motion_params.v_max);
-
-  // Test acceleration limit
-  v_next = std::min(v_next, _motion_params.a_nom * _dt + _v_actual);
-
-  if (_v_actual > 0.0 && _s_target > 0.0)
-  {
-    // This is what our deceleration should be if we want to begin a constant
-    // deceleration from now until we reach the goal
-    double deceleration = pow(_v_actual, 2) / (2.0 * _s_target);
-    deceleration = std::min(deceleration, _motion_params.a_max);
-
-    if (_motion_params.a_nom <= deceleration)
-    {
-      // If the smallest constant deceleration for reaching the goal is
-      // greater than the nominal acceleration, then we should begin
-      // decelerating right away so that we can smoothly reach the goal while
-      // decelerating as close to the nominal acceleration as possible.
-      v_next = -deceleration * _dt + _v_actual;
-    }
-  }
-
-  // Flip the sign the to correct direction before returning the value
-  return sign * v_next;
-}
-
-//==============================================================================
-template<typename SdfPtrT, typename SdfElementPtrT>
-bool get_element_required(
-  SdfPtrT& _sdf,
-  const std::string& _element_name,
-  SdfElementPtrT& _element)
-{
-  if (!_sdf->HasElement(_element_name))
-  {
-    std::cerr << "Element [" << _element_name << "] not found" << std::endl;
-    return false;
-  }
-  // using GetElementImpl() because for sdf::v9 GetElement() is not const
-  _element = _sdf->GetElementImpl(_element_name);
-  return true;
-}
-
-/*
-double compute_desired_rate_of_change(
-    double _s_target,
-    double _v_actual,
-    const MotionParams& _motion_params,
-    const double _dt);
-
-bool get_element_required(
-    const sdf::ElementPtr& _sdf,
-    const std::string& _element_name,
-    sdf::ElementPtr& _element);
-*/
-
-////////////////////////////////////////////////////////////////////////////////////////////////////
-template<typename T, typename SdfPtrT>
-bool get_sdf_attribute_required(SdfPtrT& sdf, const std::string& attribute_name,
-  T& value)
-{
-  if (sdf->HasAttribute(attribute_name))
-  {
-    if (sdf->GetAttribute(attribute_name)->Get(value))
-    {
-      std::cout << "Using specified attribute value [" << value
-                << "] for property [" << attribute_name << "]"
-                << std::endl;
-      return true;
-    }
-    else
-    {
-      std::cerr << "Failed to parse sdf attribute for [" << attribute_name
-                << "]" << std::endl;
-    }
-  }
-  else
-  {
-    std::cerr << "Attribute [" << attribute_name << "] not found" << std::endl;
-  }
-
-  return false;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////
-template<typename T, typename SdfPtrT>
-bool get_sdf_param_required(SdfPtrT& sdf, const std::string& parameter_name,
-  T& value)
-{
-  if (sdf->HasElement(parameter_name))
-  {
-    if (sdf->GetElement(parameter_name)->GetValue()->Get(value))
-    {
-      std::cout << "Using specified value [" << value << "] for property ["
-                << parameter_name << "]" << std::endl;
-      return true;
-    }
-    else
-    {
-      std::cerr << "Failed to parse sdf value for [" << parameter_name << "]"
-                <<std::endl;
-    }
-  }
-  else
-  {
-    std::cerr << "Property [" << parameter_name << "] not found" << std::endl;
-  }
-
-  return false;
-}
-
-////////////////////////////////////////////////////////////////////////////////////////////////////
-template<typename T, typename SdfPtrT>
-void get_sdf_param_if_available(SdfPtrT& sdf, const std::string& parameter_name,
-  T& value)
-{
-  if (sdf->HasElement(parameter_name))
-  {
-    if (sdf->GetElement(parameter_name)->GetValue()->Get(value))
-    {
-      std::cout << "Using specified value [" << value << "] for property ["
-                << parameter_name << "]" << std::endl;
-    }
-    else
-    {
-      std::cerr << "Failed to parse sdf value for [" << parameter_name
-                << "]" << std::endl;
-    }
-  }
-  else
-  {
-    std::cout << "Using default value [" << value << "] for property ["
-              << parameter_name << "]" << std::endl;
-  }
-}
-
-} // namespace building_sim_common
-
-#endif // SRC__BUILDING_SIM_COMMON__UTILS_HPP
diff --git a/building_sim_plugins/building_plugins_common/package.xml b/building_sim_plugins/building_plugins_common/package.xml
deleted file mode 100644
index 7f990a5..0000000
--- a/building_sim_plugins/building_plugins_common/package.xml
+++ /dev/null
@@ -1,37 +0,0 @@
-<package format="3">
-  <name>building_sim_common</name>
-  <version>1.1.0</version>
-  <description>
-    Common utility functions for Gazebo and ignition building plugins
-  </description>
-  <author>Morgan Quigley</author>
-  <author>Michael Grey</author>
-  <author>Roselle Carmen</author>
-  <author>Aaron Chong</author>
-  <author>Brandon Ong</author>
-  <author>Kevin Ma</author>
-  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
-  <license>Apache 2.0</license>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-
-  <build_depend>eigen</build_depend>
-
-  <depend>rclcpp</depend>
-  <depend>rmf_fleet_msgs</depend>
-  <depend>rmf_door_msgs</depend>
-  <depend>rmf_lift_msgs</depend>
-  <depend>building_map_msgs</depend>
-  <depend>tf2_ros</depend>
-  <depend>geometry_msgs</depend>
-  <depend>std_msgs</depend>
-  <depend>std_srvs</depend>
-  <depend>menge</depend>
-  <depend>libqt5-widgets</depend>
-  <depend>qtbase5-dev</depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-
-</package>
diff --git a/building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp b/building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp
deleted file mode 100644
index ea6fab5..0000000
--- a/building_sim_plugins/building_plugins_common/src/crowd_simulator_common.cpp
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <fstream>
-#include <cmath>
-
-#include <rclcpp/logger.hpp>
-
-#include <building_sim_common/crowd_simulator_common.hpp>
-
-namespace crowd_simulator {
-
-//================================================================
-std::shared_ptr<MengeHandle> MengeHandle::init_and_make(
-  const std::string& resource_path,
-  const std::string& behavior_file,
-  const std::string& scene_file,
-  const float sim_time_step
-)
-{
-  auto menge_handle = std::make_shared<MengeHandle>(
-    resource_path, behavior_file, scene_file, sim_time_step);
-  if (!menge_handle->_load_simulation())
-  {
-    return nullptr;
-  }
-  return menge_handle;
-}
-
-void MengeHandle::set_sim_time_step(float sim_time_step)
-{
-  this->_sim_time_step = sim_time_step;
-}
-
-float MengeHandle::get_sim_time_step() const
-{
-  return this->_sim_time_step;
-}
-
-size_t MengeHandle::get_agent_count()
-{
-  if (this->_agent_count == 0)
-  {
-    this->_agent_count = this->_sim->getNumAgents();
-  }
-  return this->_agent_count;
-}
-
-void MengeHandle::sim_step() const
-{
-  this->_sim->step();
-}
-
-AgentPtr MengeHandle::get_agent(size_t id) const
-{
-  return AgentPtr(this->_sim->getAgent(id));
-}
-
-std::string MengeHandle::_resource_file_path(const std::string& relative_path)
-const
-{
-  std::string full_path = this->_resource_path + "/" + relative_path;
-  std::cout << "Finding resource file: " << full_path << std::endl;
-  std::ifstream ifile(full_path);
-  if (!static_cast<bool>(ifile))
-  {
-    std::cerr << "File not found! " << full_path << std::endl;
-    assert(static_cast<bool>(ifile));
-  }
-  std::cout << "Found." << std::endl;
-  return full_path;
-}
-
-bool MengeHandle::_load_simulation()
-{
-  Menge::SimulatorDB sim_db;
-  Menge::PluginEngine::CorePluginEngine engine(&sim_db);
-
-  std::cout << "Start CrowdSimulator initializing [Menge]..." << std::endl;
-
-  this->_sim = std::shared_ptr<Menge::Agents::SimulatorInterface>(
-    sim_db.getDBEntry("orca")->getSimulator(
-      this->_agent_count,
-      this->_sim_time_step,
-      0,
-      std::numeric_limits<float>::infinity(),
-      this->_behavior_file,
-      this->_scene_file,
-      "",
-      "",
-      false)
-  );
-
-  if (this->_sim)
-  {
-    std::cout << std::endl << "Crowd Simulator initialized success [Menge]. " <<
-      std::endl;
-    return true;
-  }
-  std::cout <<
-    "Error in provided navmesh. Menge simulator initialized false." <<
-    std::endl;
-  return false;
-}
-
-//============================================
-ModelTypeDatabase::RecordPtr ModelTypeDatabase::emplace(
-  std::string type_name,
-  RecordPtr record_ptr)
-{
-  auto pair = this->_records.emplace(type_name, record_ptr); //return pair<iterator, bool>
-  assert(pair.second);
-  return pair.first->second;
-}
-
-ModelTypeDatabase::RecordPtr ModelTypeDatabase::get(
-  const std::string& type_name)
-const
-{
-  auto it = this->_records.find(type_name);
-  if (it == this->_records.end())
-  {
-    std::cout << "The model type [ " << type_name <<
-      " ] is not defined in scene file!" << std::endl;
-    return nullptr;
-  }
-  return it->second;
-}
-
-size_t ModelTypeDatabase::size() const
-{
-  return this->_records.size();
-}
-
-//================================================================
-
-rclcpp::Logger CrowdSimInterface::logger() const
-{
-  return rclcpp::get_logger("crowdsim");
-}
-
-void CrowdSimInterface::init_ros_node(const rclcpp::Node::SharedPtr node)
-{
-  _ros_node = std::move(node);
-}
-
-bool CrowdSimInterface::init_crowd_sim()
-{
-  _menge_handle = MengeHandle::init_and_make(
-    _resource_path,
-    _behavior_file,
-    _scene_file,
-    _sim_time_step);
-
-  if (!_sdf_loaded)
-  {
-    RCLCPP_ERROR(
-      logger(),
-      "Please load the sdf before initialize the crowd_sim interface!");
-    return false;
-  }
-  _spawn_object();
-  return true;
-}
-
-double CrowdSimInterface::get_sim_time_step() const
-{
-  return static_cast<double>(_sim_time_step);
-}
-
-bool CrowdSimInterface::_spawn_object()
-{
-  //External models are loaded first in scene file
-  size_t external_count = _external_agents.size();
-  size_t total_agent_count = _menge_handle->get_agent_count();
-
-  //external model must be included in scene file
-  assert(external_count <= total_agent_count);
-
-  for (size_t i = 0; i < external_count; ++i)
-  {
-    auto agent_ptr = _menge_handle->get_agent(i);
-    agent_ptr->_external = true;
-    _add_object(agent_ptr, _external_agents[i], "0", true);
-  }
-
-  for (size_t i = external_count; i < total_agent_count; ++i)
-  {
-    auto agent_ptr = this->_menge_handle->get_agent(i);
-    agent_ptr->_external = false;
-    std::string model_name = "agent" + std::to_string(i);
-    _add_object(agent_ptr, model_name, agent_ptr->_typeName, false);
-  }
-  return true;
-}
-
-void CrowdSimInterface::_add_object(AgentPtr agent_ptr,
-  const std::string& model_name,
-  const std::string& type_name,
-  bool is_external = false)
-{
-  assert(agent_ptr);
-  // must provide a model name in gazebo if it's an external agent
-  if (is_external)
-  {
-    assert(!model_name.empty());
-  }
-  _objects.emplace_back(
-    new Object{agent_ptr, model_name, type_name, is_external});
-}
-
-size_t CrowdSimInterface::get_num_objects() const
-{
-  return _objects.size();
-}
-
-CrowdSimInterface::ObjectPtr CrowdSimInterface::get_object_by_id(size_t id)
-const
-{
-  assert(id < _objects.size());
-  return _objects[id];
-}
-
-void CrowdSimInterface::one_step_sim() const
-{
-  _menge_handle->sim_step();
-}
-
-} //namespace crowd_simulator
diff --git a/building_sim_plugins/building_plugins_common/src/door_common.cpp b/building_sim_plugins/building_plugins_common/src/door_common.cpp
deleted file mode 100644
index 5d431f1..0000000
--- a/building_sim_plugins/building_plugins_common/src/door_common.cpp
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <memory>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/door_common.hpp>
-
-using namespace std::chrono_literals;
-
-namespace building_sim_common {
-
-rclcpp::Logger DoorCommon::logger() const
-{
-  return rclcpp::get_logger("door_" + _state.door_name);
-}
-
-DoorMode DoorCommon::requested_mode() const
-{
-  return _request.requested_mode;
-}
-
-std::vector<std::string> DoorCommon::joint_names() const
-{
-  std::vector<std::string> joint_names;
-  for (const auto& door : _doors)
-    joint_names.push_back(door.first);
-
-  return joint_names;
-}
-
-MotionParams& DoorCommon::params()
-{
-  return _params;
-}
-
-void DoorCommon::publish_state(const uint32_t door_value,
-  const rclcpp::Time& time)
-{
-  if (!_initialized)
-    return;
-
-  _state.current_mode.value = door_value;
-  _state.door_time = time;
-  _door_state_pub->publish(_state);
-}
-
-
-DoorCommon::DoorCommon(const std::string& door_name,
-  rclcpp::Node::SharedPtr node,
-  const MotionParams& params,
-  const Doors& doors)
-: _ros_node(std::move(node)),
-  _params(params),
-  _doors(doors)
-{
-  _state.door_name = door_name;
-  _request.requested_mode.value = DoorMode::MODE_CLOSED;
-
-  _door_state_pub = _ros_node->create_publisher<DoorState>(
-    "/door_states", rclcpp::SystemDefaultsQoS());
-
-  _door_request_sub = _ros_node->create_subscription<DoorRequest>(
-    "/door_requests", rclcpp::SystemDefaultsQoS(),
-    [&](DoorRequest::UniquePtr msg)
-    {
-      if (msg->door_name == _state.door_name)
-        _request = *msg;
-    });
-
-  _initialized = true;
-}
-
-bool DoorCommon::all_doors_open()
-{
-  for (const auto& door : _doors)
-    if (std::abs(door.second.open_position
-      - door.second.current_position) > _params.dx_min)
-      return false;
-
-
-
-  return true;
-}
-
-bool DoorCommon::all_doors_closed()
-{
-  for (const auto& door : _doors)
-    if (std::abs(door.second.closed_position
-      - door.second.current_position) > _params.dx_min)
-      return false;
-
-
-
-  return true;
-}
-
-double DoorCommon::calculate_target_velocity(
-  const double target,
-  const double current_position,
-  const double current_velocity,
-  const double dt)
-{
-  double dx = target - current_position;
-  if (std::abs(dx) < _params.dx_min/2.0)
-    dx = 0.0;
-
-  double door_v = compute_desired_rate_of_change(
-    dx, current_velocity, _params, dt);
-
-  return door_v;
-}
-
-std::vector<DoorCommon::DoorUpdateResult> DoorCommon::update(
-  const double time,
-  const std::vector<DoorCommon::DoorUpdateRequest>& requests)
-{
-  double dt = time - _last_update_time;
-  _last_update_time = time;
-
-  // Update simulation position and velocity of each joint and
-  // calcuate target velocity for the same
-  std::vector<DoorCommon::DoorUpdateResult> results;
-  for (const auto& request : requests)
-  {
-    const auto it = _doors.find(request.joint_name);
-    if (it != _doors.end())
-    {
-      it->second.current_position = request.position;
-      it->second.current_velocity = request.velocity;
-      DoorCommon::DoorUpdateResult result;
-      result.joint_name = request.joint_name;
-      result.fmax = _params.f_max;
-      if (requested_mode().value == DoorMode::MODE_OPEN)
-      {
-        result.velocity = calculate_target_velocity(
-          it->second.open_position,
-          request.position,
-          request.velocity,
-          dt);
-      }
-      else
-      {
-        result.velocity = calculate_target_velocity(
-          it->second.closed_position,
-          request.position,
-          request.velocity,
-          dt);
-      }
-      results.push_back(result);
-    }
-    else
-    {
-      RCLCPP_ERROR(logger(),
-        "Received update request for uninitialized joint [%s]",
-        request.joint_name.c_str());
-    }
-  }
-
-  // Publishing door states
-  if (time - _last_pub_time >= 1.0)
-  {
-    _last_pub_time = time;
-    const int32_t t_sec = static_cast<int32_t>(time);
-    const uint32_t t_nsec =
-      static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
-    const rclcpp::Time now{t_sec, t_nsec, RCL_ROS_TIME};
-
-    if (all_doors_open())
-    {
-      publish_state(DoorMode::MODE_OPEN, now);
-    }
-    else if (all_doors_closed())
-    {
-      publish_state(DoorMode::MODE_CLOSED, now);
-    }
-    else
-    {
-      publish_state(DoorMode::MODE_MOVING, now);
-    }
-  }
-
-  return results;
-}
-
-
-} // namespace building_sim_common
diff --git a/building_sim_plugins/building_plugins_common/src/lift_common.cpp b/building_sim_plugins/building_plugins_common/src/lift_common.cpp
deleted file mode 100644
index f179ef2..0000000
--- a/building_sim_plugins/building_plugins_common/src/lift_common.cpp
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <memory>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/lift_common.hpp>
-
-namespace building_sim_common {
-
-rclcpp::Logger LiftCommon::logger() const
-{
-  return rclcpp::get_logger("lift_" + _lift_state.lift_name);
-}
-
-std::string LiftCommon::get_joint_name() const
-{
-  return _cabin_joint_name;
-}
-
-double LiftCommon::get_elevation() const
-{
-  return _floor_name_to_elevation.at(_lift_state.destination_floor);
-}
-
-void LiftCommon::publish_door_request(const double time, std::string door_name,
-  uint32_t door_state)
-{
-  DoorRequest request;
-  request.request_time = rclcpp::Time(time);
-  request.requester_id = _lift_name;
-  request.door_name = door_name;
-  request.requested_mode.value = door_state;
-
-  _door_request_pub->publish(request);
-}
-
-double LiftCommon::get_step_velocity(const double dt, const double position,
-  const double velocity)
-{
-  double desired_elevation = get_elevation();
-  double dz = desired_elevation - position;
-
-  if (abs(dz) < _cabin_motion_params.dx_min / 2.0)
-    dz = 0;
-
-  return compute_desired_rate_of_change(
-    dz, velocity, _cabin_motion_params, dt);
-}
-
-void LiftCommon::update_cabin_state(const double position,
-  const double velocity)
-{
-  // TODO update current_floor only when lift reaches its destination
-  double smallest_error = std::numeric_limits<double>::max();
-  std::string closest_floor_name;
-  for (const auto& floor : _floor_name_to_elevation)
-  {
-    double tmp_error = abs(position - floor.second);
-    if (tmp_error < smallest_error)
-    {
-      smallest_error = tmp_error;
-      closest_floor_name = floor.first;
-    }
-  }
-  _lift_state.current_floor = closest_floor_name;
-
-  // Set motion state
-  if (abs(velocity) < 0.01)
-    _lift_state.motion_state = LiftState::MOTION_STOPPED;
-  else if (velocity > 0)
-    _lift_state.motion_state = LiftState::MOTION_UP;
-  else
-    _lift_state.motion_state = LiftState::MOTION_DOWN;
-}
-
-void LiftCommon::move_doors(const double time, uint32_t door_mode)
-{
-  auto cabin_door_names =
-    _floor_name_to_cabin_door_name[_lift_state.current_floor];
-  for (const auto& cabin_door : cabin_door_names)
-  {
-    const auto it = _cabin_door_states.find(cabin_door);
-    if (it == _cabin_door_states.end())
-      continue;
-    if (it->second && it->second->current_mode.value != door_mode)
-      publish_door_request(time, cabin_door, door_mode);
-  }
-  auto shaft_door_names =
-    _floor_name_to_shaft_door_name[_lift_state.current_floor];
-  for (const auto& shaft_door : shaft_door_names)
-  {
-    const auto it = _shaft_door_states.find(shaft_door);
-    if (it == _shaft_door_states.end())
-      continue;
-    if (it->second && it->second->current_mode.value != door_mode)
-      publish_door_request(time, shaft_door, door_mode);
-  }
-}
-
-void LiftCommon::open_doors(const double time)
-{
-  move_doors(time, DoorMode::MODE_OPEN);
-}
-
-void LiftCommon::close_doors(const double time)
-{
-  move_doors(time, DoorMode::MODE_CLOSED);
-}
-
-uint32_t LiftCommon::get_door_state(
-  const std::unordered_map<std::string,
-  std::vector<std::string>>& floor_to_door_map,
-  const std::unordered_map<std::string, DoorState::SharedPtr>& door_states)
-{
-  std::size_t open_count = 0;
-  std::size_t closed_count = 0;
-  const auto doors = floor_to_door_map.find(
-    _lift_state.current_floor)->second;
-  const std::size_t num = doors.size();
-  for (const std::string door : doors)
-  {
-    const auto& door_state = door_states.find(door)->second;
-    if ((door_state) &&
-      (door_state->current_mode.value == DoorMode::MODE_CLOSED))
-      closed_count++;
-
-    else if ((door_state) &&
-      (door_state->current_mode.value == DoorMode::MODE_OPEN))
-      open_count++;
-  }
-  if (open_count == num)
-    return DoorMode::MODE_OPEN;
-
-  else if (closed_count == num)
-    return DoorMode::MODE_CLOSED;
-
-  else
-    return DoorMode::MODE_MOVING;
-}
-
-void LiftCommon::update_lift_door_state()
-{
-  uint32_t cabin_door_state = get_door_state(
-    _floor_name_to_cabin_door_name, _cabin_door_states);
-  uint32_t shaft_door_state = get_door_state(
-    _floor_name_to_shaft_door_name, _shaft_door_states);
-
-  _lift_state.door_state = (cabin_door_state == shaft_door_state) ?
-    cabin_door_state : LiftState::DOOR_MOVING;
-}
-
-LiftCommon::LiftCommon(rclcpp::Node::SharedPtr node,
-  const std::string& lift_name,
-  const std::string& joint_name,
-  const MotionParams& cabin_motion_params,
-  const std::vector<std::string>& floor_names,
-  const std::unordered_map<std::string, double>& floor_name_to_elevation,
-  std::unordered_map<
-    std::string, std::vector<std::string>> floor_name_to_shaft_door_name,
-  std::unordered_map<
-    std::string, std::vector<std::string>> floor_name_to_cabin_door_name,
-  std::unordered_map<std::string, DoorState::SharedPtr> shaft_door_states,
-  std::unordered_map<std::string, DoorState::SharedPtr> cabin_door_states,
-  std::string initial_floor_name)
-: _ros_node(node),
-  _lift_name(lift_name),
-  _cabin_joint_name(joint_name),
-  _cabin_motion_params(cabin_motion_params),
-  _floor_names(floor_names),
-  _floor_name_to_elevation(floor_name_to_elevation),
-  _floor_name_to_shaft_door_name(floor_name_to_shaft_door_name),
-  _floor_name_to_cabin_door_name(floor_name_to_cabin_door_name),
-  _shaft_door_states(shaft_door_states),
-  _cabin_door_states(cabin_door_states)
-{
-  // prints out available floors for this lift
-  std::cout << "Loaded lift: " << _lift_name << std::endl;
-  std::cout << "Names  |  Elevations" << std::endl;
-  for (const auto& it : _floor_name_to_elevation)
-    std::cout << it.first << "  |  " << it.second << std::endl;
-
-  // initialize pub & sub
-  _lift_state_pub = _ros_node->create_publisher<LiftState>(
-    "/lift_states", rclcpp::SystemDefaultsQoS());
-
-  _door_request_pub = _ros_node->create_publisher<DoorRequest>(
-    "/adapter_door_requests", rclcpp::SystemDefaultsQoS());
-
-  _lift_request_sub = _ros_node->create_subscription<LiftRequest>(
-    "/lift_requests", rclcpp::SystemDefaultsQoS(),
-    [&](LiftRequest::UniquePtr msg)
-    {
-      if (msg->lift_name != _lift_name)
-        return;
-
-      if (_floor_name_to_elevation.find(
-        msg->destination_floor) == _floor_name_to_elevation.end())
-      {
-        RCLCPP_INFO(logger(),
-        "Received request for unavailable floor [%s]",
-        msg->destination_floor.c_str());
-        return;
-      }
-
-      if (_lift_request)  // Lift is still processing a previous request
-      {
-        RCLCPP_INFO(logger(),
-        "Failed to request: [%s] is busy at the moment",
-        _lift_name.c_str());
-        return;
-      }
-
-      _lift_request = std::move(msg);
-      RCLCPP_INFO(logger(),
-      "Lift [%s] requested at level [%s]",
-      _lift_name.c_str(), _lift_request->destination_floor.c_str());
-    });
-
-  _door_state_sub = _ros_node->create_subscription<DoorState>(
-    "/door_states", rclcpp::SystemDefaultsQoS(),
-    [&](DoorState::SharedPtr msg)
-    {
-      std::string name = msg->door_name;
-      if (_cabin_door_states.find(name) != _cabin_door_states.end())
-        _cabin_door_states[name] = std::move(msg);
-      else if (_shaft_door_states.find(name) != _shaft_door_states.end())
-        _shaft_door_states[name] = std::move(msg);
-    });
-
-  // Initial lift state
-  _lift_state.lift_name = _lift_name;
-  _lift_state.current_floor = _floor_names[0];
-  _lift_state.destination_floor = initial_floor_name;
-  _lift_state.door_state = LiftState::DOOR_CLOSED;
-  _lift_state.motion_state = LiftState::MOTION_STOPPED;
-  for (const std::string& floor_name : _floor_names)
-    _lift_state.available_floors.push_back(floor_name);
-}
-
-void LiftCommon::pub_lift_state(const double time)
-{
-  _last_pub_time = time;
-  const int32_t t_sec = static_cast<int32_t>(time);
-  const uint32_t t_nsec =
-    static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
-  const rclcpp::Time now{t_sec, t_nsec, RCL_ROS_TIME};
-  _lift_state.lift_time = now;
-  _lift_state_pub->publish(_lift_state);
-}
-
-LiftCommon::LiftUpdateResult LiftCommon::update(const double time,
-  const double position, const double velocity)
-{
-  const double dt = time - _last_update_time;
-  _last_update_time = time;
-
-  // Update lift state
-  update_cabin_state(position, velocity);
-  update_lift_door_state();
-
-  // Construct LiftUpdateResult
-  LiftCommon::LiftUpdateResult result;
-  result.velocity = 0.0;
-  result.fmax = _cabin_motion_params.f_max;
-
-  // Handle lift request
-  if (_lift_request)
-  {
-    std::string desired_floor = _lift_request->destination_floor;
-    uint8_t desired_door_state = _lift_request->door_state;
-    if (_lift_request->request_type == LiftRequest::REQUEST_END_SESSION)
-      _lift_state.session_id = "";
-    else
-      _lift_state.session_id = _lift_request->session_id;
-
-    if ((_lift_state.current_floor == desired_floor) &&
-      (_lift_state.door_state == desired_door_state) &&
-      (_lift_state.motion_state == LiftState::MOTION_STOPPED))
-    {
-      RCLCPP_INFO(logger(),
-        "Reached floor %s with doors %s",
-        desired_floor.c_str(), desired_door_state == 0 ? "closed" : "open");
-      _lift_request = nullptr;
-    }
-    else
-    {
-      _lift_state.destination_floor = desired_floor;
-
-      if (_lift_state.current_floor != _lift_state.destination_floor)
-      {
-        if (_lift_state.door_state != LiftState::DOOR_CLOSED)
-        {
-          close_doors(time);
-        }
-        else
-        {
-          result.velocity = get_step_velocity(dt, position, velocity);
-        }
-      }
-      else
-      {
-        if (_lift_state.motion_state != LiftState::MOTION_STOPPED)
-        {
-          result.velocity = get_step_velocity(dt, position, velocity);
-        }
-        else
-        {
-          if (desired_door_state == LiftState::DOOR_OPEN)
-          {
-            open_doors(time);
-          }
-          else if (desired_door_state == LiftState::DOOR_CLOSED)
-          {
-            close_doors(time);
-          }
-        }
-      }
-    }
-  }
-  // Publish lift state at 1 Hz
-  if (time - _last_pub_time >= 1.0)
-    pub_lift_state(time);
-
-  return result;
-}
-
-} // namespace building_sim_common
diff --git a/building_sim_plugins/building_plugins_common/src/slotcar_common.cpp b/building_sim_plugins/building_plugins_common/src/slotcar_common.cpp
deleted file mode 100644
index 2aac34c..0000000
--- a/building_sim_plugins/building_plugins_common/src/slotcar_common.cpp
+++ /dev/null
@@ -1,456 +0,0 @@
-#include <memory>
-
-#include <geometry_msgs/msg/transform_stamped.hpp>
-#include <rmf_fleet_msgs/msg/destination_request.hpp>
-#include <rclcpp/logger.hpp>
-
-#include <building_sim_common/utils.hpp>
-#include <building_sim_common/slotcar_common.hpp>
-
-using namespace building_sim_common;
-
-static double compute_yaw(const Eigen::Isometry3d& pose)
-{
-  auto quat = Eigen::Quaterniond(pose.linear());
-  // Taken from ignition math quaternion Euler()
-  double yaw = std::atan2(2 * (quat.x()*quat.y() + quat.w()*quat.z()),
-      (quat.w() * quat.w()) + (quat.x() * quat.x()) - (quat.y() * quat.y()) -
-      (quat.z() * quat.z()));
-  return yaw;
-}
-
-static Eigen::Vector3d compute_heading(const Eigen::Isometry3d& pose)
-{
-  double yaw = compute_yaw(pose);
-  return Eigen::Vector3d(std::cos(yaw), std::sin(yaw), 0.0);
-}
-
-static auto compute_dpos(const Eigen::Isometry3d& target,
-  const Eigen::Isometry3d& actual)
-{
-  Eigen::Vector3d dpos(target.translation() - actual.translation());
-  dpos(2) = 0.0;
-  return dpos;
-}
-
-rclcpp::Logger SlotcarCommon::logger() const
-{
-  return rclcpp::get_logger("slotcar_" + _model_name);
-}
-
-void SlotcarCommon::set_model_name(const std::string& model_name)
-{
-  _model_name = model_name;
-}
-
-std::string SlotcarCommon::model_name() const
-{
-  return _model_name;
-}
-
-void SlotcarCommon::init_ros_node(const rclcpp::Node::SharedPtr node)
-{
-  _current_mode.mode = rmf_fleet_msgs::msg::RobotMode::MODE_MOVING;
-  _ros_node = std::move(node);
-
-  _tf2_broadcaster = std::make_shared<tf2_ros::TransformBroadcaster>(_ros_node);
-
-  _robot_state_pub =
-    _ros_node->create_publisher<rmf_fleet_msgs::msg::RobotState>(
-    "/robot_state", 10);
-
-  auto qos_profile = rclcpp::QoS(10);
-  qos_profile.transient_local();
-  _building_map_sub =
-    _ros_node->create_subscription<building_map_msgs::msg::BuildingMap>(
-    "/map",
-    qos_profile,
-    std::bind(&SlotcarCommon::map_cb, this, std::placeholders::_1));
-
-  _traj_sub = _ros_node->create_subscription<rmf_fleet_msgs::msg::PathRequest>(
-    "/robot_path_requests",
-    10,
-    std::bind(&SlotcarCommon::path_request_cb, this, std::placeholders::_1));
-
-  _mode_sub = _ros_node->create_subscription<rmf_fleet_msgs::msg::ModeRequest>(
-    "/robot_mode_requests",
-    10,
-    std::bind(&SlotcarCommon::mode_request_cb, this, std::placeholders::_1));
-
-}
-
-bool SlotcarCommon::path_request_valid(
-  const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg)
-{
-  // Request is for another robot
-  if (msg->robot_name != _model_name)
-    return false;
-
-  // Repeated task request
-  if (msg->task_id == _current_task_id)
-  {
-    RCLCPP_INFO(
-      logger(), "%s already received task [%s] -- continuing as normal",
-      _current_task_id.c_str(), _model_name.c_str());
-    return false;
-  }
-
-  // Empty task request
-  if (msg->path.size() == 0)
-  {
-    RCLCPP_WARN(logger(), "%s received a path with no waypoints",
-      _model_name.c_str());
-    return false;
-  }
-  return true;
-}
-
-void SlotcarCommon::path_request_cb(
-  const rmf_fleet_msgs::msg::PathRequest::SharedPtr msg)
-{
-  if (path_request_valid(msg) == false)
-    return;
-
-  RCLCPP_INFO(
-    logger(),
-    "%s received a path request with %d waypoints",
-    _model_name.c_str(), (int)msg->path.size());
-
-  // Reset this if we aren't at the final waypoint
-  trajectory.resize(msg->path.size());
-  _hold_times.resize(msg->path.size());
-  for (size_t i = 0; i < msg->path.size(); ++i)
-  {
-    Eigen::Vector3d v3(
-      msg->path[i].x,
-      msg->path[i].y,
-      0);
-
-    Eigen::Vector3d yaw_euler(
-      0,
-      0,
-      msg->path[i].yaw);
-
-    Eigen::Quaterniond quat(
-      Eigen::AngleAxisd(msg->path[i].yaw, Eigen::Vector3d::UnitZ()));
-    trajectory[i].translation() = v3;
-    trajectory[i].linear() = Eigen::Matrix3d(quat);
-
-    _hold_times[i] = msg->path[i].t;
-
-  }
-  _remaining_path = msg->path;
-  _traj_wp_idx = 0;
-
-  _current_task_id = msg->task_id;
-  _adapter_error = false;
-
-  const double initial_dist = compute_dpos(trajectory.front(), _pose).norm();
-
-  if (initial_dist > INITIAL_DISTANCE_THRESHOLD)
-  {
-    trajectory.clear();
-    trajectory.push_back(_pose);
-
-    _adapter_error = true;
-  }
-}
-
-std::array<double, 2> SlotcarCommon::calculate_control_signals(
-  const std::array<double, 2>& w_tire,
-  const std::pair<double, double>& velocities,
-  const double dt) const
-{
-  std::array<double, 2> joint_signals;
-  const double v_robot = (w_tire[0] + w_tire[1]) * _tire_radius / 2.0;
-  const double w_robot = (w_tire[1] - w_tire[0]) * _tire_radius / _base_width;
-
-  const double v_target = compute_ds(velocities.first, v_robot,
-      _nominal_drive_speed,
-      _nominal_drive_acceleration, _max_drive_acceleration, dt);
-
-  const double w_target = compute_ds(velocities.second, w_robot,
-      _nominal_turn_speed,
-      _nominal_turn_acceleration, _max_turn_acceleration, dt);
-  for (std::size_t i = 0; i < 2; ++i)
-  {
-    const double yaw_sign = i == 0 ? -1.0 : 1.0;
-    joint_signals[i] = v_target / _tire_radius + yaw_sign * w_target *
-      _base_width / (2.0 * _tire_radius);
-  }
-  return joint_signals;
-}
-
-// First value of par is x_target, second is yaw_target
-std::pair<double, double> SlotcarCommon::update(const Eigen::Isometry3d& pose,
-  const std::vector<Eigen::Vector3d>& obstacle_positions,
-  const double time)
-{
-  std::pair<double, double> velocities;
-  const int32_t t_sec = static_cast<int32_t>(time);
-  const uint32_t t_nsec =
-    static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
-  const rclcpp::Time now{t_sec, t_nsec, RCL_ROS_TIME};
-  _last_update_time = time;
-
-  _pose = pose;
-  publish_robot_state(time);
-
-  if (trajectory.empty())
-    return velocities;
-
-  Eigen::Vector3d current_heading = compute_heading(_pose);
-
-  if ((unsigned int)_traj_wp_idx < trajectory.size())
-  {
-    const Eigen::Vector3d dpos = compute_dpos(
-      trajectory[_traj_wp_idx], _pose);
-
-    auto dpos_mag = dpos.norm();
-    const auto hold_time = _hold_times[_traj_wp_idx];
-
-    const bool close_enough = (dpos_mag < 0.02);
-    const bool rotate_towards_next_target = close_enough && (now < hold_time);
-
-    if (rotate_towards_next_target)
-    {
-      auto goal_heading = compute_heading(trajectory[_traj_wp_idx]);
-
-      velocities.second = compute_change_in_rotation(
-        current_heading, goal_heading);
-    }
-    else if (close_enough)
-    {
-      _traj_wp_idx++;
-      if (_remaining_path.empty())
-        return velocities;
-
-      _remaining_path.erase(_remaining_path.begin());
-      RCLCPP_INFO(logger(),
-        "%s reached waypoint %d/%d",
-        _model_name.c_str(),
-        _traj_wp_idx,
-        (int)trajectory.size());
-      if (_traj_wp_idx == trajectory.size())
-      {
-        RCLCPP_INFO(
-          logger(),
-          "%s reached goal -- rotating to face target",
-          _model_name.c_str());
-      }
-    }
-
-    if (!rotate_towards_next_target)
-    {
-      const double d_yaw_tolerance = 5.0 * M_PI / 180.0;
-
-      double dir = 1.0;
-      velocities.second =
-        compute_change_in_rotation(current_heading, dpos, &dir);
-      if (dir < 0.0)
-        current_heading *= -1.0;
-
-      // If d_yaw is less than a certain tolerance (i.e. we don't need to spin
-      // too much), then we'll include the forward velocity. Otherwise, we will
-      // only spin in place until we are oriented in the desired direction.
-      velocities.first = std::abs(velocities.second) <
-        d_yaw_tolerance ? dir * dpos_mag : 0.0;
-    }
-  }
-  else
-  {
-    const auto goal_heading = compute_heading(trajectory.back());
-    velocities.second = compute_change_in_rotation(
-      current_heading,
-      goal_heading);
-
-    // Put in a deadzone if yaw is small enough. This essentially locks the
-    // tires. COMMENTED OUT as it breaks rotations for some reason...
-    // if(std::abs(velocities.second) < std::max(0.1*M_PI/180.00, goal_yaw_tolerance))
-    // {
-    //   velocities.second = 0.0;
-    // }
-
-    velocities.first = 0.0;
-  }
-
-  // Check if we are too close to any obstacle
-  bool stop = emergency_stop(obstacle_positions, current_heading);
-
-  if (stop)
-  {
-    // Allow spinning but not translating
-    velocities.first = 0.0;
-  }
-
-  return velocities;
-}
-
-bool SlotcarCommon::emergency_stop(
-  const std::vector<Eigen::Vector3d>& obstacle_positions,
-  const Eigen::Vector3d& current_heading)
-{
-  const Eigen::Vector3d stop_zone =
-    _pose.translation() + _stop_distance * current_heading;
-
-  bool need_to_stop = false;
-  for (const auto& obstacle_pos : obstacle_positions)
-  {
-    if ((obstacle_pos - stop_zone).norm() < _stop_radius)
-    {
-      need_to_stop = true;
-      break;
-    }
-  }
-
-  if (need_to_stop != _emergency_stop)
-  {
-    _emergency_stop = need_to_stop;
-    // TODO flush logger here
-    // TODO get collision object name
-    if (need_to_stop)
-      RCLCPP_INFO_STREAM(logger(), "Stopping [" << _model_name <<
-          "] to avoid a collision");
-    else
-      RCLCPP_INFO_STREAM(logger(), "No more obstacles; resuming course for [" <<
-          _model_name << "]");
-  }
-
-  return _emergency_stop;
-}
-
-std::string SlotcarCommon::get_level_name(const double z)
-{
-  std::string level_name = "";
-  if (!_initialized_levels)
-    return level_name;
-  auto min_distance = std::numeric_limits<double>::max();
-  for (auto it = _level_to_elevation.begin(); it != _level_to_elevation.end();
-    ++it)
-  {
-    const double disp = std::abs(it->second - z);
-    if (disp < min_distance)
-    {
-      min_distance = disp;
-      level_name = it->first;
-    }
-  }
-  return level_name;
-}
-
-double SlotcarCommon::compute_change_in_rotation(
-  Eigen::Vector3d heading_vec,
-  const Eigen::Vector3d& dpos,
-  double* permissive)
-{
-  if (dpos.norm() < 1e-3)
-  {
-    // We're right next to the waypoint, so we don't really need any heading
-    // to reach it.
-    return 0.0;
-  }
-
-  // Flip the heading vector if the dot product is less than zero. That way,
-  // the robot will turn towards the heading that's closer.
-  const double dot = heading_vec.dot(dpos);
-  if (permissive && dot < 0.0)
-  {
-    heading_vec = -1.0 * heading_vec;
-    *permissive = -1.0;
-  }
-  else if (permissive)
-  {
-    *permissive = 1.0;
-  }
-
-  const auto cross = heading_vec.cross(dpos);
-  const double direction = cross(2) < 0.0 ? -1.0 : 1.0;
-  const double denom = heading_vec.norm() * dpos.norm();
-  const double d_yaw = direction * std::asin(cross.norm() / denom);
-
-  return d_yaw;
-}
-
-void SlotcarCommon::publish_robot_state(const double time)
-{
-  const int32_t t_sec = static_cast<int32_t>(time);
-  const uint32_t t_nsec =
-    static_cast<uint32_t>((time-static_cast<double>(t_sec)) *1e9);
-  const rclcpp::Time ros_time{t_sec, t_nsec, RCL_ROS_TIME};
-  if ((time - last_tf2_pub) > (1.0 / TF2_RATE))
-  {
-    // Publish tf2
-    publish_tf2(ros_time);
-    last_tf2_pub = time;
-  }
-  if ((time - last_topic_pub) > (1.0 / STATE_TOPIC_RATE))
-  {
-    // Publish state topic
-    publish_state_topic(ros_time);
-    last_topic_pub = time;
-  }
-}
-
-void SlotcarCommon::publish_tf2(const rclcpp::Time& t)
-{
-  geometry_msgs::msg::TransformStamped tf_stamped;
-  Eigen::Quaterniond quat(_pose.linear());
-  tf_stamped.header.stamp = t;
-  tf_stamped.header.frame_id = "world";
-  tf_stamped.child_frame_id = _model_name + "/base_link";
-  tf_stamped.transform.translation.x = _pose.translation()[0];
-  tf_stamped.transform.translation.y = _pose.translation()[1];
-  tf_stamped.transform.translation.z = _pose.translation()[2];
-  tf_stamped.transform.rotation.x = quat.x();
-  tf_stamped.transform.rotation.y = quat.y();
-  tf_stamped.transform.rotation.z = quat.z();
-  tf_stamped.transform.rotation.w = quat.w();
-  _tf2_broadcaster->sendTransform(tf_stamped);
-}
-
-void SlotcarCommon::publish_state_topic(const rclcpp::Time& t)
-{
-  rmf_fleet_msgs::msg::RobotState robot_state_msg;
-  robot_state_msg.name = _model_name;
-
-  robot_state_msg.location.x = _pose.translation()[0];
-  robot_state_msg.location.y = _pose.translation()[1];
-  robot_state_msg.location.yaw = compute_yaw(_pose);
-  robot_state_msg.location.t = t;
-  robot_state_msg.location.level_name = get_level_name(_pose.translation()[2]);
-
-  robot_state_msg.task_id = _current_task_id;
-  robot_state_msg.path = _remaining_path;
-  robot_state_msg.mode = _current_mode;
-
-  if (_adapter_error)
-  {
-    robot_state_msg.mode.mode =
-      rmf_fleet_msgs::msg::RobotMode::MODE_ADAPTER_ERROR;
-  }
-
-  _robot_state_pub->publish(robot_state_msg);
-}
-
-void SlotcarCommon::mode_request_cb(
-  const rmf_fleet_msgs::msg::ModeRequest::SharedPtr msg)
-{
-  _current_mode = msg->mode;
-}
-
-void SlotcarCommon::map_cb(
-  const building_map_msgs::msg::BuildingMap::SharedPtr msg)
-{
-  if (msg->levels.empty())
-  {
-    RCLCPP_ERROR(logger(), "Received empty building map");
-    return;
-  }
-
-  for (const auto& level : msg->levels)
-  {
-    _level_to_elevation.insert({level.name, level.elevation});
-  }
-  _initialized_levels = true;
-
-}
diff --git a/building_sim_plugins/building_plugins_common/src/utils.cpp b/building_sim_plugins/building_plugins_common/src/utils.cpp
deleted file mode 100644
index d1125f3..0000000
--- a/building_sim_plugins/building_plugins_common/src/utils.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-#include <cmath>
-#include <algorithm>
-
-#include <building_sim_common/utils.hpp>
-
-namespace building_gazebo_plugins {
-
-//==============================================================================
-double compute_ds(
-  double s_target,
-  double v_actual,
-  const double v_max,
-  const double accel_nom,
-  const double accel_max,
-  const double dt)
-{
-  double sign = 1.0;
-  if (s_target < 0.0)
-  {
-    // Limits get confusing when we need to go backwards, so we'll flip signs
-    // here so that we pretend the target is forwards
-    s_target *= -1.0;
-    v_actual *= -1.0;
-    sign = -1.0;
-  }
-
-  // We should try not to shoot past the targstd::vector<event::ConnectionPtr> connections;et
-  double next_s = s_target / dt;
-
-  // Test velocity limit
-  next_s = std::min(next_s, v_max);
-
-  // Test acceleration limit
-  next_s = std::min(next_s, accel_nom * dt + v_actual);
-
-  if (v_actual > 0.0 && s_target > 0.0)
-  {
-    // This is what our deceleration should be if we want to begin a constant
-    // deceleration from now until we reach the goal
-    double deceleration = pow(v_actual, 2) / s_target;
-    deceleration = std::min(deceleration, accel_max);
-
-    if (accel_nom <= deceleration)
-    {
-      // If the smallest constant deceleration for reaching the goal is
-      // greater than
-      next_s = -deceleration * dt + v_actual;
-    }
-  }
-
-  // Flip the sign the to correct direction before returning the value
-  return sign * next_s;
-}
-
-//==============================================================================
-double compute_desired_rate_of_change(
-  double _s_target,
-  double _v_actual,
-  const MotionParams& _motion_params,
-  const double _dt)
-{
-  double sign = 1.0;
-  if (_s_target < 0.0)
-  {
-    // Limits get confusing when we need to go backwards, so we'll flip signs
-    // here so that we pretend the target is forwards
-    _s_target *= -1.0;
-    _v_actual *= -1.0;
-    sign = -1.0;
-  }
-
-  // We should try not to shoot past the target
-  double v_next = _s_target / _dt;
-
-  // Test velocity limit
-  v_next = std::min(v_next, _motion_params.v_max);
-
-  // Test acceleration limit
-  v_next = std::min(v_next, _motion_params.a_nom * _dt + _v_actual);
-
-  if (_v_actual > 0.0 && _s_target > 0.0)
-  {
-    // This is what our deceleration should be if we want to begin a constant
-    // deceleration from now until we reach the goal
-    double deceleration = pow(_v_actual, 2) / (2.0 * _s_target);
-    deceleration = std::min(deceleration, _motion_params.a_max);
-
-    if (_motion_params.a_nom <= deceleration)
-    {
-      // If the smallest constant deceleration for reaching the goal is
-      // greater than the nominal acceleration, then we should begin
-      // decelerating right away so that we can smoothly reach the goal while
-      // decelerating as close to the nominal acceleration as possible.
-      v_next = -deceleration * _dt + _v_actual;
-    }
-  }
-
-  // Flip the sign to the correct direction before returning the value
-  return sign * v_next;
-}
-
-//==============================================================================
-bool get_element_required(
-  const sdf::ElementPtr& _sdf,
-  const std::string& _element_name,
-  sdf::ElementPtr& _element)
-{
-  if (!_sdf->HasElement(_element_name))
-  {
-    std::cerr << "Element [" << _element_name << "] not found" << std::endl;
-    return false;
-  }
-  _element = _sdf->GetElement(_element_name);
-  return true;
-}
-
-} // namespace building_gazebo_plugins
diff --git a/building_map_tools/model_downloader/__init__.py b/model_downloader/__init__.py
similarity index 100%
rename from building_map_tools/model_downloader/__init__.py
rename to model_downloader/__init__.py
diff --git a/building_map_tools/model_downloader/model_downloader.py b/model_downloader/model_downloader.py
similarity index 100%
rename from building_map_tools/model_downloader/model_downloader.py
rename to model_downloader/model_downloader.py
diff --git a/building_map_tools/package.xml b/package.xml
similarity index 100%
rename from building_map_tools/package.xml
rename to package.xml
diff --git a/building_map_tools/pit_crew/__init__.py b/pit_crew/__init__.py
similarity index 100%
rename from building_map_tools/pit_crew/__init__.py
rename to pit_crew/__init__.py
diff --git a/building_map_tools/pit_crew/pit_crew.py b/pit_crew/pit_crew.py
similarity index 100%
rename from building_map_tools/pit_crew/pit_crew.py
rename to pit_crew/pit_crew.py
diff --git a/building_map_tools/pit_crew/usage_examples.py b/pit_crew/usage_examples.py
similarity index 100%
rename from building_map_tools/pit_crew/usage_examples.py
rename to pit_crew/usage_examples.py
diff --git a/building_map_tools/resource/building_map_tools b/resource/building_map_tools
similarity index 100%
rename from building_map_tools/resource/building_map_tools
rename to resource/building_map_tools
diff --git a/building_map_tools/setup.cfg b/setup.cfg
similarity index 100%
rename from building_map_tools/setup.cfg
rename to setup.cfg
diff --git a/building_map_tools/setup.py b/setup.py
similarity index 100%
rename from building_map_tools/setup.py
rename to setup.py
diff --git a/test_maps/CHANGELOG.rst b/test_maps/CHANGELOG.rst
deleted file mode 100644
index 5f4778c..0000000
--- a/test_maps/CHANGELOG.rst
+++ /dev/null
@@ -1,23 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package test_maps
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-1.1.0 (2020-0-24)
------------------
-* Move message call outside of custom command cal `#184 <https://github.com/osrf/traffic_editor/issues/184>`_
-* Fix/separate model download `#183 <https://github.com/osrf/traffic_editor/issues/183>`_
-* Using custom commands within if condition due to required OUTPUT or TARGET cmake variable
-* Invoking model downloading with a separate custom command
-* Fixing build dependency (`#172 <https://github.com/osrf/traffic_editor/issues/172>`_)
-* Contributors: Aaron Chong, Luca Della Vedova, Marco A. Gutiérrez
-
-1.0.0 (2020-06-22)
-------------------
-* merging master
-* Merge pull request `#132 <https://github.com/osrf/traffic_editor/issues/132>`_ from methylDragon/ch3/author-namespaced-thumbnails
-  Support Author-namedspaced Thumbnails and Revamp building_map_generator
-* Fix build and import bug
-* Merge pull request `#100 <https://github.com/osrf/traffic_editor/issues/100>`_ from osrf/double_swing_doors_directions
-  branch on double swing door direction for sim generation
-* branch on double swing door direction for sim generation
-* Contributors: Aaron Chong, Morgan Quigley, methylDragon
diff --git a/test_maps/CMakeLists.txt b/test_maps/CMakeLists.txt
deleted file mode 100644
index f53696d..0000000
--- a/test_maps/CMakeLists.txt
+++ /dev/null
@@ -1,57 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-
-project(test_maps)
-
-find_package(ament_cmake REQUIRED)
-
-install(DIRECTORY
-  maps/
-  DESTINATION share/${PROJECT_NAME}
-)
-
-ament_package()
-
-file(GLOB_RECURSE traffic_editor_paths "maps/*.building.yaml")
-
-foreach(path ${traffic_editor_paths})
-
-  # Get the output world name
-  string(REPLACE "." ";" list1 ${path})
-  list(GET list1 0 name)
-  string(REPLACE "/" ";" list2 ${name})
-  list(GET list2 -1 world_name)
-
-  set(map_path ${path})
-  set(output_world_name ${world_name})
-  set(output_dir ${CMAKE_CURRENT_BINARY_DIR}/maps/${output_world_name})
-  set(output_world_path ${output_dir}/${output_world_name}.world)
-  set(output_model_dir ${output_dir}/models)
-
-  # first, generate the world
-  message("BUILDING WORLDFILE WITH COMMAND: ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}")
-  if (NO_DOWNLOAD_MODELS)
-    add_custom_command(
-      DEPENDS ${map_path}
-      COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
-      OUTPUT ${output_world_path}
-    )
-  else()
-    message("DOWNLOADING MODELS WITH COMMAND: ros2 run building_map_tools building_map_model_downloader ${map_path}")
-    add_custom_command(
-      DEPENDS ${map_path}
-      COMMAND ros2 run building_map_tools building_map_generator gazebo ${map_path} ${output_world_path} ${output_model_dir}
-      COMMAND ros2 run building_map_tools building_map_model_downloader ${map_path}
-      OUTPUT ${output_world_path}
-    )
-  endif()
-
-  add_custom_target(generate_${output_world_name} ALL
-    DEPENDS ${output_world_path}
-  )
-
-  install(
-    DIRECTORY ${output_dir}
-    DESTINATION share/${PROJECT_NAME}/maps
-  )
-
-endforeach()
diff --git a/test_maps/maps/door_madness/door_madness.building.yaml b/test_maps/maps/door_madness/door_madness.building.yaml
deleted file mode 100644
index d160baf..0000000
--- a/test_maps/maps/door_madness/door_madness.building.yaml
+++ /dev/null
@@ -1,49 +0,0 @@
-levels:
-  L1:
-    doors:
-      - [10, 11, {motion_axis: [1, start], motion_degrees: [3, 90], motion_direction: [2, -1], name: [1, negative_motion], type: [1, double_hinged]}]
-      - [8, 9, {motion_axis: [1, start], motion_degrees: [3, 90], motion_direction: [2, 1], name: [1, positive_motion], type: [1, double_hinged]}]
-    elevation: 0
-    flattened_x_offset: 0
-    flattened_y_offset: 0
-    floors:
-      - parameters: {texture_name: [1, blue_linoleum], texture_rotation: [3, 0], texture_scale: [3, 1]}
-        vertices: [0, 3, 4, 7]
-    layers:
-      {}
-    measurements:
-      - [0, 7, {distance: [3, 4]}]
-    models:
-      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 62.373, y: 73.121, yaw: -3.1416, z: 0}
-      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 62.64, y: 112.802, yaw: -3.1416, z: 0}
-      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 111.89, y: 72.617, yaw: -3.1416, z: 0}
-      - {model_name: VendingMachine, name: VendingMachine, static: true, x: 111.355, y: 108.893, yaw: -3.1416, z: 0}
-    vertices:
-      - [27.219, 60.337, 0, ""]
-      - [75.157, 60.87, 0, ""]
-      - [122.026, 60.739, 0, ""]
-      - [177.423, 60.604, 0, ""]
-      - [177.157, 124.787, 0, ""]
-      - [122.828, 124.787, 0, ""]
-      - [74.89, 125.585, 0, ""]
-      - [25.621, 126.118, 0, ""]
-      - [75.157, 107.742, 0, ""]
-      - [74.89, 77.116, 0, ""]
-      - [122.029, 73.92, 0, ""]
-      - [122.828, 104.813, 0, ""]
-    walls:
-      - [0, 1, {}]
-      - [1, 2, {}]
-      - [2, 3, {}]
-      - [7, 6, {}]
-      - [6, 5, {}]
-      - [5, 4, {}]
-      - [5, 11, {}]
-      - [6, 8, {}]
-      - [9, 1, {}]
-      - [10, 2, {}]
-    x_meters: 3.161074671053361
-    y_meters: 3.161074671053361
-lifts:
-  {}
-name: building
diff --git a/test_maps/maps/door_madness/door_madness.project.yaml b/test_maps/maps/door_madness/door_madness.project.yaml
deleted file mode 100644
index 06453c5..0000000
--- a/test_maps/maps/door_madness/door_madness.project.yaml
+++ /dev/null
@@ -1,4 +0,0 @@
-building:
-  filename: door_madness.building.yaml
-name: door_madness
-version: 1
diff --git a/test_maps/package.xml b/test_maps/package.xml
deleted file mode 100644
index 00a4d40..0000000
--- a/test_maps/package.xml
+++ /dev/null
@@ -1,19 +0,0 @@
-<?xml version="1.0"?>
-<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
-<package format="3">
-  <name>test_maps</name>
-  <version>1.1.0</version>
-  <description>
-    Some test maps for traffic_editor and building_map_tools.
-  </description>
-  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
-  <license>Apache License 2.0</license>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-  <buildtool_depend>building_map_tools</buildtool_depend>
-  <buildtool_depend>ros2run</buildtool_depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
diff --git a/traffic_editor/CHANGELOG.rst b/traffic_editor/CHANGELOG.rst
deleted file mode 100644
index 96c1303..0000000
--- a/traffic_editor/CHANGELOG.rst
+++ /dev/null
@@ -1,345 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package traffic_editor
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-1.1.0 (2020-09-24)
-------------------
-* Focal / Ignition dome support (`#230 <https://github.com/osrf/traffic_editor/issues/230>`_)
-* Adding lift operation range selection (`#220 <https://github.com/osrf/traffic_editor/issues/220>`_)
-* Add field in lift dialog for initial floor, handle invalid initial floor
-* Update lift display (`#216 <https://github.com/osrf/traffic_editor/issues/216>`_)
-* Allowing modification on vertex coordinates (`#215 <https://github.com/osrf/traffic_editor/issues/215>`_)
-* Merge pull request `#212 <https://github.com/osrf/traffic_editor/issues/212>`_ from osrf/feature/model-list-sort-script
-  Feature/model list sort script
-* Added helper script to sort model_list yamls
-* Support for adding and recognizing lift waypoints for multi-level navigation `#201 <https://github.com/osrf/traffic_editor/issues/201>`_
-* fix initial model angle, so it doesn't rotate 90 when placed (`#202 <https://github.com/osrf/traffic_editor/issues/202>`_)
-* Add button to generate lift waypoints in the GUI
-* Configurable texture and transparency for wall `#200 <https://github.com/osrf/traffic_editor/issues/200>`_
-* fix lifts not cleared when opening another project `#196 <https://github.com/osrf/traffic_editor/issues/196>`_ 
-* New traffic editor thumbnail generator `#191 <https://github.com/osrf/traffic_editor/issues/191>`_
-* View menu option to show/hide models `#174 <https://github.com/osrf/traffic_editor/issues/174>`_
-* Add add_edge shift alignment feature `#173 <https://github.com/osrf/traffic_editor/issues/173>`_
-* Contributors: Aaron Chong, Chen Bainian, Geoffrey Biggs, Kevin_Skywalker, Luca Della Vedova, MakinoharaShouko, Marco A. Gutierrez, Morgan Quigley, Yadu, Yadunund, kevinskwk, methylDragon, youliang
-
-1.0.0 (2020-06-22)
-------------------
-* Implement using thumbnails from installed traffic_editor_assets ament package (`#152 <https://github.com/osrf/traffic_editor/issues/152>`_)
-  * Implement parsing thumbnails from assets ament package
-  * Remove ExternalProject
-  * Update style
-  * Catch missing package error
-  Co-authored-by: Marco A. Gutiérrez <spyke.me@gmail.com>
-* Merge pull request `#153 <https://github.com/osrf/traffic_editor/issues/153>`_ from osrf/bug/model_orientation
-  Fixed orientation of model thumbnails in the gui
-* Fixed orientation of model thumbnails in the gui
-* Merge pull request `#149 <https://github.com/osrf/traffic_editor/issues/149>`_ from osrf/simulation_plugin_interface
-  process-flow sim plugin interface, and various other improvements
-* Merge pull request `#150 <https://github.com/osrf/traffic_editor/issues/150>`_ from osrf/update_style_check
-  Update style.yaml
-* Added braces around for in project.cpp
-* Update traffic_editor/package.xml
-  Co-authored-by: Marco A. Gutiérrez <marco@openrobotics.org>
-* let's not crash when loading an empty map
-* remove unused unique_ptr namespace inclusion
-* merging master
-* Merge pull request `#148 <https://github.com/osrf/traffic_editor/issues/148>`_ from osrf/fix_crop_python_style
-  merging since this is trivial (famous last words)
-* python line was too long
-* Merge pull request `#147 <https://github.com/osrf/traffic_editor/issues/147>`_ from MakinoharaShouko/master
-  Fix not generating cropped image with namespace
-* Fix not generating cropped image with namespace
-* Merge pull request `#1 <https://github.com/osrf/traffic_editor/issues/1>`_ from MakinoharaShouko/crop_fix
-  Fix not generating cropped image with namespace
-* Fix not generating cropped image with namespace
-* simplify by getting rid of pointers where possible
-* since opencv is only needed for video recording, it's now optional
-* hide the sim controls if there is no plugin present
-* Merge pull request `#132 <https://github.com/osrf/traffic_editor/issues/132>`_ from methylDragon/ch3/author-namespaced-thumbnails
-  Support Author-namedspaced Thumbnails and Revamp building_map_generator
-* Merge branch 'master' into ch3/author-namespaced-thumbnails
-* Correct README
-* Merge pull request `#128 <https://github.com/osrf/traffic_editor/issues/128>`_ from methylDragon/ch3/migrate-traffic-editor-thumbnails
-  Migrate thumbnails to traffic_editor_assets repo
-* Fix build and import bug
-* Revert default directory and make directories if they don't exist
-  Also make it less fragile by allowing expansion of the home shortcut "~"
-* Add dependency on buiding_map_tools
-  In order to ensure that pit_crew is accessible!
-* Unify building_map_generators
-  With argparse and pit_crew!
-* Pit-crewify thumbnail_generators
-* thumbnails::yeet()
-  Let's try this again..
-* Merge branch 'master' into ch3/migrate-traffic-editor-thumbnails
-* Merge pull request `#130 <https://github.com/osrf/traffic_editor/issues/130>`_ from osrf/fix/model-thumbnail-names
-  Fix/model thumbnail names
-* Corrected thumbnail for PotatoChipChair
-* Changed the name for model and thumbnail Table
-* Retarget thumbnail search path to ~/.traffic_editor
-* Implement git clone on build
-* avoid deadlock
-* adding debugging drawing hooks to simulation plugin interface
-* osrf repo
-* migrate behavior stuff into plugins, out of main tree
-* render mixed lane colors in a predictable z-stack
-* remove logging from the core traffic-editor, do it in plugins
-* option to release reserved lanes during waiting behavior node
-* adjust mutex: sim proceeds while video frame is writing to disk
-* helper function to retrieve model instances
-* WIP simplifying internal API and removing YAML scripting nonsense
-* add load function to configure simulation interface from yaml
-* epic restructuring of include files to allow a plugin interface for sim
-* Merge pull request `#118 <https://github.com/osrf/traffic_editor/issues/118>`_ from osrf/feature/teleport-dispenser
-  Feature/teleport dispenser
-* learn cmake
-* WIP trying to bring in ignition-plugin
-* log simulations to csv
-* models name instances can be edited, and saved
-* print less to the console
-* added teleport dispenser ingestor thumbnails, same as robot placeholder
-* allow editing of model instance name
-* on startup, restore editor to previous level
-* WIP process flow animation machinery
-* Merge pull request `#117 <https://github.com/osrf/traffic_editor/issues/117>`_ from osrf/master
-  bring in medium-size surgical trolley
-* Merge pull request `#116 <https://github.com/osrf/traffic_editor/issues/116>`_ from osrf/feature/surgical-trolley-med
-  added thumbnail for SurgicalTrolleyMed
-* added thumbnail for SurgicalTrolleyMed
-* restore rotation of StorageRack thumbnail
-* Merge pull request `#115 <https://github.com/osrf/traffic_editor/issues/115>`_ from osrf/master
-  bring new thumbnails to dev branch
-* Merge pull request `#114 <https://github.com/osrf/traffic_editor/issues/114>`_ from osrf/feature/trolley-bed-thumbnails
-  Feature/trolley bed thumbnails
-* copied to wrong places, replaced old thumbnails
-* added thumbnails
-* WIP teleporting other models for cargo pickup/dropoff
-* improve nav graph following, simplify creation of non-zero graph_idx
-* Merge pull request `#113 <https://github.com/osrf/traffic_editor/issues/113>`_ from osrf/master
-  merge in thumbnail improvements
-* Merge pull request `#112 <https://github.com/osrf/traffic_editor/issues/112>`_ from osrf/feature/more-thumbnails
-  added new thumbnails for hospital environment
-* added new thumbnails for hospital environment
-* WIP smarter NPC motions...
-* clean up compiler warnings
-* add string interpolation and a signaling method
-* set vertex label red if selected. try to fix github build workflow
-* checkboxes for show/hide internal traffic lanes. sim starts paused.
-* use opencv for video recording
-* loop at end of behavior schedule
-* rotate models to face the direction of travel
-* path traversal starting to work
-* basic a* planner seems ok
-* WIP agent planning
-* WIP scenario non-robot animation
-* WIP towards beginnings of 2d model scripting
-* load images concurrently on all CPU cores
-* Merge pull request `#111 <https://github.com/osrf/traffic_editor/issues/111>`_ from osrf/fix/robot-placeholder-thumbnails
-  fix model thumbnail and naming convention
-* fix model thumbnail and naming convention
-* Merge pull request `#110 <https://github.com/osrf/traffic_editor/issues/110>`_ from osrf/fix/thumbnail-name
-  fixed bookshelf thumbnail name
-* propagate unique_ptr usage to allow polymorphic compositions
-* fixed bookshelf thumbnail name
-* allow modifying of lanes in traffic mode and simplify renderings of bidirectional lanes.
-* don't insert scenario table twice
-* beginnings of sim thread
-* learning about elite c++11 memory features
-* working towards minimalist behavior sequencing
-* Merge pull request `#108 <https://github.com/osrf/traffic_editor/issues/108>`_ from osrf/feature/new-thumbnails
-  Feature/new thumbnails
-* removed empty newlines
-* changed back camera height
-* corrected thumbnail names to point to open source gazebo models
-* WIP external traffic files
-* more gazebo thumbnails, compressed largge thumbnails
-* add skeleton for traffic map dialog
-* render traffic map names in tablewidget
-* Merge pull request `#104 <https://github.com/osrf/traffic_editor/issues/104>`_ from osrf/feature/thumbnail-generation
-  Feature/thumbnail generation
-* save/load traffic-map references in project file
-* lint :sparkles:
-* added generation and merging utility scripts
-* removed ros2 launch
-* basic pipeline and docs added
-* start of external traffic map files in GUI
-* Merge pull request `#103 <https://github.com/osrf/traffic_editor/issues/103>`_ from osrf/feature/demo-assets
-  added new demo asset thumbnails
-* added new demo asset thumbnails
-* Merge pull request `#100 <https://github.com/osrf/traffic_editor/issues/100>`_ from osrf/double_swing_doors_directions
-  branch on double swing door direction for sim generation
-* branch on double swing door direction for sim generation
-* Merge pull request `#94 <https://github.com/osrf/traffic_editor/issues/94>`_ from osrf/static_parameter_for_models
-  Static parameter for models
-  Tested manually on a few worlds, looks OK
-* add static param to models in GUI
-* Merge pull request `#90 <https://github.com/osrf/traffic_editor/issues/90>`_ from osrf/feature/single-doors
-  Feature/single doors
-* abs values for motion degrees, use motion direction instead
-* fix merge conflict
-* Merge pull request `#81 <https://github.com/osrf/traffic_editor/issues/81>`_ from osrf/add_flattened_offsets
-  XY translation of each level in a 'flattened' world generation mode
-* XY translation of each level in a 'flattened' world generation mode
-* Merge pull request `#80 <https://github.com/osrf/traffic_editor/issues/80>`_ from osrf/floor_holes
-  Floor holes
-* click selects holes first, then other polygon types
-* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into floor_holes
-* Merge pull request `#79 <https://github.com/osrf/traffic_editor/issues/79>`_ from osrf/feature/model-elevation
-  Feature/model elevation
-* reverted back to using double for model::z, makes yaml parsing cleaner
-* clear all fields of project when creating a new one
-* added elevation/z param to model
-* WIP floor holes GUI tool
-* add some icons as we add a new tool for polygon-holes
-* only override drawing scale if >2 fiducials are present
-* more small fixes for levels without scale
-* trivial: update level table after adding a level
-* Merge pull request `#71 <https://github.com/osrf/traffic_editor/issues/71>`_ from osrf/fix_initial_creation_workflow
-  Fix initial creation workflow. Load drawing floorplan images immediately after they are specified in the level dialog, rather than only doing it when loading the building level from YAML.
-* refactor drawing loading so it can happen after level dialog also
-* fix crash when no levels are present
-* Merge pull request `#69 <https://github.com/osrf/traffic_editor/issues/69>`_ from osrf/create_vertex_when_starting_wall
-  create a new vertex if the add-edge click is not near an existing one
-* create a new vertex if the add-edge click is not near an existing one
-* Merge pull request `#67 <https://github.com/osrf/traffic_editor/issues/67>`_ from osrf/create_vertex_as_needed_for_edges
-  finish implementing `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ to allow continuous clicks for edge creation
-* finish implementing `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ to allow continuous clicks for edge creation
-* Merge pull request `#66 <https://github.com/osrf/traffic_editor/issues/66>`_ from osrf/click_walls_instead_of_drag
-  implement part of `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ so you can just keep clicking to chain vertices together
-* don't automatically chain doors/measurements in edge tool
-* implement part of `#63 <https://github.com/osrf/traffic_editor/issues/63>`_ so you can just keep clicking to chain vertices together
-* Merge pull request `#64 <https://github.com/osrf/traffic_editor/issues/64>`_ from osrf/specify_floor_textures
-  Specify floor textures
-* allow specification of floor texture and scale
-* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into specify_floor_textures
-* fix `#62 <https://github.com/osrf/traffic_editor/issues/62>`_, scale vertex click and paint doorjamb last
-* add explicit polygon texture params for now
-* Merge pull request `#59 <https://github.com/osrf/traffic_editor/issues/59>`_ from osrf/scenario_roi_polygon_tool
-  lots of refactoring and cleanup to allow modifying scenario polygons
-* lots of refactoring and cleanup to allow modifying scenario polygons
-* Merge pull request `#58 <https://github.com/osrf/traffic_editor/issues/58>`_ from osrf/restore_viewport_center_and_zoom
-  restore viewport translation and scale on startup
-* restore viewport translation and scale on startup
-* update readme
-* draw traffic vertices in building coords still, for now
-* Merge pull request `#53 <https://github.com/osrf/traffic_editor/issues/53>`_ from osrf/correct_thumbnail_size
-  use cropped thumbnails. add four new models.
-* use cropped thumbnails. add four new models.
-* Merge pull request `#52 <https://github.com/osrf/traffic_editor/issues/52>`_ from osrf/separate_building_map_and_traffic_map_files
-  Separate building map and traffic map files
-* fix move-model bug
-* allow deleting vertices from scenario
-* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into separate_building_map_and_traffic_map_files
-* working towards adding vertices in scenarios
-* change toolbar in response to edit mode. add to scenario skeleton.
-* scenario save/load skeleton
-* start scenario data structure
-* add tabs
-* project dialog box to set the building path
-* starting to place building within a project...
-* Merge pull request `#51 <https://github.com/osrf/traffic_editor/issues/51>`_ from osrf/add_thumbnails
-  add some new office furniture thumbnails
-* add some new office furniture thumbnails
-* finish propagating and refactoring buildings, so things compile again
-* everything is now broken
-* migrate Map to Building class
-* Merge pull request `#49 <https://github.com/osrf/traffic_editor/issues/49>`_ from osrf/restore_window_position_and_size
-  use qsettings to save/restore window position and size
-* use qsettings to save/restore window position and size
-* Merge pull request `#48 <https://github.com/osrf/traffic_editor/issues/48>`_ from osrf/add_elevation_to_level_dialog
-  set level elevation via dialog box. Various cleanups.
-* set level elevation via dialog box. Various cleanups.
-* Merge pull request `#46 <https://github.com/osrf/traffic_editor/issues/46>`_ from osrf/calculate_and_show_scale_using_fiducials
-  Calculate and show scale using fiducials
-* use measurement data only on the reference level. otherwise, ficudials
-* fix QGraphicsView item lookup to fix regression in selecting doors/walls
-* specify reference level via map-dialog box
-* redraw scene immediately after adding level
-* Merge branch 'master' into calculate_and_show_scale_using_fiducials
-* Merge pull request `#45 <https://github.com/osrf/traffic_editor/issues/45>`_ from osrf/fix_new_document_problems
-  deal more gracefully with an empty world by not crashing
-* deal more gracefully with an empty world by not crashing
-* update docs to reflect new way to add levels
-* map dialog for 'global' model properties
-* factor level table into its own file. add meas+fiducial counts to it.
-* Merge pull request `#42 <https://github.com/osrf/traffic_editor/issues/42>`_ from osrf/align_lift_layer
-  Fiducials to align layers
-* level alignment starting to work hooray
-* WIP alignment
-* working towards fiducial alignment
-* Merge pull request `#41 <https://github.com/osrf/traffic_editor/issues/41>`_ from osrf/create_lifts
-  Lifts
-* make ficudials easier to see
-* add fiducial tool
-* rotate lift doors correctly. Fix lift door yaml load bug
-* copy lift-door checkbox matrix to data structure on OK button
-* change data structure to deal with multi-door scenario on same level
-* respond appropriately to edits in door table
-* push lift elements into QGraphicsGroup and don't transform in dialog rendering
-* live updates for lift preview
-* start rendering lifts on the map using modeless dialog param updates
-* save lift x,y,yaw,width,depth
-* update level-door table combo box options when a door name changes
-* add tables for editing doors and level-door mapping
-* start working on adding lifts
-* Merge pull request `#39 <https://github.com/osrf/traffic_editor/issues/39>`_ from osrf/some_toolbar_icons
-  add a few toolbar icons
-* add a few toolbar icons
-* Merge pull request `#38 <https://github.com/osrf/traffic_editor/issues/38>`_ from osrf/set_modified_flag
-  Set modified flag
-* Merge pull request `#37 <https://github.com/osrf/traffic_editor/issues/37>`_ from osrf/unify_move_tools
-  unify move-vertex and move-model tools. Toolbar on top.
-* ask to save changes on exit
-* unify move-vertex and move-model tools. Toolbar on top.
-* Merge pull request `#35 <https://github.com/osrf/traffic_editor/issues/35>`_ from osrf/levels_layers_tabs
-  migrate level selection from a button bar into a tabbed table
-* migrate level selection from a button bar into a tabbed table
-* Merge pull request `#34 <https://github.com/osrf/traffic_editor/issues/34>`_ from osrf/editor_ui_cleanup
-  Editor UI cleanup
-* allow deletion of vertices and models
-* refactoring model selection into its own dialog
-* Merge pull request `#33 <https://github.com/osrf/traffic_editor/issues/33>`_ from osrf/add_more_models
-  Add more models
-* trolley bed thumbnails
-* storage rack model thumbnail
-* add new model thumbnails
-* add storage rack thumbnails
-* trivial cleanup
-* Merge pull request `#32 <https://github.com/osrf/traffic_editor/issues/32>`_ from osrf/use_layer_visibility_checkboxes
-  use checkboxes to specify layer visibility
-* oops. optional parameter...
-* Merge pull request `#31 <https://github.com/osrf/traffic_editor/issues/31>`_ from osrf/rendering_layers_controls
-  Rendering layers controls
-* fix compile
-* rendering starting to work
-* render layers
-* layer yaml save/load, working towards layer dialog
-* annotate YAML document with flow styles, and emit them
-* add layer table and dialog for add/edit layers
-* working towards selectable layers
-* Merge pull request `#28 <https://github.com/osrf/traffic_editor/issues/28>`_ from osrf/generate_doors
-  Generate doors
-* add various door gazebo generation stuff and demo mock lift floor changes
-* Merge pull request `#27 <https://github.com/osrf/traffic_editor/issues/27>`_ from osrf/add_dock_points
-  add dock points and generate docking nav graph params
-* add dock points and generate docking nav graph params
-* Merge pull request `#25 <https://github.com/osrf/traffic_editor/issues/25>`_ from osrf/rotate_models_visually_with_discretization
-  show model pixmaps rotating, with optional discretization
-* show model pixmaps rotating, with optional discretization
-* Merge pull request `#21 <https://github.com/osrf/traffic_editor/issues/21>`_ from osrf/spawn_robot_parameters
-  robot parameters for spawning and Gazebo world generation
-* create vertex parameters for spawning robots in simulation
-* Merge pull request `#19 <https://github.com/osrf/traffic_editor/issues/19>`_ from osrf/redraw_after_new_file_create
-  redraw after file->new, also give explicit model path for gazebo gen
-* redraw after file->new, also give explicit model path for gazebo gen
-* Merge pull request `#18 <https://github.com/osrf/traffic_editor/issues/18>`_ from osrf/add_install_target
-  add install step in cmake
-* add install step in cmake
-* Merge pull request `#17 <https://github.com/osrf/traffic_editor/issues/17>`_ from osrf/ci_update_first
-  update before installing in github workflow
-* update before installing in github workflow
-* Merge pull request `#16 <https://github.com/osrf/traffic_editor/issues/16>`_ from osrf/repository_reorganization
-  Repository reorganization
-* Merge branch 'master' of ssh://github.com/osrf/traffic_editor into repository_reorganization
-* grand reorganization as colcon-buildable packages for ros2 integration
-* Contributors: Aaron, Aaron Chong, MakinoharaShouko, Morgan Quigley, Yadu, Yadunund, methylDragon
diff --git a/traffic_editor/CMakeLists.txt b/traffic_editor/CMakeLists.txt
deleted file mode 100644
index a421604..0000000
--- a/traffic_editor/CMakeLists.txt
+++ /dev/null
@@ -1,119 +0,0 @@
-cmake_minimum_required(VERSION 3.10.0)
-
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-project(traffic_editor)
-
-find_package(yaml-cpp REQUIRED)
-find_package(ament_cmake REQUIRED)
-
-set(CMAKE_BUILD_TYPE RelWithDebInfo)
-# set(CMAKE_VERBOSE_MAKEFILE TRUE)
-
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wshadow -Wextra")
-
-set(CMAKE_AUTOMOC ON)
-set(CMAKE_AUTORCC ON)
-set(CMAKE_AUTOUIC ON)
-
-if(CMAKE_VERSION VERSION_LESS "3.7.0")
-  set(CMAKE_INCLUDE_CURRENT_DIR ON)
-endif()
-
-find_package(Qt5 COMPONENTS Widgets Concurrent REQUIRED)
-find_package(ignition-plugin1 REQUIRED COMPONENTS all)
-find_package(ignition-common3 REQUIRED)
-find_package(ament_index_cpp REQUIRED)
-
-# OpenCV is an optional dependency, only needed if you want to make videos
-# which is only really needed if you're using a process simulation plugin
-find_package(OpenCV QUIET)
-
-include_directories(.)
-include_directories(gui)
-include_directories(include)
-include_directories(${ament_index_cpp_INCLUDE_DIRS})
-
-add_executable(traffic-editor
-  gui/add_param_dialog.cpp
-  gui/building.cpp
-  gui/building_dialog.cpp
-  gui/building_level.cpp
-  gui/building_level_dialog.cpp
-  gui/building_level_table.cpp
-  gui/edge.cpp
-  gui/editor.cpp
-  gui/editor_model.cpp
-  gui/fiducial.cpp
-  gui/layer.cpp
-  gui/layer_dialog.cpp
-  gui/level.cpp
-  gui/lift.cpp
-  gui/lift_dialog.cpp
-  gui/lift_door.cpp
-  gui/lift_table.cpp
-  gui/main.cpp
-  gui/map_view.cpp
-  gui/model.cpp
-  gui/model_dialog.cpp
-  gui/param.cpp
-  gui/polygon.cpp
-  gui/preferences_dialog.cpp
-  gui/preferences_keys.cpp
-  gui/project.cpp
-  gui/project_dialog.cpp
-  gui/scenario.cpp
-  gui/scenario_dialog.cpp
-  gui/scenario_level.cpp
-  gui/scenario_table.cpp
-  gui/sim_thread.cpp
-  gui/table_list.cpp
-  gui/traffic_table.cpp
-  gui/traffic_map.cpp
-  gui/traffic_map_dialog.cpp
-  gui/vertex.cpp
-  gui/yaml_utils.cpp
-  resources/resource.qrc
-)
-
-target_link_libraries(traffic-editor
-  Qt5::Widgets
-  Qt5::Concurrent
-  ignition-plugin1::core
-  ignition-plugin1::loader
-  ignition-common3::core
-  yaml-cpp
-  ${ament_index_cpp_LIBRARIES}
-  ${OpenCV_LIBS}
-)
-
-if (OpenCV_VERSION)
-  target_compile_definitions(traffic-editor PUBLIC "HAS_OPENCV")
-endif()
-
-set_property(TARGET traffic-editor PROPERTY ENABLE_EXPORTS 1)
-
-install(
-  TARGETS traffic-editor
-  LIBRARY DESTINATION lib
-  RUNTIME DESTINATION bin
-)
-
-install(
-  DIRECTORY
-    plugins
-  DESTINATION
-    include/traffic_editor)
-
-install(
-  DIRECTORY
-    include/traffic_editor
-  DESTINATION
-    include)
-
-
-ament_export_include_directories(include)
-
-ament_package()
diff --git a/traffic_editor/LICENSE b/traffic_editor/LICENSE
deleted file mode 100644
index 261eeb9..0000000
--- a/traffic_editor/LICENSE
+++ /dev/null
@@ -1,201 +0,0 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/traffic_editor/README.md b/traffic_editor/README.md
deleted file mode 100644
index 65555a3..0000000
--- a/traffic_editor/README.md
+++ /dev/null
@@ -1,146 +0,0 @@
-![](https://github.com/osrf/traffic_editor/workflows/build/badge.svg)
-
-# Traffic Editor
-A graphical editor for robot traffic flows. The intent is to make it easy
-to annotate building floorplans with the desired robot traffic lanes and
-generate simulation models to test and evaluate different traffic schemes.
-
-## System Requirements
-
-This program is developed and tested on
-[Ubuntu 18.04 LTS](http://releases.ubuntu.com/18.04/), using
-[Qt 5](https://doc.qt.io/qt-5/qt5-intro.html) and
-[`yaml-cpp`](https://github.com/jbeder/yaml-cpp).
-
-## Compiling Instructions
-Traffic Editor is now structured as a Colcon package. After installing
-ROS 2 Eloquent, the following command sequence will create a colcon
-workspace in `~/colcon_workspace` and build `traffic-editor` there:
-
-```bash
-sudo apt update
-sudo apt install libyaml-cpp-dev qt5-default \
-  libopencv-dev libopencv-videoio-dev \
-  libignition-plugin-dev libignition-common3-dev
-mkdir -p ~/colcon_workspace/src
-cd ~/colcon_workspace/src
-git clone https://github.com/osrf/traffic_editor
-cd ~/colcon_workspace
-source /opt/ros/eloquent/setup.bash
-colcon build --packages-select traffic_editor
-```
-
-You are also **highly recommended** to also install the companion `traffic_editor_assets`
-package, which contains a nifty bunch of useful assets to use with `traffic_editor`.
-
-```bash
-cd ~/colcon_workspace/src
-git clone https://github.com/osrf/traffic_editor_assets
-cd ~/colcon_workspace
-source /opt/ros/eloquent/setup.bash
-colcon build --packages-select traffic_editor_assets
-```
-
-Then you should be able to run `traffic-editor` by sourcing the install
-space of that workspace, in a new "clean" terminal:
-```bash
-source ~/colcon_workspace/install/setup.bash
-traffic-editor
-```
-
-# Quick Start
-
-If it's the first time you are running it, starting the editor with
-`traffic-editor` should bring up a blank window.
-
-First, you'll need to make sure that `traffic-editor` knows where the
-model thumbnails are found. If you installed `traffic_editor_assets`,
-`traffic_editor` should find it automatically. The thumbnails are
-top-view renderings of various art assets that can be added to the
-environments, such as chairs.
-
-Click `Edit->Preferences...` and see if the path provided in the "Thumbnail Path" box looks reasonable. 
-
-If necessary, the "Find..." button can be used to browse the filesystem to point to any desired thumbnail directory.
-
-(If you installed the recommended `traffic_editor_assets` package, you will find its thumbnail directory in its install space at `<workspace_dir>/install/traffic_editor_assets/share/assets/thumbnails`.)
-
-### Creating a new Project and an empty Building Map
-
-Click `Project->New...` and save your new project as `test.project.yaml`
-
-Click `Edit->Project Properties...` and enter "test" as the project name and `test.building.yaml` as the building path. Then click OK.
-
-Click `Edit->Building Properties...` and enter "test" as the building name.
-Click OK.
-
-### Creating a level and adding some stuff
-
-Click the "Add..." button in the "levels" tab on the far right side of the main editor window. This will pop up a dialog where you can create a new level. Enter `L1` for the name and click OK. This will create a 10 meter square level.
-
-You can zoom in and out using the mouse wheel on the rendering on the left side of the main window. You can pan around by dragging the mouse around with the mouse wheel (or middle button) depressed.
-
-Now, you should be able to click the green dot toolbar icon, which is the "Add Vertex" tool (or press `V`) and click a few vertices in the white area. Press the `[Escape]` key to return to the "Select" tool.
-
-Now, you should be able to click the `add wall` tool (or press `W`) and drag from one vertex to another vertex to add wall segments.
-
-To delete wall segments or vertices, first press `[Escape]` to enter Select mode. Then, click on a wall segment or vertex, and press `[Delete]`.
-
-### Save your work
-
-Click `Project->Save` or press `Ctrl+S` to save the project and building map.
-
-### Adding real-world measurements to set the scale
-
-To set the scale of the drawing, click the `add measurement` tool (or press `M`) and drag from one vertex to another to add a real-world measurement line, which should show up as a pink line. Then click the `select` tool (or press `Esc`) and click on the line with the left button. This should populate the property-editor in the lower-right pane of the editor window. You can then specify the real-world length of the measurement line in meters. If you set more than one measurement line on a drawing, the editor will compute an average value of pixels-per-meter from all supplied measurements.
-
-Currently you need to re-load the document (closing the editor and re-opening) to re-compute the scale. This is not ideal, but is hopefully not a frequently-used feature. Typically the scale of a map is only set one time.
-
-### Adding lifts
-
-Click the "Add..." button in the "lifts" tab on the far right side of the main editor window. This will pop up a dialog where you can create a new lift. You can specify the name, position, size, and reference floor in the dialog.
-
-*Note: Do include the keywork "lift" in the lift name as for now this is how slotcars recognize lift models.*
-
-You can add lift doors by lick the "Add..." button below the box showing the lift. Set Door type to "Double sliding" (The only supported type for now!), and align the doors to the edge of the lift (represented by the green box). After that, select which door you want to use on each floor by simply checking the boxes on the left.
-
-Lift waypoints at the center of the lift on each level can also be generated using the "Add lift waypoints" button in the dialog. Note that waypoints will only be generated on levels that the lift is serving (has a door opening on that level).
-
-### Generating Custom Thumbnails
-
-Model thumbnails are used in `traffic_editor`. To generate a thumbnail, a simple working example is shown here to generate a `SUV`:
-```bash
-# Run as gz plugin, set --a for help options printout
-gzserver -s libthumbnail_generator.so empty.world --input ~/.gazebo/models/SUV/model.sdf --output .
-```
-After execution, you will notice a newly created `SUV.png` in your current working directory. This can be further placed into `traffic_editor_assets/assets/thumbnails`.
-
-To generate multiple model thumbnails listed in `model_list.yaml`, run this:
-```bash
-export GAZEBO_MODEL_PATH=/PATH/TO/MODELS; ./scripts/generate_thumbnails.py /PATH/TO/MODELS test/model_list.yaml ~/output
-```
-
-User can also change the script default configs:  `img_size`, `cam_height` and `fhov`, which will alter the `meters_per_pixel` value.
-
-Similarly, the generated thumbnails in `~/output` can then be added to `traffic_editor_assets/assets/thumbnails`, while also append `model_list.yaml`.
-
-### Utilities
-
-A new model list `.yaml` file can be generated using the utility script, where an optional blacklisted model names can be added, to avoid creating moving models or agents,
-
-```bash
-# e.g. MODEL_DIR = '~/.gazebo/models'
-./scripts/generate_model_list.py output_model_list.yaml -d MODEL_DIR -b test/model_blacklist.yaml
-```
-
-In the event that merging multiple model lists is required, a different utility script can be used,
-
-```bash
-./scripts/merge_model_lists.py output_model_list.yaml -s test/model_list.yaml
-```
-
-To sort the model list `.yaml` file,
-
-```bash
-./scripts/sort_model_list.py model_list.yaml
-```
diff --git a/traffic_editor/gui/add_param_dialog.cpp b/traffic_editor/gui/add_param_dialog.cpp
deleted file mode 100644
index b0e1d3c..0000000
--- a/traffic_editor/gui/add_param_dialog.cpp
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "add_param_dialog.h"
-#include <QtWidgets>
-
-
-AddParamDialog::AddParamDialog(
-  QWidget* parent,
-  const std::vector<std::pair<std::string, Param::Type>>& _param_names)
-: QDialog(parent),
-  param_names(_param_names)
-{
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  cancel_button = new QPushButton("Cancel", this);
-
-  QHBoxLayout* name_hbox_layout = new QHBoxLayout;
-  name_hbox_layout->addWidget(new QLabel("name:"));
-  name_combo_box = new QComboBox;
-  for (const auto& param_name : param_names)
-    name_combo_box->addItem(QString::fromStdString(param_name.first));
-  name_hbox_layout->addWidget(name_combo_box);
-
-  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
-  bottom_buttons_layout->addWidget(cancel_button);
-  bottom_buttons_layout->addWidget(ok_button);
-  connect(
-    ok_button, &QAbstractButton::clicked,
-    this, &AddParamDialog::ok_button_clicked);
-  connect(
-    cancel_button, &QAbstractButton::clicked,
-    this, &QDialog::reject);
-
-  QVBoxLayout* vbox_layout = new QVBoxLayout;
-  vbox_layout->addLayout(name_hbox_layout);
-  // todo: some sort of separator (?)
-  vbox_layout->addLayout(bottom_buttons_layout);
-
-  setLayout(vbox_layout);
-}
-
-AddParamDialog::~AddParamDialog()
-{
-}
-
-void AddParamDialog::ok_button_clicked()
-{
-  // todo: if this box becomes more complex in the future, validate it...
-  accept();
-}
-
-std::string AddParamDialog::get_param_name() const
-{
-  return name_combo_box->currentText().toStdString();
-}
-
-Param::Type AddParamDialog::get_param_type() const
-{
-  // loop through the allowed_params to find the name that is selected
-  // then return the type
-  for (const auto& param_name : param_names)
-  {
-    if (name_combo_box->currentText().toStdString() != param_name.first)
-      continue;
-    return param_name.second;
-  }
-  return Param::Type::UNDEFINED;
-}
diff --git a/traffic_editor/gui/add_param_dialog.h b/traffic_editor/gui/add_param_dialog.h
deleted file mode 100644
index 9eab2d1..0000000
--- a/traffic_editor/gui/add_param_dialog.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef ADD_PARAM_DIALOG_H
-#define ADD_PARAM_DIALOG_H
-
-#include <vector>
-#include <QDialog>
-#include "traffic_editor/param.h"
-class QComboBox;
-
-
-class AddParamDialog : public QDialog
-{
-public:
-  AddParamDialog(
-    QWidget* parent,
-    const std::vector<std::pair<std::string, Param::Type>>& param_names);
-  ~AddParamDialog();
-
-  std::string get_param_name() const;
-  Param::Type get_param_type() const;
-
-private:
-  QComboBox* name_combo_box;
-  QPushButton* ok_button, * cancel_button;
-  const std::vector<std::pair<std::string, Param::Type>>& param_names;
-
-private slots:
-  void ok_button_clicked();
-};
-
-#endif
diff --git a/traffic_editor/gui/building.cpp b/traffic_editor/gui/building.cpp
deleted file mode 100644
index 1f3e30f..0000000
--- a/traffic_editor/gui/building.cpp
+++ /dev/null
@@ -1,667 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-#include <fstream>
-#include <iostream>
-#include <memory>
-#include <yaml-cpp/yaml.h>
-
-#include <QFileInfo>
-#include <QDir>
-#include <QThread>
-#include <QtConcurrent/QtConcurrent>
-#include <QElapsedTimer>
-
-#include "traffic_editor/building.h"
-#include "yaml_utils.h"
-
-using std::string;
-using std::vector;
-using std::make_pair;
-using std::unique_ptr;
-using std::shared_ptr;
-
-
-Building::Building()
-: name("building")
-{
-}
-
-Building::~Building()
-{
-}
-
-/// Load a YAML file description of a building map
-///
-/// This function replaces the contents of this object with what is
-/// in the YAML file.
-bool Building::load_yaml_file()
-{
-  printf("Building::load_yaml_file(%s)\n", filename.c_str());
-  YAML::Node y;
-  try
-  {
-    y = YAML::LoadFile(filename.c_str());
-  }
-  catch (const std::exception& e)
-  {
-    printf("couldn't parse %s: %s", filename.c_str(), e.what());
-    return false;
-  }
-
-  // change directory to the path of the file, so that we can correctly open
-  // relative paths recorded in the file
-
-  // TODO: save previous directory and restore it when leaving this function
-  // in case the building file is in a different path from the project file
-  QString dir(QFileInfo(QString::fromStdString(filename)).absolutePath());
-  qDebug("changing directory to [%s]", qUtf8Printable(dir));
-  if (!QDir::setCurrent(dir))
-  {
-    printf("couldn't change directory\n");
-    return false;
-  }
-
-  if (y["name"])
-    name = y["name"].as<string>();
-
-  if (y["reference_level_name"])
-    reference_level_name = y["reference_level_name"].as<string>();
-
-  if (!y["levels"] || !y["levels"].IsMap())
-  {
-    printf("expected top-level dictionary named 'levels'");
-    return false;
-  }
-
-  levels.clear();
-  const YAML::Node yl = y["levels"];
-  for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
-  {
-    BuildingLevel level;
-    level.from_yaml(it->first.as<string>(), it->second);
-    levels.push_back(level);
-  }
-
-  QtConcurrent::blockingMap(
-    levels,
-    [&](auto& level) { level.load_drawing(); });
-
-  // now that all images are loaded, we can calculate scale for annotated
-  // measurement lanes
-  for (auto& level : levels)
-    level.calculate_scale();
-
-  lifts.clear();
-  if (y["lifts"] && y["lifts"].IsMap())
-  {
-    const YAML::Node& y_lifts = y["lifts"];
-    for (YAML::const_iterator it = y_lifts.begin(); it != y_lifts.end(); ++it)
-    {
-      Lift lift;
-      lift.from_yaml(it->first.as<string>(), it->second, levels);
-      lifts.push_back(lift);
-    }
-  }
-
-  calculate_all_transforms();
-  return true;
-}
-
-bool Building::save_yaml_file()
-{
-  printf("Building::save_yaml(%s)\n", filename.c_str());
-
-  YAML::Node y;
-  y["name"] = name;
-
-  if (!reference_level_name.empty())
-    y["reference_level_name"] = reference_level_name;
-
-  y["levels"] = YAML::Node(YAML::NodeType::Map);
-  for (const auto& level : levels)
-    y["levels"][level.name] = level.to_yaml();
-
-  y["lifts"] = YAML::Node(YAML::NodeType::Map);
-  for (const auto& lift : lifts)
-    y["lifts"][lift.name] = lift.to_yaml();
-
-  YAML::Emitter emitter;
-  yaml_utils::write_node(y, emitter);
-  std::ofstream fout(filename);
-  fout << emitter.c_str() << std::endl;
-
-  return true;
-}
-
-void Building::add_vertex(int level_index, double x, double y)
-{
-  if (level_index >= static_cast<int>(levels.size()))
-    return;
-  levels[level_index].add_vertex(x, y);
-}
-
-void Building::add_fiducial(int level_index, double x, double y)
-{
-  if (level_index >= static_cast<int>(levels.size()))
-    return;
-  levels[level_index].fiducials.push_back(Fiducial(x, y));
-}
-
-int Building::find_nearest_vertex_index(
-  int level_index,
-  double x,
-  double y,
-  double& distance)
-{
-  double min_dist = 1e100;
-  int min_index = -1;
-  for (size_t i = 0; i < levels[level_index].vertices.size(); i++)
-  {
-    const Vertex& v = levels[level_index].vertices[i];
-    const double dx = x - v.x;
-    const double dy = y - v.y;
-    const double dist2 = dx*dx + dy*dy;  // no need for sqrt each time
-    if (dist2 < min_dist)
-    {
-      min_dist = dist2;
-      min_index = i;
-    }
-  }
-  distance = sqrt(min_dist);
-  return min_index;  // will be -1 if vertices vector is empty
-}
-
-Building::NearestItem Building::nearest_items(
-  const int level_index,
-  const double x,
-  const double y)
-{
-  NearestItem ni;
-  if (level_index >= static_cast<int>(levels.size()))
-    return ni;
-  const BuildingLevel& level = levels[level_index];
-
-  for (size_t i = 0; i < level.vertices.size(); i++)
-  {
-    const Vertex& p = level.vertices[i];
-    const double dx = x - p.x;
-    const double dy = y - p.y;
-    const double dist = sqrt(dx*dx + dy*dy);
-    if (dist < ni.vertex_dist)
-    {
-      ni.vertex_dist = dist;
-      ni.vertex_idx = i;
-    }
-  }
-
-  for (size_t i = 0; i < level.fiducials.size(); i++)
-  {
-    const Fiducial& f = level.fiducials[i];
-    const double dx = x - f.x;
-    const double dy = y - f.y;
-    const double dist = sqrt(dx*dx + dy*dy);
-    if (dist < ni.fiducial_dist)
-    {
-      ni.fiducial_dist = dist;
-      ni.fiducial_idx = i;
-    }
-  }
-
-  for (size_t i = 0; i < level.models.size(); i++)
-  {
-    const Model& m = level.models[i];
-    const double dx = x - m.state.x;
-    const double dy = y - m.state.y;
-    const double dist = sqrt(dx*dx + dy*dy);  // no need for sqrt each time
-    if (dist < ni.model_dist)
-    {
-      ni.model_dist = dist;
-      ni.model_idx = i;
-    }
-  }
-
-  return ni;
-}
-
-int Building::nearest_item_index_if_within_distance(
-  const int level_index,
-  const double x,
-  const double y,
-  const double distance_threshold,
-  const ItemType item_type)
-{
-  if (level_index >= static_cast<int>(levels.size()))
-    return -1;
-
-  double min_dist = 1e100;
-  int min_index = -1;
-  if (item_type == VERTEX)
-  {
-    for (size_t i = 0; i < levels[level_index].vertices.size(); i++)
-    {
-      const Vertex& p = levels[level_index].vertices[i];
-      const double dx = x - p.x;
-      const double dy = y - p.y;
-      const double dist2 = dx*dx + dy*dy;  // no need for sqrt each time
-      if (dist2 < min_dist)
-      {
-        min_dist = dist2;
-        min_index = i;
-      }
-    }
-  }
-  else if (item_type == FIDUCIAL)
-  {
-    for (size_t i = 0; i < levels[level_index].fiducials.size(); i++)
-    {
-      const Fiducial& f = levels[level_index].fiducials[i];
-      const double dx = x - f.x;
-      const double dy = y - f.y;
-      const double dist2 = dx*dx + dy*dy;
-      if (dist2 < min_dist)
-      {
-        min_dist = dist2;
-        min_index = i;
-      }
-    }
-  }
-  else if (item_type == MODEL)
-  {
-    for (size_t i = 0; i < levels[level_index].models.size(); i++)
-    {
-      const Model& m = levels[level_index].models[i];
-      const double dx = x - m.state.x;
-      const double dy = y - m.state.y;
-      const double dist2 = dx*dx + dy*dy;  // no need for sqrt each time
-      if (dist2 < min_dist)
-      {
-        min_dist = dist2;
-        min_index = i;
-      }
-    }
-  }
-  if (sqrt(min_dist) < distance_threshold)
-    return min_index;
-  return -1;
-}
-
-void Building::add_edge(
-  const int level_index,
-  const int start_vertex_index,
-  const int end_vertex_index,
-  const Edge::Type edge_type)
-{
-  if (level_index >= static_cast<int>(levels.size()))
-    return;
-
-  printf("Building::add_edge(%d, %d, %d, %d)\n",
-    level_index,
-    start_vertex_index,
-    end_vertex_index,
-    static_cast<int>(edge_type));
-
-  levels[level_index].edges.push_back(
-    Edge(start_vertex_index, end_vertex_index, edge_type));
-}
-
-void Building::add_lane(
-  const int level_index,
-  const int start_vertex_index,
-  const int end_vertex_index,
-  const int graph_idx)
-{
-  if (level_index >= static_cast<int>(levels.size()))
-    return;
-
-  printf("Building::add_lane(%d, %d, %d, graph=%d)\n",
-    level_index,
-    start_vertex_index,
-    end_vertex_index,
-    graph_idx);
-  Edge e(start_vertex_index, end_vertex_index, Edge::LANE);
-  e.set_graph_idx(graph_idx);
-  levels[level_index].edges.push_back(e);
-}
-
-bool Building::delete_selected(const int level_index)
-{
-  if (level_index >= static_cast<int>(levels.size()))
-    return false;
-
-  printf("Building::delete_keypress()\n");
-  if (!levels[level_index].delete_selected())
-    return false;
-
-  return true;
-}
-
-void Building::add_model(
-  const int level_idx,
-  const double x,
-  const double y,
-  const double z,
-  const double yaw,
-  const std::string& model_name)
-{
-  if (level_idx >= static_cast<int>(levels.size()))
-    return;
-
-  printf("Building::add_model(%d, %.1f, %.1f, %.1f, %.2f, %s)\n",
-    level_idx, x, y, z, yaw, model_name.c_str());
-  Model m;
-  m.state.x = x;
-  m.state.y = y;
-  m.state.z = z;
-  m.state.yaw = yaw;
-  m.model_name = model_name;
-  m.instance_name = model_name;  // todo: add unique numeric suffix?
-  m.is_static = true;
-  levels[level_idx].models.push_back(m);
-}
-
-void Building::set_model_yaw(
-  const int level_idx,
-  const int model_idx,
-  const double yaw)
-{
-  if (level_idx >= static_cast<int>(levels.size()))
-    return;
-
-  levels[level_idx].models[model_idx].state.yaw = yaw;
-}
-
-void Building::clear()
-{
-  name.clear();
-  filename.clear();
-  reference_level_name.clear();
-  levels.clear();
-  lifts.clear();
-  clear_transform_cache();
-}
-
-void Building::add_level(const BuildingLevel& new_level)
-{
-  // make sure we don't have this level already
-  for (const auto& level : levels)
-  {
-    if (level.name == new_level.name)
-      return;
-  }
-  levels.push_back(new_level);
-}
-
-void Building::draw_lifts(QGraphicsScene* scene, const int level_idx)
-{
-  const BuildingLevel& level = levels[level_idx];
-  for (const auto& lift : lifts)
-  {
-    // find the level index referenced by the lift
-    int reference_floor_idx = -1;
-    for (size_t i = 0; i < levels.size(); i++)
-    {
-      if (levels[i].name == lift.reference_floor_name)
-      {
-        reference_floor_idx = static_cast<int>(i);
-        break;
-      }
-    }
-
-    Transform t;
-    if (reference_floor_idx >= 0)
-      t = get_transform(reference_floor_idx, level_idx);
-
-    lift.draw(
-      scene,
-      level.drawing_meters_per_pixel,
-      level.name,
-      level.elevation,
-      true,
-      t.scale,
-      t.dx,
-      t.dy);
-  }
-}
-
-bool Building::transform_between_levels(
-  const std::string& from_level_name,
-  const QPointF& from_point,
-  const std::string& to_level_name,
-  QPointF& to_point)
-{
-  int from_level_idx = -1;
-  int to_level_idx = -1;
-  for (size_t i = 0; i < levels.size(); i++)
-  {
-    if (levels[i].name == from_level_name)
-      from_level_idx = i;
-    if (levels[i].name == to_level_name)
-      to_level_idx = i;
-  }
-  if (from_level_idx < 0 || to_level_idx < 0)
-  {
-    to_point = from_point;
-    return false;
-  }
-  return transform_between_levels(
-    from_level_idx,
-    from_point,
-    to_level_idx,
-    to_point);
-}
-
-bool Building::transform_between_levels(
-  const int from_level_idx,
-  const QPointF& from_point,
-  const int to_level_idx,
-  QPointF& to_point)
-{
-
-  if (from_level_idx < 0 ||
-    from_level_idx >= static_cast<int>(levels.size()) ||
-    to_level_idx < 0 ||
-    to_level_idx >= static_cast<int>(levels.size()))
-  {
-    to_point = from_point;
-    return false;
-  }
-
-  const Transform t = get_transform(from_level_idx, to_level_idx);
-
-  to_point.rx() = t.scale * from_point.x() + t.dx;
-  to_point.ry() = t.scale * from_point.y() + t.dy;
-  return true;
-}
-
-void Building::clear_transform_cache()
-{
-  transforms.clear();
-}
-
-Building::Transform Building::compute_transform(
-  const int from_level_idx,
-  const int to_level_idx)
-{
-  // short-circuit if it's the same level
-  if (from_level_idx == to_level_idx)
-  {
-    Building::Transform t;
-    t.scale = 1.0;
-    t.dx = 0.0;
-    t.dy = 0.0;
-    return t;
-  }
-
-  // this internal function assumes that bounds checking has already happened
-  const BuildingLevel& from_level = levels[from_level_idx];
-  const BuildingLevel& to_level = levels[to_level_idx];
-
-  // assemble a vector of fudicials in common to these levels
-  vector<std::pair<Fiducial, Fiducial>> fiducials;
-  for (const Fiducial& f0 : from_level.fiducials)
-  {
-    for (const Fiducial& f1 : to_level.fiducials)
-    {
-      if (f0.name == f1.name)
-      {
-        fiducials.push_back(make_pair(f0, f1));
-        break;
-      }
-    }
-  }
-
-  // calculate the distances between each fiducial on their levels
-  vector<std::pair<double, double>> distances;
-  for (size_t f0_idx = 0; f0_idx < fiducials.size(); f0_idx++)
-  {
-    for (size_t f1_idx = f0_idx + 1; f1_idx < fiducials.size(); f1_idx++)
-    {
-      distances.push_back(
-        make_pair(
-          fiducials[f0_idx].first.distance(fiducials[f1_idx].first),
-          fiducials[f0_idx].second.distance(fiducials[f1_idx].second)));
-    }
-  }
-
-
-  // for now, we'll just compute the mean of the relative scale estimates.
-  // we can do fancier statistics later, if needed.
-  double relative_scale_sum = 0;
-  for (size_t i = 0; i < distances.size(); i++)
-    relative_scale_sum += distances[i].second / distances[i].first;
-  const double scale = relative_scale_sum / distances.size();
-
-  // scale the fiducials and estimate the "optimal" translation.
-  // for now, we'll just use the mean of the translation estimates.
-  double trans_x_sum = 0;
-  double trans_y_sum = 0;
-  for (const auto& fiducial : fiducials)
-  {
-    trans_x_sum += fiducial.second.x - fiducial.first.x * scale;
-    trans_y_sum += fiducial.second.y - fiducial.first.y * scale;
-  }
-  const double trans_x = trans_x_sum / fiducials.size();
-  const double trans_y = trans_y_sum / fiducials.size();
-
-  Building::Transform t;
-  t.scale = scale;
-  t.dx = trans_x;
-  t.dy = trans_y;
-
-  printf("transform %d->%d: scale = %.5f translation = (%.2f, %.2f)\n",
-    from_level_idx,
-    to_level_idx,
-    t.scale,
-    t.dx,
-    t.dy);
-
-  return t;
-}
-
-Building::Transform Building::get_transform(
-  const int from_level_idx,
-  const int to_level_idx)
-{
-  // this operation is a bit "heavy" so we'll cache the transformations
-  // as they are computed
-  LevelPair level_pair;
-  level_pair.from_idx = from_level_idx;
-  level_pair.to_idx = to_level_idx;
-
-  TransformMap::iterator transform_it = transforms.find(level_pair);
-  Transform t;
-
-  if (transform_it == transforms.end())
-  {
-    // the transform wasn't in the cache, so we need to compute it
-    t = compute_transform(from_level_idx, to_level_idx);
-    transforms[level_pair] = t;
-  }
-  else
-    t = transform_it->second;
-
-  return t;
-}
-
-void Building::calculate_all_transforms()
-{
-  if (levels.empty())
-    return;// let's not crash
-
-  clear_transform_cache();
-  for (size_t i = 0; i < levels.size(); i++)
-  {
-    for (size_t j = 0; j < levels.size(); j++)
-    {
-      get_transform(i, j);
-    }
-  }
-
-  // set drawing scale using this data
-  const int ref_idx = get_reference_level_idx();
-  const double ref_scale = levels[ref_idx].drawing_meters_per_pixel;
-  for (int i = 0; i < static_cast<int>(levels.size()); i++)
-  {
-    if (i != get_reference_level_idx())
-    {
-      Transform t = get_transform(ref_idx, i);
-      if (levels[i].fiducials.size() >= 2)
-        levels[i].drawing_meters_per_pixel = ref_scale / t.scale;
-    }
-  }
-}
-
-int Building::get_reference_level_idx()
-{
-  if (reference_level_name.empty())
-    return 0;
-  for (size_t i = 0; i < levels.size(); i++)
-  {
-    if (levels[i].name == reference_level_name)
-      return static_cast<int>(i);
-  }
-  return 0;
-}
-
-void Building::clear_scene()
-{
-  for (auto& level : levels)
-    level.clear_scene();
-}
-
-double Building::level_meters_per_pixel(const string& level_name) const
-{
-  for (const auto& level : levels)
-  {
-    if (level.name == level_name)
-      return level.drawing_meters_per_pixel;
-  }
-  return 0.05;  // just a somewhat sane default
-}
-
-void Building::rotate_all_models(const double rotation)
-{
-  for (auto& level : levels)
-  {
-    for (auto& model : level.models)
-    {
-      model.state.yaw += rotation;
-    }
-  }
-}
diff --git a/traffic_editor/gui/building_dialog.cpp b/traffic_editor/gui/building_dialog.cpp
deleted file mode 100644
index 74fad58..0000000
--- a/traffic_editor/gui/building_dialog.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "building_dialog.h"
-#include <QtWidgets>
-
-
-BuildingDialog::BuildingDialog(Building& building)
-: QDialog(), _building(building)
-{
-  setWindowTitle("Building Properties");
-  _ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  _cancel_button = new QPushButton("Cancel", this);
-
-  QHBoxLayout* building_name_hbox = new QHBoxLayout;
-  building_name_hbox->addWidget(new QLabel("Building name:"));
-  _building_name_line_edit = new QLineEdit(
-    QString::fromStdString(building.name),
-    this);
-  building_name_hbox->addWidget(_building_name_line_edit);
-
-  QHBoxLayout* reference_level_hbox = new QHBoxLayout;
-  reference_level_hbox->addWidget(new QLabel("Reference level:"));
-  _reference_floor_combo_box = new QComboBox;
-  for (const auto& level : building.levels)
-    _reference_floor_combo_box->addItem(QString::fromStdString(level.name));
-  if (!building.levels.empty() && !building.reference_level_name.empty())
-    _reference_floor_combo_box->setCurrentText(
-      QString::fromStdString(building.reference_level_name));
-  reference_level_hbox->addWidget(_reference_floor_combo_box);
-
-  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
-  bottom_buttons_hbox->addWidget(_cancel_button);
-  bottom_buttons_hbox->addWidget(_ok_button);
-  connect(
-    _ok_button, &QAbstractButton::clicked,
-    this, &BuildingDialog::ok_button_clicked);
-  connect(
-    _cancel_button, &QAbstractButton::clicked,
-    this, &QDialog::reject);
-
-  QVBoxLayout* top_vbox = new QVBoxLayout;
-
-  top_vbox->addLayout(building_name_hbox);
-  top_vbox->addLayout(reference_level_hbox);
-  // todo: some sort of separator (?)
-  top_vbox->addLayout(bottom_buttons_hbox);
-
-  setLayout(top_vbox);
-}
-
-BuildingDialog::~BuildingDialog()
-{
-}
-
-void BuildingDialog::ok_button_clicked()
-{
-  _building.name = _building_name_line_edit->text().toStdString();
-  _building.reference_level_name =
-    _reference_floor_combo_box->currentText().toStdString();
-  accept();
-}
diff --git a/traffic_editor/gui/building_dialog.h b/traffic_editor/gui/building_dialog.h
deleted file mode 100644
index a56b1a5..0000000
--- a/traffic_editor/gui/building_dialog.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_DIALOG_H
-#define BUILDING_DIALOG_H
-
-#include <QDialog>
-#include "traffic_editor/building.h"
-class QLineEdit;
-class QComboBox;
-
-
-class BuildingDialog : public QDialog
-{
-public:
-  BuildingDialog(Building& building);
-  ~BuildingDialog();
-
-private:
-  Building& _building;
-
-  QLineEdit* _building_name_line_edit;
-  QComboBox* _reference_floor_combo_box;
-  QPushButton* _ok_button, * _cancel_button;
-
-private slots:
-  void ok_button_clicked();
-};
-
-#endif
diff --git a/traffic_editor/gui/building_level.cpp b/traffic_editor/gui/building_level.cpp
deleted file mode 100644
index 38f56fe..0000000
--- a/traffic_editor/gui/building_level.cpp
+++ /dev/null
@@ -1,897 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-#include <cmath>
-
-#include <QGraphicsOpacityEffect>
-#include <QGraphicsPixmapItem>
-#include <QGraphicsScene>
-#include <QImage>
-#include <QImageReader>
-
-#include "traffic_editor/building_level.h"
-using std::string;
-using std::vector;
-
-
-BuildingLevel::BuildingLevel()
-: Level()
-{
-}
-
-BuildingLevel::~BuildingLevel()
-{
-}
-
-bool BuildingLevel::from_yaml(
-  const std::string& _name,
-  const YAML::Node& _data)
-{
-  printf("parsing level [%s]\n", _name.c_str());
-  name = _name;
-
-  if (!_data.IsMap())
-    throw std::runtime_error("level " + name + " YAML invalid");
-
-  if (_data["drawing"] && _data["drawing"].IsMap())
-  {
-    const YAML::Node& drawing_data = _data["drawing"];
-    if (!drawing_data["filename"])
-      throw std::runtime_error("level " + name + " drawing invalid");
-    drawing_filename = drawing_data["filename"].as<string>();
-    /*
-    if (!load_drawing())
-      return false;
-    */
-  }
-  else if (_data["x_meters"] && _data["y_meters"])
-  {
-    x_meters = _data["x_meters"].as<double>();
-    y_meters = _data["y_meters"].as<double>();
-    drawing_meters_per_pixel = 0.05;  // something reasonable
-    drawing_width = x_meters / drawing_meters_per_pixel;
-    drawing_height = y_meters / drawing_meters_per_pixel;
-  }
-  else
-  {
-    x_meters = 100.0;
-    y_meters = 100.0;
-    drawing_meters_per_pixel = 0.05;
-    drawing_width = x_meters / drawing_meters_per_pixel;
-    drawing_height = y_meters / drawing_meters_per_pixel;
-  }
-
-  parse_vertices(_data);
-
-  if (_data["fiducials"] && _data["fiducials"].IsSequence())
-  {
-    const YAML::Node& fy = _data["fiducials"];
-    for (YAML::const_iterator it = fy.begin(); it != fy.end(); ++it)
-    {
-      Fiducial f;
-      f.from_yaml(*it);
-      fiducials.push_back(f);
-    }
-  }
-
-  if (_data["flattened_x_offset"])
-    flattened_x_offset = _data["flattened_x_offset"].as<double>();
-  if (_data["flattened_y_offset"])
-    flattened_y_offset = _data["flattened_y_offset"].as<double>();
-
-  load_yaml_edge_sequence(_data, "lanes", Edge::LANE);
-  load_yaml_edge_sequence(_data, "walls", Edge::WALL);
-  load_yaml_edge_sequence(_data, "measurements", Edge::MEAS);
-  load_yaml_edge_sequence(_data, "doors", Edge::DOOR);
-
-  if (_data["models"] && _data["models"].IsSequence())
-  {
-    const YAML::Node& ys = _data["models"];
-    for (YAML::const_iterator it = ys.begin(); it != ys.end(); ++it)
-    {
-      Model m;
-      m.from_yaml(*it, this->name);
-      models.push_back(m);
-    }
-  }
-
-  if (_data["floors"] && _data["floors"].IsSequence())
-  {
-    const YAML::Node& yf = _data["floors"];
-    for (YAML::const_iterator it = yf.begin(); it != yf.end(); ++it)
-    {
-      Polygon p;
-      p.from_yaml(*it, Polygon::FLOOR);
-      polygons.push_back(p);
-    }
-  }
-
-  if (_data["holes"] && _data["holes"].IsSequence())
-  {
-    const YAML::Node& yf = _data["holes"];
-    for (YAML::const_iterator it = yf.begin(); it != yf.end(); ++it)
-    {
-      Polygon p;
-      p.from_yaml(*it, Polygon::HOLE);
-      polygons.push_back(p);
-    }
-  }
-
-  if (_data["elevation"])
-    elevation = _data["elevation"].as<double>();
-
-  if (_data["layers"] && _data["layers"].IsMap())
-  {
-    const YAML::Node& yl = _data["layers"];
-    for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
-    {
-      Layer layer;
-      layer.from_yaml(it->first.as<string>(), it->second);
-      layers.push_back(layer);
-    }
-  }
-
-  return true;
-}
-
-bool BuildingLevel::load_drawing()
-{
-  if (drawing_filename.empty())
-    return true;// nothing to load
-
-  printf("  level %s drawing: %s\n",
-    name.c_str(),
-    drawing_filename.c_str());
-
-  QString qfilename = QString::fromStdString(drawing_filename);
-
-  QImageReader image_reader(qfilename);
-  image_reader.setAutoTransform(true);
-  QImage image = image_reader.read();
-  if (image.isNull())
-  {
-    qWarning("unable to read %s: %s",
-      qUtf8Printable(qfilename),
-      qUtf8Printable(image_reader.errorString()));
-    return false;
-  }
-  image = image.convertToFormat(QImage::Format_Grayscale8);
-  floorplan_pixmap = QPixmap::fromImage(image);
-  drawing_width = floorplan_pixmap.width();
-  drawing_height = floorplan_pixmap.height();
-  return true;
-}
-
-YAML::Node BuildingLevel::to_yaml() const
-{
-  YAML::Node y;
-  if (!drawing_filename.empty())
-  {
-    YAML::Node drawing_node;
-    drawing_node["filename"] = drawing_filename;
-    y["drawing"] = drawing_node;
-  }
-  else
-  {
-    y["x_meters"] = x_meters;
-    y["y_meters"] = y_meters;
-  }
-  y["elevation"] = elevation;
-  y["flattened_x_offset"] = flattened_x_offset;
-  y["flattened_y_offset"] = flattened_y_offset;
-
-  for (const auto& v : vertices)
-    y["vertices"].push_back(v.to_yaml());
-
-  for (const auto& f : fiducials)
-    y["fiducials"].push_back(f.to_yaml());
-
-  for (const auto& edge : edges)
-  {
-    YAML::Node n(edge.to_yaml());
-    std::string dict_name = "unknown";
-    switch (edge.type)
-    {
-      case Edge::LANE:
-        dict_name = "lanes";
-        break;
-      case Edge::WALL:
-        dict_name = "walls";
-        break;
-      case Edge::MEAS:
-        dict_name = "measurements";
-        break;
-      case Edge::DOOR:
-        dict_name = "doors";
-        break;
-      default:
-        printf("tried to save unknown edge type: %d\n",
-          static_cast<int>(edge.type));
-        break;
-    }
-    y[dict_name].push_back(n);
-  }
-
-  for (const auto& model : models)
-    y["models"].push_back(model.to_yaml());
-
-  for (const auto& polygon : polygons)
-  {
-    switch (polygon.type)
-    {
-      case Polygon::FLOOR:
-        y["floors"].push_back(polygon.to_yaml());
-        break;
-      case Polygon::HOLE:
-        y["holes"].push_back(polygon.to_yaml());
-        break;
-      default:
-        printf("tried to save an unknown polygon type: %d\n",
-          static_cast<int>(polygon.type));
-        break;
-    }
-  }
-
-  y["layers"] = YAML::Node(YAML::NodeType::Map);
-  for (const auto& layer : layers)
-    y["layers"][layer.name] = layer.to_yaml();
-
-  return y;
-}
-
-bool BuildingLevel::delete_selected()
-{
-  edges.erase(
-    std::remove_if(
-      edges.begin(),
-      edges.end(),
-      [](const Edge& edge) { return edge.selected; }),
-    edges.end());
-
-  models.erase(
-    std::remove_if(
-      models.begin(),
-      models.end(),
-      [](const auto& model) { return model.selected; }),
-    models.end());
-
-  fiducials.erase(
-    std::remove_if(
-      fiducials.begin(),
-      fiducials.end(),
-      [](const Fiducial& fiducial) { return fiducial.selected; }),
-    fiducials.end());
-
-  polygons.erase(
-    std::remove_if(
-      polygons.begin(),
-      polygons.end(),
-      [](const Polygon& polygon) { return polygon.selected; }),
-    polygons.end());
-
-  // Vertices take a lot more care, because we have to check if a vertex
-  // is used in an edge or a polygon before deleting it, and update all
-  // higher-index vertex indices in the edges and polygon vertex lists.
-  // Since this is a potentially expensive operation, first we'll spin
-  // through the vertex list and see if any vertices are selected, and
-  // only then make a copy of the vertex list.
-  int selected_vertex_idx = -1;
-  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
-  {
-    if (vertices[i].selected)
-    {
-      selected_vertex_idx = i;
-      break;  // just grab the index of the first selected vertex
-    }
-  }
-  if (selected_vertex_idx >= 0)
-  {
-    // See if this vertex is used in any edges/polygons.
-    bool vertex_used = false;
-    for (const auto& edge : edges)
-    {
-      if (edge.start_idx == selected_vertex_idx ||
-        edge.end_idx == selected_vertex_idx)
-        vertex_used = true;
-    }
-    for (const auto& polygon : polygons)
-    {
-      for (const int& vertex_idx : polygon.vertices)
-      {
-        if (vertex_idx == selected_vertex_idx)
-          vertex_used = true;
-      }
-    }
-    if (vertex_used)
-      return false;// don't try to delete a vertex used in a shape
-
-    // the vertex is not currently being used, so let's erase it
-    vertices.erase(vertices.begin() + selected_vertex_idx);
-
-    // now go through all edges and polygons to decrement any larger indices
-    for (Edge& edge : edges)
-    {
-      if (edge.start_idx > selected_vertex_idx)
-        edge.start_idx--;
-      if (edge.end_idx > selected_vertex_idx)
-        edge.end_idx--;
-    }
-
-    for (Polygon& polygon : polygons)
-    {
-      for (int i = 0; i < static_cast<int>(polygon.vertices.size()); i++)
-      {
-        if (polygon.vertices[i] > selected_vertex_idx)
-          polygon.vertices[i]--;
-      }
-    }
-  }
-  return true;
-}
-
-void BuildingLevel::calculate_scale()
-{
-  // for now, just calculate the mean of the scale estimates
-  double scale_sum = 0.0;
-  int scale_count = 0;
-
-  for (auto& edge : edges)
-  {
-    if (edge.type == Edge::MEAS)
-    {
-      scale_count++;
-      const double dx = vertices[edge.start_idx].x - vertices[edge.end_idx].x;
-      const double dy = vertices[edge.start_idx].y - vertices[edge.end_idx].y;
-      const double distance_pixels = std::sqrt(dx*dx + dy*dy);
-      // todo: a clean, strongly-typed parameter API for edges
-      const double distance_meters =
-        edge.params[std::string("distance")].value_double;
-      scale_sum += distance_meters / distance_pixels;
-    }
-  }
-
-  if (scale_count > 0)
-  {
-    drawing_meters_per_pixel = scale_sum / static_cast<double>(scale_count);
-    printf("used %d measurements to estimate meters/pixel as %.5f\n",
-      scale_count, drawing_meters_per_pixel);
-  }
-  else
-    drawing_meters_per_pixel = 0.05;// default to something reasonable
-
-  if (drawing_width && drawing_height && drawing_meters_per_pixel > 0.0)
-  {
-    x_meters = drawing_width * drawing_meters_per_pixel;
-    y_meters = drawing_height * drawing_meters_per_pixel;
-  }
-}
-
-// todo: migrate this to the TrafficMap class eventually
-void BuildingLevel::draw_lane(
-  QGraphicsScene* scene,
-  const Edge& edge,
-  const RenderingOptions& opts) const
-{
-  const int graph_idx = edge.get_graph_idx();
-  if (graph_idx >= 0 &&
-    graph_idx < static_cast<int>(opts.show_building_lanes.size()) &&
-    !opts.show_building_lanes[graph_idx])
-    return;// don't render this lane
-
-  const auto& v_start = vertices[edge.start_idx];
-  const auto& v_end = vertices[edge.end_idx];
-  const double dx = v_end.x - v_start.x;
-  const double dy = v_end.y - v_start.y;
-  const double len = std::sqrt(dx*dx + dy*dy);
-
-  const double lane_pen_width = 1.0 / drawing_meters_per_pixel;
-
-  const QPen arrow_pen(
-    QBrush(QColor::fromRgbF(0.0, 0.0, 0.0, 0.5)),
-    lane_pen_width / 8);
-
-  // dimensions for the direction indicators along this path
-  const double arrow_w = lane_pen_width / 2.5;  // width of arrowheads
-  const double arrow_l = lane_pen_width / 2.5;  // length of arrowheads
-  const double arrow_spacing = lane_pen_width / 2.0;
-
-  const double norm_x = dx / len;
-  const double norm_y = dy / len;
-
-  // only draw arrows if it's a unidirectional lane. We used to draw
-  // arrows in both directions for bidirectional, but it was messy.
-
-  if (!edge.is_bidirectional())
-  {
-    for (double d = 0.0; d < len; d += arrow_spacing)
-    {
-      // first calculate the center vertex of this arrowhead
-      const double cx = v_start.x + d * norm_x;
-      const double cy = v_start.y + d * norm_y;
-      // one edge vertex of arrowhead
-      const double e1x = cx - arrow_w * norm_y;
-      const double e1y = cy + arrow_w * norm_x;
-      // another edge vertex of arrowhead
-      const double e2x = cx + arrow_w * norm_y;
-      const double e2y = cy - arrow_w * norm_x;
-      // tip of arrowhead
-      const double tx = cx + arrow_l * norm_x;
-      const double ty = cy + arrow_l * norm_y;
-      // now add arrowhead lines
-      scene->addLine(e1x, e1y, tx, ty, arrow_pen);
-      scene->addLine(e2x, e2y, tx, ty, arrow_pen);
-    }
-  }
-
-  QColor color;
-  switch (edge.get_graph_idx())
-  {
-    case 0: color.setRgbF(0.0, 0.5, 0.0); break;
-    case 1: color.setRgbF(0.0, 0.0, 0.5); break;
-    case 2: color.setRgbF(0.0, 0.5, 0.5); break;
-    case 3: color.setRgbF(0.5, 0.5, 0.0); break;
-    case 4: color.setRgbF(0.5, 0.0, 0.5); break;
-    case 5: color.setRgbF(0.8, 0.0, 0.0); break;
-    default: break;  // will render as dark grey
-  }
-
-  // always draw lane as red if it's selected
-  if (edge.selected)
-    color.setRgbF(0.5, 0.0, 0.0);
-
-  // always draw lanes somewhat transparent
-  color.setAlphaF(0.5);
-
-  QGraphicsLineItem* lane_item = scene->addLine(
-    v_start.x, v_start.y,
-    v_end.x, v_end.y,
-    QPen(QBrush(color), lane_pen_width, Qt::SolidLine, Qt::RoundCap));
-  lane_item->setZValue(edge.get_graph_idx() + 1.0);
-
-  // draw the orientation icon, if specified
-  auto orientation_it = edge.params.find("orientation");
-  if (orientation_it != edge.params.end())
-  {
-    // draw robot-outline box midway down this lane
-    const double mx = (v_start.x + v_end.x) / 2.0;
-    const double my = (v_start.y + v_end.y) / 2.0;
-    const double yaw = std::atan2(norm_y, norm_x);
-
-    // robot-box half-dimensions in meters
-    const double rw = 0.4 / drawing_meters_per_pixel;
-    const double rl = 0.5 / drawing_meters_per_pixel;
-
-    // calculate the corners of the 'robot' box
-
-    // front-left
-    // |mx| + |cos -sin| | rl|
-    // |my|   |sin  cos| | rw|
-    const double flx = mx + rl * std::cos(yaw) - rw * std::sin(yaw);
-    const double fly = my + rl * std::sin(yaw) + rw * std::cos(yaw);
-
-    // front-right
-    // |mx| + |cos -sin| | rl|
-    // |my|   |sin  cos| |-rw|
-    const double frx = mx + rl * std::cos(yaw) + rw * std::sin(yaw);
-    const double fry = my + rl * std::sin(yaw) - rw * std::cos(yaw);
-
-    // back-left
-    // |mx| + |cos -sin| |-rl|
-    // |my|   |sin  cos| | rw|
-    const double blx = mx - rl * std::cos(yaw) - rw * std::sin(yaw);
-    const double bly = my - rl * std::sin(yaw) + rw * std::cos(yaw);
-
-    // back-right
-    // |mx| + |cos -sin| |-rl|
-    // |my|   |sin  cos| |-rw|
-    const double brx = mx - rl * std::cos(yaw) + rw * std::sin(yaw);
-    const double bry = my - rl * std::sin(yaw) - rw * std::cos(yaw);
-
-    QPainterPath pp;
-    pp.moveTo(QPointF(flx, fly));
-    pp.lineTo(QPointF(frx, fry));
-    pp.lineTo(QPointF(brx, bry));
-    pp.lineTo(QPointF(blx, bly));
-    pp.lineTo(QPointF(flx, fly));
-    pp.moveTo(QPointF(mx, my));
-
-    QPen orientation_pen(Qt::white, 5.0);
-    if (orientation_it->second.value_string == "forward")
-    {
-      const double hix = mx + 1.0 * cos(yaw) / drawing_meters_per_pixel;
-      const double hiy = my + 1.0 * sin(yaw) / drawing_meters_per_pixel;
-      pp.lineTo(QPointF(hix, hiy));
-      scene->addPath(pp, orientation_pen);
-    }
-    else if (orientation_it->second.value_string == "backward")
-    {
-      const double hix = mx - 1.0 * cos(yaw) / drawing_meters_per_pixel;
-      const double hiy = my - 1.0 * sin(yaw) / drawing_meters_per_pixel;
-      pp.lineTo(QPointF(hix, hiy));
-      scene->addPath(pp, orientation_pen);
-    }
-  }
-}
-
-void BuildingLevel::draw_wall(QGraphicsScene* scene, const Edge& edge) const
-{
-  const auto& v_start = vertices[edge.start_idx];
-  const auto& v_end = vertices[edge.end_idx];
-
-  const double r = edge.selected ? 0.5 : 0.0;
-  const double b = edge.selected ? 0.0 : 0.5;
-
-  scene->addLine(
-    v_start.x, v_start.y,
-    v_end.x, v_end.y,
-    QPen(
-      QBrush(QColor::fromRgbF(r, 0.0, b, 0.5)),
-      0.2 / drawing_meters_per_pixel,
-      Qt::SolidLine, Qt::RoundCap));
-}
-
-void BuildingLevel::draw_meas(QGraphicsScene* scene, const Edge& edge) const
-{
-  const auto& v_start = vertices[edge.start_idx];
-  const auto& v_end = vertices[edge.end_idx];
-  const double b = edge.selected ? 0.0 : 0.5;
-
-  scene->addLine(
-    v_start.x, v_start.y,
-    v_end.x, v_end.y,
-    QPen(
-      QBrush(QColor::fromRgbF(0.5, 0, b, 0.5)),
-      0.5 / drawing_meters_per_pixel,
-      Qt::SolidLine, Qt::RoundCap));
-}
-
-void BuildingLevel::draw_door(QGraphicsScene* scene, const Edge& edge) const
-{
-  const auto& v_start = vertices[edge.start_idx];
-  const auto& v_end = vertices[edge.end_idx];
-  const double g = edge.selected ? 1.0 : 0.0;
-  const double door_thickness = 0.2;  // meters
-  const double door_motion_thickness = 0.05;  // meters
-
-  auto door_axis_it = edge.params.find("motion_axis");
-  std::string door_axis("start");
-  if (door_axis_it != edge.params.end())
-    door_axis = door_axis_it->second.value_string;
-
-  double motion_degrees = 90;
-  auto motion_degrees_it = edge.params.find("motion_degrees");
-  if (motion_degrees_it != edge.params.end())
-    motion_degrees = std::abs(motion_degrees_it->second.value_double);
-
-  int motion_dir = 1;
-  auto motion_dir_it = edge.params.find("motion_direction");
-  if (motion_dir_it != edge.params.end())
-    motion_dir = motion_dir_it->second.value_int;
-
-  QPainterPath door_motion_path;
-
-  const double door_dx = v_end.x - v_start.x;
-  const double door_dy = v_end.y - v_start.y;
-  const double door_length = std::sqrt(door_dx * door_dx + door_dy * door_dy);
-  const double door_angle = std::atan2(door_dy, door_dx);
-
-  auto door_type_it = edge.params.find("type");
-  if (door_type_it != edge.params.end())
-  {
-    const double DEG2RAD = M_PI / 180.0;
-
-    const std::string& door_type = door_type_it->second.value_string;
-    if (door_type == "hinged")
-    {
-      const double hinge_x = door_axis == "start" ? v_start.x : v_end.x;
-      const double hinge_y = door_axis == "start" ? v_start.y : v_end.y;
-      const double angle_offset = door_axis == "start" ? 0.0 : M_PI;
-
-      add_door_swing_path(
-        door_motion_path,
-        hinge_x,
-        hinge_y,
-        door_length,
-        door_angle + angle_offset,
-        door_angle + angle_offset + DEG2RAD * motion_dir * motion_degrees);
-    }
-    else if (door_type == "double_hinged")
-    {
-      // each door section is half as long as door_length
-      add_door_swing_path(
-        door_motion_path,
-        v_start.x,
-        v_start.y,
-        door_length / 2,
-        door_angle,
-        door_angle + DEG2RAD * motion_dir * motion_degrees);
-
-      add_door_swing_path(
-        door_motion_path,
-        v_end.x,
-        v_end.y,
-        door_length / 2,
-        door_angle + M_PI,
-        door_angle + M_PI - DEG2RAD * motion_dir * motion_degrees);
-    }
-    else if (door_type == "sliding")
-    {
-      add_door_slide_path(
-        door_motion_path,
-        v_start.x,
-        v_start.y,
-        door_length,
-        door_angle);
-    }
-    else if (door_type == "double_sliding")
-    {
-      // each door section is half as long as door_length
-      add_door_slide_path(
-        door_motion_path,
-        v_start.x,
-        v_start.y,
-        door_length / 2,
-        door_angle);
-      add_door_slide_path(
-        door_motion_path,
-        v_end.x,
-        v_end.y,
-        door_length / 2,
-        door_angle + M_PI);
-    }
-    else
-    {
-      printf("tried to draw unknown door type: [%s]\n", door_type.c_str());
-    }
-  }
-  scene->addPath(
-    door_motion_path,
-    QPen(Qt::black, door_motion_thickness / drawing_meters_per_pixel));
-
-  // add the doorjamb last, so it sits on top of the Z stack of the travel arc
-  scene->addLine(
-    v_start.x, v_start.y,
-    v_end.x, v_end.y,
-    QPen(
-      QBrush(QColor::fromRgbF(1.0, g, 0.0, 0.5)),
-      door_thickness / drawing_meters_per_pixel,
-      Qt::SolidLine, Qt::RoundCap));
-}
-
-void BuildingLevel::add_door_slide_path(
-  QPainterPath& path,
-  double hinge_x,
-  double hinge_y,
-  double door_length,
-  double door_angle) const
-{
-  // first draw the door as a thin line
-  path.moveTo(hinge_x, hinge_y);
-  path.lineTo(
-    hinge_x + door_length * std::cos(door_angle),
-    hinge_y + door_length * std::sin(door_angle));
-
-  // now draw a box around where it slides (in the wall, usually)
-  const double th = door_angle;  // makes expressions below single-line...
-  const double pi_2 = M_PI / 2.0;
-  const double s = 0.15 / drawing_meters_per_pixel;  // sliding panel thickness
-
-  const QPointF p1(
-    hinge_x - s * std::cos(th + pi_2),
-    hinge_y - s * std::sin(th + pi_2));
-
-  const QPointF p2(
-    hinge_x - s * std::cos(th + pi_2) - door_length * std::cos(th),
-    hinge_y - s * std::sin(th + pi_2) - door_length * std::sin(th));
-
-  const QPointF p3(
-    hinge_x + s * std::cos(th + pi_2) - door_length * std::cos(th),
-    hinge_y + s * std::sin(th + pi_2) - door_length * std::sin(th));
-
-  const QPointF p4(
-    hinge_x + s * std::cos(th + pi_2),
-    hinge_y + s * std::sin(th + pi_2));
-
-
-  path.moveTo(p1);
-  path.lineTo(p2);
-  path.lineTo(p3);
-  path.lineTo(p4);
-  path.lineTo(p1);
-}
-
-void BuildingLevel::add_door_swing_path(
-  QPainterPath& path,
-  double hinge_x,
-  double hinge_y,
-  double door_length,
-  double start_angle,
-  double end_angle) const
-{
-  path.moveTo(hinge_x, hinge_y);
-  path.lineTo(
-    hinge_x + door_length * std::cos(start_angle),
-    hinge_y + door_length * std::sin(start_angle));
-
-  const int NUM_MOTION_STEPS = 10;
-  const double angle_inc = (end_angle - start_angle) / (NUM_MOTION_STEPS-1);
-  for (int i = 0; i < NUM_MOTION_STEPS; i++)
-  {
-    // compute door opening angle at this motion step
-    const double a = start_angle + i * angle_inc;
-
-    path.lineTo(
-      hinge_x + door_length * std::cos(a),
-      hinge_y + door_length * std::sin(a));
-  }
-
-  path.lineTo(hinge_x, hinge_y);
-}
-
-void BuildingLevel::draw_polygon(
-  QGraphicsScene* scene,
-  const QBrush& brush,
-  const Polygon& polygon) const
-{
-  QBrush selected_brush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5));
-
-  QVector<QPointF> polygon_vertices;
-  for (const auto& vertex_idx: polygon.vertices)
-  {
-    const Vertex& v = vertices[vertex_idx];
-    polygon_vertices.append(QPointF(v.x, v.y));
-  }
-
-  scene->addPolygon(
-    QPolygonF(polygon_vertices),
-    QPen(Qt::black),
-    polygon.selected ? selected_brush : brush);
-}
-
-void BuildingLevel::draw_polygons(QGraphicsScene* scene) const
-{
-  const QBrush floor_brush(QColor::fromRgbF(0.9, 0.9, 0.9, 0.8));
-  const QBrush hole_brush(QColor::fromRgbF(0.3, 0.3, 0.3, 0.5));
-
-  // first draw the floor polygons
-  for (const auto& polygon : polygons)
-  {
-    if (polygon.type == Polygon::FLOOR)
-      draw_polygon(scene, floor_brush, polygon);
-  }
-
-  // now draw the holes
-  for (const auto& polygon : polygons)
-  {
-    if (polygon.type == Polygon::HOLE)
-      draw_polygon(scene, hole_brush, polygon);
-  }
-
-#if 0
-  // ahhhhh only for debugging...
-  // plot the nearest projection point to a polygon, if it's set
-  // to something nonzero
-  if (level->polygon_edge_proj_x != 0)
-  {
-    const double r = 5.0;
-    addEllipse(
-      polygon_edge_proj_x - r,
-      polygon_edge_proj_y - r,
-      2 * r,
-      2 * r,
-      QPen(Qt::black),
-      QBrush(Qt::blue));
-  }
-#endif
-}
-
-void BuildingLevel::clear_selection()
-{
-  for (auto& vertex : vertices)
-    vertex.selected = false;
-
-  for (auto& edge : edges)
-    edge.selected = false;
-
-  for (auto& model : models)
-    model.selected = false;
-
-  for (auto& polygon : polygons)
-    polygon.selected = false;
-
-  for (auto& fiducial : fiducials)
-    fiducial.selected = false;
-}
-
-void BuildingLevel::draw(
-  QGraphicsScene* scene,
-  vector<EditorModel>& editor_models,
-  const RenderingOptions& rendering_options)
-{
-  if (drawing_filename.size())
-  {
-    scene->setSceneRect(
-      QRectF(0, 0, drawing_width, drawing_height));
-    scene->addPixmap(floorplan_pixmap);
-  }
-  else
-  {
-    const double w = x_meters / drawing_meters_per_pixel;
-    const double h = y_meters / drawing_meters_per_pixel;
-    scene->setSceneRect(QRectF(0, 0, w, h));
-    scene->addRect(0, 0, w, h, QPen(), Qt::white);
-  }
-
-  draw_polygons(scene);
-
-  for (const auto& layer : layers)
-  {
-    if (!layer.visible)
-      continue;
-
-    //printf("floorplan height: %d\n", level.floorplan_pixmap.height());
-    //printf("layer pixmap height: %d\n", layer.pixmap.height());
-    QGraphicsPixmapItem* item = scene->addPixmap(layer.pixmap);
-    // set the origin of the pixmap frame to the lower-left corner
-    item->setOffset(0, -layer.pixmap.height());
-    item->setPos(
-      -layer.translation_x / drawing_meters_per_pixel,
-      layer.translation_y / drawing_meters_per_pixel);
-    item->setScale(layer.meters_per_pixel / drawing_meters_per_pixel);
-    item->setRotation(-1.0 * layer.rotation * 180.0 / M_PI);
-    QGraphicsOpacityEffect* opacity_effect = new QGraphicsOpacityEffect;
-    opacity_effect->setOpacity(0.5);
-    item->setGraphicsEffect(opacity_effect);
-  }
-
-  if (rendering_options.show_models)
-  {
-    for (Model& model : models)
-      model.draw(scene, editor_models, drawing_meters_per_pixel);
-  }
-
-  for (const auto& edge : edges)
-  {
-    switch (edge.type)
-    {
-      case Edge::LANE: draw_lane(scene, edge, rendering_options); break;
-      case Edge::WALL: draw_wall(scene, edge); break;
-      case Edge::MEAS: draw_meas(scene, edge); break;
-      case Edge::DOOR: draw_door(scene, edge); break;
-      default:
-        printf("tried to draw unknown edge type: %d\n",
-          static_cast<int>(edge.type));
-        break;
-    }
-  }
-
-  for (const auto& v : vertices)
-    v.draw(
-      scene,
-      vertex_radius / drawing_meters_per_pixel,
-      QColor::fromRgbF(0.0, 0.5, 0.0));
-
-  for (const auto& f : fiducials)
-    f.draw(scene, drawing_meters_per_pixel);
-}
-
-void BuildingLevel::clear_scene()
-{
-  for (auto& model : models)
-    model.clear_scene();
-}
diff --git a/traffic_editor/gui/building_level_dialog.cpp b/traffic_editor/gui/building_level_dialog.cpp
deleted file mode 100644
index 6cda2c5..0000000
--- a/traffic_editor/gui/building_level_dialog.cpp
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "building_level_dialog.h"
-#include <QtWidgets>
-
-
-BuildingLevelDialog::BuildingLevelDialog(BuildingLevel& _level,
-  Building& _building)
-: building_level(_level), building(_building)
-{
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  cancel_button = new QPushButton("Cancel", this);
-
-  name_line_edit = new QLineEdit(
-    QString::fromStdString(building_level.name), this);
-  QHBoxLayout* name_hbox = new QHBoxLayout;
-  name_hbox->addWidget(new QLabel("name:"));
-  name_hbox->addWidget(name_line_edit);
-
-  elevation_line_edit = new QLineEdit(
-    QString::number(building_level.elevation));
-  QHBoxLayout* elevation_hbox = new QHBoxLayout;
-  elevation_hbox->addWidget(new QLabel("elevation:"));
-  elevation_hbox->addWidget(elevation_line_edit);
-
-  drawing_filename_line_edit = new QLineEdit(
-    QString::fromStdString(building_level.drawing_filename),
-    this);
-  drawing_filename_button = new QPushButton("Find...", this);
-  QHBoxLayout* drawing_filename_hbox = new QHBoxLayout;
-  drawing_filename_hbox->addWidget(new QLabel("drawing:"));
-  drawing_filename_hbox->addWidget(drawing_filename_line_edit);
-  drawing_filename_hbox->addWidget(drawing_filename_button);
-  connect(
-    drawing_filename_button,
-    &QAbstractButton::clicked,
-    this,
-    &BuildingLevelDialog::drawing_filename_button_clicked);
-  connect(
-    drawing_filename_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &BuildingLevelDialog::drawing_filename_line_edited);
-
-  QHBoxLayout* instr_hbox = new QHBoxLayout;
-  instr_hbox->addWidget(
-    new QLabel(
-      "Explicit dimensions are only needed if drawing is not provided:"));
-
-  QHBoxLayout* x_hbox = new QHBoxLayout;
-  x_line_edit = new QLineEdit(QString::number(building_level.x_meters), this);
-  x_hbox->addWidget(new QLabel("x dimension (meters):"));
-  x_hbox->addWidget(x_line_edit);
-
-  QHBoxLayout* y_hbox = new QHBoxLayout;
-  y_line_edit = new QLineEdit(QString::number(building_level.y_meters), this);
-  y_hbox->addWidget(new QLabel("y dimension (meters):"));
-  y_hbox->addWidget(y_line_edit);
-
-  flattened_x_offset_line_edit =
-    new QLineEdit(QString::number(building_level.flattened_x_offset));
-  QHBoxLayout* flattened_x_offset_hbox = new QHBoxLayout;
-  flattened_x_offset_hbox->addWidget(
-    new QLabel("flattened x offset (meters)"));
-  flattened_x_offset_hbox->addWidget(flattened_x_offset_line_edit);
-
-  flattened_y_offset_line_edit =
-    new QLineEdit(QString::number(building_level.flattened_y_offset));
-  QHBoxLayout* flattened_y_offset_hbox = new QHBoxLayout;
-  flattened_y_offset_hbox->addWidget(
-    new QLabel("flattened y offset (meters)"));
-  flattened_y_offset_hbox->addWidget(flattened_y_offset_line_edit);
-
-  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
-  bottom_buttons_hbox->addWidget(cancel_button);
-  bottom_buttons_hbox->addWidget(ok_button);
-  connect(
-    ok_button,
-    &QAbstractButton::clicked,
-    this,
-    &BuildingLevelDialog::ok_button_clicked);
-  connect(
-    cancel_button,
-    &QAbstractButton::clicked,
-    this,
-    &QDialog::reject);
-
-  QVBoxLayout* top_vbox = new QVBoxLayout;
-  top_vbox->addLayout(name_hbox);
-  top_vbox->addLayout(elevation_hbox);
-  top_vbox->addLayout(drawing_filename_hbox);
-  top_vbox->addLayout(instr_hbox);
-  top_vbox->addLayout(x_hbox);
-  top_vbox->addLayout(y_hbox);
-  top_vbox->addLayout(flattened_x_offset_hbox);
-  top_vbox->addLayout(flattened_y_offset_hbox);
-  // todo: some sort of separator (?)
-  top_vbox->addLayout(bottom_buttons_hbox);
-
-  setLayout(top_vbox);
-
-  enable_dimensions(building_level.drawing_filename.empty());
-}
-
-BuildingLevelDialog::~BuildingLevelDialog()
-{
-}
-
-void BuildingLevelDialog::drawing_filename_button_clicked()
-{
-  QFileDialog file_dialog(this, "Find Drawing");
-  file_dialog.setFileMode(QFileDialog::ExistingFile);
-  file_dialog.setNameFilter("*.png");
-  if (file_dialog.exec() != QDialog::Accepted)
-  {
-    if (drawing_filename_line_edit->text().isEmpty())
-      enable_dimensions(true);
-    return;  // user clicked 'cancel'
-  }
-  const QString filename = file_dialog.selectedFiles().first();
-  if (!QFileInfo(filename).exists())
-  {
-    QMessageBox::critical(
-      this,
-      "Drawing file does not exist",
-      "File does not exist.");
-    if (drawing_filename_line_edit->text().isEmpty())
-      enable_dimensions(true);
-    return;
-  }
-  drawing_filename_line_edit->setText(
-    QDir::current().relativeFilePath(filename));
-  enable_dimensions(false);
-}
-
-void BuildingLevelDialog::ok_button_clicked()
-{
-  if (!drawing_filename_line_edit->text().isEmpty())
-  {
-    // make sure the drawing file exists
-    if (!QFileInfo(drawing_filename_line_edit->text()).exists())
-    {
-      QMessageBox::critical(
-        this,
-        "If supplied, drawing filename must exist",
-        "If supplied, drawing filename must exist");
-      return;
-    }
-  }
-  /*
-  // todo: figure out how to test for valid numeric values;
-  // this doesn't work but there must be a similar function somewhere
-  if (!x_line_edit->text().isNumber() || !y_line_edit->text().isNumber()) {
-    QMessageBox::critical(
-        this,
-        "X and Y dimensions must be numbers",
-        "X and Y dimensions must be numbers");
-    return;
-  }
-  */
-  if (name_line_edit->text().isEmpty())
-  {
-    QMessageBox::critical(
-      this,
-      "Name must not be empty",
-      "Name must not be empty");
-    return;
-  }
-  auto original_name = building_level.name;
-  building_level.name = name_line_edit->text().toStdString();
-  building_level.elevation = elevation_line_edit->text().toDouble();
-  for (size_t i = 0; i < building.lifts.size(); i ++)
-  {
-    if (original_name != building_level.name)
-    {
-      if (building.lifts[i].level_doors.find(original_name) !=
-        building.lifts[i].level_doors.end())
-      {
-        building.lifts[i].level_doors[building_level.name] =
-          building.lifts[i].level_doors[original_name];
-        building.lifts[i].level_doors.erase(original_name);
-      }
-    }
-    if (building.lifts[i].highest_floor == original_name)
-    {
-      building.lifts[i].highest_floor = building_level.name;
-      building.lifts[i].highest_elevation = building_level.elevation;
-    }
-    if (building.lifts[i].lowest_floor == original_name)
-    {
-      building.lifts[i].lowest_floor = building_level.name;
-      building.lifts[i].lowest_elevation = building_level.elevation;
-    }
-  }
-  building_level.drawing_filename =
-    drawing_filename_line_edit->text().toStdString();
-  if (building_level.drawing_filename.empty())
-  {
-    building_level.x_meters = x_line_edit->text().toDouble();
-    building_level.y_meters = y_line_edit->text().toDouble();
-  }
-  else
-  {
-    building_level.x_meters = 0.0;
-    building_level.y_meters = 0.0;
-  }
-
-  building_level.flattened_x_offset =
-    flattened_x_offset_line_edit->text().toDouble();
-  building_level.flattened_y_offset =
-    flattened_y_offset_line_edit->text().toDouble();
-
-  building_level.calculate_scale();
-  accept();
-}
-
-void BuildingLevelDialog::enable_dimensions(const bool enable)
-{
-  if (enable)
-  {
-    x_line_edit->setEnabled(true);
-    y_line_edit->setEnabled(true);
-  }
-  else
-  {
-    x_line_edit->setText("10");
-    y_line_edit->setText("10");
-    x_line_edit->setEnabled(false);
-    y_line_edit->setEnabled(false);
-  }
-}
-
-void BuildingLevelDialog::drawing_filename_line_edited(const QString& text)
-{
-  enable_dimensions(text.isEmpty());
-}
diff --git a/traffic_editor/gui/building_level_dialog.h b/traffic_editor/gui/building_level_dialog.h
deleted file mode 100644
index 3b46ef0..0000000
--- a/traffic_editor/gui/building_level_dialog.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_LEVEL_DIALOG_H
-#define BUILDING_LEVEL_DIALOG_H
-
-#include <QDialog>
-#include "traffic_editor/building.h"
-#include "traffic_editor/building_level.h"
-class QLineEdit;
-
-
-class BuildingLevelDialog : public QDialog
-{
-public:
-  BuildingLevelDialog(BuildingLevel& level, Building& building);
-  ~BuildingLevelDialog();
-
-private:
-  BuildingLevel& building_level;
-  Building& building;
-
-  QLineEdit* name_line_edit, * drawing_filename_line_edit;
-  QLineEdit* x_line_edit, * y_line_edit;
-  QLineEdit* flattened_x_offset_line_edit;
-  QLineEdit* flattened_y_offset_line_edit;
-  QLineEdit* elevation_line_edit;
-  QPushButton* drawing_filename_button;
-  QPushButton* ok_button, * cancel_button;
-
-  void enable_dimensions(const bool enable);
-
-private slots:
-  void drawing_filename_button_clicked();
-  void ok_button_clicked();
-  void drawing_filename_line_edited(const QString& text);
-};
-
-#endif
diff --git a/traffic_editor/gui/building_level_table.cpp b/traffic_editor/gui/building_level_table.cpp
deleted file mode 100644
index a7b4cc6..0000000
--- a/traffic_editor/gui/building_level_table.cpp
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "building_level_table.h"
-#include "building_level_dialog.h"
-#include <QtWidgets>
-
-BuildingLevelTable::BuildingLevelTable()
-: TableList(6)
-{
-  const QStringList labels =
-  { "Name", "Scale", "X", "Y", "Z", "" };
-  setHorizontalHeaderLabels(labels);
-}
-
-BuildingLevelTable::~BuildingLevelTable()
-{
-}
-
-void BuildingLevelTable::update(Building& building)
-{
-  blockSignals(true);  // avoid tons of callbacks
-
-  setRowCount(1 + building.levels.size());
-  const int reference_level_idx = building.get_reference_level_idx();
-
-  for (size_t i = 0; i < building.levels.size(); i++)
-  {
-    QTableWidgetItem* name_item =
-      new QTableWidgetItem(QString::fromStdString(building.levels[i].name));
-    setItem(i, 0, name_item);
-
-    if (static_cast<int>(i) == reference_level_idx)
-      name_item->setBackground(QBrush(QColor("#e0ffe0")));
-
-    setItem(
-      i,
-      1,
-      new QTableWidgetItem(
-        QString::number(
-          building.levels[i].drawing_meters_per_pixel,
-          'f',
-          4)));
-
-    Building::Transform t = building.get_transform(reference_level_idx, i);
-
-    setItem(i, 2, new QTableWidgetItem(QString::number(t.dx, 'f', 1)));
-    setItem(i, 3, new QTableWidgetItem(QString::number(t.dy, 'f', 1)));
-
-    setItem(
-      i,
-      4,
-      new QTableWidgetItem(
-        QString::number(building.levels[i].elevation, 'f', 1)));
-
-    QPushButton* edit_button = new QPushButton("Edit...", this);
-    setCellWidget(i, 5, edit_button);
-    edit_button->setStyleSheet("QTableWidgetItem { background-color: red; }");
-
-    connect(
-      edit_button,
-      &QAbstractButton::clicked,
-      [this, &building, i]()
-      {
-        BuildingLevelDialog level_dialog(building.levels[i], building);
-        if (level_dialog.exec() == QDialog::Accepted)
-        {
-          building.levels[i].load_drawing();
-          setWindowModified(true);  // not sure why, but this doesn't work
-        }
-        update(building);
-      });
-  }
-
-  const int last_row_idx = static_cast<int>(building.levels.size());
-  // we'll use the last row for the "Add" button
-  for (int i = 0; i < 5; i++)
-    setItem(last_row_idx, i, new QTableWidgetItem(QString()));
-
-  QPushButton* add_button = new QPushButton("Add...", this);
-  setCellWidget(last_row_idx, 5, add_button);
-  connect(
-    add_button,
-    &QAbstractButton::clicked,
-    [this, &building]()
-    {
-      BuildingLevel level;
-      BuildingLevelDialog level_dialog(level, building);
-      if (level_dialog.exec() == QDialog::Accepted)
-      {
-        level.load_drawing();
-        building.add_level(level);
-        setWindowModified(true);
-        update(building);
-        emit redraw_scene();
-      }
-    });
-
-  blockSignals(false);
-}
diff --git a/traffic_editor/gui/building_level_table.h b/traffic_editor/gui/building_level_table.h
deleted file mode 100644
index 3ae76f9..0000000
--- a/traffic_editor/gui/building_level_table.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_LEVEL_TABLE_H
-#define BUILDING_LEVEL_TABLE_H
-
-#include <QTableWidget>
-
-#include "table_list.h"
-#include "traffic_editor/building.h"
-
-class BuildingLevelTable : public TableList
-{
-  Q_OBJECT
-
-public:
-  BuildingLevelTable();
-  ~BuildingLevelTable();
-
-  void update(Building& building);
-
-signals:
-  void redraw_scene();
-};
-
-#endif
diff --git a/traffic_editor/gui/edge.cpp b/traffic_editor/gui/edge.cpp
deleted file mode 100644
index a09582e..0000000
--- a/traffic_editor/gui/edge.cpp
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "traffic_editor/edge.h"
-using std::string;
-
-
-Edge::Edge()
-: start_idx(0),
-  end_idx(0),
-  type(UNDEFINED),
-  selected(false)
-{
-}
-
-Edge::Edge(const int _start_idx, const int _end_idx, const Type _type)
-: start_idx(_start_idx),
-  end_idx(_end_idx),
-  type(_type),
-  selected(false)
-{
-  create_required_parameters();
-}
-
-Edge::~Edge()
-{
-}
-
-void Edge::from_yaml(const YAML::Node& data, const Type edge_type)
-{
-  if (!data.IsSequence())
-    throw std::runtime_error("Edge::from_yaml expected a sequence");
-  start_idx = data[0].as<double>();
-  end_idx = data[1].as<double>();
-  type = edge_type;
-  // load the parameters
-  if (data.size() >= 2)
-  {
-    for (YAML::const_iterator it = data[2].begin(); it != data[2].end(); ++it)
-    {
-      Param p;
-      p.from_yaml(it->second);
-      params[it->first.as<string>()] = p;
-    }
-  }
-
-  create_required_parameters();
-}
-
-YAML::Node Edge::to_yaml() const
-{
-  YAML::Node y;
-  y.push_back(start_idx);
-  y.push_back(end_idx);
-
-  YAML::Node params_node(YAML::NodeType::Map);
-  for (const auto& param : params)
-    params_node[param.first] = param.second.to_yaml();
-  y.push_back(params_node);
-  y.SetStyle(YAML::EmitterStyle::Flow);
-  return y;
-}
-
-bool Edge::is_bidirectional() const
-{
-  auto it = params.find("bidirectional");
-  if (it == params.end() || it->second.type != Param::BOOL)
-    return false;
-  return it->second.value_bool;
-}
-
-void Edge::set_param(const std::string& name, const std::string& value)
-{
-  auto it = params.find(name);
-  if (it == params.end())
-  {
-    printf("tried to set unknown parameter [%s]\n", name.c_str());
-    return;  // unknown parameter
-  }
-  it->second.set(value);
-}
-
-template<typename T>
-void Edge::create_param_if_needed(
-  const std::string& name,
-  const Param::Type& param_type,
-  const T& param_value)
-{
-  auto it = params.find(name);
-  if (it == params.end() || it->second.type != param_type)
-    params[name] = param_value;
-}
-
-void Edge::create_required_parameters()
-{
-  // create required parameters if they don't exist yet on this edge
-  if (type == MEAS)
-  {
-    auto it = params.find("distance");
-    if (it == params.end() || it->second.type != Param::DOUBLE)
-      params["distance"] = Param(1.0);
-  }
-  else if (type == WALL)
-  {
-    create_param_if_needed("texture_name", Param::STRING,
-      std::string("default"));
-    create_param_if_needed("alpha", Param::DOUBLE, 1.0);
-  }
-  else if (type == LANE)
-  {
-    create_param_if_needed("bidirectional", Param::BOOL, false);
-    create_param_if_needed("orientation", Param::STRING, std::string());
-    create_param_if_needed("graph_idx", Param::INT, 0);
-    create_param_if_needed("demo_mock_floor_name", Param::STRING,
-      std::string());
-    create_param_if_needed("demo_mock_lift_name", Param::STRING, std::string());
-  }
-  else if (type == DOOR)
-  {
-    create_param_if_needed("name", Param::STRING, std::string());
-    create_param_if_needed("type", Param::STRING, std::string("hinged"));
-    create_param_if_needed("motion_axis", Param::STRING, std::string("start"));
-    create_param_if_needed("motion_direction", Param::INT, 1);
-    create_param_if_needed("motion_degrees", Param::DOUBLE, 90.0);  // hinged
-  }
-}
-
-std::string Edge::type_to_string() const
-{
-  if (type == LANE)
-    return string("lane");
-  else if (type == WALL)
-    return string("wall");
-  else if (type == MEAS)
-    return string("measurement");
-  else if (type == DOOR)
-    return string("door");
-  return string("undefined");
-}
-
-QString Edge::type_to_qstring() const
-{
-  return QString::fromStdString(type_to_string());
-}
-
-void Edge::set_graph_idx(const int idx)
-{
-  if (type != LANE)
-    return;// for now at least, only lanes have graph indices
-  params["graph_idx"] = Param(idx);
-}
-
-int Edge::get_graph_idx() const
-{
-  if (type != LANE)
-    return 0;// for now, only lanes have indices defined
-  auto it = params.find("graph_idx");
-  if (it == params.end() || it->second.type != Param::INT)
-    return 0;// shouldn't get here
-  return it->second.value_int;
-}
diff --git a/traffic_editor/gui/editor.cpp b/traffic_editor/gui/editor.cpp
deleted file mode 100644
index 1355641..0000000
--- a/traffic_editor/gui/editor.cpp
+++ /dev/null
@@ -1,2411 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-#include <cmath>
-#include <string>
-#include <unistd.h>
-#include <sys/types.h>
-#include <pwd.h>
-
-#include <QtWidgets>
-
-#include <QInputDialog>
-#include <QLabel>
-#include <QListWidget>
-#include <QToolBar>
-
-#ifdef HAS_OPENCV
-#include <opencv2/core/core.hpp>
-#include <opencv2/videoio.hpp>
-#include <opencv2/imgproc.hpp>
-#endif
-
-#include <yaml-cpp/yaml.h>
-
-#include "ament_index_cpp/get_package_share_directory.hpp"
-#include "ament_index_cpp/get_package_prefix.hpp"
-#include "ament_index_cpp/get_resource.hpp"
-
-#include "add_param_dialog.h"
-#include "building_dialog.h"
-#include "building_level_dialog.h"
-#include "building_level_table.h"
-#include "editor.h"
-#include "layer_dialog.h"
-#include "lift_table.h"
-#include "map_view.h"
-#include "model_dialog.h"
-#include "preferences_dialog.h"
-#include "preferences_keys.h"
-#include "project_dialog.h"
-#include "scenario_table.h"
-#include "traffic_table.h"
-#include "ui_transform_dialog.h"
-
-using std::string;
-using std::isnan;
-
-
-Editor* Editor::instance = nullptr;
-
-Editor::Editor()
-: QMainWindow()
-{
-  instance = this;
-
-  setWindowTitle("Traffic Editor[*]");
-
-  QSettings settings;
-  qDebug("settings filename: [%s]", qUtf8Printable(settings.fileName()));
-
-  scene = new QGraphicsScene(this);
-
-  map_view = new MapView(this);
-  map_view->setScene(scene);
-
-  QVBoxLayout* left_layout = new QVBoxLayout;
-  left_layout->addWidget(map_view);
-
-  layers_table = new TableList;  // todo: replace with specific subclass?
-
-  level_table = new BuildingLevelTable;
-  connect(
-    level_table, &QTableWidget::cellClicked,
-    [=](int row, int /*col*/)
-    {
-      if (row < static_cast<int>(project.building.levels.size()))
-      {
-        // save the center point of the current level's image coordinates
-        const QPoint p_center_window(
-          map_view->viewport()->width() / 2,
-          map_view->viewport()->height() / 2);
-        QPointF p_center_scene = map_view->mapToScene(p_center_window);
-        // printf("p_center_scene: (%.1f, %.1f)\n",
-        //   p_center_scene.x(), p_center_scene.y());
-
-        QPointF p_transformed;
-        project.building.transform_between_levels(
-          level_idx,
-          p_center_scene,
-          row,
-          p_transformed);
-
-        // maintain the view scale
-        const double prev_scale = map_view->transform().m11();
-
-        double scale = prev_scale *
-        project.building.levels[row].drawing_meters_per_pixel /
-        project.building.levels[level_idx].drawing_meters_per_pixel;
-        if (isnan(scale))
-        {
-          scale = 1.0;
-          p_transformed = QPointF(0.0, 0.0);
-        }
-
-        level_idx = row;
-        create_scene();
-
-        QTransform t;
-        t.scale(scale, scale);
-        map_view->setTransform(t);
-        map_view->centerOn(p_transformed);
-      }
-    });
-
-  connect(
-    level_table,
-    &BuildingLevelTable::redraw_scene,
-    this,
-    &Editor::create_scene);
-
-  lift_table = new LiftTable;
-  connect(
-    lift_table,
-    &TableList::redraw,
-    [this]() { this->create_scene(); });
-
-  traffic_table = new TrafficTable;
-  connect(
-    traffic_table,
-    &TableList::redraw,
-    [this]() { this->create_scene(); });
-
-  connect(
-    traffic_table,
-    &QTableWidget::cellClicked,
-    [=](int row, int /*col*/)
-    {
-      project.traffic_map_idx = row;
-      traffic_table->update(project);
-    });
-
-  scenario_table = new ScenarioTable;
-  connect(
-    scenario_table,
-    &QTableWidget::cellClicked,
-    [=](int row, int /*col*/)
-    {
-      project.scenario_row_clicked(row);
-      create_scene();
-    });
-
-  right_tab_widget = new QTabWidget;
-  right_tab_widget->setStyleSheet("QTabBar::tab { color: white; }");
-  right_tab_widget->addTab(level_table, "levels");
-  right_tab_widget->addTab(layers_table, "layers");
-  right_tab_widget->addTab(lift_table, "lifts");
-  right_tab_widget->addTab(traffic_table, "traffic");
-  right_tab_widget->addTab(scenario_table, "scenarios");
-
-  property_editor = new QTableWidget;
-  property_editor->setStyleSheet(
-    "QTableWidget { background-color: #e0e0e0; color: black; gridline-color: #606060; } QLineEdit { background:white; }");
-  property_editor->setMinimumSize(600, 200);
-  property_editor->setSizePolicy(
-    QSizePolicy::Fixed,
-    QSizePolicy::MinimumExpanding);
-  property_editor->setColumnCount(2);
-  property_editor->horizontalHeader()->setVisible(false);
-  property_editor->verticalHeader()->setVisible(false);
-  property_editor->horizontalHeader()->setSectionResizeMode(
-    0,
-    QHeaderView::ResizeToContents);
-  property_editor->horizontalHeader()->setSectionResizeMode(
-    1,
-    QHeaderView::Stretch);
-  property_editor->verticalHeader()->setSectionResizeMode(
-    QHeaderView::ResizeToContents);
-  property_editor->setAutoFillBackground(true);
-  connect(
-    property_editor, &QTableWidget::cellChanged,
-    this, &Editor::property_editor_cell_changed);
-
-  QHBoxLayout* param_button_layout = new QHBoxLayout;
-
-  add_param_button = new QPushButton("Add...");
-  add_param_button->setEnabled(false);
-  connect(
-    add_param_button, &QAbstractButton::clicked,
-    this, &Editor::add_param_button_clicked);
-
-  delete_param_button = new QPushButton("Delete");
-  delete_param_button->setEnabled(false);
-  connect(
-    delete_param_button, &QAbstractButton::clicked,
-    this, &Editor::delete_param_button_clicked);
-
-  param_button_layout->addWidget(add_param_button);
-  param_button_layout->addWidget(delete_param_button);
-
-  QVBoxLayout* right_column_layout = new QVBoxLayout;
-  right_column_layout->addWidget(right_tab_widget);
-
-  QLabel* properties_label = new QLabel("Properties");
-  properties_label->setStyleSheet("QLabel { color: white; }");
-  right_column_layout->addWidget(properties_label);
-  right_column_layout->addWidget(property_editor);
-  right_column_layout->addLayout(param_button_layout);
-
-  QHBoxLayout* hbox_layout = new QHBoxLayout;
-  hbox_layout->addLayout(left_layout, 1);
-  hbox_layout->addLayout(right_column_layout);
-
-  QWidget* w = new QWidget();
-  w->setMouseTracking(true);
-  setMouseTracking(true);
-  w->setLayout(hbox_layout);
-  w->setStyleSheet("background-color: #404040");
-  setCentralWidget(w);
-
-  // PROJECT MENU
-  QMenu* project_menu = menuBar()->addMenu("&Project");
-
-  project_menu->addAction(
-    "&New...",
-    this,
-    &Editor::project_new,
-    QKeySequence(Qt::CTRL + Qt::Key_N));
-
-  project_menu->addAction(
-    "&Open...",
-    this,
-    &Editor::project_open,
-    QKeySequence(Qt::CTRL + Qt::Key_O));
-
-  project_menu->addAction(
-    "&Save",
-    this,
-    &Editor::project_save,
-    QKeySequence(Qt::CTRL + Qt::Key_S));
-
-  project_menu->addSeparator();
-
-  project_menu->addAction(
-    "E&xit",
-    this,
-    &QWidget::close,
-    QKeySequence(Qt::CTRL + Qt::Key_Q));
-
-  // EDIT MENU
-  QMenu* edit_menu = menuBar()->addMenu("&Edit");
-  edit_menu->addAction(
-    "&Building properties...",
-    this,
-    &Editor::edit_building_properties);
-  edit_menu->addAction(
-    "&Project properties...",
-    this,
-    &Editor::edit_project_properties);
-  edit_menu->addSeparator();
-  edit_menu->addAction(
-    "&Transform...",
-    this,
-    &Editor::edit_transform);
-  edit_menu->addSeparator();
-  edit_menu->addAction("&Preferences...", this, &Editor::edit_preferences);
-
-  // MODE MENU
-  QMenu* mode_menu = menuBar()->addMenu("&Mode");
-  mode_menu->addAction(
-    "&Building",
-    this,
-    [this]() { this->set_mode(MODE_BUILDING, "Building"); },
-    QKeySequence(Qt::CTRL + Qt::Key_B));
-
-  mode_menu->addAction(
-    "&Traffic lanes",
-    this,
-    [this]() { this->set_mode(MODE_TRAFFIC, "Traffic"); },
-    QKeySequence(Qt::CTRL + Qt::Key_T));
-
-  mode_menu->addAction(
-    "&Scenario",
-    this,
-    [this]() { this->set_mode(MODE_SCENARIO, "Scenario"); },
-    QKeySequence(Qt::CTRL + Qt::Key_E));
-
-  // VIEW MENU
-  QMenu* view_menu = menuBar()->addMenu("&View");
-  view_models_action =
-    view_menu->addAction("&Models", this, &Editor::view_models);
-  view_models_action->setCheckable(true);
-  view_models_action->setChecked(true);
-  view_menu->addSeparator();
-
-  zoom_fit_action =
-    view_menu->addAction("&Fit to Window", this, &Editor::zoom_fit);
-  zoom_fit_action->setEnabled(false);
-
-  // HELP MENU
-  QMenu* help_menu = menuBar()->addMenu("&Help");
-
-  help_menu->addAction("&About", this, &Editor::help_about);
-  help_menu->addAction("About &Qt", &QApplication::aboutQt);
-
-  // TOOLBAR
-  toolbar = new QToolBar();
-
-  mode_combo_box = new QComboBox;
-  mode_combo_box->addItem("Building");
-  mode_combo_box->addItem("Traffic");
-  mode_combo_box->addItem("Scenario");
-  connect(
-    mode_combo_box,
-    &QComboBox::currentTextChanged,
-    [this](const QString& text)
-    {
-      if (text == "Building")
-        set_mode(MODE_BUILDING, "Building");
-      else if (text == "Traffic")
-        set_mode(MODE_TRAFFIC, "Traffic");
-      else if (text == "Scenario")
-        set_mode(MODE_SCENARIO, "Scenario");
-    });
-
-  QLabel* mode_label = new QLabel("Edit mode:");
-  mode_label->setStyleSheet("QLabel { color: white; }");
-  toolbar->addWidget(mode_label);
-  toolbar->addWidget(mode_combo_box);
-
-  tool_button_group = new QButtonGroup(this);
-  tool_button_group->setExclusive(true);
-
-  create_tool_button(TOOL_SELECT, ":icons/select.svg", "Select (Esc)");
-  create_tool_button(TOOL_MOVE, ":icons/move.svg", "Move (M)");
-  create_tool_button(TOOL_ROTATE, ":icons/rotate.svg", "Rotate (R)");
-  create_tool_button(TOOL_ADD_VERTEX, ":icons/vertex.svg", "Add Vertex (V)");
-  create_tool_button(TOOL_ADD_FIDUCIAL, ":icons/fiducial.svg", "Add Fiducial");
-  create_tool_button(TOOL_ADD_LANE, "", "Add Lane (L)");
-  create_tool_button(TOOL_ADD_WALL, ":icons/wall.svg", "Add Wall (W)");
-  create_tool_button(
-    TOOL_ADD_MEAS,
-    ":icons/measurement.svg",
-    "Add Measurement");
-  create_tool_button(TOOL_ADD_DOOR, ":icons/door.svg", "Add Door");
-  create_tool_button(TOOL_ADD_MODEL, "", "Add Model");
-  create_tool_button(TOOL_ADD_FLOOR, ":icons/floor.svg", "Add floor polygon");
-  create_tool_button(TOOL_ADD_HOLE, ":icons/hole.svg", "Add hole polygon");
-  create_tool_button(TOOL_ADD_ROI, ":icons/roi.svg", "Add region of interest");
-  create_tool_button(TOOL_EDIT_POLYGON, "", "Edit Polygon");
-
-  connect(
-    tool_button_group,
-    QOverload<int, bool>::of(&QButtonGroup::buttonToggled),
-    this, &Editor::tool_toggled);
-
-  toolbar->addSeparator();
-
-  sim_reset_action = toolbar->addAction(
-    "Reset",
-    this,
-    &Editor::sim_reset);
-  sim_reset_action->setVisible(false);
-
-  sim_play_pause_action = toolbar->addAction(
-    "Play",
-    this,
-    &Editor::sim_play_pause);
-  sim_play_pause_action->setVisible(false);
-
-#ifdef HAS_OPENCV
-  record_start_stop_action = toolbar->addAction(
-    "Record",
-    this,
-    &Editor::record_start_stop);
-  record_start_stop_action->setVisible(false);
-#endif
-
-  toolbar->setStyleSheet(
-    "QToolBar {background-color: #404040; border: none; spacing: 5px} QToolButton {background-color: #c0c0c0; color: blue; border: 1px solid black;} QToolButton:checked {background-color: #808080; color: red; border: 1px solid black;}");
-  addToolBar(Qt::TopToolBarArea, toolbar);
-
-  ///////////////////////////////////////////////////////////
-  // SET SIZE
-  const int width =
-    settings.contains(preferences_keys::window_width) ?
-    settings.value(preferences_keys::window_width).toInt() :
-    QGuiApplication::primaryScreen()->availableSize().width();
-
-  const int height =
-    settings.contains(preferences_keys::window_height) ?
-    settings.value(preferences_keys::window_height).toInt() :
-    QGuiApplication::primaryScreen()->availableSize().height();
-
-  const int left =
-    settings.contains(preferences_keys::window_left) ?
-    settings.value(preferences_keys::window_left).toInt() :
-    0;
-
-  const int top =
-    settings.contains(preferences_keys::window_top) ?
-    settings.value(preferences_keys::window_top).toInt() :
-    0;
-
-  setGeometry(left, top, width, height);
-  map_view->adjustSize();
-
-  // default tool is the "select" tool
-  tool_button_group->button(TOOL_SELECT)->click();
-  set_mode(MODE_BUILDING, "Building");
-
-  load_model_names();
-  level_table->setCurrentCell(level_idx, 0);
-
-  scene_update_timer = new QTimer;
-  connect(
-    scene_update_timer,
-    &QTimer::timeout,
-    this,
-    &Editor::scene_update_timer_timeout);
-  scene_update_timer->start(1000 / 30);
-}
-
-Editor::~Editor()
-{
-#ifdef HAS_OPENCV
-  if (video_writer)
-  {
-    delete video_writer;
-    video_writer = nullptr;
-  }
-#endif
-}
-
-void Editor::scene_update_timer_timeout()
-{
-  if (project.building.levels.empty())
-    return;// let's not crash...
-
-  project.scenario_scene_update(scene, level_idx);
-
-  {
-    std::lock_guard<std::mutex> building_guard(
-      project.building.building_mutex);
-
-    // project->draw_scenario(scene, level_idx);
-    //project.building.levels[level_idx]->name,
-    //    building.levels[level_idx]->drawing_meters_per_pixel,
-
-    const BuildingLevel& level = project.building.levels[level_idx];
-
-    const std::string& level_name = level.name;
-    const double level_scale = level.drawing_meters_per_pixel;
-
-    // for now, we're not dealing with models changing levels from their
-    // starting level. we'll need to do that in the future at some point.
-    for (auto& model : project.building.levels[level_idx].models)
-    {
-      if (!model.is_active)
-        continue;
-
-      if (model.state.level_name != level_name)
-        continue;
-
-      model.draw(scene, editor_models, level_scale);
-    }
-
-    //scenario->draw(scene, level_idx);
-  }
-
-#ifdef HAS_OPENCV
-  record_frame_to_video();
-#endif
-}
-
-void Editor::load_model_names()
-{
-  QSettings settings;
-  QString thumbnail_path(
-    settings.value(preferences_keys::thumbnail_path).toString());
-  if (thumbnail_path.isEmpty())
-  {
-    std::string assets_dir;
-    std::string share_dir;
-
-    try
-    {
-      share_dir =
-        ament_index_cpp::get_package_share_directory("traffic_editor_assets");
-
-      ament_index_cpp::get_resource("traffic_editor_assets",
-        "assets",
-        assets_dir);
-    }
-    catch (const ament_index_cpp::PackageNotFoundError& e)
-    {
-      qWarning("Could not load default thumbnail directory! "
-        "traffic_editor_assets package not found in workspace!");
-      return;
-    }
-
-    // Strip newlines from assets_dir
-    assets_dir.erase(std::remove(assets_dir.begin(), assets_dir.end(), '\n'),
-      assets_dir.end());
-
-    // Obtain thumbnail path from traffic_editor_assets ament package
-    thumbnail_path =
-      QDir::cleanPath(
-      QDir(QApplication::applicationDirPath()).filePath(
-        (share_dir + "/" + assets_dir + "/thumbnails").c_str()
-      )
-      );
-    settings.setValue(preferences_keys::thumbnail_path, thumbnail_path);
-  }
-
-  QString model_list_path = QDir(thumbnail_path).filePath("model_list.yaml");
-
-  YAML::Node y;
-  std::string filename(model_list_path.toStdString());
-  try
-  {
-    y = YAML::LoadFile(filename);
-  }
-  catch (const std::exception& e)
-  {
-    qWarning("couldn't parse %s: %s", filename.c_str(), e.what());
-    return;
-  }
-  qInfo("parsed %s successfully", filename.c_str());
-
-  const double model_meters_per_pixel = y["meters_per_pixel"].as<double>();
-  const YAML::Node ym = y["models"];
-  for (YAML::const_iterator it = ym.begin(); it != ym.end(); ++it)
-    editor_models.push_back(
-      EditorModel(it->as<std::string>(), model_meters_per_pixel));
-}
-
-QToolButton* Editor::create_tool_button(
-  const ToolId id,
-  const QString& icon_filename,
-  const QString& tooltip)
-{
-  QToolButton* b = new QToolButton(toolbar);
-  b->setCheckable(true);
-
-  if (!icon_filename.isEmpty())
-  {
-    QIcon icon(icon_filename);
-    b->setIcon(icon);
-    b->setToolTip(tooltip);
-  }
-  else
-  {
-    b->setText(tool_id_to_string(id));
-    //b->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Maximum);
-  }
-  tools[id] = toolbar->addWidget(b);
-  tool_button_group->addButton(b, id);
-  return b;
-}
-
-Editor* Editor::get_instance()
-{
-  return instance;
-}
-
-bool Editor::load_project(const QString& filename)
-{
-  const std::string filename_std_string = filename.toStdString();
-
-  if (!project.load(filename.toStdString()))
-    return false;
-
-  level_idx = 0;
-
-  if (!project.building.levels.empty())
-  {
-    const BuildingLevel& level = project.building.levels[level_idx];
-    scene->setSceneRect(
-      QRectF(0, 0, level.drawing_width, level.drawing_height));
-    previous_mouse_point = QPointF(level.drawing_width, level.drawing_height);
-  }
-
-  create_scene();
-
-  update_tables();
-
-  if (project.has_sim_plugin())
-  {
-    printf("project has a sim plugin\n");
-    sim_reset_action->setVisible(true);
-    sim_play_pause_action->setVisible(true);
-#ifdef HAS_OPENCV
-    record_start_stop_action->setVisible(true);
-#endif
-  }
-  else
-    printf("project does not have a sim plugin\n");
-
-  QSettings settings;
-  settings.setValue(preferences_keys::previous_project_path, filename);
-
-  setWindowModified(false);
-
-  return true;
-}
-
-void Editor::restore_previous_viewport()
-{
-  QSettings settings;
-
-  if (settings.contains(preferences_keys::level_name))
-  {
-    const std::string level_name =
-      settings.value(preferences_keys::level_name).toString().toStdString();
-    for (size_t i = 0; i < project.building.levels.size(); i++)
-    {
-      if (project.building.levels[i].name == level_name)
-      {
-        level_idx = i;
-        create_scene();
-        level_table->setCurrentCell(i, 0);
-        break;
-      }
-    }
-  }
-
-  double viewport_center_x =
-    settings.contains(preferences_keys::viewport_center_x) ?
-    settings.value(preferences_keys::viewport_center_x).toDouble() :
-    0.0;
-
-  double viewport_center_y =
-    settings.contains(preferences_keys::viewport_center_y) ?
-    settings.value(preferences_keys::viewport_center_y).toDouble() :
-    0.0;
-
-  double viewport_scale =
-    settings.contains(preferences_keys::viewport_scale) ?
-    settings.value(preferences_keys::viewport_scale).toDouble() :
-    1.0;
-
-  // sanity-check the viewport center and scale, since they can be garbage
-  // if the last loaded level doesn't have its scale set up.
-  if (isnan(viewport_center_x))
-    viewport_center_x = 0.0;
-  if (isnan(viewport_center_y))
-    viewport_center_y = 0.0;
-  if (isnan(viewport_scale))
-    viewport_scale = 1.0;
-
-  printf("restoring viewport: (%.1f, %.1f, %3f)\n",
-    viewport_center_x,
-    viewport_center_y,
-    viewport_scale);
-
-  QTransform t;
-  t.scale(viewport_scale, viewport_scale);
-  map_view->setTransform(t);
-  map_view->centerOn(QPointF(viewport_center_x, viewport_center_y));
-}
-
-bool Editor::load_previous_project()
-{
-  QSettings settings;
-  const QString filename(
-    settings.value(preferences_keys::previous_project_path).toString());
-  if (!filename.isEmpty())
-    return load_project(filename);
-  return true;
-}
-
-void Editor::project_new()
-{
-  QFileDialog dialog(this, "New Project");
-  dialog.setNameFilter("*.project.yaml");
-  dialog.setDefaultSuffix(".project.yaml");
-  dialog.setAcceptMode(QFileDialog::AcceptMode::AcceptSave);
-  dialog.setConfirmOverwrite(true);
-
-  if (dialog.exec() != QDialog::Accepted)
-    return;
-
-  QFileInfo file_info(dialog.selectedFiles().first());
-  std::string fn = file_info.fileName().toStdString();
-
-  project.clear();
-  project.set_filename(file_info.absoluteFilePath().toStdString());
-  QString dir_path = file_info.dir().path();
-  QDir::setCurrent(dir_path);
-
-  create_scene();
-  project_save();
-  update_tables();
-
-  QSettings settings;
-  settings.setValue(
-    preferences_keys::previous_project_path,
-    QString::fromStdString(project.get_filename()));
-}
-
-void Editor::project_open()
-{
-  QFileDialog file_dialog(this, "Open Project");
-  file_dialog.setFileMode(QFileDialog::ExistingFile);
-  file_dialog.setNameFilter("*.project.yaml");
-
-  if (file_dialog.exec() != QDialog::Accepted)
-    return;
-
-  QFileInfo file_info(file_dialog.selectedFiles().first());
-  if (!file_info.exists())
-  {
-    QMessageBox::critical(
-      this,
-      "File does not exist",
-      "File does not exist. Cannot open file.");
-    return;
-  }
-  load_project(file_info.filePath());
-}
-
-bool Editor::project_save()
-{
-  project.save();
-  setWindowModified(false);
-  return true;
-}
-
-void Editor::help_about()
-{
-  QMessageBox::about(this, "About", "Welcome to the Traffic Editor");
-}
-
-void Editor::edit_preferences()
-{
-  PreferencesDialog preferences_dialog(this);
-
-  if (preferences_dialog.exec() == QDialog::Accepted)
-    load_model_names();
-}
-
-void Editor::edit_building_properties()
-{
-  BuildingDialog building_dialog(project.building);
-  if (building_dialog.exec() == QDialog::Accepted)
-    setWindowModified(true);
-}
-
-void Editor::edit_project_properties()
-{
-  ProjectDialog project_dialog(project);
-  if (project_dialog.exec() == QDialog::Accepted)
-    setWindowModified(true);
-}
-
-void Editor::edit_transform()
-{
-  QDialog dialog;
-  Ui::TransformDialog dialog_ui;
-  dialog_ui.setupUi(&dialog);
-  if (dialog.exec() != QDialog::Accepted)
-    return;
-
-  const double rotation =
-    dialog_ui.rotate_all_models_line_edit->text().toDouble();
-  project.building.rotate_all_models(rotation);
-  create_scene();
-  setWindowModified(true);
-}
-
-void Editor::view_models()
-{
-  project.rendering_options.show_models = view_models_action->isChecked();
-  create_scene();
-}
-
-void Editor::zoom_fit()
-{
-  // todo: implement this for real
-  //map_view->set_absolute_scale(1.0);
-  map_view->resetMatrix();
-}
-
-void Editor::mouse_event(const MouseType t, QMouseEvent* e)
-{
-  QPointF p;
-  if (!is_mouse_event_in_map(e, p))
-  {
-    e->ignore();
-    return;
-  }
-  if (level_idx >= static_cast<int>(project.building.levels.size()))
-  {
-    if (t == MOUSE_RELEASE)
-    {
-      if (project.get_filename().empty())
-      {
-        QMessageBox::critical(
-          this,
-          "No project",
-          "Please try File->New Project... or File->Open Project...");
-      }
-      else if (project.building.levels.empty())
-      {
-        QMessageBox::critical(
-          this,
-          "No levels defined",
-          "No levels defined. Use Level->Add...");
-      }
-    }
-    return;
-  }
-  // dispatch to individual mouse handler functions to save indenting...
-  switch (tool_id)
-  {
-    case TOOL_SELECT:       mouse_select(t, e, p); break;
-    case TOOL_ADD_VERTEX:   mouse_add_vertex(t, e, p); break;
-    case TOOL_MOVE:         mouse_move(t, e, p); break;
-    case TOOL_ADD_LANE:     mouse_add_lane(t, e, p); break;
-    case TOOL_ADD_WALL:     mouse_add_wall(t, e, p); break;
-    case TOOL_ADD_MEAS:     mouse_add_meas(t, e, p); break;
-    case TOOL_ADD_DOOR:     mouse_add_door(t, e, p); break;
-    case TOOL_ADD_MODEL:    mouse_add_model(t, e, p); break;
-    case TOOL_ROTATE:       mouse_rotate(t, e, p); break;
-    case TOOL_ADD_FLOOR:    mouse_add_floor(t, e, p); break;
-    case TOOL_ADD_HOLE:     mouse_add_hole(t, e, p); break;
-    case TOOL_EDIT_POLYGON: mouse_edit_polygon(t, e, p); break;
-    case TOOL_ADD_FIDUCIAL: mouse_add_fiducial(t, e, p); break;
-    case TOOL_ADD_ROI:      mouse_add_roi(t, e, p); break;
-    default: break;
-  }
-  previous_mouse_point = p;
-}
-
-void Editor::mousePressEvent(QMouseEvent* e)
-{
-  mouse_event(MOUSE_PRESS, e);
-}
-
-void Editor::mouseReleaseEvent(QMouseEvent* e)
-{
-  mouse_event(MOUSE_RELEASE, e);
-}
-
-void Editor::mouseMoveEvent(QMouseEvent* e)
-{
-  mouse_event(MOUSE_MOVE, e);
-}
-
-bool Editor::is_mouse_event_in_map(QMouseEvent* e, QPointF& p_scene)
-{
-  const QPoint p_global = mapToGlobal(e->pos());
-  const QPoint p_map = map_view->mapFromGlobal(p_global);
-  if (p_map.x() < 0 || p_map.y() < 0 ||
-    p_map.x() >= map_view->width() || p_map.y() >= map_view->height())
-    return false;
-  // This event point is valid. Now we can set p_scene.
-  p_scene = map_view->mapToScene(p_map);
-  return true;
-}
-
-void Editor::keyPressEvent(QKeyEvent* e)
-{
-  switch (e->key())
-  {
-    case Qt::Key_Delete:
-      if (project.delete_selected(level_idx))
-      {
-        clear_property_editor();
-        setWindowModified(true);
-      }
-      else
-      {
-        QMessageBox::critical(
-          this,
-          "Could not delete item",
-          "If deleting a vertex, it must not be in any edges or polygons.");
-
-        project.clear_selection(level_idx);
-      }
-      create_scene();
-      break;
-    case Qt::Key_S:
-    case Qt::Key_Escape:
-      tool_button_group->button(TOOL_SELECT)->click();
-      project.clear_selection(level_idx);
-      update_property_editor();
-      create_scene();
-      break;
-    case Qt::Key_V:
-      tool_button_group->button(TOOL_ADD_VERTEX)->click();
-      break;
-    case Qt::Key_M:
-      tool_button_group->button(TOOL_MOVE)->click();
-      break;
-    case Qt::Key_L:
-      tool_button_group->button(TOOL_ADD_LANE)->click();
-      break;
-    case Qt::Key_W:
-      tool_button_group->button(TOOL_ADD_WALL)->click();
-      break;
-    case Qt::Key_T:
-      tool_button_group->button(TOOL_ADD_MEAS)->click();
-      break;
-    case Qt::Key_O:
-      tool_button_group->button(TOOL_ADD_MODEL)->click();
-      break;
-    case Qt::Key_R:
-      tool_button_group->button(TOOL_ROTATE)->click();
-      break;
-    case Qt::Key_F:
-      tool_button_group->button(TOOL_ADD_FLOOR)->click();
-      break;
-    case Qt::Key_E:
-      tool_button_group->button(TOOL_EDIT_POLYGON)->click();
-      break;
-    case Qt::Key_B:
-      for (auto& edge : project.building.levels[level_idx].edges)
-      {
-        if (edge.type == Edge::LANE && edge.selected)
-        {
-          // toggle bidirectional flag
-          edge.set_param("bidirectional",
-            edge.is_bidirectional() ? "false" : "true");
-          create_scene();
-        }
-      }
-      break;
-    case Qt::Key_0: number_key_pressed(0); break;
-    case Qt::Key_1: number_key_pressed(1); break;
-    case Qt::Key_2: number_key_pressed(2); break;
-    case Qt::Key_3: number_key_pressed(3); break;
-    case Qt::Key_4: number_key_pressed(4); break;
-    case Qt::Key_5: number_key_pressed(5); break;
-    case Qt::Key_6: number_key_pressed(6); break;
-    case Qt::Key_7: number_key_pressed(7); break;
-    case Qt::Key_8: number_key_pressed(8); break;
-    case Qt::Key_9: number_key_pressed(9); break;
-    default:
-      break;
-  }
-}
-
-const QString Editor::tool_id_to_string(const int id)
-{
-  switch (id)
-  {
-    case TOOL_SELECT: return "&select";
-    case TOOL_MOVE: return "&move";
-    case TOOL_ROTATE: return "&rotate";
-    case TOOL_ADD_VERTEX: return "add &vertex";
-    case TOOL_ADD_LANE: return "add &lane";
-    case TOOL_ADD_WALL: return "add &wall";
-    case TOOL_ADD_MEAS: return "add measuremen&t";
-    case TOOL_ADD_DOOR: return "add door";
-    case TOOL_ADD_MODEL: return "add m&odel";
-    case TOOL_ADD_FLOOR: return "add &floor";
-    case TOOL_ADD_HOLE: return "add hole";
-    case TOOL_EDIT_POLYGON: return "&edit polygon";
-    default: return "unknown tool ID";
-  }
-}
-
-void Editor::tool_toggled(int id, bool checked)
-{
-  if (!checked)
-    return;
-
-  clicked_idx = -1;
-  remove_mouse_motion_item();
-
-  tool_id = static_cast<ToolId>(id);
-
-#if 0
-  // TODO: need to improve logic to set back to "normal" cursor...
-  // set the cursor
-  Qt::CursorShape cursor = Qt::ArrowCursor;
-  if (tool_id == TOOL_ADD_VERTEX)
-    cursor = Qt::CrossCursor;
-  map_view->setCursor(cursor);
-#endif
-
-  // set the status bar
-  switch (tool_id)
-  {
-    case TOOL_SELECT:
-      statusBar()->showMessage("Click an item to select it.");
-      break;
-    case TOOL_ADD_LANE:
-    case TOOL_ADD_WALL:
-    case TOOL_ADD_MEAS:
-      statusBar()->showMessage(
-        "Click one vertex and then another vertex to add an edge.");
-      break;
-    case TOOL_ADD_FLOOR:
-      statusBar()->showMessage(
-        "Left-click to add polygon vertices. "
-        "Right-click to close polygon.");
-      break;
-    case TOOL_EDIT_POLYGON:
-      statusBar()->showMessage(
-        "Left-click drag an edge to introduce a new vertex. "
-        "Right-click a polygon vertex to remove it from the polygon.");
-      break;
-    default:
-      statusBar()->clearMessage();
-      break;
-  }
-
-  // execute dialogs as needed
-  if (tool_id == TOOL_ADD_MODEL)
-  {
-    Model model;
-    ModelDialog dialog(this, model, editor_models);
-    if (dialog.exec() == QDialog::Accepted)
-    {
-      // find the EditorModel with the requested name
-      for (auto& em : editor_models)
-      {
-        if (em.name == model.model_name)
-        {
-          mouse_motion_editor_model = &em;
-          const QPixmap pixmap(mouse_motion_editor_model->get_pixmap());
-          mouse_motion_model = scene->addPixmap(pixmap);
-          mouse_motion_model->setOffset(-pixmap.width()/2, -pixmap.height()/2);
-          mouse_motion_model->setScale(
-            mouse_motion_editor_model->meters_per_pixel /
-            project.building.levels[level_idx].drawing_meters_per_pixel);
-          mouse_motion_model->setPos(
-            previous_mouse_point.x(),
-            previous_mouse_point.y());
-          statusBar()->showMessage("Left-click to instantiate this model.");
-          break;
-        }
-      }
-    }
-    else
-      tool_button_group->button(TOOL_SELECT)->click();// back to select mode
-  }
-}
-
-void Editor::update_property_editor()
-{
-  add_param_button->setEnabled(false);
-  delete_param_button->setEnabled(false);
-
-  if (project.building.levels.empty())
-    return;
-
-  for (const auto& p : project.building.levels[level_idx].polygons)
-  {
-    if (p.selected)
-    {
-      populate_property_editor(p);
-      return;
-    }
-  }
-
-  for (const auto& e : project.building.levels[level_idx].edges)
-  {
-    if (e.selected)
-    {
-      populate_property_editor(e);
-      return;  // stop after finding the first one
-    }
-  }
-
-  for (const auto& m : project.building.levels[level_idx].models)
-  {
-    if (m.selected)
-    {
-      populate_property_editor(m);
-      return;  // stop after finding the first one
-    }
-  }
-
-  for (const auto& v : project.building.levels[level_idx].vertices)
-  {
-    if (v.selected)
-    {
-      populate_property_editor(v);
-      return;  // stop after finding the first one
-    }
-  }
-
-  for (const auto& f : project.building.levels[level_idx].fiducials)
-  {
-    if (f.selected)
-    {
-      populate_property_editor(f);
-      return;  // stop after finding the first one
-    }
-  }
-
-  // if we get here, we never found anything :(
-  clear_property_editor();
-}
-
-QTableWidgetItem* Editor::create_table_item(
-  const QString& str,
-  bool editable)
-{
-  QTableWidgetItem* item = new QTableWidgetItem(str);
-  if (!editable)
-    item->setFlags(Qt::NoItemFlags);
-  else
-    item->setBackground(QBrush(Qt::white));
-  return item;
-}
-
-void Editor::property_editor_set_row(
-  const int row_idx,
-  const QString& label,
-  const QString& value,
-  const bool editable)
-{
-  QTableWidgetItem* label_item = new QTableWidgetItem(label);
-  label_item->setFlags(Qt::NoItemFlags);
-
-  QTableWidgetItem* value_item = new QTableWidgetItem(value);
-  if (!editable)
-    value_item->setFlags(Qt::NoItemFlags);
-  else
-    value_item->setBackground(QBrush(Qt::white));
-
-  property_editor->setItem(row_idx, 0, label_item);
-  property_editor->setItem(row_idx, 1, value_item);
-}
-
-void Editor::property_editor_set_row(
-  const int row_idx,
-  const QString& label,
-  const int& value,
-  const bool editable)
-{
-  property_editor_set_row(row_idx, label, QString::number(value), editable);
-}
-
-void Editor::property_editor_set_row(
-  const int row_idx,
-  const QString& label,
-  const double& value,
-  const int num_decimal_places,
-  const bool editable)
-{
-  property_editor_set_row(
-    row_idx,
-    label,
-    QString::number(value, 'g', num_decimal_places + 1),
-    editable);
-}
-
-void Editor::add_param_button_clicked()
-{
-  const string object_type =
-    add_param_button->property("object_type").toString().toStdString();
-  printf("add param object type: %s\n", object_type.c_str());
-
-  if (object_type == "vertex")
-  {
-    AddParamDialog dialog(this, Vertex::allowed_params);
-    if (dialog.exec() != QDialog::Accepted)
-      return;
-
-    for (auto& v : project.building.levels[level_idx].vertices)
-    {
-      if (v.selected)
-      {
-        v.params[dialog.get_param_name()] = Param(dialog.get_param_type());
-        populate_property_editor(v);
-        setWindowModified(true);
-        return;  // stop after finding the first one
-      }
-    }
-  }
-}
-
-void Editor::delete_param_button_clicked()
-{
-  QMessageBox::about(
-    this,
-    "work in progress",
-    "TODO: something...sorry. For now, hand-edit the YAML.");
-}
-
-void Editor::populate_layers_table()
-{
-  if (project.building.levels.empty())
-    return;// let's not crash...
-  const Level& level = project.building.levels[level_idx];
-  layers_table->blockSignals(true);  // otherwise we get tons of callbacks
-  layers_table->setRowCount(2 + level.layers.size());
-
-  layers_table->blockSignals(true);  // otherwise we get tons of callbacks
-  layers_table_set_row(0, "floorplan", true);
-
-  for (size_t i = 0; i < level.layers.size(); i++)
-  {
-    layers_table_set_row(
-      i + 1,
-      QString::fromStdString(level.layers[i].name),
-      level.layers[i].visible);
-  }
-
-  const int last_row_idx = static_cast<int>(level.layers.size()) + 1;
-  // we'll use the last row for the "Add" button
-  layers_table->setCellWidget(last_row_idx, 0, nullptr);
-  QPushButton* add_button = new QPushButton("Add...", this);
-  layers_table->setCellWidget(last_row_idx, 1, add_button);
-  connect(
-    add_button, &QAbstractButton::clicked,
-    [=]() { this->layer_add_button_clicked(); });
-
-  layers_table->blockSignals(false);  // re-enable callbacks
-}
-
-void Editor::layers_table_set_row(
-  const int row_idx,
-  const QString& label,
-  const bool checked)
-{
-  QCheckBox* checkbox = new QCheckBox(label);
-  checkbox->setChecked(checked);
-  layers_table->setCellWidget(row_idx, 0, checkbox);
-
-  QPushButton* button = new QPushButton("Edit...", this);
-  layers_table->setCellWidget(row_idx, 1, button);
-
-  connect(
-    button, &QAbstractButton::clicked,
-    [=]() { this->layer_edit_button_clicked(label.toStdString()); });
-  connect(
-    checkbox, &QAbstractButton::clicked,
-    [=](bool box_checked)
-    {
-      if (row_idx > 0)
-        project.building.levels[level_idx].layers[row_idx-1].visible =
-        box_checked;
-      create_scene();
-    });
-}
-
-void Editor::layer_edit_button_clicked(const std::string& label)
-{
-  printf("clicked: [%s]\n", label.c_str());
-  if (project.building.levels.empty())
-    return;
-  // find the index of this layer in the current level
-  Level& level = project.building.levels[level_idx];
-  for (size_t i = 0; i < level.layers.size(); i++)
-  {
-    Layer& layer = level.layers[i];
-    if (label != layer.name)
-      continue;
-    LayerDialog* dialog = new LayerDialog(this, layer, true);
-    dialog->show();
-    dialog->raise();
-    dialog->activateWindow();
-    connect(
-      dialog,
-      &LayerDialog::redraw,
-      this,
-      &Editor::create_scene);
-    return;  // only create a dialog for the first name match
-  }
-}
-
-void Editor::layer_add_button_clicked()
-{
-  if (level_idx >= static_cast<int>(project.building.levels.size()))
-    return;// let's not crash (yet)
-  Level& level = project.building.levels[level_idx];
-  Layer layer;
-  LayerDialog layer_dialog(this, layer);
-  if (layer_dialog.exec() != QDialog::Accepted)
-    return;
-  printf("added a layer: [%s]\n", layer.name.c_str());
-  level.layers.push_back(layer);
-  populate_layers_table();
-  setWindowModified(true);
-}
-
-void Editor::populate_property_editor(const Edge& edge)
-{
-  const BuildingLevel& level = project.building.levels[level_idx];
-  const double scale = level.drawing_meters_per_pixel;
-  const Vertex& sv = level.vertices[edge.start_idx];
-  const Vertex& ev = level.vertices[edge.end_idx];
-
-  const double sx = sv.x * scale;
-  const double sy = sv.y * scale;
-  const double ex = ev.x * scale;
-  const double ey = ev.y * scale;
-
-  const double dx = ex - sx;
-  const double dy = ey - sy;
-  const double len = sqrt(dx*dx + dy*dy);
-
-  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
-  property_editor->setRowCount(8 + edge.params.size());
-
-  property_editor_set_row(0, "edge_type", edge.type_to_qstring());
-  property_editor_set_row(1, "start_idx", edge.start_idx);
-  property_editor_set_row(2, "end_idx", edge.end_idx);
-  property_editor_set_row(3, "start x (m)", sx);
-  property_editor_set_row(4, "start y (m)", sy);
-  property_editor_set_row(5, "end x (m)", ex);
-  property_editor_set_row(6, "end y (m)", ey);
-  property_editor_set_row(7, "length (m)", len);
-
-  int row = 8;
-  for (const auto& param : edge.params)
-  {
-    property_editor_set_row(
-      row,
-      QString::fromStdString(param.first),
-      param.second.to_qstring(),
-      true);
-    row++;
-  }
-
-  property_editor->blockSignals(false);  // re-enable callbacks
-}
-
-void Editor::populate_property_editor(const Vertex& vertex)
-{
-  const BuildingLevel& level = project.building.levels[level_idx];
-  const double scale = level.drawing_meters_per_pixel;
-
-  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
-  property_editor->setRowCount(5 + vertex.params.size());
-
-  property_editor_set_row(0, "x (pixels)", vertex.x, 3, true);
-  property_editor_set_row(1, "y (pixels)", vertex.y, 3, true);
-  property_editor_set_row(2, "x (m)", vertex.x * scale);
-  property_editor_set_row(3, "y (m)", -1.0 * vertex.y * scale);
-  property_editor_set_row(
-    4,
-    "name",
-    QString::fromStdString(vertex.name),
-    true);
-
-  int row = 5;
-  for (const auto& param : vertex.params)
-  {
-    property_editor_set_row(
-      row,
-      QString::fromStdString(param.first),
-      param.second.to_qstring(),
-      true);
-    row++;
-  }
-
-  add_param_button->setEnabled(true);
-  add_param_button->setProperty("object_type", QVariant("vertex"));
-
-  property_editor->blockSignals(false);  // re-enable callbacks
-}
-
-void Editor::populate_property_editor(const Fiducial& fiducial)
-{
-  property_editor->blockSignals(true);
-
-  property_editor->setRowCount(1);
-  property_editor_set_row(
-    0,
-    "name",
-    QString::fromStdString(fiducial.name),
-    true);  // true means that this cell value is editable
-
-  property_editor->blockSignals(false);
-}
-
-void Editor::populate_property_editor(const Model& model)
-{
-  printf("populate_property_editor(model)\n");
-  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
-
-  property_editor->setRowCount(4);
-
-  property_editor_set_row(
-    0,
-    "name",
-    QString::fromStdString(model.instance_name),
-    true);
-
-  property_editor_set_row(
-    1,
-    "model_name",
-    QString::fromStdString(model.model_name));
-
-  property_editor_set_row(
-    2,
-    "elevation",
-    model.state.z,
-    3,
-    true);
-
-  property_editor_set_row(
-    3,
-    "static",
-    model.is_static ? QString("true") : QString("false"),
-    true);
-
-  property_editor->blockSignals(false);  // re-enable callbacks
-}
-
-void Editor::populate_property_editor(const Polygon& polygon)
-{
-  printf("populate_property_editor(polygon)\n");
-  property_editor->blockSignals(true);  // otherwise we get tons of callbacks
-
-  property_editor->setRowCount(polygon.params.size());
-
-  int row = 0;
-  for (const auto& param : polygon.params)
-  {
-    property_editor_set_row(
-      row,
-      QString::fromStdString(param.first),
-      param.second.to_qstring(),
-      true);
-    row++;
-  }
-
-  property_editor->blockSignals(false);  // re-enable callbacks
-}
-
-void Editor::clear_property_editor()
-{
-  property_editor->setRowCount(0);
-  add_param_button->setEnabled(false);
-  delete_param_button->setEnabled(false);
-}
-
-void Editor::property_editor_cell_changed(int row, int column)
-{
-  std::string name = property_editor->item(row, 0)->text().toStdString();
-  std::string value = property_editor->item(row, 1)->text().toStdString();
-  printf("property_editor_cell_changed(%d, %d) = param %s\n",
-    row, column, name.c_str());
-
-  for (auto& v : project.building.levels[level_idx].vertices)
-  {
-    if (!v.selected)
-      continue;
-    if (name == "name")
-      v.name = value;
-    else if (name == "x (pixels)")
-      v.x = stof(value);
-    else if (name == "y (pixels)")
-      v.y = stof(value);
-    else
-      v.set_param(name, value);
-    create_scene();
-    setWindowModified(true);
-    return;  // stop after finding the first one
-  }
-
-  for (auto& e : project.building.levels[level_idx].edges)
-  {
-    if (!e.selected)
-      continue;
-    e.set_param(name, value);
-    create_scene();
-    setWindowModified(true);
-    return;  // stop after finding the first one
-  }
-
-  for (auto& f : project.building.levels[level_idx].fiducials)
-  {
-    if (!f.selected)
-      continue;
-    if (name == "name")
-      f.name = value;
-    create_scene();
-    setWindowModified(true);
-    return;  // stop after finding the first one
-  }
-
-  for (auto& p : project.building.levels[level_idx].polygons)
-  {
-    if (!p.selected)
-      continue;
-    p.set_param(name, value);
-    setWindowModified(true);
-    return;  // stop after finding the first one
-  }
-
-  for (auto& m : project.building.levels[level_idx].models)
-  {
-    if (!m.selected)
-      continue;
-    m.set_param(name, value);
-    setWindowModified(true);
-    return; // stop after finding the first one
-  }
-}
-
-bool Editor::create_scene()
-{
-  scene->clear();  // destroys the mouse_motion_* items if they are there
-  project.clear_scene();  // forget all pointers to the graphics items
-  mouse_motion_line = nullptr;
-  mouse_motion_model = nullptr;
-  mouse_motion_ellipse = nullptr;
-  mouse_motion_polygon = nullptr;
-
-  project.draw(scene, level_idx, editor_models);
-
-  return true;
-}
-
-void Editor::draw_mouse_motion_line_item(
-  const double mouse_x,
-  const double mouse_y)
-{
-  double pen_width = 1;
-  QColor color;
-  switch (tool_id)
-  {
-    case TOOL_ADD_LANE:
-      pen_width = 20;
-      color = QColor::fromRgbF(0, 0, 1, 0.5);
-      break;
-    case TOOL_ADD_WALL:
-      pen_width = 5;
-      color = QColor::fromRgbF(0, 0, 1, 0.5);
-      break;
-    case TOOL_ADD_MEAS:
-      pen_width = 5;
-      color = QColor::fromRgbF(1, 0, 1, 0.5);
-      break;
-    default:
-      break;
-  }
-
-  QPen pen(QBrush(color), pen_width, Qt::SolidLine, Qt::RoundCap);
-  const auto& start =
-    project.building.levels[level_idx].vertices[clicked_idx];
-  if (!mouse_motion_line)
-    mouse_motion_line = scene->addLine(start.x, start.y, mouse_x, mouse_y, pen);
-  else
-    mouse_motion_line->setLine(start.x, start.y, mouse_x, mouse_y);
-}
-
-void Editor::remove_mouse_motion_item()
-{
-  if (mouse_motion_line)
-  {
-    scene->removeItem(mouse_motion_line);
-    delete mouse_motion_line;
-    mouse_motion_line = nullptr;
-  }
-  if (mouse_motion_model)
-  {
-    scene->removeItem(mouse_motion_model);
-    delete mouse_motion_model;
-    mouse_motion_model = nullptr;
-  }
-  if (mouse_motion_ellipse)
-  {
-    scene->removeItem(mouse_motion_ellipse);
-    delete mouse_motion_ellipse;
-    mouse_motion_ellipse = nullptr;
-  }
-  if (mouse_motion_polygon)
-  {
-    scene->removeItem(mouse_motion_polygon);
-    delete mouse_motion_polygon;
-    mouse_motion_polygon = nullptr;
-  }
-  mouse_motion_editor_model = nullptr;
-
-  mouse_vertex_idx = -1;
-  mouse_fiducial_idx = -1;
-}
-
-///////////////////////////////////////////////////////////////////////
-// MOUSE HANDLERS
-///////////////////////////////////////////////////////////////////////
-
-void Editor::mouse_select(
-  const MouseType type, QMouseEvent* e, const QPointF& p)
-{
-  if (type != MOUSE_PRESS)
-    return;
-  const QPoint p_global = mapToGlobal(e->pos());
-  const QPoint p_map = map_view->mapFromGlobal(p_global);
-  QGraphicsItem* item = map_view->itemAt(p_map);
-
-  project.mouse_select_press(mode, level_idx, p.x(), p.y(), item);
-
-  // todo: figure out something smarter than this abomination
-  selected_polygon = project.get_selected_polygon(mode, level_idx);
-
-  // todo: be smarter and go find the actual GraphicsItem to avoid
-  // a full repaint here?
-  create_scene();
-  update_property_editor();
-}
-
-void Editor::mouse_add_vertex(
-  const MouseType t, QMouseEvent*, const QPointF& p)
-{
-  if (t == MOUSE_PRESS)
-  {
-    if (mode == MODE_BUILDING || mode == MODE_TRAFFIC)
-      project.building.add_vertex(level_idx, p.x(), p.y());
-    else if (mode == MODE_SCENARIO)
-    {
-      if (project.scenario_idx < 0)
-      {
-        QMessageBox::warning(
-          this,
-          "Add Vertex",
-          "No scenario currently defined.");
-        return;
-      }
-      project.add_scenario_vertex(level_idx, p.x(), p.y());
-    }
-    setWindowModified(true);
-    create_scene();
-  }
-}
-
-void Editor::mouse_add_fiducial(
-  const MouseType t, QMouseEvent*, const QPointF& p)
-{
-  if (t == MOUSE_PRESS)
-  {
-    project.building.add_fiducial(level_idx, p.x(), p.y());
-    setWindowModified(true);
-    create_scene();
-  }
-}
-
-void Editor::mouse_move(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  if (t == MOUSE_PRESS)
-  {
-    Building::NearestItem ni =
-      project.building.nearest_items(level_idx, p.x(), p.y());
-
-    // todo: use QGraphics stuff to see if we clicked a model pixmap...
-    const double model_dist_thresh = 0.5 /
-      project.building.levels[level_idx].drawing_meters_per_pixel;
-
-    if (ni.model_idx >= 0 && ni.model_dist < model_dist_thresh)
-    {
-      // Now we need to find the pixmap item for this model.
-      const Model& model =
-        project.building.levels[level_idx].models[ni.model_idx];
-      mouse_motion_model = get_closest_pixmap_item(
-        QPointF(model.state.x, model.state.y));
-      mouse_model_idx = ni.model_idx;
-    }
-    else if (ni.vertex_idx >= 0 && ni.vertex_dist < 10.0)
-    {
-      mouse_vertex_idx = ni.vertex_idx;
-      // todo: save the QGrahpicsEllipse or group, to avoid full repaints?
-    }
-    else if (ni.fiducial_idx >= 0 && ni.fiducial_dist < 10.0)
-    {
-      mouse_fiducial_idx = ni.fiducial_idx;
-      // todo: save the QGrahpicsEllipse or group, to avoid full repaints?
-    }
-  }
-  else if (t == MOUSE_RELEASE)
-  {
-    mouse_vertex_idx = -1;
-    mouse_fiducial_idx = -1;
-    create_scene();  // this will free mouse_motion_model
-    setWindowModified(true);
-  }
-  else if (t == MOUSE_MOVE)
-  {
-    if (!(e->buttons() & Qt::LeftButton))
-      return;// we only care about mouse-dragging, not just motion
-    printf("mouse move, vertex_idx = %d, fiducial_idx = %d\n",
-      mouse_vertex_idx,
-      mouse_fiducial_idx);
-    if (mouse_motion_model != nullptr)
-    {
-      // we're dragging a model
-      // update both the nav_model data and the pixmap in the scene
-      Model& model =
-        project.building.levels[level_idx].models[mouse_model_idx];
-      model.state.x = p.x();
-      model.state.y = p.y();
-      mouse_motion_model->setPos(p);
-    }
-    else if (mouse_vertex_idx >= 0)
-    {
-      // we're dragging a vertex
-      Vertex& pt =
-        project.building.levels[level_idx].vertices[mouse_vertex_idx];
-      pt.x = p.x();
-      pt.y = p.y();
-      create_scene();
-    }
-    else if (mouse_fiducial_idx >= 0)
-    {
-      Fiducial& f =
-        project.building.levels[level_idx].fiducials[mouse_fiducial_idx];
-      f.x = p.x();
-      f.y = p.y();
-      printf("moved fiducial %d to (%.1f, %.1f)\n",
-        mouse_fiducial_idx,
-        f.x,
-        f.y);
-      create_scene();
-    }
-  }
-}
-
-void Editor::mouse_add_edge(
-  const MouseType t,
-  QMouseEvent* e,
-  const QPointF& p,
-  const Edge::Type& edge_type)
-{
-  QPointF p_aligned(p);
-  if (clicked_idx >= 0 && e->modifiers() & Qt::ShiftModifier)
-  {
-    const auto& start =
-      project.building.levels[level_idx].vertices[clicked_idx];
-    align_point(QPointF(start.x, start.y), p_aligned);
-  }
-
-  if (t == MOUSE_PRESS)
-  {
-    if (e->buttons() & Qt::RightButton)
-    {
-      // right button means "exit edge drawing mode please"
-      clicked_idx = -1;
-      remove_mouse_motion_item();
-      return;
-    }
-
-    const int prev_clicked_idx = clicked_idx;
-    clicked_idx = project.building.nearest_item_index_if_within_distance(
-      level_idx, p_aligned.x(), p_aligned.y(), 10.0, Building::VERTEX);
-
-    if (clicked_idx < 0)
-    {
-      // current click is not on an existing vertex. Add one.
-      project.building.add_vertex(level_idx, p_aligned.x(), p_aligned.y());
-
-      // set the new vertex as "clicked_idx"  todo: encapsulate better
-      clicked_idx =
-        static_cast<int>(
-        project.building.levels[level_idx].vertices.size() - 1);
-    }
-
-    if (prev_clicked_idx < 0)
-      return;// no previous vertex click happened; nothing else to do
-
-    if (clicked_idx == prev_clicked_idx)  // don't create self edge loops
-    {
-      remove_mouse_motion_item();
-      return;
-    }
-
-    if (edge_type != Edge::LANE)
-      project.building.add_edge(
-        level_idx,
-        prev_clicked_idx,
-        clicked_idx,
-        edge_type);
-    else
-    {
-      project.add_lane(
-        level_idx,
-        prev_clicked_idx,
-        clicked_idx);
-    }
-
-    if (edge_type == Edge::DOOR || edge_type == Edge::MEAS)
-    {
-      clicked_idx = -1;  // doors and measurements don't usually chain
-      remove_mouse_motion_item();
-    }
-
-    create_scene();
-    setWindowModified(true);
-  }
-  else if (t == MOUSE_MOVE)
-  {
-    if (clicked_idx < 0)
-      return;
-
-    draw_mouse_motion_line_item(p_aligned.x(), p_aligned.y());
-  }
-}
-
-void Editor::mouse_add_lane(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_edge(t, e, p, Edge::LANE);
-}
-
-void Editor::mouse_add_wall(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_edge(t, e, p, Edge::WALL);
-}
-
-void Editor::mouse_add_meas(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_edge(t, e, p, Edge::MEAS);
-}
-
-void Editor::mouse_add_door(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_edge(t, e, p, Edge::DOOR);
-}
-
-void Editor::mouse_add_model(
-  const MouseType t, QMouseEvent*, const QPointF& p)
-{
-  if (t == MOUSE_PRESS)
-  {
-    if (mouse_motion_editor_model == nullptr)
-      return;
-    project.building.add_model(
-      level_idx,
-      p.x(),
-      p.y(),
-      0.0,
-      M_PI / 2.0,
-      mouse_motion_editor_model->name);
-    /*
-    const int model_row = model_name_list_widget->currentRow();
-    if (model_row < 0)
-      return;  // nothing currently selected. nothing to do.
-    .add_model(level_idx, p.x(), p.y(), 0.0, editor_models[model_row].name);
-    */
-    setWindowModified(true);
-    create_scene();
-  }
-  else if (t == MOUSE_MOVE)
-  {
-    if (mouse_motion_editor_model == nullptr)
-      return;// nothing currently selected. nothing to do.
-    if (mouse_motion_model == nullptr)
-    {
-      const QPixmap pixmap(mouse_motion_editor_model->get_pixmap());
-      mouse_motion_model = scene->addPixmap(pixmap);
-      mouse_motion_model->setOffset(-pixmap.width()/2, -pixmap.height()/2);
-      mouse_motion_model->setScale(
-        mouse_motion_editor_model->meters_per_pixel /
-        project.building.levels[level_idx].drawing_meters_per_pixel);
-    }
-    mouse_motion_model->setPos(p.x(), p.y());
-  }
-}
-
-double Editor::discretize_angle(const double& angle)
-{
-  const double discretization = 45.0 * M_PI / 180.0;
-  return discretization * round(angle / discretization);
-}
-
-void Editor::align_point(const QPointF& start, QPointF& end)
-{
-  if (qAbs(start.x() - end.x()) < qAbs(start.y() - end.y()))
-    end.setX(start.x());
-  else
-    end.setY(start.y());
-}
-
-void Editor::mouse_rotate(
-  const MouseType t, QMouseEvent* mouse_event, const QPointF& p)
-{
-  if (t == MOUSE_PRESS)
-  {
-    clicked_idx = project.building.nearest_item_index_if_within_distance(
-      level_idx,
-      p.x(),
-      p.y(),
-      50.0,
-      Building::MODEL);
-    if (clicked_idx < 0)
-      return;// nothing to do. click wasn't on a model.
-
-    const Model& model =
-      project.building.levels[level_idx].models[clicked_idx];
-    mouse_motion_model = get_closest_pixmap_item(
-      QPointF(model.state.x, model.state.y));
-    QPen pen(Qt::red);
-    pen.setWidth(4);
-    const double r = static_cast<double>(ROTATION_INDICATOR_RADIUS);
-    mouse_motion_ellipse = scene->addEllipse(
-      model.state.x - r,  // ellipse upper-left column
-      model.state.y - r,  // ellipse upper-left row
-      2 * r,  // ellipse width
-      2 * r,  // ellipse height
-      pen);
-    mouse_motion_line = scene->addLine(
-      model.state.x,
-      model.state.y,
-      model.state.x + r * cos(model.state.yaw),
-      model.state.y - r * sin(model.state.yaw),
-      pen);
-  }
-  else if (t == MOUSE_RELEASE)
-  {
-    //remove_mouse_motion_item();
-    if (clicked_idx < 0)
-      return;
-    const Model& model =
-      project.building.levels[level_idx].models[clicked_idx];
-    const double dx = p.x() - model.state.x;
-    const double dy = -(p.y() - model.state.y);  // vertical axis is flipped
-    double mouse_yaw = atan2(dy, dx);
-    if (mouse_event->modifiers() & Qt::ShiftModifier)
-      mouse_yaw = discretize_angle(mouse_yaw);
-    project.building.set_model_yaw(level_idx, clicked_idx, mouse_yaw);
-    clicked_idx = -1;  // we're done rotating it now
-    setWindowModified(true);
-    // now re-render the whole scene (could optimize in the future...)
-    create_scene();
-  }
-  else if (t == MOUSE_MOVE)
-  {
-    if (clicked_idx < 0)
-      return;// nothing currently selected. nothing to do.
-
-    // re-orient the mouse_motion_model item and heading indicator as needed
-    const Model& model =
-      project.building.levels[level_idx].models[clicked_idx];
-    const double dx = p.x() - model.state.x;
-    const double dy = -(p.y() - model.state.y);  // vertical axis is flipped
-    double mouse_yaw = atan2(dy, dx);
-    if (mouse_event->modifiers() & Qt::ShiftModifier)
-      mouse_yaw = discretize_angle(mouse_yaw);
-    const double r = static_cast<double>(ROTATION_INDICATOR_RADIUS);
-    mouse_motion_line->setLine(
-      model.state.x,
-      model.state.y,
-      model.state.x + r * cos(mouse_yaw),
-      model.state.y - r * sin(mouse_yaw));
-
-    if (mouse_motion_model)
-      mouse_motion_model->setRotation(
-        (-mouse_yaw + M_PI / 2.0) * 180.0 / M_PI);
-  }
-}
-
-QGraphicsPixmapItem* Editor::get_closest_pixmap_item(const QPointF& p)
-{
-  // todo: use fancier calls if the scene graph gets so big that a linear
-  // search becomes intolerably slow
-  const QList<QGraphicsItem*> items = scene->items();
-  QGraphicsPixmapItem* pixmap_item = nullptr;
-  double min_dist = 1.0e9;
-  for (const auto item : items)
-  {
-    if (item->type() != QGraphicsPixmapItem::Type)
-      continue;// ignore anything other than the pixmaps (models)
-    const double model_click_distance = QLineF(p, item->pos()).length();
-    const double width = item->boundingRect().width();
-    const double height = item->boundingRect().height();
-    printf("model_click_distance = %.2f bounds = (%.1f, %.1f)\n",
-      model_click_distance, width, height);
-    if (model_click_distance < min_dist)
-    {
-      min_dist = model_click_distance;
-      pixmap_item = qgraphicsitem_cast<QGraphicsPixmapItem*>(item);
-    }
-  }
-  return pixmap_item;
-}
-
-void Editor::mouse_add_polygon(
-  const MouseType t,
-  QMouseEvent* e,
-  const QPointF& p,
-  const Polygon::Type& polygon_type)
-{
-  if (t == MOUSE_PRESS)
-  {
-    if (e->buttons() & Qt::LeftButton)
-    {
-      const Project::NearestItem ni =
-        project.nearest_items(mode, level_idx, p.x(), p.y());
-      clicked_idx = ni.vertex_dist < 10.0 ? ni.vertex_idx : -1;
-      if (clicked_idx < 0)
-        return;// nothing to do. click wasn't on a vertex.
-
-      Vertex* v = nullptr;
-      if (mode == MODE_BUILDING)
-        v = &project.building.levels[level_idx].vertices[clicked_idx];
-      else if (mode == MODE_SCENARIO)
-        v = &project.scenario_level(level_idx)->vertices[clicked_idx];
-
-      v->selected = true;  // todo: colorize it?
-
-      if (mouse_motion_polygon == nullptr)
-      {
-        QVector<QPointF> polygon_vertices;
-        polygon_vertices.append(QPointF(v->x, v->y));
-        QPolygonF polygon(polygon_vertices);
-        mouse_motion_polygon = scene->addPolygon(
-          polygon,
-          QPen(Qt::black),
-          QBrush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5)));
-        mouse_motion_polygon_vertices.clear();
-      }
-
-      // only add vertex_idx is NOT already in the vertex list
-      if (std::find(
-          mouse_motion_polygon_vertices.begin(),
-          mouse_motion_polygon_vertices.end(),
-          clicked_idx) == mouse_motion_polygon_vertices.end())
-        mouse_motion_polygon_vertices.push_back(clicked_idx);
-    }
-    else if (e->buttons() & Qt::RightButton)
-    {
-      if (mouse_motion_polygon == nullptr)
-        return;
-      if (mouse_motion_polygon_vertices.size() >= 3)
-      {
-        Polygon polygon;
-        polygon.type = polygon_type;
-        polygon.create_required_parameters();
-        for (const auto& i : mouse_motion_polygon_vertices)
-        {
-          polygon.vertices.push_back(i);
-        }
-        if (mode == MODE_BUILDING)
-          project.building.levels[level_idx].polygons.push_back(polygon);
-        else if (mode == MODE_SCENARIO)
-          project.scenario_level(level_idx)->polygons.push_back(polygon);
-      }
-      scene->removeItem(mouse_motion_polygon);
-      delete mouse_motion_polygon;
-      mouse_motion_polygon = nullptr;
-
-      setWindowModified(true);
-      project.clear_selection(level_idx);
-      create_scene();
-    }
-  }
-  else if (t == MOUSE_MOVE)
-  {
-    if (mouse_motion_polygon == nullptr)
-      return;
-
-    // first, remove the previous polygon
-    scene->removeItem(mouse_motion_polygon);
-    delete mouse_motion_polygon;
-
-    // now, make the updated polygon
-    QVector<QPointF> polygon_vertices;
-    for (const auto& vertex_idx: mouse_motion_polygon_vertices)
-    {
-      const Vertex* v = nullptr;
-      if (mode == MODE_BUILDING)
-        v = &project.building.levels[level_idx].vertices[vertex_idx];
-      else if (mode == MODE_SCENARIO)
-        v = &project.scenario_level(level_idx)->vertices[vertex_idx];
-
-      polygon_vertices.append(QPointF(v->x, v->y));
-    }
-    polygon_vertices.append(QPointF(p.x(), p.y()));
-
-    // insert the updated polygon into the scene
-    QPolygonF polygon(polygon_vertices);
-    mouse_motion_polygon = scene->addPolygon(
-      polygon,
-      QPen(Qt::black),
-      QBrush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5)));
-  }
-}
-
-void Editor::mouse_add_floor(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_polygon(t, e, p, Polygon::FLOOR);
-}
-
-void Editor::mouse_add_hole(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_polygon(t, e, p, Polygon::HOLE);
-}
-
-void Editor::mouse_add_roi(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  mouse_add_polygon(t, e, p, Polygon::ROI);
-}
-
-void Editor::mouse_edit_polygon(
-  const MouseType t, QMouseEvent* e, const QPointF& p)
-{
-  if (selected_polygon == nullptr)
-    return;// no polygon is selected, nothing to do
-
-  if (t == MOUSE_PRESS)
-  {
-    if (e->buttons() & Qt::RightButton)
-    {
-      const Project::NearestItem ni = project.nearest_items(
-        mode, level_idx, p.x(), p.y());
-      if (ni.vertex_dist > 10.0)
-      {
-        printf("right-click wasn't near a vertex: %.1f\n", ni.vertex_dist);
-        return;  // click wasn't near a vertex
-      }
-      else
-      {
-        printf("removing vertex %d\n", ni.vertex_idx);
-      }
-      selected_polygon->remove_vertex(ni.vertex_idx);
-      setWindowModified(true);
-      create_scene();
-    }
-    else if (e->buttons() & Qt::LeftButton)
-    {
-      mouse_edge_drag_polygon =
-        project.polygon_edge_drag_press(
-        mode,
-        level_idx,
-        selected_polygon,
-        p.x(),
-        p.y());
-      if (mouse_edge_drag_polygon.movable_vertex < 0)
-        return;
-
-      if (mouse_motion_polygon != nullptr)
-      {
-        qWarning("edit_polygon_release() without null mouse_motion_polygon!");
-        return;
-      }
-
-      mouse_motion_polygon = scene->addPolygon(
-        mouse_edge_drag_polygon.polygon,
-        QPen(Qt::black),
-        QBrush(QColor::fromRgbF(1.0, 1.0, 0.5, 0.5)));
-    }
-  }
-  else if (t == MOUSE_RELEASE)
-  {
-    // todo by drag mode (left/right button?)
-    if (mouse_motion_polygon == nullptr)
-    {
-      qInfo("woah! edit_polygon_release() with null mouse_motion_polygon!");
-      return;
-    }
-    printf("replacing vertices of polygon...\n");
-    scene->removeItem(mouse_motion_polygon);
-    delete mouse_motion_polygon;
-    mouse_motion_polygon = nullptr;
-
-    const Project::NearestItem ni = project.nearest_items(
-      mode, level_idx, p.x(), p.y());
-
-    if (ni.vertex_dist > 10.0)
-      return;// nothing to do; didn't release near a vertex
-
-    const int release_vertex_idx = ni.vertex_idx;
-
-    if (std::find(
-        selected_polygon->vertices.begin(),
-        selected_polygon->vertices.end(),
-        release_vertex_idx) != selected_polygon->vertices.end())
-      return;// Release vertex is already in the polygon. Don't do anything.
-
-    selected_polygon->vertices.insert(
-      selected_polygon->vertices.begin() +
-      mouse_edge_drag_polygon.movable_vertex,
-      release_vertex_idx);
-
-    setWindowModified(true);
-    create_scene();
-  }
-  else if (t == MOUSE_MOVE)
-  {
-    if (e->buttons() & Qt::LeftButton)
-    {
-      if (mouse_motion_polygon == nullptr)
-      {
-        qInfo("woah! edit_polygon_release() with null mouse_motion_polygon!");
-        return;
-      }
-      QPolygonF polygon = mouse_motion_polygon->polygon();
-      polygon[mouse_edge_drag_polygon.movable_vertex] = QPointF(p.x(), p.y());
-      mouse_motion_polygon->setPolygon(polygon);
-    }
-  }
-}
-
-void Editor::number_key_pressed(const int n)
-{
-  bool found_edge = false;
-  for (auto& edge : project.building.levels[level_idx].edges)
-  {
-    if (edge.selected && edge.type == Edge::LANE)
-    {
-      edge.set_graph_idx(n);
-      found_edge = true;
-    }
-  }
-  if (found_edge)
-  {
-    create_scene();
-    update_property_editor();
-  }
-
-  project.traffic_map_idx = n;
-  traffic_table->update(project);
-}
-
-bool Editor::maybe_save()
-{
-  if (!isWindowModified())
-    return true;// no need to ask to save the document
-  const QMessageBox::StandardButton button_clicked =
-    QMessageBox::warning(
-    this,
-    "Project not saved!",
-    "Do you want to save your changes?",
-    QMessageBox::Save | QMessageBox::Discard | QMessageBox::Cancel);
-  switch (button_clicked)
-  {
-    case QMessageBox::Save:
-      return project_save();
-    case QMessageBox::Cancel:
-      return false;
-    default:
-      break;
-  }
-  return true;
-}
-
-void Editor::showEvent(QShowEvent* event)
-{
-  QMainWindow::showEvent(event);
-  sim_thread.start();
-}
-
-void Editor::closeEvent(QCloseEvent* event)
-{
-  printf("waiting on sim_thread...\n");
-  sim_thread.requestInterruption();
-  sim_thread.quit();
-  sim_thread.wait();
-
-  // save window geometry
-  QSettings settings;
-  settings.setValue(preferences_keys::window_left, geometry().x());
-  settings.setValue(preferences_keys::window_top, geometry().y());
-  settings.setValue(preferences_keys::window_width, geometry().width());
-  settings.setValue(preferences_keys::window_height, geometry().height());
-
-  // save viewport center and scale
-  const QPoint p_center_window(
-    map_view->viewport()->width() / 2,
-    map_view->viewport()->height() / 2);
-  const QPointF p_center_scene = map_view->mapToScene(p_center_window);
-
-  printf("closeEvent:  (%d, %d) -> (%.1f, %.1f)\n",
-    p_center_window.x(),
-    p_center_window.y(),
-    p_center_scene.x(),
-    p_center_scene.y());
-
-  const double scale = map_view->transform().m11();
-  settings.setValue(preferences_keys::viewport_center_x, p_center_scene.x());
-  settings.setValue(preferences_keys::viewport_center_y, p_center_scene.y());
-  settings.setValue(preferences_keys::viewport_scale, scale);
-
-  if (!project.building.levels.empty())
-    settings.setValue(
-      preferences_keys::level_name,
-      QString::fromStdString(project.building.levels[level_idx].name));
-
-  if (maybe_save())
-    event->accept();
-  else
-    event->ignore();
-}
-
-void Editor::set_tool_visibility(const ToolId id, const bool visible)
-{
-  QAction* a = tools[id];
-  if (a)
-    a->setVisible(visible);
-  else
-    printf("unable to find tool action %d\n", static_cast<int>(id));
-}
-
-void Editor::set_mode(const EditorModeId _mode, const QString& mode_string)
-{
-  if (mode_combo_box->currentText() != mode_string)
-  {
-    mode_combo_box->blockSignals(true);
-    mode_combo_box->setCurrentText(mode_string);
-    mode_combo_box->blockSignals(false);
-  }
-
-  mode = _mode;
-
-  // building tools
-  set_tool_visibility(TOOL_ADD_WALL, mode == MODE_BUILDING);
-  set_tool_visibility(TOOL_ADD_MEAS, mode == MODE_BUILDING);
-  set_tool_visibility(TOOL_ADD_DOOR, mode == MODE_BUILDING);
-  set_tool_visibility(TOOL_ADD_MODEL, mode == MODE_BUILDING);
-  set_tool_visibility(TOOL_ADD_FLOOR, mode == MODE_BUILDING);
-  set_tool_visibility(TOOL_ADD_HOLE, mode == MODE_BUILDING);
-  set_tool_visibility(TOOL_ADD_FIDUCIAL, mode == MODE_BUILDING);
-
-  // traffic tools
-  set_tool_visibility(TOOL_ADD_LANE, mode == MODE_TRAFFIC);
-
-  // scenario tools
-  set_tool_visibility(TOOL_ADD_ROI, mode == MODE_SCENARIO);
-
-  // "multi-purpose" tools
-  set_tool_visibility(TOOL_EDIT_POLYGON, mode != MODE_TRAFFIC);
-}
-
-void Editor::update_tables()
-{
-  populate_layers_table();
-  level_table->update(project.building);
-  lift_table->update(project.building);
-  scenario_table->update(project);
-  traffic_table->update(project);
-}
-
-void Editor::sim_reset()
-{
-  printf("TODO: sim_reset()\n");
-  // todo: signal to the sim thread to reset the project
-}
-
-void Editor::sim_play_pause()
-{
-  printf("sim_play_pause()\n");
-  project.sim_is_paused = !project.sim_is_paused;
-}
-
-#ifdef HAS_OPENCV
-void Editor::record_start_stop()
-{
-  is_recording = !is_recording;
-}
-
-void Editor::record_frame_to_video()
-{
-  if (!is_recording)
-    return;
-
-  QPixmap pixmap = map_view->viewport()->grab();
-  const int w = pixmap.size().width();
-  const int h = pixmap.size().height();
-  QImage image(pixmap.toImage());
-  // int format = static_cast<int>(image.format());
-  cv::Mat mat(
-    h,
-    w,
-    CV_8UC4,
-    const_cast<uchar*>(image.bits()),
-    static_cast<size_t>(image.bytesPerLine()));
-  cv::Mat mat_rgb_swap;
-  cv::cvtColor(mat, mat_rgb_swap, cv::COLOR_RGBA2BGRA);
-
-  if (video_writer == nullptr)
-  {
-    printf("initializing video writer...\n");
-    video_writer =
-      new cv::VideoWriter(
-      "test.avi",
-      cv::VideoWriter::fourcc('M', 'J', 'P', 'G'),
-      30,
-      cv::Size(w, h));
-  }
-
-  video_writer->write(mat_rgb_swap);
-}
-#endif
-
-void Editor::sim_tick()
-{
-  // called from sim thread
-
-  if (!project.sim_is_paused)
-    project.sim_tick();
-}
diff --git a/traffic_editor/gui/editor.h b/traffic_editor/gui/editor.h
deleted file mode 100644
index 2b60565..0000000
--- a/traffic_editor/gui/editor.h
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef EDITOR_H
-#define EDITOR_H
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include <QGraphicsItem>
-#include <QGraphicsEllipseItem>
-#include <QGraphicsPixmapItem>
-#include <QGraphicsPolygonItem>
-#include <QGraphicsScene>
-#include <QMainWindow>
-#include <QSettings>
-
-#include "project.h"
-#include "traffic_editor/editor_model.h"
-#include "editor_mode_id.h"
-#include "sim_thread.h"
-
-class BuildingLevelTable;
-class MapView;
-class Level;
-class LiftTable;
-class ScenarioTable;
-class TrafficTable;
-
-#ifdef HAS_OPENCV
-namespace cv {
-class VideoWriter;
-}
-#endif
-
-QT_BEGIN_NAMESPACE
-class QAction;
-class QButtonGroup;
-class QComboBox;
-class QGraphicsView;
-class QHBoxLayout;
-class QLabel;
-class QLineEdit;
-class QListWidget;
-class QMenu;
-class QMouseEvent;
-class QPushButton;
-class QTableWidget;
-class QTableWidgetItem;
-class QTabWidget;
-class QTimer;
-class QToolButton;
-QT_END_NAMESPACE
-
-
-class Editor : public QMainWindow
-{
-  Q_OBJECT
-
-public:
-  Editor();
-  ~Editor();
-
-  static Editor* get_instance();
-
-  /// Load a project, replacing the current project being edited
-  bool load_project(const QString& filename);
-
-  /// Attempt to load the most recently saved project, just for convenience
-  /// when starting the application since often we want to 'resume' editing.
-  bool load_previous_project();
-
-  /// Attempt to restore the previous viewport scale and center point
-  void restore_previous_viewport();
-
-protected:
-  void mousePressEvent(QMouseEvent* e);
-  void mouseReleaseEvent(QMouseEvent* e);
-  void mouseMoveEvent(QMouseEvent* e);
-  void keyPressEvent(QKeyEvent* event);
-  void closeEvent(QCloseEvent* event);
-  void showEvent(QShowEvent* event) override;
-
-private:
-  EditorModeId mode = MODE_BUILDING;
-
-  void set_mode(const EditorModeId _mode, const QString& mode_string);
-
-  enum ToolId
-  {
-    TOOL_SELECT = 1,
-    TOOL_ADD_VERTEX,
-    TOOL_MOVE,
-    TOOL_ADD_LANE,
-    TOOL_ADD_WALL,
-    TOOL_ADD_MEAS,
-    TOOL_ADD_DOOR,
-    TOOL_ADD_MODEL,
-    TOOL_ROTATE,
-    TOOL_ADD_FLOOR,
-    TOOL_EDIT_POLYGON,
-    TOOL_ADD_ZONE,
-    TOOL_ADD_FIDUCIAL,
-    TOOL_ADD_ROI,
-    TOOL_ADD_HOLE,
-  } tool_id = TOOL_SELECT;
-
-  std::map<ToolId, QAction*> tools;
-  void set_tool_visibility(const ToolId id, const bool visible);
-
-  /////////////////
-  // MENU ACTIONS
-  void project_new();
-  void project_open();
-  bool project_save();
-
-  bool maybe_save();
-  void edit_preferences();
-  void edit_building_properties();
-  void edit_project_properties();
-  void edit_transform();
-
-  void level_add();
-  void level_edit();
-  void update_level_buttons();
-
-  void zoom_fit();
-  void view_models();
-
-  void help_about();
-
-  bool is_mouse_event_in_map(QMouseEvent* e, QPointF& p_scene);
-
-  QToolBar* toolbar;
-  QToolButton* create_tool_button(
-    const ToolId id,
-    const QString& icon_filename,
-    const QString& tooltip);
-  void tool_toggled(int id, bool checked);
-
-  QComboBox* mode_combo_box;
-
-/////////////////////////////
-  static Editor* instance;  // there will only be one instance
-
-  Project project;
-  int level_idx = 0;  // level that we are currently editing
-  int clicked_idx = -1;  // point most recently clicked
-  //int polygon_idx = -1;  // currently selected polygon
-  Polygon* selected_polygon = nullptr;
-
-  QButtonGroup* level_button_group;
-  QHBoxLayout* level_button_hbox_layout;
-  QGraphicsScene* scene;
-  MapView* map_view;
-
-  QAction* save_action;
-  QAction* zoom_in_action, * zoom_out_action;
-  QAction* zoom_normal_action, * zoom_fit_action;
-  QAction* view_models_action;
-
-  const QString tool_id_to_string(const int id);
-  QButtonGroup* tool_button_group;
-
-  QTabWidget* right_tab_widget;
-
-  QTableWidget* create_tabbed_table();
-  void update_tables();
-
-  QTableWidget* layers_table;
-  void populate_layers_table();
-  void layers_table_set_row(
-    const int row_idx,
-    const QString& label,
-    const bool checked);
-  void layer_edit_button_clicked(const std::string& label);
-  void layer_add_button_clicked();
-
-  BuildingLevelTable* level_table;
-  LiftTable* lift_table;
-  ScenarioTable* scenario_table;
-  TrafficTable* traffic_table;
-
-  QTableWidget* property_editor;
-  void update_property_editor();
-  void clear_property_editor();
-  void populate_property_editor(const Edge& edge);
-  void populate_property_editor(const Model& model);
-  void populate_property_editor(const Vertex& vertex);
-  void populate_property_editor(const Fiducial& fiducial);
-  void populate_property_editor(const Polygon& polygon);
-
-  QTableWidgetItem* create_table_item(const QString& str,
-    bool editable = false);
-  void property_editor_cell_changed(int row, int column);
-  void property_editor_set_row(
-    const int row_idx,
-    const QString& label,
-    const QString& value,
-    const bool editable = false);
-  void property_editor_set_row(
-    const int row_idx,
-    const QString& label,
-    const int& value,
-    const bool editable = false);
-  void property_editor_set_row(
-    const int row_idx,
-    const QString& label,
-    const double& value,
-    const int max_decimal_places = 3,
-    const bool editable = false);
-  QPushButton* add_param_button, * delete_param_button;
-  void add_param_button_clicked();
-  void delete_param_button_clicked();
-
-  QAction* sim_reset_action;
-  QAction* sim_play_pause_action;
-  void sim_reset();
-  void sim_play_pause();
-  SimThread sim_thread;
-
-public:
-  void sim_tick();  // called by SimThread
-
-private:
-
-#ifdef HAS_OPENCV
-  QAction* record_start_stop_action;
-  bool is_recording = false;
-  void record_start_stop();
-  void record_frame_to_video();
-  cv::VideoWriter* video_writer = nullptr;
-#endif
-
-  std::vector<EditorModel> editor_models;
-  EditorModel* mouse_motion_editor_model = nullptr;
-  void load_model_names();
-
-  bool create_scene();
-
-  const static int ROTATION_INDICATOR_RADIUS = 50;
-  QGraphicsLineItem* mouse_motion_line = nullptr;
-  QGraphicsEllipseItem* mouse_motion_ellipse = nullptr;
-  QGraphicsPixmapItem* mouse_motion_model = nullptr;
-  QGraphicsPolygonItem* mouse_motion_polygon = nullptr;
-
-  int mouse_model_idx = -1;
-  int mouse_vertex_idx = -1;
-  int mouse_fiducial_idx = -1;
-  std::vector<int> mouse_motion_polygon_vertices;
-  //int mouse_motion_polygon_vertex_idx = -1;
-  Polygon::EdgeDragPolygon mouse_edge_drag_polygon;
-
-  void draw_mouse_motion_line_item(const double mouse_x, const double mouse_y);
-  void remove_mouse_motion_item();
-
-  void number_key_pressed(const int n);
-
-  // mouse handlers for various tools
-  enum MouseType
-  {
-    MOUSE_UNDEFINED = 0,
-    MOUSE_PRESS = 1,
-    MOUSE_RELEASE = 2,
-    MOUSE_MOVE = 3
-  };
-
-  void mouse_event(const MouseType t, QMouseEvent* e);
-
-  // helper function to avoid repeating lots of "add edge" code
-  void mouse_add_edge(
-    const MouseType t,
-    QMouseEvent* e,
-    const QPointF& p,
-    const Edge::Type& edge_type);
-
-  // helper function to avoid repeating lots of "add polygon" code
-  void mouse_add_polygon(
-    const MouseType t,
-    QMouseEvent* e,
-    const QPointF& p,
-    const Polygon::Type& polygon_type);
-
-  QGraphicsPixmapItem* get_closest_pixmap_item(const QPointF& p);
-  double discretize_angle(const double& angle);
-  void align_point(const QPointF& start, QPointF& end);
-
-  void mouse_select(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_move(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_rotate(const MouseType t, QMouseEvent* e, const QPointF& p);
-
-  void mouse_add_vertex(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_fiducial(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_lane(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_wall(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_meas(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_door(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_model(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_floor(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_hole(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_add_roi(const MouseType t, QMouseEvent* e, const QPointF& p);
-  void mouse_edit_polygon(const MouseType t, QMouseEvent* e, const QPointF& p);
-
-  QPointF previous_mouse_point;
-
-  QTimer* scene_update_timer;
-  void scene_update_timer_timeout();
-};
-
-#endif
diff --git a/traffic_editor/gui/editor_mode_id.h b/traffic_editor/gui/editor_mode_id.h
deleted file mode 100644
index a8677f9..0000000
--- a/traffic_editor/gui/editor_mode_id.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef EDITOR_MODE_ID_H
-#define EDITOR_MODE_ID_H
-
-enum EditorModeId
-{
-  MODE_BUILDING = 1,
-  MODE_TRAFFIC = 2,
-  MODE_SCENARIO = 3
-};
-
-#endif
diff --git a/traffic_editor/gui/editor_model.cpp b/traffic_editor/gui/editor_model.cpp
deleted file mode 100644
index 72cb6ec..0000000
--- a/traffic_editor/gui/editor_model.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-
-#include <QDir>
-#include <QImage>
-#include <QImageReader>
-#include <QSettings>
-
-#include "traffic_editor/editor_model.h"
-
-using std::string;
-
-
-EditorModel::EditorModel(const string _name, const double _meters_per_pixel)
-: name(_name),
-  name_lowercase(_name),
-  meters_per_pixel(_meters_per_pixel)
-{
-  // make a lowercase copy for fast auto-complete
-  std::transform(
-    name_lowercase.begin(),
-    name_lowercase.end(),
-    name_lowercase.begin(),
-    [](unsigned char c) { return std::tolower(c); });
-}
-
-EditorModel::~EditorModel()
-{
-}
-
-QPixmap EditorModel::get_pixmap()
-{
-  if (!pixmap.isNull())
-    return pixmap;
-
-  // if we get here, we have to load the image from disk and generate pixmap
-
-  const QString THUMBNAIL_PATH_KEY("editor/thumbnail_path");
-  QSettings settings;
-  QString thumbnail_path(settings.value(THUMBNAIL_PATH_KEY).toString());
-
-  string filename =
-    thumbnail_path.toStdString() +
-    "/images/cropped/" +
-    name +
-    string(".png");
-  // qInfo("loading: [%s]", filename.c_str());
-  QImageReader image_reader(QString::fromStdString(filename));
-  image_reader.setAutoTransform(true);  // not sure what this does
-  QImage image = image_reader.read();
-  if (image.isNull())
-  {
-    qWarning("unable to read %s: %s",
-      filename.c_str(),
-      qUtf8Printable(image_reader.errorString()));
-    return QPixmap();
-  }
-  pixmap = QPixmap::fromImage(image);
-  return pixmap;
-}
diff --git a/traffic_editor/gui/fiducial.cpp b/traffic_editor/gui/fiducial.cpp
deleted file mode 100644
index 19d3905..0000000
--- a/traffic_editor/gui/fiducial.cpp
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <cmath>
-
-#include <QGraphicsScene>
-#include <QGraphicsSimpleTextItem>
-
-#include "traffic_editor/fiducial.h"
-using std::string;
-
-Fiducial::Fiducial()
-{
-}
-
-Fiducial::Fiducial(double _x, double _y, const string& _name)
-: x(_x), y(_y), name(_name)
-{
-}
-
-void Fiducial::from_yaml(const YAML::Node& data)
-{
-  if (!data.IsSequence())
-    throw std::runtime_error("Vertex::from_yaml expected a sequence");
-  x = data[0].as<double>();
-  y = data[1].as<double>();
-  name = data[2].as<string>();
-}
-
-YAML::Node Fiducial::to_yaml() const
-{
-  // This is in image space. I think it's safe to say nobody is clicking
-  // with more than 1/1000 precision inside a single pixel.
-  YAML::Node node;
-  node.SetStyle(YAML::EmitterStyle::Flow);
-  node.push_back(std::round(x * 1000.0) / 1000.0);
-  node.push_back(std::round(y * 1000.0) / 1000.0);
-  node.push_back(name);
-  return node;
-}
-
-void Fiducial::draw(
-  QGraphicsScene* scene,
-  const double meters_per_pixel) const
-{
-  const double a = 0.5;
-  const QColor color = QColor::fromRgbF(0.0, 0.0, 1.0, a);
-  const QColor selected_color = QColor::fromRgbF(1.0, 0.0, 0.0, a);
-
-  QPen pen(selected ? selected_color : color);
-  pen.setWidth(0.2 / meters_per_pixel);
-  const double radius = 0.5 / meters_per_pixel;
-
-  scene->addEllipse(
-    x - radius,
-    y - radius,
-    2 * radius,
-    2 * radius,
-    pen);
-  scene->addLine(x, y - 2 * radius, x, y + 2 * radius, pen);
-  scene->addLine(x - 2 * radius, y, x + 2 * radius, y, pen);
-
-  if (!name.empty())
-  {
-    QGraphicsSimpleTextItem* item = scene->addSimpleText(
-      QString::fromStdString(name));
-    item->setBrush(QColor(0, 0, 255, 255));
-    item->setPos(x, y + radius);
-  }
-}
-
-double Fiducial::distance(const Fiducial& f)
-{
-  const double dx = f.x - x;
-  const double dy = f.y - y;
-  return std::sqrt(dx*dx + dy*dy);
-}
diff --git a/traffic_editor/gui/layer.cpp b/traffic_editor/gui/layer.cpp
deleted file mode 100644
index e8380a2..0000000
--- a/traffic_editor/gui/layer.cpp
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <QImageReader>
-#include "traffic_editor/layer.h"
-using std::string;
-using std::vector;
-
-Layer::Layer()
-{
-}
-
-Layer::~Layer()
-{
-}
-
-bool Layer::from_yaml(const std::string& _name, const YAML::Node& y)
-{
-  if (!y.IsMap())
-    throw std::runtime_error("Layer::from_yaml() expected a map");
-  name = _name;
-  filename = y["filename"].as<string>();
-  meters_per_pixel = y["meters_per_pixel"].as<double>();
-  translation_x = y["translation_x"].as<double>();
-  translation_y = y["translation_y"].as<double>();
-  rotation = y["rotation"].as<double>();
-  if (y["visible"])
-    visible = y["visible"].as<bool>();
-
-  // now try to load the image
-  QImageReader image_reader(QString::fromStdString(filename));
-  image_reader.setAutoTransform(true);
-  QImage image = image_reader.read();
-  if (image.isNull())
-  {
-    qWarning("unable to read %s: %s",
-      qUtf8Printable(QString::fromStdString(filename)),
-      qUtf8Printable(image_reader.errorString()));
-    return false;
-  }
-  image = image.convertToFormat(QImage::Format_Grayscale8);
-  pixmap = QPixmap::fromImage(image);
-  printf("successfully opened %s\n", filename.c_str());
-
-  return true;
-}
-
-YAML::Node Layer::to_yaml() const
-{
-  YAML::Node y;
-  y.SetStyle(YAML::EmitterStyle::Flow);
-  y["filename"] = filename;
-  y["meters_per_pixel"] = meters_per_pixel;
-  y["translation_x"] = translation_x;
-  y["translation_y"] = translation_y;
-  y["rotation"] = rotation;
-  y["visible"] = visible;
-  return y;
-}
diff --git a/traffic_editor/gui/layer_dialog.cpp b/traffic_editor/gui/layer_dialog.cpp
deleted file mode 100644
index 261c3eb..0000000
--- a/traffic_editor/gui/layer_dialog.cpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "layer_dialog.h"
-#include <QtWidgets>
-
-
-LayerDialog::LayerDialog(QWidget* parent, Layer& _layer, bool edit_mode)
-: QDialog(parent),
-  layer(_layer),
-  _edit_mode(edit_mode)
-{
-  setWindowTitle("Layer Properties");
-  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  bottom_buttons_layout->addWidget(ok_button);
-  connect(
-    ok_button, &QAbstractButton::clicked,
-    this, &LayerDialog::ok_button_clicked);
-
-  // When using this dialog in "edit mode," it is modeless and instantly
-  // updating, so there is no "cancel" function.
-  if (!edit_mode)
-  {
-    cancel_button = new QPushButton("Cancel", this);
-    bottom_buttons_layout->addWidget(cancel_button);
-    connect(
-      cancel_button, &QAbstractButton::clicked,
-      this, &QDialog::reject);
-  }
-
-  QHBoxLayout* name_hbox_layout = new QHBoxLayout;
-  name_line_edit = new QLineEdit(QString::fromStdString(layer.name), this);
-  name_hbox_layout->addWidget(new QLabel("name:"));
-  name_hbox_layout->addWidget(name_line_edit);
-
-  QHBoxLayout* filename_layout = new QHBoxLayout;
-  filename_line_edit = new QLineEdit(
-    QString::fromStdString(layer.filename), this);
-  filename_button = new QPushButton("Find...", this);
-  filename_layout->addWidget(new QLabel("image:"));
-  filename_layout->addWidget(filename_line_edit);
-  filename_layout->addWidget(filename_button);
-  connect(
-    filename_button, &QAbstractButton::clicked,
-    this, &LayerDialog::filename_button_clicked);
-  connect(
-    filename_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &LayerDialog::filename_line_edited);
-
-  QHBoxLayout* scale_hbox_layout = new QHBoxLayout;
-  scale_hbox_layout->addWidget(new QLabel("Meters per pixel:"));
-  scale_line_edit = new QLineEdit(
-    QString::number(layer.meters_per_pixel),
-    this);
-  scale_hbox_layout->addWidget(scale_line_edit);
-
-  QHBoxLayout* translation_x_hbox_layout = new QHBoxLayout;
-  translation_x_hbox_layout->addWidget(new QLabel("X translation (meters):"));
-  translation_x_line_edit = new QLineEdit(
-    QString::number(layer.translation_x),
-    this);
-  translation_x_hbox_layout->addWidget(translation_x_line_edit);
-
-  QHBoxLayout* translation_y_hbox_layout = new QHBoxLayout;
-  translation_y_hbox_layout->addWidget(new QLabel("Y translation (meters):"));
-  translation_y_line_edit = new QLineEdit(
-    QString::number(layer.translation_y),
-    this);
-  translation_y_hbox_layout->addWidget(translation_y_line_edit);
-
-  QHBoxLayout* rotation_hbox_layout = new QHBoxLayout;
-  rotation_hbox_layout->addWidget(new QLabel("Rotation (radians):"));
-  rotation_line_edit = new QLineEdit(
-    QString::number(layer.rotation),
-    this);
-  rotation_hbox_layout->addWidget(rotation_line_edit);
-
-  QVBoxLayout* vbox_layout = new QVBoxLayout;
-  vbox_layout->addLayout(name_hbox_layout);
-  vbox_layout->addLayout(filename_layout);
-  vbox_layout->addLayout(scale_hbox_layout);
-  vbox_layout->addLayout(translation_x_hbox_layout);
-  vbox_layout->addLayout(translation_y_hbox_layout);
-  vbox_layout->addLayout(rotation_hbox_layout);
-  // todo: some sort of separator (?)
-  vbox_layout->addLayout(bottom_buttons_layout);
-
-  connect(
-    filename_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &LayerDialog::update_layer);
-
-  connect(
-    scale_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &LayerDialog::update_layer);
-
-  connect(
-    translation_x_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &LayerDialog::update_layer);
-
-  connect(
-    translation_y_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &LayerDialog::update_layer);
-
-  connect(
-    rotation_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &LayerDialog::update_layer);
-
-  setLayout(vbox_layout);
-}
-
-LayerDialog::~LayerDialog()
-{
-}
-
-void LayerDialog::filename_button_clicked()
-{
-  QFileDialog file_dialog(this, "Find Image");
-  file_dialog.setFileMode(QFileDialog::ExistingFile);
-  file_dialog.setNameFilter("*.png");
-  if (file_dialog.exec() != QDialog::Accepted)
-  {
-    return;  // user clicked 'cancel'
-  }
-  const QString filename = file_dialog.selectedFiles().first();
-  if (!QFileInfo(filename).exists())
-  {
-    QMessageBox::critical(
-      this,
-      "Image file does not exist",
-      "File does not exist.");
-    return;
-  }
-  filename_line_edit->setText(
-    QDir::current().relativeFilePath(filename));
-}
-
-void LayerDialog::ok_button_clicked()
-{
-  if (!filename_line_edit->text().isEmpty())
-  {
-    // make sure the drawing file exists
-    if (!QFileInfo(filename_line_edit->text()).exists())
-    {
-      QMessageBox::critical(
-        this,
-        "Image file must exist",
-        "Image file must exist");
-      return;
-    }
-  }
-  /*
-  // todo: figure out how to test for valid numeric values;
-  // this doesn't work but there must be a similar function somewhere
-  if (!x_line_edit->text().isNumber() || !y_line_edit->text().isNumber()) {
-    QMessageBox::critical(
-        this,
-        "X and Y dimensions must be numbers",
-        "X and Y dimensions must be numbers");
-    return;
-  }
-  */
-  if (name_line_edit->text().isEmpty())
-  {
-    QMessageBox::critical(
-      this,
-      "Name must not be empty",
-      "Name must not be empty");
-    return;
-  }
-  update_layer();
-
-  accept();
-}
-
-void LayerDialog::filename_line_edited(const QString& /*text*/)
-{
-  // todo: render on parent if file exists?
-}
-
-void LayerDialog::update_layer()
-{
-  layer.name = name_line_edit->text().toStdString();
-  layer.filename = filename_line_edit->text().toStdString();
-  layer.rotation = rotation_line_edit->text().toDouble();
-  layer.translation_x = translation_x_line_edit->text().toDouble();
-  layer.translation_y = translation_y_line_edit->text().toDouble();
-  layer.meters_per_pixel = scale_line_edit->text().toDouble();
-  emit redraw();
-}
diff --git a/traffic_editor/gui/layer_dialog.h b/traffic_editor/gui/layer_dialog.h
deleted file mode 100644
index bbbf209..0000000
--- a/traffic_editor/gui/layer_dialog.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LAYER_DIALOG_H
-#define LAYER_DIALOG_H
-
-#include <QDialog>
-#include <QObject>
-#include "traffic_editor/layer.h"
-class QLineEdit;
-
-
-class LayerDialog : public QDialog
-{
-  Q_OBJECT
-
-public:
-  LayerDialog(QWidget* parent, Layer& _layer, bool edit_mode = true);
-  ~LayerDialog();
-
-private:
-  Layer& layer;
-  bool _edit_mode = true;
-
-  QLineEdit* name_line_edit;
-  QLineEdit* filename_line_edit;
-  QLineEdit* scale_line_edit;
-  QLineEdit* translation_x_line_edit;
-  QLineEdit* translation_y_line_edit;
-  QLineEdit* rotation_line_edit;
-
-  QPushButton* filename_button;
-  QPushButton* ok_button, * cancel_button;
-
-  void update_layer();
-
-private slots:
-  void filename_button_clicked();
-  void ok_button_clicked();
-  void filename_line_edited(const QString& text);
-
-signals:
-  void redraw();
-};
-
-#endif
diff --git a/traffic_editor/gui/level.cpp b/traffic_editor/gui/level.cpp
deleted file mode 100644
index 9e2a37f..0000000
--- a/traffic_editor/gui/level.cpp
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-#include <cmath>
-
-#include <QGraphicsScene>
-#include <QImage>
-#include <QImageReader>
-
-#include "traffic_editor/level.h"
-using std::string;
-using std::vector;
-
-
-Level::Level()
-{
-}
-
-Level::~Level()
-{
-}
-
-void Level::load_yaml_edge_sequence(
-  const YAML::Node& data,
-  const char* sequence_name,
-  const Edge::Type type)
-{
-  if (!data[sequence_name] || !data[sequence_name].IsSequence())
-    return;
-
-  const YAML::Node& yl = data[sequence_name];
-  for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
-  {
-    Edge e;
-    e.from_yaml(*it, type);
-    edges.push_back(e);
-  }
-}
-
-double Level::point_to_line_segment_distance(
-  const double x, const double y,
-  const double x0, const double y0,
-  const double x1, const double y1,
-  double& x_proj, double& y_proj)
-{
-  // this portion figures out which edge is closest to (x, y) by repeatedly
-  // testing the distance from the click to each edge in the polygon, using
-  // geometry similar to that explained in:
-  // https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
-
-  const double dx = x1 - x0;
-  const double dy = y1 - y0;
-  const double segment_length_squared = dx*dx + dy*dy;
-
-  const double dx0 = x - x0;
-  const double dy0 = y - y0;
-  const double dot = dx0*dx + dy0*dy;
-  const double t = std::max(
-    0.0,
-    std::min(1.0, dot / segment_length_squared));
-
-  x_proj = x0 + t * dx;
-  y_proj = y0 + t * dy;
-
-  const double dx_proj = x - x_proj;
-  const double dy_proj = y - y_proj;
-
-  const double dist = std::sqrt(dx_proj * dx_proj + dy_proj * dy_proj);
-
-  /*
-  printf("   p=(%.1f, %.1f) p0=(%.1f, %.1f) p1=(%.1f, %.1f) t=%.3f proj=(%.1f, %.1f) dist=%.3f\n",
-      x, y, x0, y0, x1, y1, t, x_proj, y_proj, dist);
-  */
-
-  return dist;
-}
-
-/*
- * This function returns the index of the polygon vertex that will be
- * 'split' by the newly created edge
- */
-Polygon::EdgeDragPolygon Level::polygon_edge_drag_press(
-  const Polygon* polygon,
-  const double x,
-  const double y)
-{
-  Polygon::EdgeDragPolygon edp;
-
-  if (polygon == nullptr || polygon->vertices.empty())
-    return edp;
-
-  // cruise along all possible line segments and calculate the distance
-  // to this point
-
-  int min_idx = 0;
-  double min_dist = 1.0e9;
-
-  for (size_t v0_idx = 0; v0_idx < polygon->vertices.size(); v0_idx++)
-  {
-    const size_t v1_idx =
-      v0_idx < polygon->vertices.size() - 1 ? v0_idx + 1 : 0;
-    const size_t v0 = polygon->vertices[v0_idx];
-    const size_t v1 = polygon->vertices[v1_idx];
-
-    const double x0 = vertices[v0].x;
-    const double y0 = vertices[v0].y;
-    const double x1 = vertices[v1].x;
-    const double y1 = vertices[v1].y;
-
-    double x_proj = 0, y_proj = 0;
-    const double dist = point_to_line_segment_distance(
-      x, y, x0, y0, x1, y1, x_proj, y_proj);
-
-    if (dist < min_dist)
-    {
-      min_idx = v0;
-      min_dist = dist;
-
-      // save the nearest projected point to help debug this visually
-      polygon_edge_proj_x = x_proj;
-      polygon_edge_proj_y = y_proj;
-    }
-  }
-
-  // create the mouse motion polygon and insert a new edge
-  QVector<QPointF> polygon_vertices;
-  for (size_t i = 0; i < polygon->vertices.size(); i++)
-  {
-    const int v_idx = polygon->vertices[i];
-    const Vertex& v = vertices[v_idx];
-    polygon_vertices.append(QPointF(v.x, v.y));
-    if (v_idx == min_idx)
-    {
-      polygon_vertices.append(QPointF(x, y));  // current mouse location
-      edp.movable_vertex = i + 1;
-    }
-  }
-  edp.polygon = QPolygonF(polygon_vertices);
-
-  return edp;
-}
-
-bool Level::parse_vertices(const YAML::Node& _data)
-{
-  if (_data["vertices"] && _data["vertices"].IsSequence())
-  {
-    const YAML::Node& pts = _data["vertices"];
-    for (YAML::const_iterator it = pts.begin(); it != pts.end(); ++it)
-    {
-      Vertex v;
-      v.from_yaml(*it);
-      vertices.push_back(v);
-    }
-  }
-  return true;
-}
-
-void Level::add_vertex(const double x, const double y)
-{
-  vertices.push_back(Vertex(x, y));
-}
diff --git a/traffic_editor/gui/lift.cpp b/traffic_editor/gui/lift.cpp
deleted file mode 100644
index fb8bae0..0000000
--- a/traffic_editor/gui/lift.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-#include <cmath>
-
-#include <QGraphicsScene>
-#include <QGraphicsSimpleTextItem>
-
-#include "traffic_editor/lift.h"
-using std::string;
-
-
-Lift::Lift()
-{
-}
-
-void Lift::from_yaml(const std::string& _name, const YAML::Node& data,
-  const std::vector<BuildingLevel>& levels)
-{
-  if (!data.IsMap())
-    throw std::runtime_error("Lift::from_yaml() expected a map");
-  x = data["x"].as<double>();
-  y = data["y"].as<double>();
-  yaw = data["yaw"].as<double>();
-  name = _name;
-  reference_floor_name = data["reference_floor_name"].as<string>();
-  if (data["initial_floor_name"])
-    initial_floor_name = data["initial_floor_name"].as<string>();
-  else
-    initial_floor_name = reference_floor_name;
-  width = data["width"].as<double>();
-  depth = data["depth"].as<double>();
-
-  if (data["doors"] && data["doors"].IsMap())
-  {
-    const YAML::Node& yd = data["doors"];
-    for (YAML::const_iterator it = yd.begin(); it != yd.end(); ++it)
-    {
-      LiftDoor door;
-      door.from_yaml(it->first.as<string>(), it->second);
-      doors.push_back(door);
-    }
-  }
-
-  if (data["highest_floor"])
-    highest_floor = data["highest_floor"].as<string>();
-  if (data["lowest_floor"])
-    lowest_floor = data["lowest_floor"].as<string>();
-  for (const auto& level : levels)
-  {
-    if (level.name == highest_floor)
-      highest_elevation = level.elevation;
-    if (level.name == lowest_floor)
-      lowest_elevation = level.elevation;
-  }
-
-  // for every level, load if every door can open
-  if (data["level_doors"] && data["level_doors"].IsMap())
-  {
-    const YAML::Node ym = data["level_doors"];
-    for (YAML::const_iterator it = ym.begin(); it != ym.end(); ++it)
-    {
-      const std::string level_name = it->first.as<string>();
-      const YAML::Node& ds = it->second;  // doors sequence node
-      if (ds.IsSequence())
-      {
-        for (YAML::const_iterator dit = ds.begin(); dit != ds.end(); ++dit)
-        {
-          const std::string door_name = (*dit).as<string>();
-          level_doors[level_name].push_back(door_name);
-        }
-      }
-    }
-  }
-}
-
-YAML::Node Lift::to_yaml() const
-{
-  // This is in image space. I think it's safe to say nobody is clicking
-  // with more than 1/1000 precision inside a single pixel.
-
-  YAML::Node n;
-  n["x"] = std::round(x * 1000.0) / 1000.0;
-  n["y"] = std::round(y * 1000.0) / 1000.0;
-  // let's give yaw another decimal place because, I don't know, reasons (?)
-  n["yaw"] = std::round(yaw * 10000.0) / 10000.0;
-  n["reference_floor_name"] = reference_floor_name;
-  n["highest_floor"] = highest_floor;
-  n["lowest_floor"] = lowest_floor;
-  n["initial_floor_name"] = initial_floor_name;
-  n["width"] = std::round(width * 1000.0) / 1000.0;
-  n["depth"] = std::round(depth * 1000.0) / 1000.0;
-
-  n["doors"] = YAML::Node(YAML::NodeType::Map);
-  for (const auto& door : doors)
-    n["doors"][door.name] = door.to_yaml();
-
-  n["level_doors"] = YAML::Node(YAML::NodeType::Map);
-  for (LevelDoorMap::const_iterator level_it = level_doors.begin();
-    level_it != level_doors.end();
-    ++level_it)
-  {
-    const DoorNameList& dlist = level_it->second;
-    for (DoorNameList::const_iterator door_it = dlist.begin();
-      door_it != dlist.end();
-      ++door_it)
-    {
-      n["level_doors"][level_it->first].push_back(*door_it);
-      n["level_doors"][level_it->first].SetStyle(YAML::EmitterStyle::Flow);
-    }
-  }
-  return n;
-}
-
-/// The level_name parameter is required in order to know how to draw the
-/// doors, since many lifts have more than one set of doors, which open on
-/// some but not all floors. It's not being used (yet).
-void Lift::draw(
-  QGraphicsScene* scene,
-  const double meters_per_pixel,
-  const string& level_name,
-  const double elevation,
-  const bool apply_transformation,
-  const double scale,
-  const double translate_x,
-  const double translate_y) const
-{
-  if (elevation > highest_elevation || elevation < lowest_elevation)
-    return;
-  const double cabin_w = width / meters_per_pixel;
-  const double cabin_d = depth / meters_per_pixel;
-  QPen cabin_pen(Qt::black);
-  cabin_pen.setWidth(0.05 / meters_per_pixel);
-
-  QGraphicsRectItem* cabin_rect = new QGraphicsRectItem(
-    -cabin_w / 2.0,
-    -cabin_d / 2.0,
-    cabin_w,
-    cabin_d);
-  cabin_rect->setPen(cabin_pen);
-  auto it = level_doors.find(level_name);
-  if (it == level_doors.end())
-    cabin_rect->setBrush(QBrush(QColor::fromRgbF(1.0, 0.3, 0.3, 0.3)));
-  else
-    cabin_rect->setBrush(QBrush(QColor::fromRgbF(0.5, 1.0, 0.5, 0.5)));
-  scene->addItem(cabin_rect);
-
-  QList<QGraphicsItem*> items;
-  items.append(cabin_rect);
-
-  if (!name.empty())
-  {
-    QFont font("Helvetica");
-    font.setPointSize(0.2 / meters_per_pixel);
-    QGraphicsSimpleTextItem* text_item = scene->addSimpleText(
-      QString::fromStdString(name), font);
-    text_item->setBrush(QColor(255, 0, 0, 255));
-    text_item->setPos(-cabin_w / 3.0, 0.0);
-
-    // todo: set font size to something reasonable
-    // todo: center-align text?
-    items.append(text_item);
-  }
-
-  if (it != level_doors.end())
-  {
-    for (const LiftDoor& door : doors)
-    {
-      if (find(it->second.begin(), it->second.end(), door.name)
-        == it->second.end())
-        continue;
-      const double door_x = door.x / meters_per_pixel;
-      const double door_y = -door.y / meters_per_pixel;
-      const double door_w = door.width / meters_per_pixel;
-      const double door_thickness = 0.2 / meters_per_pixel;
-      QGraphicsRectItem* door_item = new QGraphicsRectItem(
-        -door_w / 2.0,
-        -door_thickness / 2.0,
-        door_w,
-        door_thickness);
-      door_item->setRotation(-180.0 / 3.1415926 * door.motion_axis_orientation);
-      door_item->setPos(door_x, door_y);
-
-      QPen door_pen(Qt::red);
-      door_pen.setWidth(0.05 / meters_per_pixel);
-      door_item->setPen(door_pen);
-      door_item->setBrush(QBrush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5)));
-
-      items.append(door_item);
-    }
-  }
-
-  QGraphicsItemGroup* group = scene->createItemGroup(items);
-
-  if (apply_transformation)
-  {
-    group->setRotation(-180.0 / 3.1415926 * yaw);
-    group->setPos(x * scale + translate_x, y * scale + translate_y);
-  }
-}
-
-bool Lift::level_door_opens(
-  const std::string& level_name,
-  const std::string& door_name,
-  const std::vector<BuildingLevel>& levels) const
-{
-  LevelDoorMap::const_iterator level_it = level_doors.find(level_name);
-  if (level_it == level_doors.end())
-    return false;
-  for (const auto& level : levels)
-  {
-    if (level.name == level_name)
-    {
-      if (level.elevation < lowest_elevation ||
-        level.elevation > highest_elevation)
-        return false;
-      break;
-    }
-  }
-  const DoorNameList& names = level_it->second;
-  if (std::find(names.begin(), names.end(), door_name) == names.end())
-    return false;
-  return true;
-}
diff --git a/traffic_editor/gui/lift_dialog.cpp b/traffic_editor/gui/lift_dialog.cpp
deleted file mode 100644
index c1c4856..0000000
--- a/traffic_editor/gui/lift_dialog.cpp
+++ /dev/null
@@ -1,572 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "lift_dialog.h"
-#include <cfloat>
-#include <QtWidgets>
-using std::vector;
-
-
-LiftDialog::LiftDialog(Lift& lift, Building& building)
-: QDialog(),
-  _lift(lift),
-  _building(building)
-{
-  setWindowTitle("Lift Properties");
-  for (const auto& level : building.levels)
-    _level_names.push_back(QString::fromStdString(level.name));
-
-  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
-  _ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  bottom_buttons_hbox->addWidget(_ok_button);
-  connect(
-    _ok_button, &QAbstractButton::clicked,
-    this, &LiftDialog::ok_button_clicked);
-
-  _cancel_button = new QPushButton("Cancel", this);
-  bottom_buttons_hbox->addWidget(_cancel_button);
-  connect(
-    _cancel_button,
-    &QAbstractButton::clicked,
-    this,
-    &QDialog::reject);
-
-  QHBoxLayout* name_hbox = new QHBoxLayout;
-  name_hbox->addWidget(new QLabel("Name:"));
-  _name_line_edit =
-    new QLineEdit(QString::fromStdString(_lift.name), this);
-  connect(
-    _name_line_edit,
-    &QLineEdit::textEdited,
-    [this](const QString& text)
-    {
-      _lift.name = text.toStdString();
-      update_lift_view();
-      emit redraw();
-    });
-  name_hbox->addWidget(_name_line_edit);
-
-  QHBoxLayout* ref_name_hbox = new QHBoxLayout;
-  ref_name_hbox->addWidget(new QLabel("Reference floor:"));
-  _reference_floor_combo_box = new QComboBox;
-  for (const QString& level_name : _level_names)
-    _reference_floor_combo_box->addItem(level_name);
-  _reference_floor_combo_box->setCurrentText(
-    QString::fromStdString(_lift.reference_floor_name));
-  connect(
-    _reference_floor_combo_box,
-    &QComboBox::currentTextChanged,
-    [this](const QString& text)
-    {
-      _lift.reference_floor_name = text.toStdString();
-      emit redraw();
-    });
-  ref_name_hbox->addWidget(_reference_floor_combo_box);
-
-  QHBoxLayout* init_floor_hbox = new QHBoxLayout;
-  init_floor_hbox->addWidget(new QLabel("Initial floor:"));
-  _initial_floor_combo_box = new QComboBox;
-  for (const QString& level_name : _level_names)
-    _initial_floor_combo_box->addItem(level_name);
-  _initial_floor_combo_box->setCurrentText(
-    QString::fromStdString(_lift.initial_floor_name));
-  connect(
-    _initial_floor_combo_box,
-    &QComboBox::currentTextChanged,
-    [this](const QString& text)
-    {
-      _lift.initial_floor_name = text.toStdString();
-      emit redraw();
-    });
-  init_floor_hbox->addWidget(_initial_floor_combo_box);
-
-  QHBoxLayout* highest_name_hbox = new QHBoxLayout;
-  highest_name_hbox->addWidget(new QLabel("Highest floor:"));
-  _highest_floor_combo_box = new QComboBox;
-  for (const QString& level_name : _level_names)
-    _highest_floor_combo_box->addItem(level_name);
-  _highest_floor_combo_box->addItem("");  // empty string for not specifying
-  _highest_floor_combo_box->setCurrentText(
-    QString::fromStdString(_lift.highest_floor));
-  connect(
-    _highest_floor_combo_box,
-    &QComboBox::currentTextChanged,
-    [this](const QString& text)
-    {
-      _lift.highest_floor = text.toStdString();
-      if (_lift.highest_floor.empty())
-        _lift.highest_elevation = DBL_MAX;
-      else
-      {
-        for (const auto& level : _building.levels)
-        {
-          if (level.name == _lift.highest_floor)
-          {
-            _lift.highest_elevation = level.elevation;
-            break;
-          }
-        }
-      }
-      update_level_table();
-      emit redraw();
-    });
-  highest_name_hbox->addWidget(_highest_floor_combo_box);
-
-  QHBoxLayout* lowest_name_hbox = new QHBoxLayout;
-  lowest_name_hbox->addWidget(new QLabel("Lowest floor:"));
-  _lowest_floor_combo_box = new QComboBox;
-  for (const QString& level_name : _level_names)
-    _lowest_floor_combo_box->addItem(level_name);
-  _lowest_floor_combo_box->addItem("");
-  _lowest_floor_combo_box->setCurrentText(
-    QString::fromStdString(_lift.lowest_floor));
-  connect(
-    _lowest_floor_combo_box,
-    &QComboBox::currentTextChanged,
-    [this](const QString& text)
-    {
-      _lift.lowest_floor = text.toStdString();
-      if (_lift.lowest_floor.empty())
-        _lift.lowest_elevation = -DBL_MAX;
-      else
-      {
-        for (const auto& level : _building.levels)
-        {
-          if (level.name == _lift.lowest_floor)
-          {
-            _lift.lowest_elevation = level.elevation;
-            break;
-          }
-        }
-      }
-      update_level_table();
-      emit redraw();
-    });
-  lowest_name_hbox->addWidget(_lowest_floor_combo_box);
-
-  QHBoxLayout* x_hbox = new QHBoxLayout;
-  x_hbox->addWidget(new QLabel("X:"));
-  _x_line_edit =
-    new QLineEdit(QString::number(_lift.x), this);
-  connect(
-    _x_line_edit,
-    &QLineEdit::textEdited,
-    [this](const QString& text)
-    {
-      _lift.x = text.toDouble();
-      update_lift_wps();
-    });
-  x_hbox->addWidget(_x_line_edit);
-
-  QHBoxLayout* y_hbox = new QHBoxLayout;
-  y_hbox->addWidget(new QLabel("Y:"));
-  _y_line_edit =
-    new QLineEdit(QString::number(_lift.y), this);
-  connect(
-    _y_line_edit,
-    &QLineEdit::textEdited,
-    [this](const QString& text)
-    {
-      _lift.y = text.toDouble();
-      update_lift_wps();
-    });
-  y_hbox->addWidget(_y_line_edit);
-
-  QHBoxLayout* yaw_hbox = new QHBoxLayout;
-  yaw_hbox->addWidget(new QLabel("Yaw:"));
-  _yaw_line_edit =
-    new QLineEdit(QString::number(_lift.yaw), this);
-  connect(
-    _yaw_line_edit,
-    &QLineEdit::textEdited,
-    [this](const QString& text)
-    {
-      _lift.yaw = text.toDouble();
-      update_lift_view();
-      emit redraw();
-    });
-  yaw_hbox->addWidget(_yaw_line_edit);
-
-  QHBoxLayout* width_hbox = new QHBoxLayout;
-  width_hbox->addWidget(new QLabel("Cabin width:"));
-  _width_line_edit =
-    new QLineEdit(QString::number(_lift.width), this);
-  connect(
-    _width_line_edit,
-    &QLineEdit::textEdited,
-    [this](const QString& text)
-    {
-      _lift.width = text.toDouble();
-      update_lift_view();
-      emit redraw();
-    });
-  width_hbox->addWidget(_width_line_edit);
-
-  QHBoxLayout* depth_hbox = new QHBoxLayout;
-  depth_hbox->addWidget(new QLabel("Cabin depth:"));
-  _depth_line_edit =
-    new QLineEdit(QString::number(_lift.depth), this);
-  connect(
-    _depth_line_edit,
-    &QLineEdit::textEdited,
-    [this](const QString& text)
-    {
-      _lift.depth = text.toDouble();
-      update_lift_view();
-      emit redraw();
-    });
-  depth_hbox->addWidget(_depth_line_edit);
-
-  QHBoxLayout* add_wp_hbox = new QHBoxLayout;
-  _add_wp_button = new QPushButton("Add lift waypoints", this);
-  add_wp_hbox->addWidget(_add_wp_button);
-  connect(
-    _add_wp_button, &QAbstractButton::clicked,
-    this, &LiftDialog::update_lift_wps);
-
-  _level_table = new QTableWidget;
-  _level_table->setMinimumSize(200, 200);
-  _level_table->verticalHeader()->setVisible(false);
-  _level_table->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
-
-  _level_table->setHorizontalHeaderItem(0, new QTableWidgetItem("Level name"));
-  /*
-  _level_table->horizontalHeader()->setSectionResizeMode(
-      0, QHeaderView::Stretch);
-  */
-
-  _door_table = new QTableWidget;
-  _door_table->setMinimumSize(400, 200);
-  _door_table->verticalHeader()->setVisible(false);
-  _door_table->setColumnCount(6);
-  _door_table->setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
-
-  _door_table->setHorizontalHeaderItem(0, new QTableWidgetItem("Door name"));
-  _door_table->horizontalHeader()->setSectionResizeMode(
-    0, QHeaderView::Stretch);
-
-  _door_table->setHorizontalHeaderItem(1, new QTableWidgetItem("Door type"));
-  _door_table->horizontalHeader()->setSectionResizeMode(
-    1, QHeaderView::ResizeToContents);
-
-  _door_table->setHorizontalHeaderItem(2, new QTableWidgetItem("X"));
-  _door_table->horizontalHeader()->setSectionResizeMode(
-    2, QHeaderView::ResizeToContents);
-
-  _door_table->setHorizontalHeaderItem(3, new QTableWidgetItem("Y"));
-  _door_table->horizontalHeader()->setSectionResizeMode(
-    3, QHeaderView::ResizeToContents);
-
-  _door_table->setHorizontalHeaderItem(4, new QTableWidgetItem("Orientation"));
-  _door_table->horizontalHeader()->setSectionResizeMode(
-    4, QHeaderView::ResizeToContents);
-
-  _door_table->setHorizontalHeaderItem(5, new QTableWidgetItem("Width"));
-  _door_table->horizontalHeader()->setSectionResizeMode(
-    5, QHeaderView::ResizeToContents);
-
-  _door_table->verticalHeader()->setSectionResizeMode(
-    QHeaderView::ResizeToContents);
-
-  QVBoxLayout* left_vbox = new QVBoxLayout;
-  left_vbox->addLayout(name_hbox);
-  left_vbox->addLayout(ref_name_hbox);
-  left_vbox->addLayout(highest_name_hbox);
-  left_vbox->addLayout(lowest_name_hbox);
-  left_vbox->addLayout(init_floor_hbox);
-  left_vbox->addLayout(x_hbox);
-  left_vbox->addLayout(y_hbox);
-  left_vbox->addLayout(yaw_hbox);
-  left_vbox->addLayout(width_hbox);
-  left_vbox->addLayout(depth_hbox);
-  left_vbox->addLayout(add_wp_hbox);
-  left_vbox->addWidget(_level_table);
-
-  QVBoxLayout* right_vbox = new QVBoxLayout;
-
-  _lift_scene = new QGraphicsScene;
-
-  _lift_view = new QGraphicsView;
-  _lift_view->setScene(_lift_scene);
-  _lift_view->setMinimumSize(400, 400);
-  right_vbox->addWidget(_lift_view, 1);
-
-  right_vbox->addWidget(_door_table);
-
-  QHBoxLayout* top_hbox = new QHBoxLayout;
-  top_hbox->addLayout(left_vbox);
-  top_hbox->addLayout(right_vbox, 1);
-
-  QVBoxLayout* top_vbox = new QVBoxLayout;
-  top_vbox->addLayout(top_hbox);
-  // todo: some sort of separator (?)
-  top_vbox->addLayout(bottom_buttons_hbox);
-
-  setLayout(top_vbox);
-
-  _name_line_edit->setFocus(Qt::OtherFocusReason);
-
-  update_door_table();
-  update_level_table();
-
-  connect(
-    _door_table, &QTableWidget::cellChanged,
-    this, &LiftDialog::door_table_cell_changed);
-
-  update_lift_view();
-  adjustSize();
-}
-
-LiftDialog::~LiftDialog()
-{
-}
-
-void LiftDialog::ok_button_clicked()
-{
-  if (_name_line_edit->text().isEmpty())
-  {
-    QMessageBox::critical(this, "Error", "Lift name is empty");
-    return;
-  }
-
-  if (_lift.lowest_elevation > _lift.highest_elevation)
-  {
-    QMessageBox::critical(this, "Error", "Lowest floor above highest floor");
-    return;
-  }
-  /*
-  _lift.name = _name_line_edit->text().toStdString();
-  _lift.reference_floor_name =
-    _reference_floor_combo_box->currentText().toStdString();
-  _lift.highest_floor = _highest_floor_combo_box->currentText().toStdString();
-  _lift.lowest_floor = _lowest_floor_combo_box->currentText().toStdString();
-
-  _lift.x = _x_line_edit->text().toDouble();
-  _lift.y = _y_line_edit->text().toDouble();
-  _lift.yaw = _yaw_line_edit->text().toDouble();
-
-  _lift.width = _width_line_edit->text().toDouble();
-  _lift.depth = _depth_line_edit->text().toDouble();
-  */
-  // grab all the level-door checkbox matrix states and save them
-  for (int level_row = 0; level_row < _level_table->rowCount(); level_row++)
-  {
-    const std::string level_name =
-      _level_table->item(level_row, 0)->text().toStdString();
-    _lift.level_doors.erase(level_name);
-    for (int door_col = 1; door_col < _level_table->columnCount(); door_col++)
-    {
-      const std::string door_name =
-        _level_table->horizontalHeaderItem(door_col)->text().toStdString();
-      const QWidget* widget = _level_table->cellWidget(level_row, door_col);
-      const QCheckBox* checkbox = qobject_cast<const QCheckBox*>(widget);
-      if (checkbox)
-      {
-        const bool checked = checkbox->isChecked();
-        printf("level %s door %s: %d\n",
-          level_name.c_str(),
-          door_name.c_str(),
-          checked ? 1 : 0);
-        if (checked)
-          _lift.level_doors[level_name].push_back(door_name);
-      }
-      else
-      {
-        printf("level %s door %s: indeterminate state!\n",
-          level_name.c_str(),
-          door_name.c_str());
-      }
-    }
-  }
-  update_lift_view();
-  emit redraw();
-  accept();
-}
-
-void LiftDialog::update_lift_wps()
-{
-  const QPointF from_point = QPointF(_lift.x, _lift.y);
-  QPointF to_point;
-
-  bool found = false;
-  for (size_t level_idx = 0; level_idx < _level_names.size(); level_idx++)
-  {
-    const std::string level_name = _level_names[level_idx].toStdString();
-    // Vertices will only be generated on levels that the lift is serving (has
-    // a door opening on that level)
-    if (_lift.level_doors[level_name].size() != 0)
-    {
-      _building.transform_between_levels(
-        _lift.reference_floor_name,
-        from_point,
-        _building.levels[level_idx].name,
-        to_point);
-      found = false;
-
-      for (auto& v : _building.levels[level_idx].vertices)
-      {
-        auto it = v.params.find("lift_cabin");
-        if ((it != v.params.end()) && (it->second.value_string == _lift.name))
-        {
-          v.x = to_point.x();
-          v.y = to_point.y();
-          found = true;
-        }
-      }
-      if (!found)
-      {
-        _building.add_vertex(level_idx, to_point.x(), to_point.y());
-        _building.levels[level_idx].vertices.back().params["lift_cabin"] =
-          _lift.name;
-      }
-    }
-  }
-  emit redraw();
-}
-
-void LiftDialog::update_door_table()
-{
-  _door_table->setRowCount(1 + _lift.doors.size());
-  for (size_t i = 0; i < _lift.doors.size(); i++)
-  {
-    const LiftDoor& door = _lift.doors[i];  // save some typing
-    set_door_cell(i, 0, QString::fromStdString(door.name));
-
-    // set the numeric fields
-    set_door_cell(i, 2, QString::number(door.x));
-    set_door_cell(i, 3, QString::number(door.y));
-    set_door_cell(i, 4, QString::number(door.motion_axis_orientation));
-    _door_table->setCellWidget(i, 5, nullptr);
-    set_door_cell(i, 5, QString::number(door.width));
-
-    // create a drop-down list for the door type
-    QComboBox* type_box = new QComboBox;
-    type_box->addItem("<undefined>", QVariant(0));
-    type_box->addItem("Single sliding", QVariant(1));
-    type_box->addItem("Double sliding", QVariant(2));
-    type_box->addItem("Single telescoping", QVariant(3));
-    type_box->addItem("Double telescoping", QVariant(4));
-    type_box->setCurrentIndex(static_cast<int>(door.door_type));
-
-    _door_table->setCellWidget(i, 1, type_box);
-  }
-
-  // we'll use the last row for the "Add" button
-  const int last_row_idx = static_cast<int>(_lift.doors.size());
-  _door_table->setCellWidget(last_row_idx, 0, nullptr);
-  _door_table->setCellWidget(last_row_idx, 1, nullptr);
-  _door_table->setCellWidget(last_row_idx, 2, nullptr);
-  _door_table->setCellWidget(last_row_idx, 3, nullptr);
-  _door_table->setCellWidget(last_row_idx, 4, nullptr);
-  QPushButton* add_button = new QPushButton("Add...", this);
-  _door_table->setCellWidget(last_row_idx, 5, add_button);
-  connect(
-    add_button,
-    &QAbstractButton::clicked,
-    [this]()
-    {
-      LiftDoor door;
-      door.name = "name";
-      door.door_type = LiftDoor::DOUBLE_SLIDING;
-      _lift.doors.push_back(door);
-      update_door_table();
-      update_lift_view();
-    });
-}
-
-void LiftDialog::set_door_cell(
-  const int row,
-  const int col,
-  const QString& text)
-{
-  _door_table->setItem(row, col, new QTableWidgetItem(text));
-}
-
-void LiftDialog::update_level_table()
-{
-  _level_table->setColumnCount(1 + static_cast<int>(_lift.doors.size()));
-  _level_table->setHorizontalHeaderItem(0, new QTableWidgetItem("Level"));
-  for (size_t door_idx = 0; door_idx < _lift.doors.size(); door_idx++)
-  {
-    _level_table->setHorizontalHeaderItem(
-      door_idx + 1,
-      new QTableWidgetItem(
-        QString::fromStdString(_lift.doors[door_idx].name)));
-  }
-  //blockSignals(true);
-  _level_table->setRowCount(_level_names.size());
-  for (size_t level_idx = 0; level_idx < _level_names.size(); level_idx++)
-  {
-    const QString& level_name = _level_names[level_idx];
-    QTableWidgetItem* name_item = new QTableWidgetItem(level_name);
-    name_item->setFlags(name_item->flags() & ~Qt::ItemIsEditable);
-    _level_table->setItem(level_idx, 0, name_item);
-
-    for (size_t door_idx = 0; door_idx < _lift.doors.size(); door_idx++)
-    {
-      QCheckBox* checkbox = new QCheckBox;
-      checkbox->setStyleSheet("margin-left: 50%; margin-right: 50%");
-      if (_lift.level_door_opens(
-          level_name.toStdString(),
-          _lift.doors[door_idx].name,
-          _building.levels))
-        checkbox->setChecked(true);
-      _level_table->setCellWidget(level_idx, door_idx + 1, checkbox);
-    }
-  }
-  //blockSignals(false);
-}
-
-void LiftDialog::door_table_cell_changed(int row, int col)
-{
-  // printf("door_table_cell_changed(%d, %d)\n", row, col);
-  if (row >= static_cast<int>(_lift.doors.size()))
-  {
-    printf("invalid door row: %d\n", row);
-    return;  // let's not crash
-  }
-
-  // If a door name was changed, we need to update the options shown in all
-  // the level_table combo boxes
-  if (col == 0)  // name
-  {
-    _lift.doors[row].name = _door_table->item(row, col)->text().toStdString();
-    update_level_table();
-  }
-  else if (col == 1)
-  {
-    // todo: door type
-  }
-  else if (col == 2) // x
-    _lift.doors[row].x = _door_table->item(row, col)->text().toDouble();
-  else if (col == 3) // y
-    _lift.doors[row].y = _door_table->item(row, col)->text().toDouble();
-  else if (col == 4) // orientation
-    _lift.doors[row].motion_axis_orientation =
-      _door_table->item(row, col)->text().toDouble();
-  else if (col == 5) // width
-    _lift.doors[row].width = _door_table->item(row, col)->text().toDouble();
-
-  update_lift_view();
-  emit redraw();
-}
-
-void LiftDialog::update_lift_view()
-{
-  _lift_scene->clear();
-  _lift.draw(_lift_scene, 0.01, std::string(), _lift.lowest_elevation, false);
-}
diff --git a/traffic_editor/gui/lift_dialog.h b/traffic_editor/gui/lift_dialog.h
deleted file mode 100644
index 7febd81..0000000
--- a/traffic_editor/gui/lift_dialog.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LIFT_DIALOG_H
-#define LIFT_DIALOG_H
-
-#include <vector>
-
-#include <QDialog>
-#include <QObject>
-
-#include "traffic_editor/lift.h"
-#include "traffic_editor/building.h"
-
-class QLineEdit;
-class QLabel;
-class QTableWidget;
-class QComboBox;
-
-
-class LiftDialog : public QDialog
-{
-  Q_OBJECT
-
-public:
-  LiftDialog(Lift& lift, Building& building);
-  ~LiftDialog();
-
-private:
-  Lift& _lift;
-  Building& _building;
-
-  std::vector<QString> _level_names;
-
-  QLineEdit* _name_line_edit;
-  QComboBox* _reference_floor_combo_box;
-  QComboBox* _highest_floor_combo_box;
-  QComboBox* _lowest_floor_combo_box;
-  QComboBox* _initial_floor_combo_box;
-  QLineEdit* _x_line_edit;
-  QLineEdit* _y_line_edit;
-  QLineEdit* _yaw_line_edit;
-  QLineEdit* _width_line_edit;
-  QLineEdit* _depth_line_edit;
-
-  QTableWidget* _door_table;
-  QTableWidget* _level_table;
-
-  QGraphicsView* _lift_view;
-  QGraphicsScene* _lift_scene;
-
-  QPushButton* _ok_button, * _cancel_button;
-  QPushButton* _add_wp_button;
-
-  void update_door_table();
-  void set_door_cell(const int row, const int col, const QString& text);
-  void door_table_cell_changed(int row, int col);
-
-  void update_level_table();
-  void update_lift_view();
-
-  void update_lift_wps();
-
-private slots:
-  void ok_button_clicked();
-
-signals:
-  void redraw();
-};
-
-#endif
diff --git a/traffic_editor/gui/lift_door.cpp b/traffic_editor/gui/lift_door.cpp
deleted file mode 100644
index 590782c..0000000
--- a/traffic_editor/gui/lift_door.cpp
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <cmath>
-
-#include "traffic_editor/lift_door.h"
-
-YAML::Node LiftDoor::to_yaml() const
-{
-  // This is in image space. I think it's safe to say nobody is clicking
-  // with more than 1/1000 precision inside a single pixel.
-
-  YAML::Node n;
-  n["x"] = std::round(x * 1000.0) / 1000.0;
-  n["y"] = std::round(y * 1000.0) / 1000.0;
-  n["width"] = std::round(width * 1000.0) / 1000.0;
-  n["door_type"] = static_cast<int>(door_type);
-  // let's give yaw another decimal place because, I don't know, reasons (?)
-  n["motion_axis_orientation"] =
-    std::round(motion_axis_orientation * 10000.0) / 10000.0;
-  return n;
-}
-
-void LiftDoor::from_yaml(const std::string& _name, const YAML::Node& data)
-{
-  if (!data.IsMap())
-    throw std::runtime_error("LiftDoor::from_yaml() expected a map");
-  x = data["x"].as<double>();
-  y = data["y"].as<double>();
-  width = data["width"].as<double>();
-  door_type = static_cast<DoorType>(data["door_type"].as<int>());
-  motion_axis_orientation = data["motion_axis_orientation"].as<double>();
-  name = _name;
-}
diff --git a/traffic_editor/gui/lift_table.cpp b/traffic_editor/gui/lift_table.cpp
deleted file mode 100644
index c689e45..0000000
--- a/traffic_editor/gui/lift_table.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "lift_dialog.h"
-#include "lift_table.h"
-#include <QtWidgets>
-
-LiftTable::LiftTable()
-: TableList()
-{
-  const QStringList labels = { "Name", "" };
-  setHorizontalHeaderLabels(labels);
-}
-
-LiftTable::~LiftTable()
-{
-}
-
-void LiftTable::update(Building& building)
-{
-  blockSignals(true);
-  setRowCount(1 + building.lifts.size());
-  for (size_t i = 0; i < building.lifts.size(); i++)
-  {
-    setItem(
-      i,
-      0,
-      new QTableWidgetItem(
-        QString::fromStdString(building.lifts[i].name)));
-
-    QPushButton* edit_button = new QPushButton("Edit...", this);
-    setCellWidget(i, 1, edit_button);
-
-    connect(
-      edit_button,
-      &QAbstractButton::clicked,
-      [this, &building, i]()
-      {
-        /*
-        LiftDialog lift_dialog(building.lifts[i], building);
-        lift_dialog.exec();
-        update(building);
-        emit redraw();
-        */
-        LiftDialog* dialog = new LiftDialog(building.lifts[i], building);
-        dialog->show();
-        dialog->raise();
-        dialog->activateWindow();
-        connect(
-          dialog,
-          &LiftDialog::redraw,
-          [this]() { emit redraw(); });
-      });
-  }
-
-  // we'll use the last row for the "Add" button
-  const int last_row_idx = static_cast<int>(building.lifts.size());
-  setCellWidget(last_row_idx, 0, nullptr);
-  setItem(
-    last_row_idx,
-    0,
-    new QTableWidgetItem(
-      QString::fromStdString("")));
-  QPushButton* add_button = new QPushButton("Add...", this);
-  setCellWidget(last_row_idx, 1, add_button);
-  connect(
-    add_button, &QAbstractButton::clicked,
-    [this, &building]()
-    {
-      Lift lift;
-      LiftDialog lift_dialog(lift, building);
-      if (lift_dialog.exec() == QDialog::Accepted)
-      {
-        building.lifts.push_back(lift);
-        update(building);
-        emit redraw();
-      }
-    });
-
-  blockSignals(false);
-}
diff --git a/traffic_editor/gui/lift_table.h b/traffic_editor/gui/lift_table.h
deleted file mode 100644
index f682613..0000000
--- a/traffic_editor/gui/lift_table.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LIFT_TABLE_H
-#define LIFT_TABLE_H
-
-#include <QTableWidget>
-
-#include "table_list.h"
-#include "traffic_editor/building.h"
-
-class LiftTable : public TableList
-{
-public:
-  LiftTable();
-  ~LiftTable();
-
-  void update(Building& building);
-};
-
-#endif
diff --git a/traffic_editor/gui/main.cpp b/traffic_editor/gui/main.cpp
deleted file mode 100644
index 91b3b83..0000000
--- a/traffic_editor/gui/main.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "editor.h"
-#include "preferences_keys.h"
-#include <QtWidgets>
-#include <string>
-#include <QSettings>
-
-int main(int argc, char* argv[])
-{
-  QApplication app(argc, argv);
-  app.setOrganizationName("open-robotics");
-  app.setOrganizationDomain("openrobotics.org");
-  app.setApplicationName("traffic-editor");
-
-  QCommandLineParser parser;
-  parser.addHelpOption();
-  parser.addPositionalArgument("[project]", "Project to open");
-  parser.process(QCoreApplication::arguments());
-
-  Editor editor;
-  QSettings settings;
-
-  const bool load_previous = settings.value(
-    preferences_keys::open_previous_project, QVariant(true)).toBool();
-
-  if (load_previous && parser.positionalArguments().isEmpty())
-    editor.load_previous_project();
-
-  if (parser.positionalArguments().length() >= 1)
-    editor.load_project(parser.positionalArguments().at(0));
-
-  editor.show();
-
-  editor.restore_previous_viewport();
-
-  return app.exec();
-}
diff --git a/traffic_editor/gui/map_view.cpp b/traffic_editor/gui/map_view.cpp
deleted file mode 100644
index b1d5260..0000000
--- a/traffic_editor/gui/map_view.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "map_view.h"
-#include <QScrollBar>
-
-MapView::MapView(QWidget* parent)
-: QGraphicsView(parent),
-  is_panning(false),
-  pan_start_x(0),
-  pan_start_y(0)
-{
-  setMouseTracking(true);
-  viewport()->setMouseTracking(true);
-  setTransformationAnchor(QGraphicsView::NoAnchor);
-}
-
-void MapView::wheelEvent(QWheelEvent* e)
-{
-  // calculate the map position before we scale things
-  const QPointF p_start = mapToScene(e->pos());
-
-  // scale things
-  if (e->delta() > 0)
-    scale(1.1, 1.1);
-  else
-    scale(0.9, 0.9);
-
-  // calculate the mouse map position now that we've scaled
-  const QPointF p_end = mapToScene(e->pos());
-
-  // translate the map back so hopefully the mouse stays in the same spot
-  const QPointF diff = p_end - p_start;
-  translate(diff.x(), diff.y());
-}
-
-void MapView::mousePressEvent(QMouseEvent* e)
-{
-  if (e->button() == Qt::MiddleButton)
-  {
-    is_panning = true;
-    pan_start_x = e->x();
-    pan_start_y = e->y();
-    // setCursor(Qt::ClosedHandCursor);
-    e->accept();
-    return;
-  }
-  e->ignore();
-}
-
-void MapView::mouseReleaseEvent(QMouseEvent* e)
-{
-  if (e->button() == Qt::MiddleButton)
-  {
-    is_panning = false;
-    e->accept();
-    return;
-  }
-  e->ignore();
-}
-
-void MapView::mouseMoveEvent(QMouseEvent* e)
-{
-  if (is_panning)
-  {
-    const int dx = e->x() - pan_start_x;
-    const int dy = e->y() - pan_start_y;
-    horizontalScrollBar()->setValue(horizontalScrollBar()->value() - dx);
-    verticalScrollBar()->setValue(verticalScrollBar()->value() - dy);
-    pan_start_x = e->x();
-    pan_start_y = e->y();
-    e->accept();
-    return;
-  }
-  e->ignore();
-}
-
-void MapView::zoom_fit(const Building& building, int level_index)
-{
-  if (building.levels.empty())
-    return;
-  const BuildingLevel& level = building.levels[level_index];
-  const int w = level.drawing_width;
-  const int h = level.drawing_height;
-  const double cx = w / 2;
-  const double cy = h / 2;
-  // todo: this doesn't seem to work. not sure how to use this function.
-  ensureVisible(cx, cy, w, h);
-  //resetTransform();
-  //fitInView(cx, cy, w, h, Qt::KeepAspectRatio);
-  //centerOn(cx, cy);
-}
diff --git a/traffic_editor/gui/map_view.h b/traffic_editor/gui/map_view.h
deleted file mode 100644
index 867b100..0000000
--- a/traffic_editor/gui/map_view.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef MAP_VIEW_H
-#define MAP_VIEW_H
-
-#include <QGraphicsView>
-#include <QWheelEvent>
-
-#include "traffic_editor/building.h"
-
-
-class MapView : public QGraphicsView
-{
-  Q_OBJECT
-
-public:
-  MapView(QWidget* parent = nullptr);
-  void zoom_fit(const Building& building, int level_index);
-
-protected:
-  void wheelEvent(QWheelEvent* event);
-  void mouseMoveEvent(QMouseEvent* e);
-  void mousePressEvent(QMouseEvent* e);
-  void mouseReleaseEvent(QMouseEvent* e);
-
-  bool is_panning;
-  int pan_start_x, pan_start_y;
-};
-
-#endif
diff --git a/traffic_editor/gui/model.cpp b/traffic_editor/gui/model.cpp
deleted file mode 100644
index 6ffec8e..0000000
--- a/traffic_editor/gui/model.cpp
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <cmath>
-
-#include <QtGlobal>
-#include <QGraphicsPixmapItem>
-#include <QGraphicsColorizeEffect>
-
-#include "traffic_editor/model.h"
-using std::string;
-
-// String comparison helper
-bool iequals(const string& a, const string& b)
-{
-  return std::equal(a.begin(), a.end(),
-      b.begin(), b.end(),
-      [](char _a, char _b)
-      {
-        return tolower(_a) == tolower(_b);
-      });
-}
-
-Model::Model()
-{
-}
-
-void Model::from_yaml(const YAML::Node& data, const string& level_name)
-{
-  if (!data.IsMap())
-    throw std::runtime_error("Model::from_yaml() expected a map");
-  state.x = data["x"].as<double>();
-  state.y = data["y"].as<double>();
-  if (data["z"])
-  {
-    state.z = data["z"].as<double>();
-  }
-  else
-  {
-    qWarning(
-      "parsed a deprecated .building.yaml, models should have z defined.");
-    state.z = 0.0;
-  }
-  state.yaw = data["yaw"].as<double>();
-
-  model_name = data["model_name"].as<string>();
-  instance_name = data["name"].as<string>();
-
-  state.level_name = level_name;
-  starting_level = level_name;
-
-  if (data["static"])
-    is_static = data["static"].as<bool>();
-  else
-    is_static = true;
-}
-
-YAML::Node Model::to_yaml() const
-{
-  // This is in image space. I think it's safe to say nobody is clicking
-  // with more than 1/1000 precision inside a single pixel.
-
-  YAML::Node n;
-  n.SetStyle(YAML::EmitterStyle::Flow);
-  n["x"] = std::round(state.x * 1000.0) / 1000.0;
-  n["y"] = std::round(state.y * 1000.0) / 1000.0;
-  n["z"] = std::round(state.z * 1000.0) / 1000.0;
-  // let's give yaw another decimal place because, I don't know, reasons (?)
-  n["yaw"] = std::round(state.yaw * 10000.0) / 10000.0;
-  n["name"] = instance_name;
-  n["model_name"] = model_name;
-  n["static"] = is_static;
-  return n;
-}
-
-void Model::set_param(const std::string& name, const std::string& value)
-{
-  if (name == "elevation")
-  {
-    try
-    {
-      state.z = std::stod(value);
-    }
-    catch (const std::exception& e)
-    {
-      qWarning("[elevation] field can only be a double/float.");
-    }
-  }
-  else if (name == "static")
-  {
-    // not sure if there is a super elite way to parse 'true' in STL
-    string lowercase(value);
-    std::transform(
-      lowercase.begin(),
-      lowercase.end(),
-      lowercase.begin(),
-      [](char c) { return std::tolower(c); });
-
-    if (value == "true")
-      is_static = true;
-    else
-      is_static = false;
-  }
-  else if (name == "name")
-  {
-    instance_name = value;
-  }
-  else
-  {
-    printf("WARNING: setting unknown model parameter: [%s]\n", name.c_str());
-  }
-}
-
-void Model::draw(
-  QGraphicsScene* scene,
-  std::vector<EditorModel>& editor_models,
-  const double drawing_meters_per_pixel)
-{
-  if (pixmap_item == nullptr)
-  {
-    // find the pixmap we need for this model
-    QPixmap pixmap;
-    double model_meters_per_pixel = 1.0;  // will get overridden
-    for (auto& editor_model : editor_models)
-    {
-      if (editor_model.name == model_name)
-      {
-        pixmap = editor_model.get_pixmap();
-        model_meters_per_pixel = editor_model.meters_per_pixel;
-        break;
-      }
-    }
-    if (pixmap.isNull())
-    {
-      // BACKWARDS COMPATIBILITY PATCH: Try again, but...
-      // Use the first matching namespaced thumbnail for a
-      // specified non-namespaced model, with warnings.
-
-      // (Also modifies the model name inplace!)
-      for (auto& editor_model : editor_models)
-      {
-        // Get ending token
-        std::string ending_token;
-        size_t delimiter_index = editor_model.name.find("/");
-
-        if (delimiter_index != std::string::npos)
-        {
-          ending_token = editor_model.name
-            .substr(delimiter_index + 1, editor_model.name.length());
-        }
-        else
-        {
-          ending_token = editor_model.name;
-        }
-
-        // Check if namespaced model_name is the name we are looking for
-        // Match mismatched cases
-        if (iequals(ending_token, model_name))
-        {
-          // Skip rematches from previous for loop
-          if (model_name == editor_model.name)
-            continue;
-
-          pixmap = editor_model.get_pixmap();
-          model_meters_per_pixel = editor_model.meters_per_pixel;
-
-          printf("\n[WARNING] Thumbnail %1$s not found, "
-            "substituting %2$s instead!\n"
-            "(%1$s will be saved as %2$s)\n\n",
-            model_name.c_str(), editor_model.name.c_str());
-
-          // And reassign it!
-          model_name = editor_model.name;
-          break;
-        }
-      }
-
-      // Check again for pixmap find status
-      if (pixmap.isNull())
-      {
-        if (!error_printed)
-        {
-          printf("[ERROR] No thumbnail found: %s\n", model_name.c_str());
-          error_printed = true;
-        }
-        return;  // couldn't load the pixmap; ignore it.
-      }
-    }
-
-    pixmap_item = scene->addPixmap(pixmap);
-    pixmap_item->setOffset(-pixmap.width()/2, -pixmap.height()/2);
-    pixmap_item->setScale(model_meters_per_pixel / drawing_meters_per_pixel);
-    pixmap_item->setZValue(100.0);  // just anything taller than 0
-  }
-
-  pixmap_item->setPos(state.x, state.y);
-  pixmap_item->setRotation((-state.yaw + M_PI / 2.0) * 180.0 / M_PI);
-
-  // make the model "glow" if it is selected
-  if (selected)
-  {
-    QGraphicsColorizeEffect* colorize = new QGraphicsColorizeEffect;
-    colorize->setColor(QColor::fromRgbF(1.0, 0.2, 0.0, 1.0));
-    colorize->setStrength(1.0);
-    pixmap_item->setGraphicsEffect(colorize);
-  }
-}
-
-void Model::clear_scene()
-{
-  pixmap_item = nullptr;
-}
diff --git a/traffic_editor/gui/model_dialog.cpp b/traffic_editor/gui/model_dialog.cpp
deleted file mode 100644
index 418a2ff..0000000
--- a/traffic_editor/gui/model_dialog.cpp
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "model_dialog.h"
-#include <QtWidgets>
-using std::vector;
-
-
-ModelDialog::ModelDialog(
-  QWidget* parent,
-  Model& model,
-  const vector<EditorModel>& editor_models)
-: QDialog(parent),
-  _model(model),
-  _editor_models(editor_models)
-{
-  setWindowTitle("Model Properties");
-  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
-  _ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  bottom_buttons_layout->addWidget(_ok_button);
-  connect(
-    _ok_button, &QAbstractButton::clicked,
-    this, &ModelDialog::ok_button_clicked);
-
-  _cancel_button = new QPushButton("Cancel", this);
-  bottom_buttons_layout->addWidget(_cancel_button);
-  connect(
-    _cancel_button, &QAbstractButton::clicked,
-    this, &QDialog::reject);
-
-  QVBoxLayout* model_name_vbox_layout = new QVBoxLayout;
-  model_name_vbox_layout->addWidget(new QLabel("Name:"));
-
-  _model_name_line_edit =
-    new QLineEdit(QString::fromStdString(_model.model_name), this);
-  model_name_vbox_layout->addWidget(_model_name_line_edit);
-  connect(
-    _model_name_line_edit,
-    &QLineEdit::textEdited,
-    this,
-    &ModelDialog::model_name_line_edited);
-
-  _model_name_list_widget = new QListWidget;
-  model_name_vbox_layout->addWidget(_model_name_list_widget);
-  connect(
-    _model_name_list_widget,
-    &QListWidget::currentRowChanged,
-    this,
-    &ModelDialog::model_name_list_widget_changed);
-
-  _model_preview_label = new QLabel;
-  _model_preview_label->setMinimumSize(400, 400);
-  _model_preview_label->setSizePolicy(
-    QSizePolicy::MinimumExpanding,
-    QSizePolicy::Expanding);
-
-  QHBoxLayout* top_hbox_layout = new QHBoxLayout;
-  top_hbox_layout->addLayout(model_name_vbox_layout);
-  top_hbox_layout->addWidget(_model_preview_label);
-
-  QVBoxLayout* vbox_layout = new QVBoxLayout;
-  vbox_layout->addLayout(top_hbox_layout);
-  // todo: some sort of separator (?)
-  vbox_layout->addLayout(bottom_buttons_layout);
-
-  setLayout(vbox_layout);
-
-  for (const auto& em : _editor_models)
-    _model_name_list_widget->addItem(QString::fromStdString(em.name));
-
-  if (!_editor_models.empty())
-    _model_name_list_widget->setCurrentItem(
-      _model_name_list_widget->item(0));
-
-  _model_name_line_edit->setFocus(Qt::OtherFocusReason);
-}
-
-ModelDialog::~ModelDialog()
-{
-}
-
-void ModelDialog::ok_button_clicked()
-{
-  if (_model.model_name.empty())  // _model_name_line_edit->text().isEmpty())
-  {
-    QMessageBox::critical(this, "Error", "Model name missing");
-    return;
-  }
-
-  accept();
-}
-
-void ModelDialog::model_name_line_edited(const QString& text)
-{
-  // todo: render on parent if file exists?
-  if (_model_name_list_widget->count() == 0)
-  {
-    qWarning("model name list widget is empty :(");
-    return;  // nothing to do; there is no available model list
-  }
-
-  // see if we can auto-complete with anything in the list box
-  // scroll the list box to the first thing
-  const std::string user_text_lower(text.toLower().toStdString());
-  // could become super fancy but for now let's just do linear search...
-  size_t closest_idx = 0;
-  for (size_t i = 0; i < _editor_models.size(); i++)
-  {
-    if (user_text_lower < _editor_models[i].name_lowercase)
-    {
-      closest_idx = i;
-      break;
-    }
-  }
-  QListWidgetItem* item = _model_name_list_widget->item(closest_idx);
-  _model_name_list_widget->setCurrentItem(item);
-  _model_name_list_widget->scrollToItem(
-    item,
-    QAbstractItemView::PositionAtTop);
-}
-
-void ModelDialog::model_name_list_widget_changed(int row)
-{
-  _model.model_name = _editor_models[row].name;
-  const QPixmap& model_pixmap = _editor_models[row].get_pixmap();
-  if (model_pixmap.isNull())
-    return;// we don't have a pixmap to draw :(
-  // scale the pixmap so it fits within the currently allotted space
-  const int w = _model_preview_label->width();
-  const int h = _model_preview_label->height();
-  _model_preview_label->setPixmap(
-    model_pixmap.scaled(w, h, Qt::KeepAspectRatio));
-}
diff --git a/traffic_editor/gui/model_dialog.h b/traffic_editor/gui/model_dialog.h
deleted file mode 100644
index 436d95b..0000000
--- a/traffic_editor/gui/model_dialog.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef MODEL_DIALOG_H
-#define MODEL_DIALOG_H
-
-#include <QDialog>
-#include <QObject>
-#include "traffic_editor/model.h"
-#include "traffic_editor/editor_model.h"
-#include <vector>
-class QLineEdit;
-class QListWidget;
-class QLabel;
-
-
-class ModelDialog : public QDialog
-{
-  Q_OBJECT
-
-public:
-  ModelDialog(
-    QWidget* parent,
-    Model& model,
-    const std::vector<EditorModel>& editor_models);
-  ~ModelDialog();
-
-private:
-  Model& _model;
-  std::vector<EditorModel> _editor_models;
-
-  QLineEdit* _model_name_line_edit;
-  QListWidget* _model_name_list_widget;
-  QLabel* _model_preview_label;
-
-  QPushButton* _ok_button, * _cancel_button;
-
-private slots:
-  void ok_button_clicked();
-  void model_name_line_edited(const QString& text);
-  void model_name_list_widget_changed(int row);
-};
-
-#endif
diff --git a/traffic_editor/gui/param.cpp b/traffic_editor/gui/param.cpp
deleted file mode 100644
index b4340fd..0000000
--- a/traffic_editor/gui/param.cpp
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "traffic_editor/param.h"
-using std::string;
-
-
-Param::Param()
-: type(UNDEFINED), value_int(0), value_double(0.0), value_bool(false)
-{
-}
-
-Param::Param(const Type& t)
-: type(t), value_int(0), value_double(0.0), value_bool(false)
-{
-}
-
-Param::Param(const std::string& s)
-: type(STRING),
-  value_int(0),
-  value_double(0.0),
-  value_string(s),
-  value_bool(false)
-{
-}
-
-Param::Param(const int& i)
-: type(INT), value_int(i), value_double(0.0), value_bool(false)
-{
-}
-
-Param::Param(const double& d)
-: type(DOUBLE), value_int(0), value_double(d), value_bool(false)
-{
-}
-
-Param::Param(const bool& b)
-: type(BOOL), value_int(0), value_double(0.0), value_bool(b)
-{
-}
-
-Param::~Param()
-{
-}
-
-void Param::from_yaml(const YAML::Node& data)
-{
-  if (!data.IsSequence())
-    throw std::runtime_error("Param::from_yaml expected a YAML sequence");
-  type = static_cast<Type>(data[0].as<int>());
-  if (type == STRING)
-    value_string = data[1].as<string>();
-  else if (type == INT)
-    value_int = data[1].as<int>();
-  else if (type == DOUBLE)
-    value_double = data[1].as<double>();
-  else if (type == BOOL)
-    value_bool = data[1].as<bool>();
-  else
-    throw std::runtime_error("Param::from_yaml found an unknown type");
-}
-
-YAML::Node Param::to_yaml() const
-{
-  if (type == UNDEFINED)
-    return YAML::Node();
-
-  YAML::Node y;
-  y.push_back(static_cast<int>(type));
-  if (type == STRING)
-    y.push_back(value_string);
-  else if (type == INT)
-    y.push_back(value_int);
-  else if (type == DOUBLE)
-    y.push_back(value_double);
-  else if (type == BOOL)
-    y.push_back(value_bool);
-  else
-    throw std::runtime_error("Param::to_yaml found an unknown type");
-  return y;
-}
-
-void Param::set(const std::string& value)
-{
-  if (type == INT)
-    value_int = stoi(value);
-  else if (type == DOUBLE)
-    value_double = stod(value);
-  else if (type == STRING)
-    value_string = value;
-  else if (type == BOOL)
-    value_bool = (value == "true") || (value == "True");
-  else
-    throw std::runtime_error("Param::set() found an unknown type");
-}
-
-QString Param::to_qstring() const
-{
-  if (type == DOUBLE)
-    return QString::number(value_double);
-  else if (type == BOOL)
-    return value_bool ? QString("true") : QString("false");
-  else if (type == STRING)
-    return QString::fromStdString(value_string);
-  else if (type == INT)
-    return QString::number(value_int);
-  else
-    return QString("unknown type!");
-}
diff --git a/traffic_editor/gui/polygon.cpp b/traffic_editor/gui/polygon.cpp
deleted file mode 100644
index d545777..0000000
--- a/traffic_editor/gui/polygon.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "traffic_editor/polygon.h"
-using std::string;
-using std::vector;
-
-
-Polygon::Polygon()
-{
-  create_required_parameters();
-}
-
-Polygon::~Polygon()
-{
-}
-
-void Polygon::from_yaml(const YAML::Node& data, const Type polygon_type)
-{
-  if (!data.IsMap())
-    throw std::runtime_error("Polygon::from_yaml() expected a map");
-  type = polygon_type;
-  for (YAML::const_iterator it = data["vertices"].begin();
-    it != data["vertices"].end(); ++it)
-  {
-    vertices.push_back(it->as<int>());
-  }
-
-  // load the parameters
-  if (data["parameters"])
-  {
-    for (YAML::const_iterator it = data["parameters"].begin();
-      it != data["parameters"].end();
-      ++it)
-    {
-      Param p;
-      p.from_yaml(it->second);
-      params[it->first.as<string>()] = p;
-    }
-  }
-
-  create_required_parameters();
-}
-
-YAML::Node Polygon::to_yaml() const
-{
-  YAML::Node y;
-  for (const auto& vertex_idx : vertices)
-    y["vertices"].push_back(vertex_idx);
-  y["vertices"].SetStyle(YAML::EmitterStyle::Flow);
-  y["parameters"] = YAML::Node(YAML::NodeType::Map);
-  for (const auto& param : params)
-    y["parameters"][param.first] = param.second.to_yaml();
-  y["parameters"].SetStyle(YAML::EmitterStyle::Flow);
-  return y;
-}
-
-void Polygon::remove_vertex(const int vertex_idx)
-{
-  // find first occurrence of this vertex_idx
-  int vertex_occurrence_idx = -1;
-  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
-  {
-    if (vertices[i] == vertex_idx)
-    {
-      vertex_occurrence_idx = i;
-      break;
-    }
-  }
-  if (vertex_occurrence_idx < 0)
-  {
-    printf("never found vertex %d\n", vertex_idx);
-    return;  // never found it. so sad.
-  }
-  printf("found vertex %d at polygon vertices idx %d\n",
-    vertex_idx,
-    vertex_occurrence_idx);
-
-  vertices.erase(vertices.begin() + vertex_occurrence_idx);
-
-  // not sure what's going on here, but it doesn't work :(
-  //vector<int> &v = vertices;  // save typing
-  //v.erase(std::remove(v.begin(), v.end(), vertex_idx), v.end());
-}
-
-void Polygon::set_param(const std::string& name, const std::string& value)
-{
-  auto it = params.find(name);
-  if (it == params.end())
-  {
-    printf("tried to set unknown parameter [%s]\n", name.c_str());
-    return;  // unknown parameter
-  }
-  it->second.set(value);
-}
-
-void Polygon::create_required_parameters()
-{
-  // create required parameters if they don't exist yet on this edge
-  if (type == FLOOR)
-  {
-    create_param_if_needed(
-      "texture_name",
-      Param::STRING,
-      std::string("blue_linoleum"));
-    create_param_if_needed("texture_scale", Param::DOUBLE, 1.0);
-    create_param_if_needed("texture_rotation", Param::DOUBLE, 0.0);
-  }
-}
-
-template<typename T>
-void Polygon::create_param_if_needed(
-  const std::string& name,
-  const Param::Type& param_type,
-  const T& param_value)
-{
-  auto it = params.find(name);
-  if (it == params.end() || it->second.type != param_type)
-    params[name] = param_value;
-}
diff --git a/traffic_editor/gui/preferences_dialog.cpp b/traffic_editor/gui/preferences_dialog.cpp
deleted file mode 100644
index e489b3e..0000000
--- a/traffic_editor/gui/preferences_dialog.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "preferences_dialog.h"
-#include "preferences_keys.h"
-#include <QtWidgets>
-
-
-PreferencesDialog::PreferencesDialog(QWidget* parent)
-: QDialog(parent)
-{
-  setWindowTitle("Preferences");
-
-  QSettings settings;
-
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  cancel_button = new QPushButton("Cancel", this);
-
-  QHBoxLayout* thumbnail_path_layout = new QHBoxLayout;
-  thumbnail_path_line_edit = new QLineEdit(
-    settings.value(preferences_keys::thumbnail_path).toString(), this);
-  thumbnail_path_button = new QPushButton("Find...", this);
-  thumbnail_path_layout->addWidget(new QLabel("thumbnail path:"));
-  thumbnail_path_layout->addWidget(thumbnail_path_line_edit);
-  thumbnail_path_layout->addWidget(thumbnail_path_button);
-  connect(
-    thumbnail_path_button, &QAbstractButton::clicked,
-    this, &PreferencesDialog::thumbnail_path_button_clicked);
-
-  QHBoxLayout* bottom_buttons_layout = new QHBoxLayout;
-  bottom_buttons_layout->addWidget(cancel_button);
-  bottom_buttons_layout->addWidget(ok_button);
-  connect(
-    ok_button, &QAbstractButton::clicked,
-    this, &PreferencesDialog::ok_button_clicked);
-  connect(
-    cancel_button, &QAbstractButton::clicked,
-    this, &QDialog::reject);
-
-  open_previous_project_checkbox = new QCheckBox(
-    "Open previous project at startup", this);
-  open_previous_project_checkbox->setChecked(
-    settings.value(preferences_keys::open_previous_project).toBool());
-
-  QVBoxLayout* vbox_layout = new QVBoxLayout;
-  vbox_layout->addWidget(open_previous_project_checkbox);
-  vbox_layout->addLayout(thumbnail_path_layout);
-  // todo: some sort of separator (?)
-  vbox_layout->addLayout(bottom_buttons_layout);
-
-  setLayout(vbox_layout);
-}
-
-PreferencesDialog::~PreferencesDialog()
-{
-}
-
-void PreferencesDialog::thumbnail_path_button_clicked()
-{
-  QFileDialog file_dialog(this, "Find Thumbnail Path");
-  file_dialog.setFileMode(QFileDialog::Directory);
-  file_dialog.setOption(QFileDialog::ShowDirsOnly);
-  if (file_dialog.exec() != QDialog::Accepted)
-    return;// user clicked 'cancel'
-
-  const QString path = file_dialog.selectedFiles().first();
-  if (!QFileInfo(path).exists())
-  {
-    QMessageBox::critical(
-      this,
-      "path does not exist",
-      "path does not exist");
-    return;
-  }
-  thumbnail_path_line_edit->setText(path);
-}
-
-void PreferencesDialog::ok_button_clicked()
-{
-  if (!thumbnail_path_line_edit->text().isEmpty())
-  {
-    // make sure the path exists
-    if (!QFileInfo(thumbnail_path_line_edit->text()).exists())
-    {
-      QMessageBox::critical(
-        this,
-        "Thumbnail path must exist",
-        "Thumbnail path must exist");
-      return;
-    }
-  }
-
-  QSettings settings;
-
-  settings.setValue(
-    preferences_keys::thumbnail_path,
-    thumbnail_path_line_edit->text());
-
-  settings.setValue(
-    preferences_keys::open_previous_project,
-    open_previous_project_checkbox->isChecked());
-
-  accept();
-}
diff --git a/traffic_editor/gui/preferences_dialog.h b/traffic_editor/gui/preferences_dialog.h
deleted file mode 100644
index c52e8d2..0000000
--- a/traffic_editor/gui/preferences_dialog.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef PREFERENCES_DIALOG_H
-#define PREFERENCES_DIALOG_H
-
-#include <QDialog>
-class QLineEdit;
-class QCheckBox;
-
-
-class PreferencesDialog : public QDialog
-{
-public:
-  PreferencesDialog(QWidget* parent);
-  ~PreferencesDialog();
-
-private:
-  QLineEdit* thumbnail_path_line_edit;
-  QPushButton* thumbnail_path_button;
-  QCheckBox* open_previous_project_checkbox;
-  QPushButton* ok_button, * cancel_button;
-
-private slots:
-  void thumbnail_path_button_clicked();
-  void ok_button_clicked();
-};
-
-#endif
diff --git a/traffic_editor/gui/preferences_keys.cpp b/traffic_editor/gui/preferences_keys.cpp
deleted file mode 100644
index 0e69b5c..0000000
--- a/traffic_editor/gui/preferences_keys.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-#include "preferences_keys.h"
-
-const QString preferences_keys::thumbnail_path(
-  "editor/thumbnail_path");
-
-const QString preferences_keys::open_previous_project(
-  "editor/open_previous_project");
-
-const QString preferences_keys::previous_project_path(
-  "editor/previous_project_path");
-
-const QString preferences_keys::window_width("editor/window_width");
-const QString preferences_keys::window_height("editor/window_height");
-const QString preferences_keys::window_left("editor/window_left");
-const QString preferences_keys::window_top("editor/window_top");
-
-const QString preferences_keys::viewport_center_x("editor/viewport_center_x");
-const QString preferences_keys::viewport_center_y("editor/viewport_center_y");
-const QString preferences_keys::viewport_scale("editor/viewport_scale");
-const QString preferences_keys::level_name("editor/level_name");
diff --git a/traffic_editor/gui/preferences_keys.h b/traffic_editor/gui/preferences_keys.h
deleted file mode 100644
index 66fe640..0000000
--- a/traffic_editor/gui/preferences_keys.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#ifndef PREFERENCES_KEYS_H
-#define PREFERENCES_KEYS_H
-
-#include <QString>
-
-namespace preferences_keys {
-
-extern const QString thumbnail_path;
-extern const QString open_previous_project;
-extern const QString previous_project_path;
-extern const QString window_width;
-extern const QString window_height;
-extern const QString window_left;
-extern const QString window_top;
-extern const QString viewport_center_x;
-extern const QString viewport_center_y;
-extern const QString viewport_scale;
-extern const QString level_name;
-}
-
-#endif
diff --git a/traffic_editor/gui/project.cpp b/traffic_editor/gui/project.cpp
deleted file mode 100644
index cbd10e4..0000000
--- a/traffic_editor/gui/project.cpp
+++ /dev/null
@@ -1,716 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <cmath>
-#include <fstream>
-
-#include "project.h"
-#include "yaml_utils.h"
-
-#include <QFileInfo>
-#include <QDir>
-#include <QGraphicsItem>
-
-using std::string;
-using std::vector;
-
-
-Project::Project()
-{
-  for (size_t i = 0; i < rendering_options.show_building_lanes.size(); i++)
-    rendering_options.show_building_lanes[i] = true;
-}
-
-Project::~Project()
-{
-}
-
-bool Project::load_yaml_file(const std::string& _filename)
-{
-  filename = _filename;
-
-  YAML::Node yaml;
-  try
-  {
-    yaml = YAML::LoadFile(filename.c_str());
-  }
-  catch (const std::exception& e)
-  {
-    printf("couldn't parse %s: %s", filename.c_str(), e.what());
-    return false;
-  }
-
-  // change directory to the path of the file, so that we can correctly open
-  // relative paths recorded in the file
-
-  // TODO: save previous directory and restore it, in case other files
-  // we load are in different directories (!)
-
-  QString dir(QFileInfo(QString::fromStdString(filename)).absolutePath());
-  printf("changing directory to [%s]", qUtf8Printable(dir));
-  if (!QDir::setCurrent(dir))
-  {
-    printf("couldn't change directory\n");
-    return false;
-  }
-
-  if (yaml["name"])
-    name = yaml["name"].as<string>();
-
-  if (yaml["building"] && yaml["building"].IsMap())
-  {
-    if (!yaml["building"]["filename"])
-    {
-      printf("expected a 'filename' key within the 'building' map\n");
-      return false;
-    }
-    building.filename = yaml["building"]["filename"].as<string>();
-    if (!building.load_yaml_file())
-      return false;
-  }
-
-  if (yaml["scenarios"] && yaml["scenarios"].IsSequence())
-  {
-    for (YAML::const_iterator scenario_node = yaml["scenarios"].begin();
-      scenario_node != yaml["scenarios"].end();
-      ++scenario_node)
-    {
-      std::unique_ptr<Scenario> scenario(new Scenario);
-      scenario->filename = (*scenario_node)["filename"].as<string>();
-      if (!scenario->load())
-      {
-        printf("couldn't load [%s]\n", scenario->filename.c_str());
-        //return false;
-      }
-      scenarios.push_back(std::move(scenario));
-    }
-    if (!scenarios.empty())
-      scenario_idx = 0;
-  }
-
-  if (yaml["traffic_maps"] && yaml["traffic_maps"].IsMap())
-  {
-    const YAML::Node& ytm = yaml["traffic_maps"];
-    for (YAML::const_iterator it = ytm.begin(); it != ytm.end(); ++it)
-    {
-      TrafficMap tm;
-      tm.from_project_yaml(it->first.as<string>(), it->second);
-      traffic_maps.push_back(tm);
-    }
-  }
-
-  return true;
-}
-
-bool Project::save_yaml_file() const
-{
-  printf("Project::save_yaml_file()\n");
-
-  YAML::Node y;
-  y["version"] = 1;
-  y["name"] = name;
-
-  y["building"] = YAML::Node(YAML::NodeType::Map);
-  y["building"]["filename"] = building.filename;
-
-  for (const auto& scenario : scenarios)
-  {
-    printf("saving scenario\n");
-    YAML::Node scenario_node;
-    scenario_node["filename"] = scenario->filename;
-    y["scenarios"].push_back(scenario_node);
-  }
-
-  y["traffic_maps"] = YAML::Node(YAML::NodeType::Map);
-  for (const auto& traffic_map : traffic_maps)
-    y["traffic_maps"][traffic_map.name] = traffic_map.to_project_yaml();
-
-  YAML::Emitter emitter;
-  yaml_utils::write_node(y, emitter);
-  std::ofstream fout(filename);
-  fout << emitter.c_str() << std::endl;
-
-  return true;
-}
-
-bool Project::save()
-{
-  if (!save_yaml_file())
-    return false;
-
-  building.save_yaml_file();
-
-  /*
-  // TODO: currently the scenarios are not fully parsed, so we
-  // can't save them back to disk without data loss
-  for (const auto& scenario : scenarios)
-    if (!scenario->save())
-      return false;
-  */
-
-  return true;
-}
-
-bool Project::load(const std::string& _filename)
-{
-  // future extension point: dispatch based on file type (json/yaml/...)
-  return load_yaml_file(_filename);
-}
-
-void Project::add_scenario_vertex(
-  const int level_idx,
-  const double x,
-  const double y)
-{
-  printf("add_scenario_vertex(%d, %.3f, %.3f)\n", level_idx, x, y);
-  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
-    return;
-  scenarios[scenario_idx]->add_vertex(building.levels[level_idx].name, x, y);
-}
-
-void Project::scenario_row_clicked(const int row)
-{
-  printf("Project::scenario_row_clicked(%d)\n", row);
-  if (row < 0 || row >= static_cast<int>(scenarios.size()))
-  {
-    scenario_idx = -1;
-    return;
-  }
-  scenario_idx = row;
-}
-
-void Project::draw(
-  QGraphicsScene* scene,
-  const int level_idx,
-  std::vector<EditorModel>& editor_models)
-{
-  std::lock_guard<std::mutex> building_guard(building.building_mutex);
-
-  if (building.levels.empty())
-  {
-    printf("nothing to draw!\n");
-    return;
-  }
-
-  building.levels[level_idx].draw(scene, editor_models, rendering_options);
-  building.draw_lifts(scene, level_idx);
-
-  if (scenario_idx >= 0)
-    scenarios[scenario_idx]->draw(
-      scene,
-      building.levels[level_idx].name,
-      building.levels[level_idx].drawing_meters_per_pixel,
-      editor_models);
-}
-
-void Project::clear_selection(const int level_idx)
-{
-  if (building.levels.empty())
-    return;
-  building.levels[level_idx].clear_selection();
-
-  if (scenario_idx >= 0)
-    scenarios[scenario_idx]->clear_selection(building.levels[level_idx].name);
-}
-
-bool Project::delete_selected(const int level_idx)
-{
-  if (building.levels.empty())
-    return false;
-  if (!building.delete_selected(level_idx))
-    return false;
-  const std::string level_name = building.levels[level_idx].name;
-  if (scenario_idx >= 0 &&
-    !scenarios[scenario_idx]->delete_selected(level_name))
-    return false;
-  return true;
-}
-
-Project::NearestItem Project::nearest_items(
-  EditorModeId mode,
-  const int level_index,
-  const double x,
-  const double y)
-{
-  NearestItem ni;
-
-  if (level_index >= static_cast<int>(building.levels.size()))
-    return ni;
-  const BuildingLevel& building_level = building.levels[level_index];
-
-  if (mode == MODE_BUILDING)
-  {
-    for (size_t i = 0; i < building_level.vertices.size(); i++)
-    {
-      const Vertex& p = building_level.vertices[i];
-      const double dx = x - p.x;
-      const double dy = y - p.y;
-      const double dist = std::sqrt(dx*dx + dy*dy);
-      if (dist < ni.vertex_dist)
-      {
-        ni.vertex_dist = dist;
-        ni.vertex_idx = i;
-      }
-    }
-
-    for (size_t i = 0; i < building_level.fiducials.size(); i++)
-    {
-      const Fiducial& f = building_level.fiducials[i];
-      const double dx = x - f.x;
-      const double dy = y - f.y;
-      const double dist = std::sqrt(dx*dx + dy*dy);
-      if (dist < ni.fiducial_dist)
-      {
-        ni.fiducial_dist = dist;
-        ni.fiducial_idx = i;
-      }
-    }
-
-    for (size_t i = 0; i < building_level.models.size(); i++)
-    {
-      const Model& m = building_level.models[i];
-      const double dx = x - m.state.x;
-      const double dy = y - m.state.y;
-      const double dist = std::sqrt(dx*dx + dy*dy);  // no need for sqrt each time
-      if (dist < ni.model_dist)
-      {
-        ni.model_dist = dist;
-        ni.model_idx = i;
-      }
-    }
-  }
-  else if (mode == MODE_SCENARIO)
-  {
-    if (scenario_idx < 0 ||
-      scenario_idx >= static_cast<int>(scenarios.size()))
-      return ni;
-    const Scenario& scenario = *scenarios[scenario_idx];
-
-    for (const ScenarioLevel& scenario_level : scenario.levels)
-    {
-      if (scenario_level.name != building_level.name)
-        continue;
-
-      for (size_t i = 0; i < scenario_level.vertices.size(); i++)
-      {
-        const Vertex& p = scenario_level.vertices[i];
-        const double dx = x - p.x;
-        const double dy = y - p.y;
-        const double dist = std::sqrt(dx*dx + dy*dy);
-        if (dist < ni.vertex_dist)
-        {
-          ni.vertex_dist = dist;
-          ni.vertex_idx = i;
-        }
-      }
-    }
-  }
-
-  return ni;
-}
-
-ScenarioLevel* Project::scenario_level(const int building_level_idx)
-{
-  if (building_level_idx >= static_cast<int>(building.levels.size()))
-    return nullptr;
-  const BuildingLevel& building_level = building.levels[building_level_idx];
-
-  if (scenario_idx < 0 ||
-    scenario_idx >= static_cast<int>(scenarios.size()))
-    return nullptr;
-  // I'm sure this is a horrific abomination. Fix someday.
-  Scenario& scenario = *scenarios[scenario_idx];
-  for (size_t i = 0; i < scenario.levels.size(); i++)
-  {
-    if (scenario.levels[i].name == building_level.name)
-      return &scenario.levels[i];
-  }
-  return nullptr;
-}
-
-void Project::mouse_select_press(
-  const EditorModeId mode,
-  const int level_idx,
-  const double x,
-  const double y,
-  QGraphicsItem* graphics_item)
-{
-  clear_selection(level_idx);
-  const NearestItem ni = nearest_items(mode, level_idx, x, y);
-
-  const double vertex_dist_thresh =
-    building.levels[level_idx].vertex_radius /
-    building.levels[level_idx].drawing_meters_per_pixel;
-
-  if (mode == MODE_BUILDING)
-  {
-    // todo: use QGraphics stuff to see if we clicked a model pixmap...
-    const double model_dist_thresh = 0.5 /
-      building.levels[level_idx].drawing_meters_per_pixel;
-
-    if (rendering_options.show_models &&
-      ni.model_idx >= 0 &&
-      ni.model_dist < model_dist_thresh)
-      building.levels[level_idx].models[ni.model_idx].selected = true;
-    else if (ni.vertex_idx >= 0 && ni.vertex_dist < vertex_dist_thresh)
-      building.levels[level_idx].vertices[ni.vertex_idx].selected = true;
-    else if (ni.fiducial_idx >= 0 && ni.fiducial_dist < 10.0)
-      building.levels[level_idx].fiducials[ni.fiducial_idx].selected = true;
-    else
-    {
-      // use the QGraphics stuff to see if it's an edge segment or polygon
-      if (graphics_item)
-      {
-        switch (graphics_item->type())
-        {
-          case QGraphicsLineItem::Type:
-            set_selected_line_item(
-              level_idx,
-              qgraphicsitem_cast<QGraphicsLineItem*>(graphics_item),
-              mode);
-            break;
-
-          case QGraphicsPolygonItem::Type:
-            set_selected_containing_polygon(mode, level_idx, x, y);
-            break;
-
-          default:
-            printf("clicked unhandled type: %d\n",
-              static_cast<int>(graphics_item->type()));
-            break;
-        }
-      }
-    }
-  }
-  else if (mode == MODE_TRAFFIC)
-  {
-    // todo: keep traffic-map vertices separate from building vertices
-    // for now, they're using the same vertex list.
-
-    if (ni.vertex_idx >= 0 && ni.vertex_dist < vertex_dist_thresh)
-      building.levels[level_idx].vertices[ni.vertex_idx].selected = true;
-    else
-    {
-      // use the QGraphics stuff to see if it's an edge segment or polygon
-      if (graphics_item)
-      {
-        switch (graphics_item->type())
-        {
-          case QGraphicsLineItem::Type:
-            set_selected_line_item(
-              level_idx,
-              qgraphicsitem_cast<QGraphicsLineItem*>(graphics_item),
-              mode);
-            break;
-
-          default:
-            printf("clicked unhandled type: %d\n",
-              static_cast<int>(graphics_item->type()));
-            break;
-        }
-      }
-    }
-  }
-  else if (mode == MODE_SCENARIO && scenario_idx >= 0)
-  {
-    ScenarioLevel* level = scenario_level(level_idx);
-    if (ni.vertex_dist < 10.0)
-      level->vertices[ni.vertex_idx].selected = true;
-    else
-    {
-      // use the QGraphics stuff to see if it's an edge segment or polygon
-      if (graphics_item)
-      {
-        switch (graphics_item->type())
-        {
-          case QGraphicsPolygonItem::Type:
-            set_selected_containing_polygon(mode, level_idx, x, y);
-            break;
-
-          default:
-            printf("clicked unhandled type: %d\n",
-              static_cast<int>(graphics_item->type()));
-            break;
-        }
-      }
-
-    }
-  }
-}
-
-void Project::set_selected_line_item(
-  const int level_idx,
-  QGraphicsLineItem* line_item,
-  const EditorModeId mode)
-{
-  clear_selection(level_idx);
-
-  if (line_item == nullptr)
-    return;
-
-  // find if any of our lanes match those vertices
-  for (auto& edge : building.levels[level_idx].edges)
-  {
-    if (mode == MODE_TRAFFIC)
-    {
-      if (edge.type != Edge::LANE)
-        continue;
-      if (edge.get_graph_idx() != traffic_map_idx)
-        continue;
-    }
-    if (mode == MODE_BUILDING && edge.type == Edge::LANE)
-      continue;
-
-    // look up the line's vertices
-    const double x1 = line_item->line().x1();
-    const double y1 = line_item->line().y1();
-    const double x2 = line_item->line().x2();
-    const double y2 = line_item->line().y2();
-
-    const auto& v_start = building.levels[level_idx].vertices[edge.start_idx];
-    const auto& v_end = building.levels[level_idx].vertices[edge.end_idx];
-
-    // calculate distances
-    const double dx1 = v_start.x - x1;
-    const double dy1 = v_start.y - y1;
-    const double dx2 = v_end.x - x2;
-    const double dy2 = v_end.y - y2;
-    const double v1_dist = std::sqrt(dx1*dx1 + dy1*dy1);
-    const double v2_dist = std::sqrt(dx2*dx2 + dy2*dy2);
-
-    const double thresh = 10.0;  // it should be really tiny if it matches
-    if (v1_dist < thresh && v2_dist < thresh)
-    {
-      edge.selected = true;
-      return;  // stop after first one is found, don't select multiple
-    }
-  }
-}
-
-Polygon::EdgeDragPolygon Project::polygon_edge_drag_press(
-  const EditorModeId mode,
-  const int level_idx,
-  const Polygon* polygon,
-  const double x,
-  const double y)
-{
-  Polygon::EdgeDragPolygon edp;
-
-  if (level_idx < 0 || level_idx > static_cast<int>(building.levels.size()))
-    return edp;// oh no
-
-  if (mode == MODE_BUILDING)
-    return building.levels[level_idx].polygon_edge_drag_press(polygon, x, y);
-  else if (mode == MODE_SCENARIO)
-  {
-    ScenarioLevel* slevel = scenario_level(level_idx);
-    if (slevel == nullptr)
-      return edp;
-    return slevel->polygon_edge_drag_press(polygon, x, y);
-  }
-
-  return edp;
-}
-
-Polygon* Project::get_selected_polygon(
-  const EditorModeId mode,
-  const int level_idx)
-{
-  if (mode == MODE_BUILDING)
-  {
-    for (size_t i = 0; i < building.levels[level_idx].polygons.size(); i++)
-    {
-      if (building.levels[level_idx].polygons[i].selected)
-        return &building.levels[level_idx].polygons[i];// abomination
-    }
-  }
-  else if (mode == MODE_SCENARIO)
-  {
-    ScenarioLevel* slevel = scenario_level(level_idx);
-    if (slevel)
-    {
-      for (size_t i = 0; i < slevel->polygons.size(); i++)
-      {
-        if (slevel->polygons[i].selected)
-          return &slevel->polygons[i];// abomination
-      }
-    }
-  }
-  return nullptr;
-}
-
-void Project::set_selected_containing_polygon(
-  const EditorModeId mode,
-  const int level_idx,
-  const double x,
-  const double y)
-{
-  Level* level = nullptr;
-  if (mode == MODE_BUILDING)
-    level = &building.levels[level_idx];
-  else if (mode == MODE_SCENARIO)
-    level = scenario_level(level_idx);
-
-  if (level == nullptr)
-    return;
-
-  // holes are "higher" in our Z-stack (to make them clickable), so first
-  // we need to make a list of all polygons that contain this point.
-  vector<Polygon*> containing_polygons;
-  for (size_t i = 0; i < level->polygons.size(); i++)
-  {
-    Polygon& polygon = level->polygons[i];
-    QVector<QPointF> polygon_vertices;
-    for (const auto& vertex_idx: polygon.vertices)
-    {
-      const Vertex& v = level->vertices[vertex_idx];
-      polygon_vertices.append(QPointF(v.x, v.y));
-    }
-    QPolygonF qpolygon(polygon_vertices);
-    if (qpolygon.containsPoint(QPoint(x, y), Qt::OddEvenFill))
-      containing_polygons.push_back(&level->polygons[i]);
-  }
-
-  // first search for holes
-  for (Polygon* p : containing_polygons)
-  {
-    if (p->type == Polygon::HOLE)
-    {
-      p->selected = true;
-      return;
-    }
-  }
-
-  // if we get here, just return the first thing.
-  for (Polygon* p : containing_polygons)
-  {
-    p->selected = true;
-    return;
-  }
-}
-
-void Project::clear()
-{
-  building.clear();
-  name.clear();
-  filename.clear();
-  scenarios.clear();
-  scenario_idx = -1;
-}
-
-void Project::sim_tick()
-{
-  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
-    return;
-  scenarios[scenario_idx]->sim_tick(building);
-}
-
-void Project::sim_reset()
-{
-  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
-    return;
-  scenarios[scenario_idx]->sim_reset(building);
-}
-
-void Project::clear_scene()
-{
-  building.clear_scene();
-
-  for (auto& scenario : scenarios)
-    scenario->clear_scene();
-}
-
-void Project::add_lane(
-  const int level_idx,
-  const int start_idx,
-  const int end_idx)
-{
-  building.add_lane(level_idx, start_idx, end_idx, traffic_map_idx);
-}
-
-void Project::scenario_scene_update(
-  QGraphicsScene* scene,
-  const int level_idx)
-{
-  if (scenario_idx < 0 || scenario_idx >= static_cast<int>(scenarios.size()))
-    return;
-  scenarios[scenario_idx]->scene_update(scene, building, level_idx);
-}
-
-bool Project::has_sim_plugin()
-{
-  for (const auto& scenario : scenarios)
-  {
-    if (scenario->sim_plugin)
-      return true;
-  }
-  return false;
-}
-
-bool Project::set_filename(const std::string& _fn)
-{
-  const string suffix(".project.yaml");
-
-  // ensure there is at least one character in addition to the suffix length
-  if (_fn.size() <= suffix.size())
-  {
-    printf("Project::set_filename() too short: [%s]\n", _fn.c_str());
-    return false;
-  }
-
-  // ensure the filename ends in .project.yaml
-  // it should, because the "save as" dialog appends it, but...
-  if (_fn.compare(_fn.size() - suffix.size(), suffix.size(), suffix))
-  {
-    printf(
-      "Project::set_filename() filename had unexpected suffix: [%s]\n",
-      _fn.c_str());
-    return false;
-  }
-
-  const string no_suffix(_fn.substr(0, _fn.size() - suffix.size()));
-
-  const size_t last_slash_pos = no_suffix.rfind('/', no_suffix.size());
-
-  const string stem(
-    (last_slash_pos == string::npos) ?
-    no_suffix :
-    string(no_suffix, last_slash_pos + 1));
-
-  filename = _fn;
-
-  if (name.empty())
-  {
-    name = stem;
-  }
-
-  if (building.name.empty())
-  {
-    building.name = stem;
-  }
-  if (building.filename.empty())
-  {
-    building.filename = stem + std::string(".building.yaml");
-  }
-
-  printf(
-    "set project filename to [%s] stem: [%s] building filename: [%s]\n",
-    filename.c_str(),
-    stem.c_str(),
-    building.filename.c_str());
-  return true;
-}
diff --git a/traffic_editor/gui/project.h b/traffic_editor/gui/project.h
deleted file mode 100644
index ca95654..0000000
--- a/traffic_editor/gui/project.h
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef PROJECT_H
-#define PROJECT_H
-
-#include "traffic_editor/building.h"
-#include "traffic_editor/editor_model.h"
-#include "editor_mode_id.h"
-#include "scenario.h"
-#include "traffic_map.h"
-
-#include <array>
-#include <memory>
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-
-class QGraphicsScene;
-class QGraphicsItem;
-class QGraphicsLineItem;
-
-
-class Project
-{
-public:
-  std::string name;
-
-  Building building;
-  std::vector<std::unique_ptr<Scenario>> scenarios;
-  std::vector<TrafficMap> traffic_maps;
-
-  int scenario_idx = -1;  // the current scenario being viewed/edited
-  int traffic_map_idx = 0;  // the current traffic map being viewed/edited
-
-  /////////////////////////////////
-  Project();
-  ~Project();
-
-  bool save();
-  bool load(const std::string& _filename);
-
-  void clear();
-
-  void add_scenario_vertex(int level_index, double x, double y);
-  void scenario_row_clicked(const int row);
-
-  void clear_scene();
-
-  void draw(
-    QGraphicsScene* scene,
-    const int level_idx,
-    std::vector<EditorModel>& editor_models);
-
-  void scenario_scene_update(
-    QGraphicsScene* scene,
-    const int level_idx);
-
-  void clear_selection(const int level_idx);
-  bool delete_selected(const int level_idx);
-
-  struct NearestItem
-  {
-    double model_dist = 1e100;
-    int model_idx = -1;
-
-    double vertex_dist = 1e100;
-    int vertex_idx = -1;
-
-    double fiducial_dist = 1e100;
-    int fiducial_idx = -1;
-  };
-
-  NearestItem nearest_items(
-    EditorModeId mode,
-    const int level_index,
-    const double x,
-    const double y);
-
-  ScenarioLevel* scenario_level(const int building_level_idx);
-
-  void set_selected_containing_polygon(
-    const EditorModeId mode,
-    const int level_idx,
-    const double x,
-    const double y);
-
-  void mouse_select_press(
-    const EditorModeId mode,
-    const int level_idx,
-    const double x,
-    const double y,
-    QGraphicsItem* graphics_item);
-
-  Polygon::EdgeDragPolygon polygon_edge_drag_press(
-    const EditorModeId mode,
-    const int level_idx,
-    const Polygon* polygon,
-    const double x,
-    const double y);
-
-  Polygon* get_selected_polygon(const EditorModeId mode, const int level_idx);
-
-  void add_lane(
-    const int level_idx,
-    const int start_idx,
-    const int end_idx);
-
-  // simulation stuff
-  void sim_reset();
-  void sim_tick();
-  bool sim_is_paused = true;
-
-  RenderingOptions rendering_options;
-
-  bool has_sim_plugin();
-
-  bool set_filename(const std::string& _filename);
-  std::string get_filename() { return filename; }
-
-private:
-  bool load_yaml_file(const std::string& _filename);
-  bool save_yaml_file() const;
-
-  void set_selected_line_item(
-    const int level_idx,
-    QGraphicsLineItem* line_item,
-    const EditorModeId mode);
-
-  std::string filename;
-};
-
-#endif
diff --git a/traffic_editor/gui/project_dialog.cpp b/traffic_editor/gui/project_dialog.cpp
deleted file mode 100644
index d09cee5..0000000
--- a/traffic_editor/gui/project_dialog.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "project_dialog.h"
-#include <QtWidgets>
-
-
-ProjectDialog::ProjectDialog(Project& _project)
-: QDialog(),
-  project(_project)
-{
-  setWindowTitle("Project Properties");
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  cancel_button = new QPushButton("Cancel", this);
-
-  QHBoxLayout* name_hbox = new QHBoxLayout;
-  name_hbox->addWidget(new QLabel("Project name:"));
-  name_line_edit = new QLineEdit(QString::fromStdString(project.name));
-  name_hbox->addWidget(name_line_edit);
-
-  QHBoxLayout* building_hbox = new QHBoxLayout;
-  building_path_line_edit = new QLineEdit(
-    QString::fromStdString(project.building.filename));
-  QPushButton* building_path_button = new QPushButton("Find...");
-  connect(
-    building_path_button,
-    &QAbstractButton::clicked,
-    this,
-    &ProjectDialog::building_path_button_clicked);
-
-  building_hbox->addWidget(new QLabel("Building path:"));
-  building_hbox->addWidget(building_path_line_edit);
-  building_hbox->addWidget(building_path_button);
-
-  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
-  bottom_buttons_hbox->addWidget(cancel_button);
-  bottom_buttons_hbox->addWidget(ok_button);
-  connect(
-    ok_button,
-    &QAbstractButton::clicked,
-    this,
-    &ProjectDialog::ok_button_clicked);
-  connect(
-    cancel_button,
-    &QAbstractButton::clicked,
-    this,
-    &QDialog::reject);
-
-  QVBoxLayout* top_vbox = new QVBoxLayout;
-  top_vbox->addLayout(name_hbox);
-  top_vbox->addLayout(building_hbox);
-  // todo: some sort of separator (?)
-  top_vbox->addLayout(bottom_buttons_hbox);
-
-  setLayout(top_vbox);
-}
-
-ProjectDialog::~ProjectDialog()
-{
-}
-
-void ProjectDialog::ok_button_clicked()
-{
-  project.name = name_line_edit->text().toStdString();
-
-  // if the building filename has changed, load it.
-  const std::string previous_building_filename = project.building.filename;
-  project.building.filename = building_path_line_edit->text().toStdString();
-  if (project.building.filename != previous_building_filename)
-    project.building.load_yaml_file();
-
-  accept();
-}
-
-void ProjectDialog::building_path_button_clicked()
-{
-  QFileDialog file_dialog(this, "Building File");
-  file_dialog.setFileMode(QFileDialog::ExistingFile);
-  file_dialog.setNameFilter("*.building.yaml");
-  if (file_dialog.exec() != QDialog::Accepted)
-    return;// user clicked 'cancel' in the QFileDialog
-  const QString filename = file_dialog.selectedFiles().first();
-  if (!QFileInfo(filename).exists())  // is this check even needed?
-  {
-    QMessageBox::critical(
-      this,
-      "Building file does not exist",
-      "File does not exist.");
-    return;
-  }
-  // todo: probably should change to the path of this project before
-  // calculating the relative path. This is already done
-  // implicitly, but maybe should be more explicit here.
-  building_path_line_edit->setText(
-    QDir::current().relativeFilePath(filename));
-}
diff --git a/traffic_editor/gui/project_dialog.h b/traffic_editor/gui/project_dialog.h
deleted file mode 100644
index d1ef8f5..0000000
--- a/traffic_editor/gui/project_dialog.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef PROJECT_DIALOG_H
-#define PROJECT_DIALOG_H
-
-#include <QDialog>
-#include "project.h"
-class QLineEdit;
-class QComboBox;
-
-
-class ProjectDialog : public QDialog
-{
-public:
-  ProjectDialog(Project& _project);
-  ~ProjectDialog();
-
-private:
-  Project& project;
-
-  QLineEdit* name_line_edit;
-  QLineEdit* building_path_line_edit;
-  QPushButton* ok_button, * cancel_button;
-
-private slots:
-  void ok_button_clicked();
-  void building_path_button_clicked();
-};
-
-#endif
diff --git a/traffic_editor/gui/scenario.cpp b/traffic_editor/gui/scenario.cpp
deleted file mode 100644
index 0000ab8..0000000
--- a/traffic_editor/gui/scenario.cpp
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <fstream>
-#include <ignition/common/SystemPaths.hh>
-
-#include "scenario.h"
-#include "yaml_utils.h"
-
-using std::string;
-using std::unique_ptr;
-
-
-Scenario::Scenario()
-{
-}
-
-Scenario::~Scenario()
-{
-}
-
-bool Scenario::load()
-{
-  printf("Scenario::load(%s)\n", filename.c_str());
-  YAML::Node yaml;
-  try
-  {
-    yaml = YAML::LoadFile(filename.c_str());
-  }
-  catch (const std::exception& e)
-  {
-    printf("couldn't parse %s: %s", filename.c_str(), e.what());
-    return false;
-  }
-
-  if (yaml["name"])
-    name = yaml["name"].as<string>();
-
-  levels.clear();
-  if (yaml["levels"])
-  {
-    const YAML::Node yl = yaml["levels"];
-    for (YAML::const_iterator it = yl.begin(); it != yl.end(); ++it)
-    {
-      ScenarioLevel l;
-      l.from_yaml(it->first.as<string>(), it->second);
-      levels.push_back(l);
-    }
-  }
-
-  if (yaml["plugin_name"])
-  {
-    string plugin_path = yaml["plugin_path"].as<string>();
-    ignition::common::SystemPaths paths;
-    paths.AddPluginPaths(plugin_path);
-
-    const string plugin_name = yaml["plugin_name"].as<string>();
-    std::string lib_path = paths.FindSharedLibrary(plugin_name);
-    printf("FindSharedLibrary returned [%s]\n", lib_path.c_str());
-
-    ignition::plugin::Loader loader;
-    std::unordered_set<string> plugin_libs = loader.LoadLib(lib_path);
-    std::unordered_set<string> sim_libs =
-      loader.PluginsImplementing("Simulation");
-
-    for (const auto& s : plugin_libs)
-      printf("  found plugin library: [%s]\n", s.c_str());
-
-    for (const auto& s : sim_libs)
-      printf("  found simulation library: [%s]\n", s.c_str());
-
-    for (const std::string& plugin_class_name : plugin_libs)
-    {
-      if (sim_libs.find(plugin_class_name) != sim_libs.end())
-      {
-        printf(
-          "trying to instantiate [%s] from library [%s]...\n",
-          plugin_class_name.c_str(),
-          plugin_name.c_str());
-        sim_plugin = loader.Instantiate(plugin_class_name);
-
-        if (sim_plugin.IsEmpty())
-        {
-          printf("simulation plugin instantiation failed :(\n");
-          break;
-        }
-
-        printf("success! created a simulation plugin instance!\n");
-        Simulation* sim = sim_plugin->QueryInterface<Simulation>();
-        if (!sim)
-        {
-          printf("woah! couldn't get interface to plugin!\n");
-          break;
-        }
-
-        sim->load(yaml["plugin_config"]);
-        break;
-      }
-    }
-  }
-
-  print();
-
-  return true;
-}
-
-void Scenario::print() const
-{
-  printf("scenario: [%s]\n", name.c_str());
-  printf("  filename: [%s]\n", filename.c_str());
-}
-
-bool Scenario::save() const
-{
-  YAML::Node y;
-  y["version"] = 1;
-  y["name"] = name;
-
-  y["levels"] = YAML::Node(YAML::NodeType::Map);
-  for (const ScenarioLevel& level : levels)
-    y["levels"][level.name] = level.to_yaml();
-
-  YAML::Emitter emitter;
-  yaml_utils::write_node(y, emitter);
-  std::ofstream fout(filename);
-  fout << emitter.c_str() << std::endl;
-
-  return true;
-}
-
-void Scenario::draw(
-  QGraphicsScene* scene,
-  const std::string& level_name,
-  const double meters_per_pixel,
-  std::vector<EditorModel>& /*editor_models*/) const
-{
-  printf("Scenario::draw(%s)\n", level_name.c_str());
-  for (const ScenarioLevel& level : levels)
-  {
-    if (level.name == level_name)
-    {
-      level.draw(scene, meters_per_pixel);
-      break;
-    }
-  }
-}
-
-void Scenario::add_vertex(
-  const std::string& level_name,
-  const double x,
-  const double y)
-{
-  printf("Scenario::add_vertex(%s, %.1f, %.1f)\n", level_name.c_str(), x, y);
-  for (ScenarioLevel& level : levels)
-  {
-    if (level.name == level_name)
-    {
-      level.add_vertex(x, y);
-      return;
-    }
-  }
-  // if we get here, we didn't find a ScenarioLevel for this level name,
-  // so we have to add it now.
-  printf("adding level [%s] to scenario\n", level_name.c_str());
-  ScenarioLevel level;
-  level.name = level_name;
-  level.add_vertex(x, y);
-  levels.push_back(level);
-}
-
-void Scenario::clear_selection(const std::string& level_name)
-{
-  for (ScenarioLevel& level : levels)
-  {
-    if (level.name == level_name)
-      level.clear_selection();
-  }
-}
-
-bool Scenario::delete_selected(const std::string& level_name)
-{
-  for (ScenarioLevel& level : levels)
-  {
-    if (level.name == level_name)
-      return level.delete_selected();
-  }
-  return true;
-}
-
-void Scenario::sim_tick(Building& building)
-{
-  if (!sim_plugin.IsEmpty())
-  {
-    std::lock_guard<std::mutex> building_guard(building.building_mutex);
-    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
-    if (sim)
-      sim->tick(building);
-  }
-}
-
-void Scenario::sim_reset(Building& building)
-{
-  if (!sim_plugin.IsEmpty())
-  {
-    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
-    if (sim)
-      sim->reset(building);
-  }
-
-  sim_time_seconds = 0.0;
-  sim_tick_counter = 0;
-}
-
-void Scenario::clear_scene()
-{
-  printf("Scenario::clear_scene()\n");
-
-  if (!sim_plugin.IsEmpty())
-  {
-    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
-    if (sim)
-      sim->scene_clear();
-  }
-}
-
-void Scenario::scene_update(
-  QGraphicsScene* scene,
-  Building& building,
-  const int level_idx)
-{
-  if (!sim_plugin.IsEmpty())
-  {
-    std::lock_guard<std::mutex> building_guard(building.building_mutex);
-    Simulation* sim = sim_plugin->QueryInterface<Simulation>();
-    if (sim)
-      sim->scene_update(scene, building, level_idx);
-  }
-}
diff --git a/traffic_editor/gui/scenario.h b/traffic_editor/gui/scenario.h
deleted file mode 100644
index a49857c..0000000
--- a/traffic_editor/gui/scenario.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef SCENARIO_H
-#define SCENARIO_H
-
-#include "traffic_editor/building.h"
-#include "traffic_editor/editor_model.h"
-#include "traffic_editor/model.h"
-#include "scenario_level.h"
-#include "traffic_editor/vertex.h"
-#include "plugins/simulation.h"
-
-#include <ignition/plugin/SpecializedPluginPtr.hh>
-#include <ignition/plugin/Loader.hh>
-
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-
-class Scenario
-{
-public:
-  std::string name;
-  std::string filename;
-  std::vector<ScenarioLevel> levels;
-
-  /////////////////////////////////
-  Scenario();
-  ~Scenario();
-
-  bool load();
-  bool save() const;
-
-  void clear_scene();
-
-  void draw(
-    QGraphicsScene* scene,
-    const std::string& level_name,
-    const double meters_per_pixel,
-    std::vector<EditorModel>& editor_models) const;
-
-  void add_vertex(
-    const std::string& level_name,
-    const double x,
-    const double y);
-
-  void clear_selection(const std::string& level_name);
-  bool delete_selected(const std::string& level_name);
-
-  void print() const;
-
-  // simulation stuff
-  double sim_time_seconds = 0.0;
-  int sim_tick_counter = 0;
-
-  void sim_tick(Building& building);
-  void sim_reset(Building& building);
-
-  void scene_update(
-    QGraphicsScene* scene,
-    Building& building,
-    const int level_idx);
-
-  std::vector<std::string> behavior_signals;
-
-  ignition::plugin::SpecializedPluginPtr<Simulation> sim_plugin;
-};
-
-#endif
diff --git a/traffic_editor/gui/scenario_dialog.cpp b/traffic_editor/gui/scenario_dialog.cpp
deleted file mode 100644
index 0c77bac..0000000
--- a/traffic_editor/gui/scenario_dialog.cpp
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "scenario_dialog.h"
-#include <QtWidgets>
-#include <utility>
-using std::unique_ptr;
-
-
-ScenarioDialog::ScenarioDialog(Scenario& _scenario)
-: QDialog(),
-  scenario(_scenario)
-{
-  setWindowTitle("Scenario Properties");
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  cancel_button = new QPushButton("Cancel", this);
-
-  QHBoxLayout* name_hbox = new QHBoxLayout;
-  name_hbox->addWidget(new QLabel("Scenario name:"));
-  name_line_edit = new QLineEdit(QString::fromStdString(scenario.name));
-  name_hbox->addWidget(name_line_edit);
-
-  QHBoxLayout* scenario_hbox = new QHBoxLayout;
-  scenario_path_line_edit = new QLineEdit(
-    QString::fromStdString(scenario.filename));
-  QPushButton* scenario_path_button = new QPushButton("Find...");
-  connect(
-    scenario_path_button,
-    &QAbstractButton::clicked,
-    this,
-    &ScenarioDialog::scenario_path_button_clicked);
-
-  scenario_hbox->addWidget(new QLabel("Scenario path:"));
-  scenario_hbox->addWidget(scenario_path_line_edit);
-  scenario_hbox->addWidget(scenario_path_button);
-
-  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
-  bottom_buttons_hbox->addWidget(cancel_button);
-  bottom_buttons_hbox->addWidget(ok_button);
-  connect(
-    ok_button,
-    &QAbstractButton::clicked,
-    this,
-    &ScenarioDialog::ok_button_clicked);
-  connect(
-    cancel_button,
-    &QAbstractButton::clicked,
-    this,
-    &QDialog::reject);
-
-  QVBoxLayout* top_vbox = new QVBoxLayout;
-  top_vbox->addLayout(name_hbox);
-  top_vbox->addLayout(scenario_hbox);
-  // todo: some sort of separator (?)
-  top_vbox->addLayout(bottom_buttons_hbox);
-
-  setLayout(top_vbox);
-}
-
-ScenarioDialog::~ScenarioDialog()
-{
-}
-
-void ScenarioDialog::ok_button_clicked()
-{
-  scenario.name = name_line_edit->text().toStdString();
-
-  if (scenario_path_line_edit->text().isEmpty())
-  {
-    QMessageBox::critical(
-      this,
-      "Scenario filename not provided",
-      "Scenario filename must be defined. Otherwise click [Cancel].");
-    return;
-  }
-
-  if (!scenario_path_line_edit->text().endsWith(".scenario.yaml"))
-  {
-    QMessageBox::critical(
-      this,
-      "Bad scenario filename",
-      "Scenario filename must end in .scenario.yaml");
-    return;
-  }
-
-  scenario.filename = scenario_path_line_edit->text().toStdString();
-
-  accept();
-}
-
-void ScenarioDialog::scenario_path_button_clicked()
-{
-  QFileDialog file_dialog(this, "Scenario File");
-  //file_dialog.setFileMode(QFileDialog::ExistingFile);
-  file_dialog.setNameFilter("*.scenario.yaml");
-  if (file_dialog.exec() != QDialog::Accepted)
-    return;// user clicked 'cancel' in the QFileDialog
-  const QString filename = file_dialog.selectedFiles().first();
-
-  // if the scenario filename has changed, load it.
-  const std::string previous_scenario_filename = scenario.filename;
-
-  scenario_path_line_edit->setText(
-    QDir::current().relativeFilePath(filename));
-
-  scenario.filename = scenario_path_line_edit->text().toStdString();
-
-  if (scenario.filename != previous_scenario_filename)
-  {
-    if (QFileInfo(filename).exists() && !scenario.load())
-    {
-      QMessageBox::critical(
-        this,
-        "Unable to load scenario file",
-        "Unable to load scenario file. Check filename?");
-    }
-  }
-}
diff --git a/traffic_editor/gui/scenario_dialog.h b/traffic_editor/gui/scenario_dialog.h
deleted file mode 100644
index 9da4e57..0000000
--- a/traffic_editor/gui/scenario_dialog.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef SCENARIO_DIALOG_H
-#define SCENARIO_DIALOG_H
-
-#include <QDialog>
-#include <memory>
-#include "project.h"
-class QLineEdit;
-class QComboBox;
-
-
-class ScenarioDialog : public QDialog
-{
-public:
-  ScenarioDialog(Scenario& _scenario);
-  ~ScenarioDialog();
-
-  Scenario& scenario;
-
-private:
-
-  QLineEdit* name_line_edit;
-  QLineEdit* scenario_path_line_edit;
-  QPushButton* ok_button, * cancel_button;
-
-private slots:
-  void ok_button_clicked();
-  void scenario_path_button_clicked();
-};
-
-#endif
diff --git a/traffic_editor/gui/scenario_level.cpp b/traffic_editor/gui/scenario_level.cpp
deleted file mode 100644
index 3e6ed91..0000000
--- a/traffic_editor/gui/scenario_level.cpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-
-#include <QGraphicsOpacityEffect>
-#include <QGraphicsPixmapItem>
-#include <QGraphicsScene>
-#include <QImage>
-#include <QImageReader>
-
-#include "scenario_level.h"
-using std::string;
-using std::vector;
-
-
-ScenarioLevel::ScenarioLevel()
-: Level()
-{
-}
-
-ScenarioLevel::~ScenarioLevel()
-{
-}
-
-bool ScenarioLevel::from_yaml(
-  const std::string& _name,
-  const YAML::Node& yaml_node)
-{
-  printf("parsing scenario level [%s]\n", _name.c_str());
-
-  name = _name;
-
-  if (!yaml_node.IsMap())
-    throw std::runtime_error("level " + name + " YAML invalid");
-
-  parse_vertices(yaml_node);
-
-  if (yaml_node["roi"] && yaml_node["roi"].IsSequence())
-  {
-    const YAML::Node& y_roi = yaml_node["roi"];
-    for (YAML::const_iterator it = y_roi.begin(); it != y_roi.end(); ++it)
-    {
-      Polygon p;
-      p.from_yaml(*it, Polygon::ROI);
-      polygons.push_back(p);
-    }
-  }
-  return true;
-}
-
-YAML::Node ScenarioLevel::to_yaml() const
-{
-  YAML::Node y;
-  for (const auto& v : vertices)
-    y["vertices"].push_back(v.to_yaml());
-
-  for (const auto& polygon : polygons)
-  {
-    switch (polygon.type)
-    {
-      case Polygon::ROI:
-        y["roi"].push_back(polygon.to_yaml());
-        break;
-      default:
-        printf("tried to save an unknown polygon type: %d\n",
-          static_cast<int>(polygon.type));
-        break;
-    }
-  }
-
-  return y;
-}
-
-bool ScenarioLevel::delete_selected()
-{
-  // Vertices take a lot more care, because we have to check if a vertex
-  // is used in an edge or a polygon before deleting it, and update all
-  // higher-index vertex indices in the edges and polygon vertex lists.
-  // Since this is a potentially expensive operation, first we'll spin
-  // through the vertex list and see if any vertices are selected, and
-  // only then make a copy of the vertex list.
-  int selected_vertex_idx = -1;
-  for (int i = 0; i < static_cast<int>(vertices.size()); i++)
-  {
-    if (vertices[i].selected)
-    {
-      selected_vertex_idx = i;
-      break;  // just grab the index of the first selected vertex
-    }
-  }
-  if (selected_vertex_idx >= 0)
-  {
-    // See if this vertex is used in any edges/polygons.
-    bool vertex_used = false;
-    for (const auto& polygon : polygons)
-    {
-      for (const int& vertex_idx : polygon.vertices)
-      {
-        if (vertex_idx == selected_vertex_idx)
-          vertex_used = true;
-      }
-    }
-    if (vertex_used)
-      return false;// don't try to delete a vertex used in a shape
-
-    // the vertex is not currently being used, so let's erase it
-    vertices.erase(vertices.begin() + selected_vertex_idx);
-
-    for (Polygon& polygon : polygons)
-    {
-      for (int i = 0; i < static_cast<int>(polygon.vertices.size()); i++)
-      {
-        if (polygon.vertices[i] > selected_vertex_idx)
-          polygon.vertices[i]--;
-      }
-    }
-  }
-  return true;
-}
-
-void ScenarioLevel::draw_polygons(QGraphicsScene* scene) const
-{
-  QBrush polygon_brush(QColor::fromRgbF(0.8, 0.8, 0.0, 0.2));
-  QBrush selected_polygon_brush(QColor::fromRgbF(1.0, 0.0, 0.0, 0.5));
-
-  for (const auto& polygon : polygons)
-  {
-    // now draw the polygons
-    QVector<QPointF> polygon_vertices;
-    for (const auto& vertex_idx: polygon.vertices)
-    {
-      const Vertex& v = vertices[vertex_idx];
-      polygon_vertices.append(QPointF(v.x, v.y));
-    }
-    scene->addPolygon(
-      QPolygonF(polygon_vertices),
-      QPen(Qt::black),
-      polygon.selected ? selected_polygon_brush : polygon_brush);
-  }
-}
-
-void ScenarioLevel::clear_selection()
-{
-  for (auto& vertex : vertices)
-    vertex.selected = false;
-
-  for (auto& polygon : polygons)
-    polygon.selected = false;
-}
-
-void ScenarioLevel::draw(
-  QGraphicsScene* scene,
-  const double meters_per_pixel) const
-{
-  draw_polygons(scene);
-
-  for (const auto& v : vertices)
-    v.draw(scene, 0.1 / meters_per_pixel, QColor::fromRgbF(1.0, 1.0, 0.0));
-}
diff --git a/traffic_editor/gui/scenario_level.h b/traffic_editor/gui/scenario_level.h
deleted file mode 100644
index eda2503..0000000
--- a/traffic_editor/gui/scenario_level.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef SCENARIO_LEVEL_H
-#define SCENARIO_LEVEL_H
-
-#include "traffic_editor/level.h"
-
-#include <yaml-cpp/yaml.h>
-#include <string>
-
-class QGraphicsScene;
-
-
-class ScenarioLevel : public Level
-{
-public:
-  std::string name;
-
-  ScenarioLevel();
-  ~ScenarioLevel();
-
-  bool from_yaml(const std::string& _name, const YAML::Node& yaml_node);
-  YAML::Node to_yaml() const;
-
-  bool delete_selected();
-
-  void clear_selection();
-
-  void draw(
-    QGraphicsScene* scene,
-    const double meters_per_pixel) const;
-
-  void draw_polygons(QGraphicsScene* scene) const;
-};
-
-#endif
diff --git a/traffic_editor/gui/scenario_table.cpp b/traffic_editor/gui/scenario_table.cpp
deleted file mode 100644
index 96289b1..0000000
--- a/traffic_editor/gui/scenario_table.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "scenario_dialog.h"
-#include "scenario_table.h"
-#include <QtWidgets>
-using std::unique_ptr;
-
-
-ScenarioTable::ScenarioTable()
-: TableList(2)
-{
-  const QStringList labels = { "#", "Name", "" };
-  setHorizontalHeaderLabels(labels);
-}
-
-ScenarioTable::~ScenarioTable()
-{
-}
-
-void ScenarioTable::update(Project& project)
-{
-  blockSignals(true);
-  setRowCount(1 + project.scenarios.size());
-  for (size_t i = 0; i < project.scenarios.size(); i++)
-  {
-    const Scenario& scenario = *project.scenarios[i];
-
-    QTableWidgetItem* name_item =
-      new QTableWidgetItem(QString::fromStdString(scenario.name));
-
-    if (static_cast<int>(i) == project.scenario_idx)
-      name_item->setBackground(QBrush(QColor("#e0ffe0")));
-
-    setItem(i, 0, name_item);
-
-    QPushButton* edit_button = new QPushButton("Edit...", this);
-    setCellWidget(i, 1, edit_button);
-    connect(
-      edit_button,
-      &QAbstractButton::clicked,
-      [this, &project, i]()
-      {
-        ScenarioDialog dialog(*project.scenarios[i]);
-        dialog.exec();
-        update(project);
-        emit redraw();
-      });
-  }
-
-  // we'll use the last row for the "Add" button
-  const int last_row_idx = static_cast<int>(project.scenarios.size());
-  setCellWidget(last_row_idx, 0, nullptr);
-  QPushButton* add_button = new QPushButton("Add...", this);
-  setCellWidget(last_row_idx, 1, add_button);
-  connect(
-    add_button, &QAbstractButton::clicked,
-    [this, &project]()
-    {
-      unique_ptr<Scenario> scenario = std::make_unique<Scenario>();
-      ScenarioDialog scenario_dialog(*scenario);
-      if (scenario_dialog.exec() == QDialog::Accepted)
-      {
-        project.scenarios.push_back(std::move(scenario));
-        update(project);
-        emit redraw();
-      }
-      else
-        scenario.release();
-    });
-
-  blockSignals(false);
-}
diff --git a/traffic_editor/gui/scenario_table.h b/traffic_editor/gui/scenario_table.h
deleted file mode 100644
index f521254..0000000
--- a/traffic_editor/gui/scenario_table.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef SCENARIO_TABLE_H
-#define SCENARIO_TABLE_H
-
-#include <QTableWidget>
-
-#include "table_list.h"
-#include "project.h"
-
-class ScenarioTable : public TableList
-{
-public:
-  ScenarioTable();
-  ~ScenarioTable();
-
-  void update(Project& project);
-};
-
-#endif
diff --git a/traffic_editor/gui/sim_thread.cpp b/traffic_editor/gui/sim_thread.cpp
deleted file mode 100644
index b76b0ab..0000000
--- a/traffic_editor/gui/sim_thread.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "sim_thread.h"
-#include <QTimer>
-#include "editor.h"
-
-SimThread::SimThread()
-: QThread()
-{
-}
-
-SimThread::~SimThread()
-{
-}
-
-void SimThread::run()
-{
-  printf("entering SimThread::run()\n");
-  while (true)
-  {
-    usleep(100);  // todo: user-editable parameter here from GUI...
-    if (isInterruptionRequested())
-      break;
-    Editor::get_instance()->sim_tick();
-  }
-}
diff --git a/traffic_editor/gui/sim_thread.h b/traffic_editor/gui/sim_thread.h
deleted file mode 100644
index 1e443f6..0000000
--- a/traffic_editor/gui/sim_thread.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef SIM_THREAD_H
-#define SIM_THREAD_H
-
-#include <QThread>
-
-class SimThread : public QThread
-{
-  Q_OBJECT
-
-public:
-  SimThread();
-  ~SimThread();
-
-  void run() override;
-};
-
-#endif
diff --git a/traffic_editor/gui/table_list.cpp b/traffic_editor/gui/table_list.cpp
deleted file mode 100644
index cadc7e2..0000000
--- a/traffic_editor/gui/table_list.cpp
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "table_list.h"
-#include <QtWidgets>
-
-TableList::TableList(const int num_cols)
-{
-  const char* style =
-    "QTableWidget { background-color: #e0e0e0; color: black; } "
-    "QHeaderView::section { color: white; } "
-    "QLineEdit { background:white; } "
-    "QCheckBox { padding-left: 5px; background-color: #e0e0e0; } "
-    "QPushButton { margin: 5px; background-color: #c0c0c0; border: 1px solid black; } "
-    "QPushButton:pressed { background-color: #808080; }";
-  setStyleSheet(style);
-  setColumnCount(num_cols);
-  setMinimumSize(400, 200);
-
-  verticalHeader()->setVisible(false);
-  verticalHeader()->setSectionResizeMode(
-    QHeaderView::ResizeToContents);
-
-  horizontalHeader()->setVisible(true);
-  horizontalHeader()->setDefaultAlignment(Qt::AlignLeft);
-  horizontalHeader()->setSectionResizeMode(
-    0, QHeaderView::Stretch);
-
-  for (int col = 1; col < num_cols; col++)
-    horizontalHeader()->setSectionResizeMode(
-      col,
-      QHeaderView::ResizeToContents);
-
-  setAutoFillBackground(true);
-
-  setSizePolicy(
-    QSizePolicy::Fixed,
-    QSizePolicy::MinimumExpanding);
-}
-
-TableList::~TableList()
-{
-}
diff --git a/traffic_editor/gui/table_list.h b/traffic_editor/gui/table_list.h
deleted file mode 100644
index 8cf9744..0000000
--- a/traffic_editor/gui/table_list.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef TABLE_LIST_H
-#define TABLE_LIST_H
-
-#include <QTableWidget>
-
-class TableList : public QTableWidget
-{
-  Q_OBJECT
-
-public:
-  TableList(const int num_cols = 2);
-  ~TableList();
-
-signals:
-  void redraw();
-};
-
-#endif
diff --git a/traffic_editor/gui/traffic_map.cpp b/traffic_editor/gui/traffic_map.cpp
deleted file mode 100644
index 236ddbd..0000000
--- a/traffic_editor/gui/traffic_map.cpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "traffic_map.h"
-#include <yaml-cpp/yaml.h>
-
-using std::string;
-
-TrafficMap::TrafficMap()
-{
-}
-
-TrafficMap::~TrafficMap()
-{
-}
-
-bool TrafficMap::from_project_yaml(const string& _name, const YAML::Node& y)
-{
-  name = _name;
-
-  if (y["offset"] && y["offset"].IsSequence())
-  {
-    x_offset = y["offset"][0].as<double>();
-    y_offset = y["offset"][1].as<double>();
-  }
-
-  // todo: open 'filename' and load its contents
-  if (y["filename"])
-  {
-    filename = y["filename"].as<string>();
-    return load_file();
-  }
-
-  return true;
-}
-
-bool TrafficMap::load_file()
-{
-  printf("Building::load_yaml_file(%s)\n", filename.c_str());
-  YAML::Node y;
-  try
-  {
-    y = YAML::LoadFile(filename.c_str());
-  }
-  catch (const std::exception& e)
-  {
-    printf("couldn't parse %s: %s", filename.c_str(), e.what());
-    return false;
-  }
-  printf("parsed traffic-map file %s\n", filename.c_str());
-
-  return true;
-}
-
-YAML::Node TrafficMap::to_project_yaml() const
-{
-  YAML::Node y;
-  y["filename"] = filename;
-  y["offset"].push_back(x_offset);
-  y["offset"].push_back(y_offset);
-  y["offset"].SetStyle(YAML::EmitterStyle::Flow);
-  return y;
-}
diff --git a/traffic_editor/gui/traffic_map.h b/traffic_editor/gui/traffic_map.h
deleted file mode 100644
index 0d74011..0000000
--- a/traffic_editor/gui/traffic_map.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef TRAFFIC_MAP_H
-#define TRAFFIC_MAP_H
-
-#include <string>
-#include <yaml-cpp/yaml.h>
-
-class TrafficMap
-{
-public:
-  std::string name;
-  std::string filename;
-  double x_offset = 0;
-  double y_offset = 0;
-  bool visible = true;
-
-  /////////////////////////////////
-  TrafficMap();
-  ~TrafficMap();
-
-  bool from_project_yaml(const std::string& name, const YAML::Node& data);
-  YAML::Node to_project_yaml() const;
-
-  bool load_file();
-};
-
-#endif
diff --git a/traffic_editor/gui/traffic_map_dialog.cpp b/traffic_editor/gui/traffic_map_dialog.cpp
deleted file mode 100644
index fb57961..0000000
--- a/traffic_editor/gui/traffic_map_dialog.cpp
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "traffic_map_dialog.h"
-#include <QtWidgets>
-
-
-TrafficMapDialog::TrafficMapDialog(TrafficMap& _traffic_map)
-: QDialog(),
-  traffic_map(_traffic_map)
-{
-  setWindowTitle("Traffic Map Properties");
-  ok_button = new QPushButton("OK", this);  // first button = [enter] button
-  cancel_button = new QPushButton("Cancel", this);
-
-  QHBoxLayout* name_hbox = new QHBoxLayout;
-  name_hbox->addWidget(new QLabel("Traffic map name:"));
-  name_line_edit = new QLineEdit(QString::fromStdString(traffic_map.name));
-  name_hbox->addWidget(name_line_edit);
-
-  QHBoxLayout* path_hbox = new QHBoxLayout;
-  path_line_edit =
-    new QLineEdit(QString::fromStdString(traffic_map.filename));
-  QPushButton* path_button = new QPushButton("Find...");
-  connect(
-    path_button,
-    &QAbstractButton::clicked,
-    this,
-    &TrafficMapDialog::path_button_clicked);
-
-  path_hbox->addWidget(new QLabel("Traffic map path:"));
-  path_hbox->addWidget(path_line_edit);
-  path_hbox->addWidget(path_button);
-
-  QHBoxLayout* bottom_buttons_hbox = new QHBoxLayout;
-  bottom_buttons_hbox->addWidget(cancel_button);
-  bottom_buttons_hbox->addWidget(ok_button);
-  connect(
-    ok_button,
-    &QAbstractButton::clicked,
-    this,
-    &TrafficMapDialog::ok_button_clicked);
-  connect(
-    cancel_button,
-    &QAbstractButton::clicked,
-    this,
-    &QDialog::reject);
-
-  QVBoxLayout* top_vbox = new QVBoxLayout;
-  top_vbox->addLayout(name_hbox);
-  top_vbox->addLayout(path_hbox);
-  // todo: some sort of separator (?)
-  top_vbox->addLayout(bottom_buttons_hbox);
-
-  setLayout(top_vbox);
-}
-
-TrafficMapDialog::~TrafficMapDialog()
-{
-}
-
-void TrafficMapDialog::ok_button_clicked()
-{
-  traffic_map.name = name_line_edit->text().toStdString();
-
-  if (path_line_edit->text().isEmpty())
-  {
-    QMessageBox::critical(
-      this,
-      "Filename not provided",
-      "Filename must be defined. Otherwise click [Cancel].");
-    return;
-  }
-
-  if (!path_line_edit->text().endsWith(".traffic_map.yaml"))
-  {
-    QMessageBox::critical(
-      this,
-      "Bad filename",
-      "Filename must end in .traffic_map.yaml");
-    return;
-  }
-
-  traffic_map.filename = path_line_edit->text().toStdString();
-
-  accept();
-}
-
-void TrafficMapDialog::path_button_clicked()
-{
-  QFileDialog file_dialog(this, "Traffic Map File");
-  //file_dialog.setFileMode(QFileDialog::ExistingFile);
-  file_dialog.setNameFilter("*.traffic_map.yaml");
-  if (file_dialog.exec() != QDialog::Accepted)
-    return;// user clicked 'cancel' in the QFileDialog
-  const QString filename = file_dialog.selectedFiles().first();
-
-  // if the filename has changed, load it.
-  const std::string previous_filename = traffic_map.filename;
-
-  path_line_edit->setText(QDir::current().relativeFilePath(filename));
-
-  traffic_map.filename = path_line_edit->text().toStdString();
-
-  if (traffic_map.filename != previous_filename)
-  {
-    if (QFileInfo(filename).exists() && !traffic_map.load_file())
-    {
-      QMessageBox::critical(
-        this,
-        "Unable to load file",
-        "Unable to load file. Check filename?");
-    }
-  }
-}
diff --git a/traffic_editor/gui/traffic_map_dialog.h b/traffic_editor/gui/traffic_map_dialog.h
deleted file mode 100644
index 9bcede7..0000000
--- a/traffic_editor/gui/traffic_map_dialog.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef TRAFFIC_MAP_DIALOG_H
-#define TRAFFIC_MAP_DIALOG_H
-
-#include <QDialog>
-#include "project.h"
-#include "traffic_map.h"
-class QLineEdit;
-class QComboBox;
-
-
-class TrafficMapDialog : public QDialog
-{
-public:
-  TrafficMapDialog(TrafficMap& _scenario);
-  ~TrafficMapDialog();
-
-private:
-  TrafficMap& traffic_map;
-
-  QLineEdit* name_line_edit;
-  QLineEdit* path_line_edit;
-  QPushButton* ok_button, * cancel_button;
-
-private slots:
-  void ok_button_clicked();
-  void path_button_clicked();
-};
-
-#endif
diff --git a/traffic_editor/gui/traffic_table.cpp b/traffic_editor/gui/traffic_table.cpp
deleted file mode 100644
index 43aa7b1..0000000
--- a/traffic_editor/gui/traffic_table.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include "traffic_table.h"
-#include "traffic_map_dialog.h"
-#include <QtWidgets>
-
-
-TrafficTable::TrafficTable()
-: TableList(3)
-{
-  const QStringList labels = { "Show", "Name", "" };
-  setHorizontalHeaderLabels(labels);
-  horizontalHeader()->setSectionResizeMode(
-    0, QHeaderView::ResizeToContents);
-  horizontalHeader()->setSectionResizeMode(
-    1, QHeaderView::Stretch);
-}
-
-TrafficTable::~TrafficTable()
-{
-}
-
-void TrafficTable::update(Project& project)
-{
-  RenderingOptions& opts = project.rendering_options;
-
-  const size_t num_internal_lanes = opts.show_building_lanes.size();
-
-  blockSignals(true);
-  setRowCount(
-    1 +
-    num_internal_lanes +
-    project.traffic_maps.size());
-
-  // first render the 10 "internal" traffic maps stored in the building yaml
-  for (size_t i = 0; i < num_internal_lanes; i++)
-  {
-    QCheckBox* checkbox = new QCheckBox;
-    checkbox->setChecked(opts.show_building_lanes[i]);
-    setCellWidget(i, 0, checkbox);
-    connect(
-      checkbox,
-      &QAbstractButton::clicked,
-      [this, &project, i](bool box_checked)
-      {
-        project.rendering_options.show_building_lanes[i] = box_checked;
-        emit redraw();
-      });
-
-
-    QTableWidgetItem* name_item =
-      new QTableWidgetItem(QString("Graph %1").arg(i));
-
-    if (static_cast<int>(i) == project.traffic_map_idx)
-      name_item->setBackground(QBrush(QColor("#e0ffe0")));
-
-    setItem(i, 1, name_item);
-  }
-
-  // now the "explicitly linked" external traffic maps
-  for (size_t i = 0; i < project.traffic_maps.size(); i++)
-  {
-    const TrafficMap& traffic_map = project.traffic_maps[i];
-
-    QCheckBox* checkbox = new QCheckBox;
-    checkbox->setChecked(traffic_map.visible);
-    setCellWidget(num_internal_lanes + i, 0, checkbox);
-    connect(
-      checkbox,
-      &QAbstractButton::clicked,
-      [this, &project, i](bool box_checked)
-      {
-        project.traffic_maps[i].visible = box_checked;
-        emit redraw();
-      });
-
-    QTableWidgetItem* name_item =
-      new QTableWidgetItem(QString::fromStdString(traffic_map.name));
-    setItem(num_internal_lanes + i, 1, name_item);
-
-    QPushButton* edit_button = new QPushButton("Edit...", this);
-    setCellWidget(num_internal_lanes + i, 2, edit_button);
-    connect(
-      edit_button,
-      &QAbstractButton::clicked,
-      [this, &project, i]()
-      {
-        TrafficMapDialog dialog(project.traffic_maps[i]);
-        dialog.exec();
-        update(project);
-        emit redraw();
-      });
-  }
-
-  // we'll use the last row for the "Add" button
-  const int last_row_idx =
-    static_cast<int>(num_internal_lanes + project.traffic_maps.size());
-
-  setCellWidget(last_row_idx, 0, nullptr);
-  setCellWidget(last_row_idx, 1, nullptr);
-  QPushButton* add_button = new QPushButton("Add...", this);
-  setCellWidget(last_row_idx, 2, add_button);
-  connect(
-    add_button,
-    &QAbstractButton::clicked,
-    [this, &project]()
-    {
-      TrafficMap traffic_map;
-      TrafficMapDialog dialog(traffic_map);
-      if (dialog.exec() == QDialog::Accepted)
-      {
-        project.traffic_maps.push_back(traffic_map);
-        update(project);
-        emit redraw();
-      }
-    });
-
-  blockSignals(false);
-}
diff --git a/traffic_editor/gui/traffic_table.h b/traffic_editor/gui/traffic_table.h
deleted file mode 100644
index b5bf495..0000000
--- a/traffic_editor/gui/traffic_table.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef TRAFFIC_TABLE_H
-#define TRAFFIC_TABLE_H
-
-#include <QTableWidget>
-
-#include "table_list.h"
-#include "project.h"
-
-class TrafficTable : public TableList
-{
-public:
-  TrafficTable();
-  ~TrafficTable();
-
-  void update(Project& project);
-};
-
-#endif
diff --git a/traffic_editor/gui/transform_dialog.ui b/traffic_editor/gui/transform_dialog.ui
deleted file mode 100644
index e08187f..0000000
--- a/traffic_editor/gui/transform_dialog.ui
+++ /dev/null
@@ -1,94 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<ui version="4.0">
- <class>TransformDialog</class>
- <widget class="QDialog" name="TransformDialog">
-  <property name="geometry">
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>379</width>
-    <height>152</height>
-   </rect>
-  </property>
-  <property name="windowTitle">
-   <string>Dialog</string>
-  </property>
-  <layout class="QFormLayout" name="formLayout">
-   <item row="0" column="0">
-    <widget class="QLabel" name="rotate_all_models_label">
-     <property name="text">
-      <string>Rotate all models:</string>
-     </property>
-    </widget>
-   </item>
-   <item row="0" column="1">
-    <widget class="QLineEdit" name="rotate_all_models_line_edit">
-     <property name="text">
-      <string>0</string>
-     </property>
-    </widget>
-   </item>
-   <item row="2" column="1">
-    <widget class="QDialogButtonBox" name="buttonBox">
-     <property name="standardButtons">
-      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
-     </property>
-     <property name="centerButtons">
-      <bool>false</bool>
-     </property>
-    </widget>
-   </item>
-   <item row="1" column="1">
-    <spacer name="verticalSpacer">
-     <property name="orientation">
-      <enum>Qt::Vertical</enum>
-     </property>
-     <property name="sizeType">
-      <enum>QSizePolicy::MinimumExpanding</enum>
-     </property>
-     <property name="sizeHint" stdset="0">
-      <size>
-       <width>20</width>
-       <height>40</height>
-      </size>
-     </property>
-    </spacer>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>accepted()</signal>
-   <receiver>TransformDialog</receiver>
-   <slot>accept()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>273</x>
-     <y>121</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>189</x>
-     <y>75</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>rejected()</signal>
-   <receiver>TransformDialog</receiver>
-   <slot>reject()</slot>
-   <hints>
-    <hint type="sourcelabel">
-     <x>273</x>
-     <y>121</y>
-    </hint>
-    <hint type="destinationlabel">
-     <x>189</x>
-     <y>75</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>
diff --git a/traffic_editor/gui/vertex.cpp b/traffic_editor/gui/vertex.cpp
deleted file mode 100644
index 7c884f8..0000000
--- a/traffic_editor/gui/vertex.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <cmath>
-
-#include <QGraphicsScene>
-#include <QGraphicsSimpleTextItem>
-
-#include "traffic_editor/vertex.h"
-using std::string;
-using std::vector;
-using std::pair;
-
-const vector<pair<string, Param::Type>> Vertex::allowed_params
-{
-  { "is_parking_spot", Param::Type::BOOL },
-  { "is_charger", Param::Type::BOOL},
-  { "dock_name", Param::Type::STRING},
-  { "workcell_name", Param::Type::STRING },
-  { "spawn_robot_type", Param::Type::STRING },
-  { "spawn_robot_name", Param::Type::STRING },
-  { "is_holding_point", Param::Type::BOOL },
-  { "is_passthrough_point", Param::Type::BOOL }
-};
-
-
-Vertex::Vertex()
-: x(0), y(0), selected(false)
-{
-}
-
-Vertex::Vertex(double _x, double _y, const string& _name)
-: x(_x), y(_y), name(_name), selected(false)
-{
-}
-
-void Vertex::from_yaml(const YAML::Node& data)
-{
-  if (!data.IsSequence())
-    throw std::runtime_error("Vertex::from_yaml expected a sequence");
-  x = data[0].as<double>();
-  y = data[1].as<double>();
-  if (data.size() < 4)
-    return;// todo: remove... intended only during format transition
-  // skip the z-offset in data[2] for now
-  name = data[3].as<string>();
-
-  // load the parameters, all of which (including the params map) are
-  // optional at the moment.
-  if (data.size() >= 4)
-  {
-    for (YAML::const_iterator it = data[4].begin(); it != data[4].end(); ++it)
-    {
-      Param p;
-      p.from_yaml(it->second);
-      params[it->first.as<string>()] = p;
-    }
-  }
-}
-
-YAML::Node Vertex::to_yaml() const
-{
-  // This is in image space. I think it's safe to say nobody is clicking
-  // with more than 1/1000 precision inside a single pixel.
-
-  YAML::Node vertex_node;
-  vertex_node.SetStyle(YAML::EmitterStyle::Flow);
-  vertex_node.push_back(std::round(x * 1000.0) / 1000.0);
-  vertex_node.push_back(std::round(y * 1000.0) / 1000.0);
-  vertex_node.push_back(0.0);  // placeholder for Z offsets in the future
-  vertex_node.push_back(name);
-
-  if (!params.empty())
-  {
-    YAML::Node params_node(YAML::NodeType::Map);
-    for (const auto& param : params)
-      params_node[param.first] = param.second.to_yaml();
-    vertex_node.push_back(params_node);
-  }
-  return vertex_node;
-}
-
-void Vertex::draw(
-  QGraphicsScene* scene,
-  const double radius,
-  const QColor& color) const
-{
-  QPen vertex_pen(Qt::black);
-  vertex_pen.setWidthF(radius / 2.0);
-
-  const double a = 0.5;
-
-  QColor nonselected_color(color);
-  nonselected_color.setAlphaF(a);
-
-  QColor selected_color = QColor::fromRgbF(1.0, 0.0, 0.0, a);
-
-  scene->addEllipse(
-    x - radius,
-    y - radius,
-    2 * radius,
-    2 * radius,
-    vertex_pen,
-    selected ? QBrush(selected_color) : QBrush(nonselected_color));
-
-  if (!name.empty())
-  {
-    QGraphicsSimpleTextItem* item = scene->addSimpleText(
-      QString::fromStdString(name),
-      QFont("Helvetica", 6));
-    item->setBrush(selected ? selected_color : color);
-    item->setPos(x, y + radius);
-  }
-}
-
-void Vertex::set_param(const std::string& param_name, const std::string& value)
-{
-  auto it = params.find(param_name);
-  if (it == params.end())
-  {
-    printf("tried to set unknown parameter [%s]\n", param_name.c_str());
-    return;  // unknown parameter
-  }
-  it->second.set(value);
-}
diff --git a/traffic_editor/gui/yaml_utils.cpp b/traffic_editor/gui/yaml_utils.cpp
deleted file mode 100644
index 9f00add..0000000
--- a/traffic_editor/gui/yaml_utils.cpp
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#include <algorithm>
-
-#include "yaml_utils.h"
-
-#include <string>
-using std::string;
-
-
-// Recursive function to write YAML ordered maps. Credit: Dave Hershberger
-// posted to this GitHub issue: https://github.com/jbeder/yaml-cpp/issues/169
-void yaml_utils::write_node(
-  const YAML::Node& node,
-  YAML::Emitter& emitter)
-{
-  switch (node.Style())
-  {
-    case YAML::EmitterStyle::Block:
-      emitter << YAML::Block;
-      break;
-    case YAML::EmitterStyle::Flow:
-      emitter << YAML::Flow;
-      break;
-    default:
-      break;
-  }
-
-  switch (node.Type())
-  {
-    case YAML::NodeType::Sequence:
-    {
-      emitter << YAML::BeginSeq;
-      for (size_t i = 0; i < node.size(); i++)
-        write_node(node[i], emitter);
-      emitter << YAML::EndSeq;
-      break;
-    }
-    case YAML::NodeType::Map:
-    {
-      emitter << YAML::BeginMap;
-      // the keys are stored in random order, so we need to collect and sort
-      std::vector<string> keys;
-      keys.reserve(node.size());
-      for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
-        keys.push_back(it->first.as<string>());
-      std::sort(keys.begin(), keys.end());
-      for (size_t i = 0; i < keys.size(); i++)
-      {
-        emitter << YAML::Key << keys[i] << YAML::Value;
-        write_node(node[keys[i]], emitter);
-      }
-      emitter << YAML::EndMap;
-      break;
-    }
-    default:
-      emitter << node;
-      break;
-  }
-}
diff --git a/traffic_editor/gui/yaml_utils.h b/traffic_editor/gui/yaml_utils.h
deleted file mode 100644
index 50458a8..0000000
--- a/traffic_editor/gui/yaml_utils.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef YAML_UTILS_H
-#define YAML_UTILS_H
-
-#include <yaml-cpp/yaml.h>
-
-namespace yaml_utils {
-
-// Recursive function to write YAML ordered maps. Credit: Dave Hershberger
-void write_node(const YAML::Node& node, YAML::Emitter& emitter);
-
-}
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/building.h b/traffic_editor/include/traffic_editor/building.h
deleted file mode 100644
index 93826d8..0000000
--- a/traffic_editor/include/traffic_editor/building.h
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_H
-#define BUILDING_H
-
-
-class QGraphicsScene;
-
-#include <memory>
-#include <mutex>
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-
-#include <QGraphicsLineItem>
-#include <QPointF>
-
-#include "building_level.h"
-#include "lift.h"
-
-
-class Building
-{
-public:
-  Building();
-  virtual ~Building();
-
-  std::string name;
-  std::string reference_level_name;
-  std::vector<BuildingLevel> levels;
-  std::vector<Lift> lifts;
-  std::mutex building_mutex;
-
-  std::string filename;
-
-  bool load_yaml_file();
-  bool save_yaml_file();
-  void clear();  // clear all internal data structures
-
-  void add_level(const BuildingLevel& level);
-
-  void add_vertex(int level_index, double x, double y);
-  void add_fiducial(int level_index, double x, double y);
-
-  int find_nearest_vertex_index(
-    int level_index, double x, double y, double& distance);
-
-  enum ItemType { VERTEX=1, MODEL, FIDUCIAL };
-  struct NearestItem
-  {
-    double model_dist = 1e100;
-    int model_idx = -1;
-
-    double vertex_dist = 1e100;
-    int vertex_idx = -1;
-
-    double fiducial_dist = 1e100;
-    int fiducial_idx = -1;
-  };
-
-  NearestItem nearest_items(
-    const int level_index,
-    const double x,
-    const double y);
-
-  int nearest_item_index_if_within_distance(
-    const int level_index,
-    const double x,
-    const double y,
-    const double distance_threshold,
-    const ItemType item_type);
-
-  void add_edge(
-    const int level_idx,
-    const int start_idx,
-    const int end_idx,
-    const Edge::Type edge_type);
-
-  void add_lane(
-    const int level_idx,
-    const int start_idx,
-    const int end_idx,
-    const int graph_idx);
-
-  void add_model(
-    const int level_idx,
-    const double x,
-    const double y,
-    const double z,
-    const double yaw,
-    const std::string& model_name);
-
-  bool delete_selected(const int level_index);
-
-  void set_model_yaw(
-    const int level_idx,
-    const int model_idx,
-    const double yaw);
-
-  void draw_lifts(QGraphicsScene* scene, const int level_idx);
-
-  bool transform_between_levels(
-    const std::string& from_level_name,
-    const QPointF& from_point,
-    const std::string& to_level_name,
-    QPointF& to_point);
-
-  bool transform_between_levels(
-    const int from_level_idx,
-    const QPointF& from_point,
-    const int to_level_idx,
-    QPointF& to_point);
-
-  void clear_transform_cache();
-
-  struct LevelPair
-  {
-    int from_idx = -1;
-    int to_idx = -1;
-
-    bool operator<(const LevelPair& rhs) const
-    {
-      return std::tie(from_idx, to_idx) < std::tie(rhs.from_idx, rhs.to_idx);
-    }
-  };
-
-  // to apply transform: first scale, then translate
-  struct Transform
-  {
-    double scale = 1.0;
-    double dx = 0.0;
-    double dy = 0.0;
-  };
-  typedef std::map<LevelPair, Transform> TransformMap;
-  TransformMap transforms;
-
-  Transform compute_transform(
-    const int from_level_idx,
-    const int to_level_idx);
-
-  Transform get_transform(
-    const int from_level_idx,
-    const int to_level_idx);
-
-  void calculate_all_transforms();
-
-  int get_reference_level_idx();
-
-  void clear_scene();
-
-  double level_meters_per_pixel(const std::string& level_name) const;
-
-  void rotate_all_models(const double rotation);
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/building_level.h b/traffic_editor/include/traffic_editor/building_level.h
deleted file mode 100644
index ec91018..0000000
--- a/traffic_editor/include/traffic_editor/building_level.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef BUILDING_LEVEL_H
-#define BUILDING_LEVEL_H
-
-#include "traffic_editor/level.h"
-
-#include <yaml-cpp/yaml.h>
-#include <string>
-
-#include "traffic_editor/edge.h"
-#include "traffic_editor/editor_model.h"
-#include "traffic_editor/fiducial.h"
-#include "traffic_editor/layer.h"
-#include "traffic_editor/model.h"
-#include "traffic_editor/polygon.h"
-#include "traffic_editor/rendering_options.h"
-#include "traffic_editor/vertex.h"
-
-#include <QPixmap>
-#include <QPainterPath>
-class QGraphicsScene;
-
-
-class BuildingLevel : public Level
-{
-public:
-  BuildingLevel();
-  ~BuildingLevel();
-
-  std::string drawing_filename;
-  int drawing_width = 0;
-  int drawing_height = 0;
-  double drawing_meters_per_pixel = 0.05;
-  double elevation = 0.0;
-  const double vertex_radius = 0.1;  // meters
-
-  double x_meters = 10.0;  // manually specified if no drawing supplied
-  double y_meters = 10.0;  // manually specified if no drawing supplied
-
-  // when generating the building in "flattened" mode, the levels have
-  // to be offset in the (x, y) plane to avoid clobbering each other.
-  double flattened_x_offset = 0.0;
-  double flattened_y_offset = 0.0;
-
-  std::vector<Model> models;
-  std::vector<Fiducial> fiducials;
-
-  QPixmap floorplan_pixmap;
-
-  bool from_yaml(const std::string& name, const YAML::Node& data);
-  YAML::Node to_yaml() const;
-
-  bool delete_selected();
-  void calculate_scale();
-
-  void clear_selection();
-
-  void draw(
-    QGraphicsScene* scene,
-    std::vector<EditorModel>& editor_models,
-    const RenderingOptions& rendering_options);
-
-  void clear_scene();
-
-  bool load_drawing();
-
-private:
-  void draw_lane(
-    QGraphicsScene* scene,
-    const Edge& edge,
-    const RenderingOptions& rendering_options) const;
-
-  void draw_wall(QGraphicsScene* scene, const Edge& edge) const;
-  void draw_meas(QGraphicsScene* scene, const Edge& edge) const;
-  void draw_door(QGraphicsScene* scene, const Edge& edge) const;
-  void draw_fiducials(QGraphicsScene* scene) const;
-  void draw_polygons(QGraphicsScene* scene) const;
-
-  // helper function
-  void draw_polygon(
-    QGraphicsScene* scene,
-    const QBrush& brush,
-    const Polygon& polygon) const;
-
-  void add_door_swing_path(
-    QPainterPath& path,
-    double hinge_x,
-    double hinge_y,
-    double door_length,
-    double start_angle,
-    double end_angle) const;
-
-  void add_door_slide_path(
-    QPainterPath& path,
-    double hinge_x,
-    double hinge_y,
-    double door_length,
-    double door_angle) const;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/edge.h b/traffic_editor/include/traffic_editor/edge.h
deleted file mode 100644
index 2ec6ad6..0000000
--- a/traffic_editor/include/traffic_editor/edge.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef EDGE_H
-#define EDGE_H
-
-#include <string>
-#include <map>
-
-#include <yaml-cpp/yaml.h>
-
-#include "param.h"
-#include <QString>
-
-
-class Edge
-{
-public:
-  int start_idx, end_idx;
-
-  enum Type
-  {
-    UNDEFINED = 0,
-    LANE,
-    WALL,
-    MEAS,
-    DOOR
-  } type;
-
-  bool selected;  // only for visualization, not saved to YAML
-
-  Edge();
-  Edge(const int _start_idx, const int _end_idx, const Type _type);
-  ~Edge();
-
-  std::map<std::string, Param> params;
-
-  void from_yaml(const YAML::Node& data, const Type edge_type);
-  YAML::Node to_yaml() const;
-
-  void set_param(const std::string& name, const std::string& value);
-
-  bool is_bidirectional() const;
-
-  void create_required_parameters();
-
-  template<typename T>
-  void create_param_if_needed(
-    const std::string& name,
-    const Param::Type& param_type,
-    const T& param_value);
-
-  std::string type_to_string() const;
-  QString type_to_qstring() const;
-  void set_graph_idx(const int idx);
-  int get_graph_idx() const;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/editor_model.h b/traffic_editor/include/traffic_editor/editor_model.h
deleted file mode 100644
index 508b12e..0000000
--- a/traffic_editor/include/traffic_editor/editor_model.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef EDITOR_MODEL_H
-#define EDITOR_MODEL_H
-
-/*
- * Represents a simulation model class and related helpers for rendering.
- */
-
-#include <string>
-#include <QPixmap>
-
-class EditorModel
-{
-public:
-  EditorModel(const std::string _name, const double _meters_per_pixel);
-  ~EditorModel();
-
-  std::string name, name_lowercase;
-  QPixmap pixmap;
-  double meters_per_pixel;
-
-  QPixmap get_pixmap();  // will load if needed
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/fiducial.h b/traffic_editor/include/traffic_editor/fiducial.h
deleted file mode 100644
index 43decf7..0000000
--- a/traffic_editor/include/traffic_editor/fiducial.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef FIDUCIAL_H
-#define FIDUCIAL_H
-
-#include <map>
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-
-class QGraphicsScene;
-
-
-class Fiducial
-{
-public:
-  double x = 0.0;
-  double y = 0.0;
-  std::string name;
-
-  bool selected = false;
-
-  Fiducial();
-  Fiducial(double _x, double _y, const std::string& _name = std::string());
-
-  void from_yaml(const YAML::Node& data);
-  YAML::Node to_yaml() const;
-
-  void draw(QGraphicsScene*, const double meters_per_pixel) const;
-
-  double distance(const Fiducial& f);
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/layer.h b/traffic_editor/include/traffic_editor/layer.h
deleted file mode 100644
index 0f90f99..0000000
--- a/traffic_editor/include/traffic_editor/layer.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LAYER_H
-#define LAYER_H
-
-#include <string>
-
-#include <QPixmap>
-
-#include <yaml-cpp/yaml.h>
-
-
-class Layer
-{
-public:
-  Layer();
-  ~Layer();
-
-  std::string name;
-  std::string filename;
-  bool visible = true;
-
-  double meters_per_pixel = 0.05;  // relative to the parent floorplan scale
-  double translation_x = 0.0;
-  double translation_y = 0.0;
-  double rotation = 0.0;
-
-  QPixmap pixmap;
-
-  bool from_yaml(const std::string& name, const YAML::Node& data);
-  YAML::Node to_yaml() const;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/level.h b/traffic_editor/include/traffic_editor/level.h
deleted file mode 100644
index 57f60ad..0000000
--- a/traffic_editor/include/traffic_editor/level.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LEVEL_H
-#define LEVEL_H
-
-#include <yaml-cpp/yaml.h>
-#include <string>
-
-#include "edge.h"
-#include "fiducial.h"
-#include "layer.h"
-#include "model.h"
-#include "polygon.h"
-#include "vertex.h"
-
-#include <QPixmap>
-#include <QPainterPath>
-class QGraphicsScene;
-
-
-class Level
-{
-public:
-  Level();
-  ~Level();
-
-  std::string name;
-
-  std::vector<Vertex> vertices;
-  std::vector<Edge> edges;
-  std::vector<Polygon> polygons;
-
-  std::vector<Layer> layers;
-
-  // temporary, just for debugging polygon edge projection...
-  double polygon_edge_proj_x = 0.0;
-  double polygon_edge_proj_y = 0.0;
-
-  virtual bool from_yaml(const std::string& name, const YAML::Node& data) = 0;
-  virtual YAML::Node to_yaml() const = 0;
-
-  virtual bool delete_selected() = 0;
-
-  Polygon::EdgeDragPolygon polygon_edge_drag_press(
-    const Polygon* polygon,
-    const double x,
-    const double y);
-
-  virtual void clear_selection() = 0;
-
-  void add_vertex(const double x, const double y);
-
-protected:
-  double point_to_line_segment_distance(
-    const double x,
-    const double y,
-    const double x0,
-    const double y0,
-    const double x1,
-    const double y1,
-    double& x_proj,
-    double& y_proj);
-
-  void load_yaml_edge_sequence(
-    const YAML::Node& data,
-    const char* sequence_name,
-    const Edge::Type type);
-
-  bool parse_vertices(const YAML::Node& _data);
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/lift.h b/traffic_editor/include/traffic_editor/lift.h
deleted file mode 100644
index e5f985f..0000000
--- a/traffic_editor/include/traffic_editor/lift.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LIFT_H
-#define LIFT_H
-
-class QGraphicsScene;
-class QGraphicsView;
-
-/*
- * This class represents a lift, including the shape of the lift cabin,
- * the location and names of its doors, and the floors at which it can stop.
- */
-
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-#include <cfloat>
-#include "building_level.h"
-#include "lift_door.h"
-
-
-class Lift
-{
-public:
-  std::string name;
-  std::string reference_floor_name;
-  std::string initial_floor_name;
-
-  // (x, y, yaw) of the cabin center, relative to reference_floor_name origin
-  double x = 0.0;
-  double y = 0.0;
-  double yaw = 0.0;
-
-  // for now, we will model all lift cabins as rectangles
-  double width = 1.0;  // meters
-  double depth = 1.0;  // meters
-
-  std::string highest_floor;  // highest floor the lift can reach
-  std::string lowest_floor;  // lowest floor the lift can reach
-  double highest_elevation = DBL_MAX;
-  double lowest_elevation = -DBL_MAX;
-
-  std::vector<LiftDoor> doors;
-
-  // Many lifts have multiple sets of doors which open depending on the
-  // level the lift is visiting. In the most complex case, multiple
-  // sets of doors can open on a level, so unfortunately, the data
-  // structure needs to cater for this, even though it is not common.
-  // If a (level name, door name) combination is not in this data structure,
-  // that means that the door does not open on this level.
-  // It is possible (and expected) that some lifts do not go to all levels,
-  // and that some lifts skip some levels, so this data structure is
-  // expected to be "sparse"
-  typedef std::list<std::string> DoorNameList;
-  typedef std::map<std::string, DoorNameList> LevelDoorMap;
-  LevelDoorMap level_doors;
-
-  ////////////////////////////////////////////////////////////////////////
-
-  Lift();
-
-  YAML::Node to_yaml() const;
-  void from_yaml(const std::string& _name, const YAML::Node& data,
-    const std::vector<BuildingLevel>& levels);
-
-  void draw(
-    QGraphicsScene* scene,
-    const double meters_per_pixel,
-    const std::string& level_name,
-    const double elevation,
-    const bool apply_transformation = true,
-    const double scale = 1.0,
-    const double translate_x = 0.0,
-    const double translate_y = 0.0) const;
-
-  bool level_door_opens(
-    const std::string& level_name,
-    const std::string& door_name,
-    const std::vector<BuildingLevel>& levels) const;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/lift_door.h b/traffic_editor/include/traffic_editor/lift_door.h
deleted file mode 100644
index 45bee5b..0000000
--- a/traffic_editor/include/traffic_editor/lift_door.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef LIFT_DOOR_H
-#define LIFT_DOOR_H
-
-#include <yaml-cpp/yaml.h>
-
-
-class LiftDoor
-{
-public:
-  std::string name;
-
-  double x = 0.0;  // center of door, relative to the cabin center
-  double y = 0.5;  // center of door, relative to the cabin center
-
-  double width = 1.0;  // doorway width in meters when fully opened
-
-  // Motion axis is defined relative to the cabin orientation.
-  // Typically it will be 0 or pi/2.
-  double motion_axis_orientation = 0.0;
-
-  enum DoorType
-  {
-    UNDEFINED = 0,
-    SINGLE_SLIDING,
-    DOUBLE_SLIDING,
-    SINGLE_TELESCOPE,
-    DOUBLE_TELESCOPE
-  } door_type = DOUBLE_SLIDING;
-
-  YAML::Node to_yaml() const;
-  void from_yaml(const std::string& _name, const YAML::Node& data);
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/model.h b/traffic_editor/include/traffic_editor/model.h
deleted file mode 100644
index 3d504f7..0000000
--- a/traffic_editor/include/traffic_editor/model.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef MODEL_H
-#define MODEL_H
-
-/*
- * This class represents an instance of a model on a navigation map
- * The pixmap for visualization is stored in the EditorModel class; this
- * class instead represents the _placement_ of a Model reference on
- * a map.
- */
-
-#include "editor_model.h"
-#include "model_state.h"
-
-#include <string>
-#include <algorithm>
-#include <yaml-cpp/yaml.h>
-#include <QGraphicsScene>
-
-class Building;
-class QGraphicsPixmapItem;
-
-
-class Model
-{
-public:
-  ModelState state;
-
-  std::string model_name;
-  std::string instance_name;
-  bool selected = false;  // only for visualization, not saved to YAML
-  bool is_static = true;
-  bool is_active = false;
-  bool error_printed = false;
-  std::string starting_level;  // used when resetting a test scenario
-  QGraphicsPixmapItem* pixmap_item = nullptr;
-
-  Model();
-
-  YAML::Node to_yaml() const;
-  void from_yaml(const YAML::Node& data, const std::string& level_name);
-
-  void set_param(const std::string& name, const std::string& value);
-
-  void draw(
-    QGraphicsScene* scene,
-    std::vector<EditorModel>& editor_models,
-    const double meters_per_pixel);
-
-  void clear_scene();
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/model_state.h b/traffic_editor/include/traffic_editor/model_state.h
deleted file mode 100644
index c4a69a6..0000000
--- a/traffic_editor/include/traffic_editor/model_state.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef MODEL_STATE_H
-#define MODEL_STATE_H
-
-#include <string>
-
-class ModelState
-{
-public:
-  double x = 0.0;
-  double y = 0.0;
-  double z = 0.0;
-  double yaw = 0.0;
-  std::string level_name;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/param.h b/traffic_editor/include/traffic_editor/param.h
deleted file mode 100644
index 1dff577..0000000
--- a/traffic_editor/include/traffic_editor/param.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef PARAM_H
-#define PARAM_H
-
-#include <string>
-
-#include <yaml-cpp/yaml.h>
-#include <QString>
-
-
-class Param
-{
-public:
-  enum Type
-  {
-    UNDEFINED = 0,
-    STRING,
-    INT,
-    DOUBLE,
-    BOOL
-  } type;
-
-  Param();
-  ~Param();
-  Param(const std::string& s);
-  Param(const int& i);
-  Param(const double& d);
-  Param(const bool& b);
-  Param(const Type& t);
-
-  void from_yaml(const YAML::Node& data);
-  YAML::Node to_yaml() const;
-
-  int value_int;
-  double value_double;
-  std::string value_string;
-  bool value_bool;
-
-  void set(const std::string& value);
-
-  QString to_qstring() const;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/polygon.h b/traffic_editor/include/traffic_editor/polygon.h
deleted file mode 100644
index 65fa382..0000000
--- a/traffic_editor/include/traffic_editor/polygon.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef POLYGON_H
-#define POLYGON_H
-
-#include <map>
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-
-#include <QPolygonF>
-
-#include "param.h"
-
-
-class Polygon
-{
-public:
-  std::vector<int> vertices;
-  bool selected = false;
-
-  std::map<std::string, Param> params;
-
-  enum Type
-  {
-    UNDEFINED = 0,
-    FLOOR,
-    ZONE,
-    ROI,
-    HOLE
-  } type = UNDEFINED;
-
-  Polygon();
-  ~Polygon();
-
-  void from_yaml(const YAML::Node& data, const Type polygon_type);
-  YAML::Node to_yaml() const;
-
-  void remove_vertex(const int vertex_idx);
-
-  struct EdgeDragPolygon
-  {
-    QPolygonF polygon;
-    int movable_vertex = -1;
-  };
-
-  void set_param(const std::string& name, const std::string& value);
-  void create_required_parameters();
-
-  template<typename T>
-  void create_param_if_needed(
-    const std::string& name,
-    const Param::Type& param_type,
-    const T& param_value);
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/rendering_options.h b/traffic_editor/include/traffic_editor/rendering_options.h
deleted file mode 100644
index 8b15767..0000000
--- a/traffic_editor/include/traffic_editor/rendering_options.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef RENDERING_OPTIONS_H
-#define RENDERING_OPTIONS_H
-
-class RenderingOptions
-{
-public:
-  static const int NUM_BUILDING_LANES = 10;
-  std::array<bool, NUM_BUILDING_LANES> show_building_lanes;
-
-  bool show_models = true;
-};
-
-#endif
diff --git a/traffic_editor/include/traffic_editor/vertex.h b/traffic_editor/include/traffic_editor/vertex.h
deleted file mode 100644
index a2f5752..0000000
--- a/traffic_editor/include/traffic_editor/vertex.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2019 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef VERTEX_H
-#define VERTEX_H
-
-#include <map>
-#include <string>
-#include <vector>
-#include <yaml-cpp/yaml.h>
-
-#include <QColor>
-
-#include "param.h"
-
-class QGraphicsScene;
-
-
-class Vertex
-{
-public:
-  double x;
-  double y;
-  std::string name;
-
-  bool selected;
-
-  std::map<std::string, Param> params;
-
-  Vertex();
-  Vertex(double _x, double _y, const std::string& _name = std::string());
-
-  void from_yaml(const YAML::Node& data);
-  YAML::Node to_yaml() const;
-
-  void set_param(const std::string& name, const std::string& value);
-
-  void draw(
-    QGraphicsScene* scene,
-    const double radius,
-    const QColor& color) const;
-
-  ////////////////////////////////////////////////////////////
-  static const std::vector<std::pair<std::string, Param::Type>> allowed_params;
-};
-
-#endif
diff --git a/traffic_editor/package.xml b/traffic_editor/package.xml
deleted file mode 100644
index ca298ac..0000000
--- a/traffic_editor/package.xml
+++ /dev/null
@@ -1,22 +0,0 @@
-<?xml version="1.0"?>
-<?xml-model href="http://download.ros.org/schema/package_format3.xsd" schematypens="http://www.w3.org/2001/XMLSchema"?>
-<package format="3">
-  <name>traffic_editor</name>
-  <version>1.1.0</version>
-  <description>traffic editor</description>
-  <maintainer email="morgan@openrobotics.org">Morgan Quigley</maintainer>
-  <license>Apache License 2.0</license>
-
-  <build_depend>ament_cmake</build_depend>
-  <build_depend>ament_index_cpp</build_depend>
-  <build_depend>ignition-plugin</build_depend>
-  <build_depend>ignition-common3</build_depend>
-  <build_depend>yaml-cpp</build_depend>
-  <build_depend>libqt5-concurrent</build_depend>
-  <build_depend>libqt5-widgets</build_depend>
-  <build_depend>qtbase5-dev</build_depend>
-    
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
diff --git a/traffic_editor/plugins/simulation.h b/traffic_editor/plugins/simulation.h
deleted file mode 100644
index 90dad17..0000000
--- a/traffic_editor/plugins/simulation.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2019-2020 Open Source Robotics Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
-*/
-
-#ifndef PLUGINS_SIMULATION_H
-#define PLUGINS_SIMULATION_H
-
-#include "traffic_editor/building.h"
-
-class QGraphicsScene;
-
-class Simulation
-{
-public:
-  virtual ~Simulation() = default;
-
-  virtual void load(const YAML::Node& config_data) = 0;
-  virtual void tick(Building& building) = 0;
-  virtual void reset(Building& building) = 0;
-
-  virtual void scene_update(
-    QGraphicsScene* scene,
-    Building& building,
-    const int level_idx) = 0;
-
-  virtual void scene_clear() = 0;
-};
-
-#endif
diff --git a/traffic_editor/resources/icons/door.svg b/traffic_editor/resources/icons/door.svg
deleted file mode 100644
index beb2a42..0000000
--- a/traffic_editor/resources/icons/door.svg
+++ /dev/null
@@ -1,77 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="door.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="11.2"
-     inkscape:cx="27.100113"
-     inkscape:cy="33.864481"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="1920"
-     inkscape:window-height="1027"
-     inkscape:window-x="0"
-     inkscape:window-y="25"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:none;stroke:#000000;stroke-width:0.265;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
-       d="m 4.6274451,295.74794 v -14.31585 h 8.1812699 l 0.01885,14.29223 z"
-       id="path815"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="ccccc" />
-    <circle
-       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26499999;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       id="path817"
-       cx="11.528274"
-       cy="289.65305"
-       r="0.49609375" />
-    <rect
-       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.29922625;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       id="rect821"
-       width="5.7535338"
-       height="5.1629467"
-       x="5.8284969"
-       y="282.58313" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/fiducial.svg b/traffic_editor/resources/icons/fiducial.svg
deleted file mode 100644
index dfd317f..0000000
--- a/traffic_editor/resources/icons/fiducial.svg
+++ /dev/null
@@ -1,93 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933333 16.933334"
-   version="1.1"
-   id="svg19"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="fiducial.svg">
-  <defs
-     id="defs13">
-    <marker
-       inkscape:stockid="Arrow1Lend"
-       orient="auto"
-       refY="0.0"
-       refX="0.0"
-       id="Arrow1Lend"
-       style="overflow:visible;"
-       inkscape:isstock="true">
-      <path
-         id="path4555"
-         d="M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z "
-         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#999999;fill-opacity:1"
-         transform="scale(0.8) rotate(180) translate(12.5,0)" />
-    </marker>
-  </defs>
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="16"
-     inkscape:cx="64.533408"
-     inkscape:cy="32.137345"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="3840"
-     inkscape:window-height="2132"
-     inkscape:window-x="3840"
-     inkscape:window-y="0"
-     inkscape:window-maximized="1"
-     inkscape:measure-start="-22.7284,31.8198"
-     inkscape:measure-end="7.82868,32.5774" />
-  <metadata
-     id="metadata16">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <circle
-       style="fill:none;stroke:#000000;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none"
-       id="path40"
-       cx="8.4666672"
-       cy="288.53333"
-       r="5.8462968" />
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       d="M 0.26458333,288.53332 H 16.66875"
-       id="path12"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cc" />
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       d="M 8.4666667,280.33123 V 296.7354"
-       id="path12-3"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cc" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/floor.svg b/traffic_editor/resources/icons/floor.svg
deleted file mode 100644
index 8632e08..0000000
--- a/traffic_editor/resources/icons/floor.svg
+++ /dev/null
@@ -1,64 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="floor.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="11.2"
-     inkscape:cx="23.307062"
-     inkscape:cy="26.535094"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="1920"
-     inkscape:window-height="1027"
-     inkscape:window-x="0"
-     inkscape:window-y="25"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:#9d9d9d;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 1.8544457,294.89749 v -7.21698 h 7.1815476 v -6.07124 h 6.4610307 v 10.97312 z"
-       id="path3718"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="ccccccc" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/hole.svg b/traffic_editor/resources/icons/hole.svg
deleted file mode 100644
index fecf43a..0000000
--- a/traffic_editor/resources/icons/hole.svg
+++ /dev/null
@@ -1,69 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="floor_hole.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="7.919596"
-     inkscape:cx="12.655125"
-     inkscape:cy="20.619827"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="1920"
-     inkscape:window-height="1027"
-     inkscape:window-x="0"
-     inkscape:window-y="25"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:#9d9d9d;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 1.8544457,294.89749 v -7.21698 h 7.1815476 v -6.07124 h 6.4610307 v 10.97312 z"
-       id="path3718"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="ccccccc" />
-    <path
-       style="fill:#ffffff;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"
-       d="m 7.7248884,290.62163 5.1026786,-4.08686 0.377976,5.31529 z"
-       id="path831"
-       inkscape:connector-curvature="0" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/measurement.svg b/traffic_editor/resources/icons/measurement.svg
deleted file mode 100644
index 6c6e359..0000000
--- a/traffic_editor/resources/icons/measurement.svg
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="measurement.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="11.2"
-     inkscape:cx="6.6106333"
-     inkscape:cy="32.695808"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="1920"
-     inkscape:window-height="1027"
-     inkscape:window-x="0"
-     inkscape:window-y="25"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:none;stroke:#f758ea;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       d="M 2.3151041,291.75557 14.882812,284.19604"
-       id="path833"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cc" />
-    <circle
-       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.265;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
-       id="path816"
-       cx="2.3032923"
-       cy="291.67288"
-       r="1.7634745" />
-    <circle
-       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26499999;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       id="path816-3"
-       cx="14.811942"
-       cy="284.1488"
-       r="1.7634746" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/move.svg b/traffic_editor/resources/icons/move.svg
deleted file mode 100644
index 54300f1..0000000
--- a/traffic_editor/resources/icons/move.svg
+++ /dev/null
@@ -1,92 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="move.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="22.4"
-     inkscape:cx="56.802761"
-     inkscape:cy="26.1421"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="3840"
-     inkscape:window-height="2132"
-     inkscape:window-x="3840"
-     inkscape:window-y="0"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <rect
-       style="fill:#000000;stroke-width:0.30093893"
-       id="rect8"
-       width="2.1764336"
-       height="11.822602"
-       x="7.5017977"
-       y="282.69199" />
-    <rect
-       style="fill:#000000;stroke-width:0.30093893"
-       id="rect10"
-       width="11.527037"
-       height="2.4182594"
-       x="2.7996266"
-       y="287.36731" />
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 0.73614025,288.54953 3.62765145,-2.55579 v 5.24849 z"
-       id="path14"
-       inkscape:connector-curvature="0" />
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 16.212895,288.57437 -3.627652,-2.55578 v 5.24848 z"
-       id="path14-3"
-       inkscape:connector-curvature="0" />
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 8.733064,296.34817 2.815297,-3.29326 H 5.7669502 Z"
-       id="path14-3-6"
-       inkscape:connector-curvature="0" />
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.37491754px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 8.5573865,280.88938 2.8152975,3.29326 H 5.5912728 Z"
-       id="path14-3-6-7"
-       inkscape:connector-curvature="0" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/roi.svg b/traffic_editor/resources/icons/roi.svg
deleted file mode 100644
index 8068fda..0000000
--- a/traffic_editor/resources/icons/roi.svg
+++ /dev/null
@@ -1,64 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="roi.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="22.4"
-     inkscape:cx="32.521772"
-     inkscape:cy="27.966633"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="3840"
-     inkscape:window-height="2107"
-     inkscape:window-x="0"
-     inkscape:window-y="25"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:#fff93b;fill-opacity:1;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 1.8544457,294.89749 v -7.21698 h 7.1815476 v -6.07124 h 6.4610307 v 10.97312 z"
-       id="path3718"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="ccccccc" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/rotate.svg b/traffic_editor/resources/icons/rotate.svg
deleted file mode 100644
index c4d9a3e..0000000
--- a/traffic_editor/resources/icons/rotate.svg
+++ /dev/null
@@ -1,99 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933333 16.933334"
-   version="1.1"
-   id="svg19"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="rotate.svg">
-  <defs
-     id="defs13">
-    <marker
-       inkscape:stockid="Arrow1Lend"
-       orient="auto"
-       refY="0.0"
-       refX="0.0"
-       id="Arrow1Lend"
-       style="overflow:visible;"
-       inkscape:isstock="true">
-      <path
-         id="path4555"
-         d="M 0.0,0.0 L 5.0,-5.0 L -12.5,0.0 L 5.0,5.0 L 0.0,0.0 z "
-         style="fill-rule:evenodd;stroke:#000000;stroke-width:1pt;stroke-opacity:1;fill:#999999;fill-opacity:1"
-         transform="scale(0.8) rotate(180) translate(12.5,0)" />
-    </marker>
-  </defs>
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="15.839192"
-     inkscape:cx="26.167374"
-     inkscape:cy="32.289048"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="3840"
-     inkscape:window-height="2132"
-     inkscape:window-x="3840"
-     inkscape:window-y="0"
-     inkscape:window-maximized="1"
-     inkscape:measure-start="-22.7284,31.8198"
-     inkscape:measure-end="7.82868,32.5774" />
-  <metadata
-     id="metadata16">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:none;stroke:#000000;stroke-width:1;stroke-miterlimit:4;stroke-dasharray:none"
-       id="path40"
-       sodipodi:type="arc"
-       sodipodi:cx="8.5359201"
-       sodipodi:cy="288.24695"
-       sodipodi:rx="5.8033128"
-       sodipodi:ry="5.8033128"
-       sodipodi:start="2.1655519"
-       sodipodi:end="0.92116654"
-       sodipodi:open="true"
-       d="m 5.2842873,293.05375 a 5.8033128,5.8033128 0 0 1 -2.3197665,-6.43098 5.8033128,5.8033128 0 0 1 5.4121932,-4.17695 5.8033128,5.8033128 0 0 1 5.633139,3.87382 5.8033128,5.8033128 0 0 1 -1.963557,6.54853" />
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 10.590555,294.64467 0.584652,-3.20723 2.438834,2.25509 z"
-       id="path4838"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cccc" />
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.26458332px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 6.4834057,294.562 -0.584652,-3.20723 -2.438834,2.25509 z"
-       id="path4838-3"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cccc" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/select.svg b/traffic_editor/resources/icons/select.svg
deleted file mode 100644
index 2b66ea7..0000000
--- a/traffic_editor/resources/icons/select.svg
+++ /dev/null
@@ -1,64 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933333 16.933334"
-   version="1.1"
-   id="svg4861"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="select.svg">
-  <defs
-     id="defs4855" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="15.839192"
-     inkscape:cx="34.481937"
-     inkscape:cy="43.697704"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     inkscape:window-width="3840"
-     inkscape:window-height="2132"
-     inkscape:window-x="3840"
-     inkscape:window-y="0"
-     inkscape:window-maximized="1"
-     units="px" />
-  <metadata
-     id="metadata4858">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title></dc:title>
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:#000000;stroke:#000000;stroke-width:0.35283428px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
-       d="m 5.4563332,281.5101 v 11.44989 l 2.6731238,-1.06925 1.2697335,3.76464 2.0493945,-0.82421 -1.336562,-3.67555 2.433616,-0.93 z"
-       id="path4882"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cccccccc" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/vertex.svg b/traffic_editor/resources/icons/vertex.svg
deleted file mode 100644
index 52db02e..0000000
--- a/traffic_editor/resources/icons/vertex.svg
+++ /dev/null
@@ -1,64 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="add_vertex.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="11.2"
-     inkscape:cx="49.261772"
-     inkscape:cy="8.1624995"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="3840"
-     inkscape:window-height="2132"
-     inkscape:window-x="3840"
-     inkscape:window-y="0"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <circle
-       style="fill:#008000;stroke-width:0.52625465"
-       id="path29"
-       cx="8.5292225"
-       cy="288.44189"
-       r="4.9172764" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/icons/wall.svg b/traffic_editor/resources/icons/wall.svg
deleted file mode 100644
index 2f2fae9..0000000
--- a/traffic_editor/resources/icons/wall.svg
+++ /dev/null
@@ -1,76 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="no"?>
-<!-- Created with Inkscape (http://www.inkscape.org/) -->
-
-<svg
-   xmlns:dc="http://purl.org/dc/elements/1.1/"
-   xmlns:cc="http://creativecommons.org/ns#"
-   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
-   xmlns:svg="http://www.w3.org/2000/svg"
-   xmlns="http://www.w3.org/2000/svg"
-   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
-   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
-   width="64"
-   height="64"
-   viewBox="0 0 16.933334 16.933334"
-   version="1.1"
-   id="svg8"
-   inkscape:version="0.92.3 (2405546, 2018-03-11)"
-   sodipodi:docname="wall.svg">
-  <defs
-     id="defs2" />
-  <sodipodi:namedview
-     id="base"
-     pagecolor="#ffffff"
-     bordercolor="#666666"
-     borderopacity="1.0"
-     inkscape:pageopacity="0.0"
-     inkscape:pageshadow="2"
-     inkscape:zoom="11.2"
-     inkscape:cx="23.574919"
-     inkscape:cy="33.052951"
-     inkscape:document-units="mm"
-     inkscape:current-layer="layer1"
-     showgrid="false"
-     units="px"
-     inkscape:window-width="1920"
-     inkscape:window-height="1027"
-     inkscape:window-x="0"
-     inkscape:window-y="25"
-     inkscape:window-maximized="1" />
-  <metadata
-     id="metadata5">
-    <rdf:RDF>
-      <cc:Work
-         rdf:about="">
-        <dc:format>image/svg+xml</dc:format>
-        <dc:type
-           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
-        <dc:title />
-      </cc:Work>
-    </rdf:RDF>
-  </metadata>
-  <g
-     inkscape:label="Layer 1"
-     inkscape:groupmode="layer"
-     id="layer1"
-     transform="translate(0,-280.06665)">
-    <path
-       style="fill:none;stroke:#1812f4;stroke-width:3;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       d="M 2.3151041,291.75557 14.882812,284.19604"
-       id="path833"
-       inkscape:connector-curvature="0"
-       sodipodi:nodetypes="cc" />
-    <circle
-       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.265;stroke-opacity:1;stroke-miterlimit:4;stroke-dasharray:none"
-       id="path816"
-       cx="2.3032923"
-       cy="291.67288"
-       r="1.7634745" />
-    <circle
-       style="fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:0.26499999;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1"
-       id="path816-3"
-       cx="14.811942"
-       cy="284.1488"
-       r="1.7634746" />
-  </g>
-</svg>
diff --git a/traffic_editor/resources/resource.qrc b/traffic_editor/resources/resource.qrc
deleted file mode 100644
index f6141bb..0000000
--- a/traffic_editor/resources/resource.qrc
+++ /dev/null
@@ -1,16 +0,0 @@
-<!DOCTYPE RCC>
-<RCC version="1.0">
-<qresource>
-  <file>icons/vertex.svg</file>
-  <file>icons/move.svg</file>
-  <file>icons/rotate.svg</file>
-  <file>icons/select.svg</file>
-  <file>icons/fiducial.svg</file>
-  <file>icons/roi.svg</file>
-  <file>icons/floor.svg</file>
-  <file>icons/hole.svg</file>
-  <file>icons/wall.svg</file>
-  <file>icons/door.svg</file>
-  <file>icons/measurement.svg</file>
-</qresource>
-</RCC>
diff --git a/traffic_editor/scripts/generate_model_list.py b/traffic_editor/scripts/generate_model_list.py
deleted file mode 100755
index 79398d4..0000000
--- a/traffic_editor/scripts/generate_model_list.py
+++ /dev/null
@@ -1,78 +0,0 @@
-#!/usr/bin/env python3
-
-# Copyright 2020 Open Source Robotics Foundation, Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import pit_crew
-
-import sys
-import yaml
-import argparse
-
-
-if __name__ == '__main__':
-    parser = argparse.ArgumentParser()
-    parser.add_argument(
-        'output_yaml',
-        help='Output yaml file that the directory of models will be added to.'
-    )
-    parser.add_argument(
-        '-d', '--model-dir', help='Directory of models to be added.'
-    )
-    parser.add_argument(
-        '-b', '--blacklist-models', default='',
-        help='Optional blacklisted models that will be excluded from your '
-        'model directory'
-    )
-    parser.add_argument(
-        '--meters-per-pixel', type=float, default=0.004,
-        help='Scale of models in meters per pixel for the images.'
-    )
-    args = parser.parse_args(sys.argv[1:])
-
-    y = {}
-    y['models'] = []
-
-    blacklist_yaml = None
-    if args.blacklist_models != '':
-        print('Blacklisted models:')
-        with open(args.blacklist_models) as f:
-            blacklist_yaml = yaml.load(f)
-            print(blacklist_yaml)
-
-    models = pit_crew.get_local_model_name_tuples(path=args.model_dir,
-                                                  lower=False,
-                                                  use_dir_as_name=True)
-
-    for model in models:
-        if blacklist_yaml is not None and \
-                model.model_name in blacklist_yaml['blacklist']:
-            print('ignoring {} because it is blacklisted'.format(
-                    model.model_name))
-            continue
-
-        if model.author_name:
-            y['models'].append("%s/%s" % (model.author_name,
-                                          model.model_name))
-        else:
-            y['models'].append(model.model_name)
-
-    assert len(y['models']) > 0, "No models found!"
-    print('found {} models'.format(len(y['models'])))
-
-    y['models'] = sorted(y['models'], key=lambda s: s.lower())
-    y['meters_per_pixel'] = 0.004
-
-    with open(args.output_yaml, 'w') as f:
-        yaml.dump(y, f, default_flow_style=False)
diff --git a/traffic_editor/scripts/generate_thumbnails.py b/traffic_editor/scripts/generate_thumbnails.py
deleted file mode 100755
index 7a819d6..0000000
--- a/traffic_editor/scripts/generate_thumbnails.py
+++ /dev/null
@@ -1,79 +0,0 @@
-#!/usr/bin/env python
-
-# Copyright 2020 Open Source Robotics Foundation, Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import os
-import sys
-import yaml
-import argparse
-
-
-class ThumbnailsGenerator:
-    def __init__(self, argv=sys.argv):
-        parser = argparse.ArgumentParser()
-        parser.add_argument(
-                'models_dir', default='~/.gazebo/models',
-                help='Directory of models to be added')
-        parser.add_argument(
-                'model_list', default='../test/model_list.yaml',
-                help='Path of model_list.yaml')
-        parser.add_argument(
-                'output_dir', default='.',
-                help='Directory where the output images will be saved')
-        # Optional arguments
-        parser.add_argument(
-                '--size', dest='img_size', default=4000,
-                help='Output thumbnail Image pixel size')
-        parser.add_argument(
-                '--height', dest='cam_height', default=200,
-                help='Scene camara height')
-        parser.add_argument(
-                '--hfov', dest='cam_hfov', default=0.08,
-                help='Scene camera horizontal FOV')
-        args = parser.parse_args(argv[1:])
-
-        self.output_dir = args.output_dir
-        self.models_dir = args.models_dir
-        self.img_size = args.img_size
-        self.cam_height = args.cam_height
-        self.cam_hfov = args.cam_hfov
-
-        self.yaml = None
-        with open(args.model_list) as f:
-            self.yaml = yaml.load(f)
-        print(self.yaml)
-
-    def run(self):
-        for full_model_name in self.yaml['models']:
-            model_name = full_model_name.split("/")[-1]
-            sdf_path = "{}/{}/model.sdf".format(self.models_dir, model_name)
-
-            if os.path.exists(sdf_path) is False:
-                print(" Warn!! {} doesnt exist, skip!".format(model_name))
-                continue
-
-            command = "gzserver -s libthumbnail_generator.so \
-                    empty.world --input '{}' --output '{}' \
-                    --img-size {} --cam-height {} --cam-hfov {} ".format(
-                    sdf_path, self.output_dir, self.img_size,
-                    self.cam_height, self.cam_hfov)
-            print("------------------------------------------------------")
-            os.system(command)
-
-
-if __name__ == '__main__':
-    thumbnails_generator = ThumbnailsGenerator(sys.argv)
-    thumbnails_generator.run()
-    print("Done All")
diff --git a/traffic_editor/scripts/merge_model_lists.py b/traffic_editor/scripts/merge_model_lists.py
deleted file mode 100755
index 081a0ee..0000000
--- a/traffic_editor/scripts/merge_model_lists.py
+++ /dev/null
@@ -1,64 +0,0 @@
-#!/usr/bin/env python
-
-# Copyright 2020 Open Source Robotics Foundation, Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import os
-import sys
-import yaml
-import argparse
-
-
-if __name__ == '__main__':
-    parser = argparse.ArgumentParser()
-    parser.add_argument(
-        'destination',
-        help='Destination list of models which the source will be '
-        'merged into.'
-    )
-    parser.add_argument('-s', '--source', help='Source list of models.')
-    args = parser.parse_args(sys.argv[1:])
-
-    if not os.path.exists(args.source):
-        print('Source model list not found: {}'.format(args.source))
-        exit()
-    if not os.path.exists(args.destination):
-        print('Destination model list not found: {}'.format(args.destination))
-        exit()
-
-    source_yaml = None
-    with open(args.source) as f:
-        source_yaml = yaml.load(f)
-
-    destination_yaml = None
-    with open(args.destination) as f:
-        destination_yaml = yaml.load(f)
-
-    if abs(source_yaml['meters_per_pixel'] -
-            destination_yaml['meters_per_pixel']) > 1e-6:
-        print('Both model lists have different meters_per_pixel.')
-        exit()
-
-    for model_name in source_yaml['models']:
-        if model_name in destination_yaml['models']:
-            print('Skipping model {} because it already exists'.format(
-                    model_name))
-            continue
-        destination_yaml['models'].append(model_name)
-
-    destination_yaml['models'] = sorted(
-            destination_yaml['models'], key=lambda s: s.lower())
-
-    with open(args.destination, 'w') as f:
-        yaml.dump(destination_yaml, f, default_flow_style=False)
diff --git a/traffic_editor/scripts/sort_model_list.py b/traffic_editor/scripts/sort_model_list.py
deleted file mode 100755
index 3382301..0000000
--- a/traffic_editor/scripts/sort_model_list.py
+++ /dev/null
@@ -1,43 +0,0 @@
-#!/usr/bin/env python
-
-# Copyright 2020 Open Source Robotics Foundation, Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import os
-import sys
-import yaml
-import argparse
-
-
-if __name__ == '__main__':
-    parser = argparse.ArgumentParser()
-    parser.add_argument(
-        'model_list',
-        help='model_list.yaml file that needs to be sorted.'
-    )
-    args = parser.parse_args(sys.argv[1:])
-
-    if not os.path.exists(args.model_list):
-        print('Model list file not found: {}'.format(args.source))
-        exit()
-
-    model_list_yaml = None
-    with open(args.model_list) as f:
-        model_list_yaml = yaml.load(f)
-
-    model_list_yaml['models'] = sorted(
-            model_list_yaml['models'], key=lambda s: s.lower())
-
-    with open(args.model_list, 'w') as f:
-        yaml.dump(model_list_yaml, f, default_flow_style=False)
diff --git a/traffic_editor/test/model_blacklist.yaml b/traffic_editor/test/model_blacklist.yaml
deleted file mode 100644
index 3461878..0000000
--- a/traffic_editor/test/model_blacklist.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
-blacklist:
-- Humans
diff --git a/traffic_editor/test/model_list.yaml b/traffic_editor/test/model_list.yaml
deleted file mode 100644
index d8c2157..0000000
--- a/traffic_editor/test/model_list.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
-meters_per_pixel: 0.004
-models:
-  - ambulance
-  - beer
-  - coke_can
-- 
2.25.1

